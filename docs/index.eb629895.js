let $d5b33d7c30034067$var$_canvas,$d5b33d7c30034067$var$_geometry,$d5b33d7c30034067$var$_context,$d5b33d7c30034067$var$_lineGeometry,$d5b33d7c30034067$var$_coneGeometry,$04ef886a022e9ae8$var$fbxTree,$04ef886a022e9ae8$var$connections,$04ef886a022e9ae8$var$sceneGraph,$7c432a5c23fdd3a1$var$model,$7c432a5c23fdd3a1$var$mixer,$7c432a5c23fdd3a1$var$rightEye,$7c432a5c23fdd3a1$var$leftEye,$7c432a5c23fdd3a1$var$mouthCues,$7c432a5c23fdd3a1$var$audio,$b8705bfef224a9de$export$1cf47f9eac95b665,$649b5a10055e0f2c$var$createCanvasFunction,$649b5a10055e0f2c$var$ImageDataClass,$649b5a10055e0f2c$var$loadImageFunction,$1924ca1b0c205a21$var$recognition,$54b47fc030b7b21e$var$scene,$54b47fc030b7b21e$var$camera,$54b47fc030b7b21e$var$renderer,$54b47fc030b7b21e$var$controls,$54b47fc030b7b21e$var$clock;function $parcel$exportWildcard(n,r){return Object.keys(r).forEach(function(i){"default"===i||"__esModule"===i||n.hasOwnProperty(i)||Object.defineProperty(n,i,{enumerable:!0,get:function(){return r[i]}})}),n}function $parcel$export(n,r,i,a){Object.defineProperty(n,r,{get:i,set:a,enumerable:!0,configurable:!0})}function $parcel$interopDefault(n){return n&&n.__esModule?n.default:n}var $51861dfc7ca9d588$export$a143d493d941bafc,$51861dfc7ca9d588$export$f99ded8fe4b79145,$eeb0961446aae8e3$export$d622b2ad8d90c771,$eeb0961446aae8e3$export$6100ba28696e12de,$7221566bd4d49f44$export$aafa59e2e03f2942,$7221566bd4d49f44$export$68d8715fc104d294,$parcel$global="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},$parcel$modules={},$parcel$inits={},parcelRequire=$parcel$global.parcelRequire94c2;null==parcelRequire&&((parcelRequire=function(n){if(n in $parcel$modules)return $parcel$modules[n].exports;if(n in $parcel$inits){var r=$parcel$inits[n];delete $parcel$inits[n];var i={id:n,exports:{}};return $parcel$modules[n]=i,r.call(i.exports,i,i.exports),i.exports}var a=Error("Cannot find module '"+n+"'");throw a.code="MODULE_NOT_FOUND",a}).register=function(n,r){$parcel$inits[n]=r},$parcel$global.parcelRequire94c2=parcelRequire),parcelRequire.register("2CD9z",function(module,exports){/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/var $hPtJY=parcelRequire("hPtJY");!function(n,r){module.exports=r(parcelRequire("7YRm1"))}(self,__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(n,r,i)=>{var a,s=(a=(a="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(n){function r(){return D.buffer!=k&&q(D.buffer),U}function s(){return D.buffer!=k&&q(D.buffer),F}function o(){return D.buffer!=k&&q(D.buffer),B}function l(){return D.buffer!=k&&q(D.buffer),z}function u(){return D.buffer!=k&&q(D.buffer),V}n=n||{},c||(c=void 0!==n?n:{}),c.ready=new Promise(function(n,r){h=n,d=r});var c,h,d,p,f,m,g,_,y,b=Object.assign({},c),v="./this.program",x=(n,r)=>{throw r},w="object"==typeof window,T="function"==typeof importScripts,S="object"==typeof $hPtJY&&"object"==typeof $hPtJY.versions&&"string"==typeof $hPtJY.versions.node,E=c.ENVIRONMENT_IS_PTHREAD||!1,A="";function M(n){return c.locateFile?c.locateFile(n,A):A+n}if(S){let n;A=T?i(908).dirname(A)+"/":"//",y=()=>{_||(g=i(1384),_=i(908))},p=function(n,r){return y(),n=_.normalize(n),g.readFileSync(n,r?void 0:"utf8")},m=n=>((n=p(n,!0)).buffer||(n=new Uint8Array(n)),n),f=(n,r,i)=>{y(),n=_.normalize(n),g.readFile(n,function(n,a){n?i(n):r(a.buffer)})},1<$hPtJY.argv.length&&(v=$hPtJY.argv[1].replace(/\\/g,"/")),$hPtJY.argv.slice(2),$hPtJY.on("uncaughtException",function(n){if(!(n instanceof eh))throw n}),$hPtJY.on("unhandledRejection",function(n){throw n}),x=(n,r)=>{if(et())throw $hPtJY.exitCode=n,r;r instanceof eh||C("exiting due to exception: "+r),$hPtJY.exit(n)},c.inspect=function(){return"[Emscripten Module object]"};try{n=i(9925)}catch(n){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),n}i.g.Worker=n.Worker}else(w||T)&&(T?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),a&&(A=a),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",S||(p=n=>{var r=new XMLHttpRequest;return r.open("GET",n,!1),r.send(null),r.responseText},T&&(m=n=>{var r=new XMLHttpRequest;return r.open("GET",n,!1),r.responseType="arraybuffer",r.send(null),new Uint8Array(r.response)}),f=(n,r,i)=>{var a=new XMLHttpRequest;a.open("GET",n,!0),a.responseType="arraybuffer",a.onload=()=>{200==a.status||0==a.status&&a.response?r(a.response):i()},a.onerror=i,a.send(null)}));S&&"undefined"==typeof performance&&(i.g.performance=i(6953).performance);var I=console.log.bind(console),P=console.warn.bind(console);S&&(y(),I=n=>g.writeSync(1,n+"\n"),P=n=>g.writeSync(2,n+"\n"));var O,R=c.print||I,C=c.printErr||P;Object.assign(c,b),b=null,c.thisProgram&&(v=c.thisProgram),c.quit&&(x=c.quit),c.wasmBinary&&(O=c.wasmBinary);var L=c.noExitRuntime||!1;"object"!=typeof WebAssembly&&eo("no native wasm support detected");var D,N,k,U,F,B,z,V,G=!1,j="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function H(n,r,i){var a=(r>>>=0)+i;for(i=r;n[i]&&!(i>=a);)++i;if(16<i-r&&n.buffer&&j)return j.decode(n.buffer instanceof SharedArrayBuffer?n.slice(r,i):n.subarray(r,i));for(a="";r<i;){var s=n[r++];if(128&s){var o=63&n[r++];if(192==(224&s))a+=String.fromCharCode((31&s)<<6|o);else{var l=63&n[r++];65536>(s=224==(240&s)?(15&s)<<12|o<<6|l:(7&s)<<18|o<<12|l<<6|63&n[r++])?a+=String.fromCharCode(s):(s-=65536,a+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else a+=String.fromCharCode(s)}return a}function $(n,r){return(n>>>=0)?H(s(),n,r):""}function W(n,r,i,a){if(!(0<a))return 0;var s=i>>>=0;a=i+a-1;for(var o=0;o<n.length;++o){var l=n.charCodeAt(o);if(55296<=l&&57343>=l&&(l=65536+((1023&l)<<10)|1023&n.charCodeAt(++o)),127>=l){if(i>=a)break;r[i++>>>0]=l}else{if(2047>=l){if(i+1>=a)break;r[i++>>>0]=192|l>>6}else{if(65535>=l){if(i+2>=a)break;r[i++>>>0]=224|l>>12}else{if(i+3>=a)break;r[i++>>>0]=240|l>>18,r[i++>>>0]=128|l>>12&63}r[i++>>>0]=128|l>>6&63}r[i++>>>0]=128|63&l}}return r[i>>>0]=0,i-s}function X(n){for(var r=0,i=0;i<n.length;++i){var a=n.charCodeAt(i);127>=a?r++:2047>=a?r+=2:55296<=a&&57343>=a?(r+=4,++i):r+=3}return r}function q(n){k=n,c.HEAP8=U=new Int8Array(n),c.HEAP16=new Int16Array(n),c.HEAP32=B=new Int32Array(n),c.HEAPU8=F=new Uint8Array(n),c.HEAPU16=new Uint16Array(n),c.HEAPU32=z=new Uint32Array(n),c.HEAPF32=new Float32Array(n),c.HEAPF64=V=new Float64Array(n)}E&&(k=c.buffer);var Y=c.INITIAL_MEMORY||16777216;if(E)D=c.wasmMemory,k=c.buffer;else if(c.wasmMemory)D=c.wasmMemory;else if(!((D=new WebAssembly.Memory({initial:Y/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw C("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),S&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");D&&(k=D.buffer),Y=k.byteLength,q(k);var K,Z=[],J=[],Q=[],ee=[];function et(){return L||!1}function en(){var n=c.preRun.shift();Z.unshift(n)}var er,ei=0,ea=null,es=null;function eo(n){throw E?postMessage({cmd:"onAbort",arg:n}):c.onAbort&&c.onAbort(n),C(n="Aborted("+n+")"),G=!0,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),d(n),n}function el(){return er.startsWith("data:application/octet-stream;base64,")}function eu(){var n=er;try{if(n==er&&O)return new Uint8Array(O);if(m)return m(n);throw"both async and sync fetching of the wasm failed"}catch(n){eo(n)}}er="ort-wasm-threaded.wasm",el()||(er=M(er));var ec={};function eh(n){this.name="ExitStatus",this.message="Program terminated with exit("+n+")",this.status=n}function ed(n){(n=eg.Vb[n])||eo(),eg.mc(n)}function ep(n){var r=eg.Cc();if(!r)return 6;eg.ac.push(r),eg.Vb[n.Ub]=r,r.Ub=n.Ub;var i={cmd:"run",start_routine:n.Ic,arg:n.zc,pthread_ptr:n.Ub};return r.$b=()=>{i.time=performance.now(),r.postMessage(i,n.Nc)},r.loaded&&(r.$b(),delete r.$b),0}function ef(n){if(E)return eK(1,1,n);et()||(eg.oc(),c.onExit&&c.onExit(n),G=!0),x(n,new eh(n))}function em(n,r){if(!r&&E)throw eb(n),"unwind";et()||E||(th(),e_(Q),tc(0),e8[1].length&&e7(1,10),e8[2].length&&e7(2,10),eg.oc()),ef(n)}var eg={Yb:[],ac:[],qc:[],Vb:{},fc:function(){E&&eg.Ec()},Pc:function(){},Ec:function(){eg.receiveObjectTransfer=eg.Gc,eg.threadInitTLS=eg.pc,eg.setExitStatus=eg.nc,L=!1},nc:function(){},oc:function(){for(var n of Object.values(eg.Vb))eg.mc(n);for(n of eg.Yb)n.terminate();eg.Yb=[]},mc:function(n){var r=n.Ub;delete eg.Vb[r],eg.Yb.push(n),eg.ac.splice(eg.ac.indexOf(n),1),n.Ub=0,tg(r)},Gc:function(){},pc:function(){eg.qc.forEach(n=>n())},Fc:function(n,r){n.onmessage=i=>{var a=(i=i.data).cmd;if(n.Ub&&(eg.Bc=n.Ub),i.targetThread&&i.targetThread!=to()){var s=eg.Vb[i.Qc];s?s.postMessage(i,i.transferList):C('Internal error! Worker sent a message "'+a+'" to target pthread '+i.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===a?eH(i.queue):"spawnThread"===a?ep(i):"cleanupThread"===a?ed(i.thread):"killThread"===a?(i=i.thread,a=eg.Vb[i],delete eg.Vb[i],a.terminate(),tg(i),eg.ac.splice(eg.ac.indexOf(a),1),a.Ub=0):"cancelThread"===a?eg.Vb[i.thread].postMessage({cmd:"cancel"}):"loaded"===a?(n.loaded=!0,r&&r(n),n.$b&&(n.$b(),delete n.$b)):"print"===a?R("Thread "+i.threadId+": "+i.text):"printErr"===a?C("Thread "+i.threadId+": "+i.text):"alert"===a?alert("Thread "+i.threadId+": "+i.text):"setimmediate"===i.target?n.postMessage(i):"onAbort"===a?c.onAbort&&c.onAbort(i.arg):a&&C("worker sent an unknown command "+a);eg.Bc=void 0},n.onerror=n=>{throw C("worker sent an error! "+n.filename+":"+n.lineno+": "+n.message),n},S&&(n.on("message",function(r){n.onmessage({data:r})}),n.on("error",function(r){n.onerror(r)}),n.on("detachedExit",function(){})),n.postMessage({cmd:"load",urlOrBlob:c.mainScriptUrlOrBlob||a,wasmMemory:D,wasmModule:N})},yc:function(){var n=M("ort-wasm-threaded.worker.js");eg.Yb.push(new Worker(n))},Cc:function(){return 0==eg.Yb.length&&(eg.yc(),eg.Fc(eg.Yb[0])),eg.Yb.pop()}};function e_(n){for(;0<n.length;)n.shift()(c)}function ey(n){var r=tv();return n=n(),tx(r),n}function eb(n){if(E)return eK(2,0,n);try{em(n)}catch(n){n instanceof eh||"unwind"==n||x(1,n)}}c.PThread=eg,c.establishStackSpace=function(){var n=to(),r=o()[n+44>>2>>>0];n=o()[n+48>>2>>>0],tb(r,r-n),tx(r)};var ev=[];function ex(n){var r=ev[n];return r||(n>=ev.length&&(ev.length=n+1),ev[n]=r=K.get(n)),r}c.invokeEntryPoint=function(n,r){n=ex(n)(r),et()?eg.nc(n):t_(n)};var ew,eT,eS=[],eE=0,eA=0;function eM(n){this.Zb=n,this.Sb=n-24,this.xc=function(n){l()[this.Sb+4>>2>>>0]=n},this.bc=function(){return l()[this.Sb+4>>2>>>0]},this.wc=function(n){l()[this.Sb+8>>2>>>0]=n},this.Dc=function(){return l()[this.Sb+8>>2>>>0]},this.rc=function(){o()[this.Sb>>2>>>0]=0},this.hc=function(n){n=n?1:0,r()[this.Sb+12>>0>>>0]=n},this.uc=function(){return 0!=r()[this.Sb+12>>0>>>0]},this.ic=function(n){n=n?1:0,r()[this.Sb+13>>0>>>0]=n},this.kc=function(){return 0!=r()[this.Sb+13>>0>>>0]},this.fc=function(n,r){this.cc(0),this.xc(n),this.wc(r),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(o(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(o(),this.Sb>>2,1)},this.cc=function(n){l()[this.Sb+16>>2>>>0]=n},this.tc=function(){return l()[this.Sb+16>>2>>>0]},this.vc=function(){if(tS(this.bc()))return l()[this.Zb>>2>>>0];var n=this.tc();return 0!==n?n:this.Zb}}function eI(n){return tu(new eM(n).Sb)}function eP(n,r,i,a){return E?eK(3,1,n,r,i,a):eO(n,r,i,a)}function eO(n,r,i,a){if("undefined"==typeof SharedArrayBuffer)return C("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var s=[];return E&&0===s.length?eP(n,r,i,a):(n={Ic:i,Ub:n,zc:a,Nc:s},E?(n.Oc="spawnThread",postMessage(n,s),0):ep(n))}function eR(n,r,i){return E?eK(4,1,n,r,i):0}function eC(n,r){if(E)return eK(5,1,n,r)}function eL(n,r){if(E)return eK(6,1,n,r)}function eD(n,r,i){if(E)return eK(7,1,n,r,i)}function eN(n,r,i){return E?eK(8,1,n,r,i):0}function ek(n,r){if(E)return eK(9,1,n,r)}function eU(n,r,i){if(E)return eK(10,1,n,r,i)}function eF(n,r,i,a){if(E)return eK(11,1,n,r,i,a)}function eB(n,r,i,a){if(E)return eK(12,1,n,r,i,a)}function ez(n,r,i,a){if(E)return eK(13,1,n,r,i,a)}function eV(n){if(E)return eK(14,1,n)}function eG(n,r){if(E)return eK(15,1,n,r)}function ej(n,r,i){if(E)return eK(16,1,n,r,i)}function eH(n){Atomics.store(o(),n>>2,1),to()&&tm(n),Atomics.compareExchange(o(),n>>2,1,0)}function e$(n){return l()[n>>>2]+4294967296*o()[n+4>>>2]}function eW(n,r,i,a,s,o){return E?eK(17,1,n,r,i,a,s,o):-52}function eX(n,r,i,a,s,o){if(E)return eK(18,1,n,r,i,a,s,o)}function eq(n){var i=X(n)+1,a=tl(i);return a&&W(n,r(),a,i),a}function eY(n,r,i){function a(n){return(n=n.toTimeString().match(/\(([A-Za-z ]+)\)$/))?n[1]:"GMT"}if(E)return eK(19,1,n,r,i);var s=(new Date).getFullYear(),u=new Date(s,0,1),c=new Date(s,6,1);s=u.getTimezoneOffset();var h=c.getTimezoneOffset(),d=Math.max(s,h);o()[n>>2>>>0]=60*d,o()[r>>2>>>0]=Number(s!=h),n=a(u),r=a(c),n=eq(n),r=eq(r),h<s?(l()[i>>2>>>0]=n,l()[i+4>>2>>>0]=r):(l()[i>>2>>>0]=r,l()[i+4>>2>>>0]=n)}function eK(n,r){var i=arguments.length-2,a=arguments;return ey(()=>{for(var s=tw(8*i),o=s>>3,l=0;l<i;l++){var c=a[2+l];u()[o+l>>>0]=c}return tf(n,i,s,r)})}c.executeNotifiedProxyingQueue=eH,eT=S?()=>{var n=$hPtJY.hrtime();return 1e3*n[0]+n[1]/1e6}:E?()=>performance.now()-c.__performance_now_clock_drift:()=>performance.now();var eZ,eJ=[],eQ={};function e0(){if(!eZ){var n,r={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:v||"./this.program"};for(n in eQ)void 0===eQ[n]?delete r[n]:r[n]=eQ[n];var i=[];for(n in r)i.push(n+"="+r[n]);eZ=i}return eZ}function e1(n,i){if(E)return eK(20,1,n,i);var a=0;return e0().forEach(function(s,o){var u=i+a;for(o=l()[n+4*o>>2>>>0]=u,u=0;u<s.length;++u)r()[o++>>0>>>0]=s.charCodeAt(u);r()[o>>0>>>0]=0,a+=s.length+1}),0}function e3(n,r){if(E)return eK(21,1,n,r);var i=e0();l()[n>>2>>>0]=i.length;var a=0;return i.forEach(function(n){a+=n.length+1}),l()[r>>2>>>0]=a,0}function e4(n){return E?eK(22,1,n):52}function e6(n,r,i,a){return E?eK(23,1,n,r,i,a):52}function e5(n,r,i,a,s){return E?eK(24,1,n,r,i,a,s):70}var e8=[null,[],[]];function e7(n,r){var i=e8[n];0===r||10===r?((1===n?R:C)(H(i,0)),i.length=0):i.push(r)}function e9(n,r,i,a){if(E)return eK(25,1,n,r,i,a);for(var o=0,u=0;u<i;u++){var c=l()[r>>2>>>0],h=l()[r+4>>2>>>0];r+=8;for(var d=0;d<h;d++)e7(n,s()[c+d>>>0]);o+=h}return l()[a>>2>>>0]=o,0}var te=0;function tt(n){return 0==n%4&&(0!=n%100||0==n%400)}var tn=[31,29,31,30,31,30,31,31,30,31,30,31],tr=[31,28,31,30,31,30,31,31,30,31,30,31];function ti(n,i,a,s){function l(n,r,i){for(n="number"==typeof n?n.toString():n||"";n.length<r;)n=i[0]+n;return n}function u(n,r){return l(n,r,"0")}function c(n,r){var i;function a(n){return 0>n?-1:0<n?1:0}return 0===(i=a(n.getFullYear()-r.getFullYear()))&&0===(i=a(n.getMonth()-r.getMonth()))&&(i=a(n.getDate()-r.getDate())),i}function h(n){switch(n.getDay()){case 0:return new Date(n.getFullYear()-1,11,29);case 1:return n;case 2:return new Date(n.getFullYear(),0,3);case 3:return new Date(n.getFullYear(),0,2);case 4:return new Date(n.getFullYear(),0,1);case 5:return new Date(n.getFullYear()-1,11,31);case 6:return new Date(n.getFullYear()-1,11,30)}}function d(n){var r=n.Wb;for(n=new Date(new Date(n.Xb+1900,0,1).getTime());0<r;){var i=n.getMonth(),a=(tt(n.getFullYear())?tn:tr)[i];if(!(r>a-n.getDate())){n.setDate(n.getDate()+r);break}r-=a-n.getDate()+1,n.setDate(1),11>i?n.setMonth(i+1):(n.setMonth(0),n.setFullYear(n.getFullYear()+1))}return i=new Date(n.getFullYear()+1,0,4),r=h(new Date(n.getFullYear(),0,4)),i=h(i),0>=c(r,n)?0>=c(i,n)?n.getFullYear()+1:n.getFullYear():n.getFullYear()-1}var p=o()[s+40>>2>>>0];for(var f in s={Lc:o()[s>>2>>>0],Kc:o()[s+4>>2>>>0],dc:o()[s+8>>2>>>0],jc:o()[s+12>>2>>>0],ec:o()[s+16>>2>>>0],Xb:o()[s+20>>2>>>0],Tb:o()[s+24>>2>>>0],Wb:o()[s+28>>2>>>0],Rc:o()[s+32>>2>>>0],Jc:o()[s+36>>2>>>0],Mc:p?$(p):""},a=$(a),p={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})a=a.replace(RegExp(f,"g"),p[f]);var m="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),g="January February March April May June July August September October November December".split(" ");for(f in p={"%a":function(n){return m[n.Tb].substring(0,3)},"%A":function(n){return m[n.Tb]},"%b":function(n){return g[n.ec].substring(0,3)},"%B":function(n){return g[n.ec]},"%C":function(n){return u((n.Xb+1900)/100|0,2)},"%d":function(n){return u(n.jc,2)},"%e":function(n){return l(n.jc,2," ")},"%g":function(n){return d(n).toString().substring(2)},"%G":function(n){return d(n)},"%H":function(n){return u(n.dc,2)},"%I":function(n){return 0==(n=n.dc)?n=12:12<n&&(n-=12),u(n,2)},"%j":function(n){for(var r=0,i=0;i<=n.ec-1;r+=(tt(n.Xb+1900)?tn:tr)[i++]);return u(n.jc+r,3)},"%m":function(n){return u(n.ec+1,2)},"%M":function(n){return u(n.Kc,2)},"%n":function(){return"\n"},"%p":function(n){return 0<=n.dc&&12>n.dc?"AM":"PM"},"%S":function(n){return u(n.Lc,2)},"%t":function(){return"	"},"%u":function(n){return n.Tb||7},"%U":function(n){return u(Math.floor((n.Wb+7-n.Tb)/7),2)},"%V":function(n){var r=Math.floor((n.Wb+7-(n.Tb+6)%7)/7);if(2>=(n.Tb+371-n.Wb-2)%7&&r++,r)53==r&&(4==(i=(n.Tb+371-n.Wb)%7)||3==i&&tt(n.Xb)||(r=1));else{r=52;var i=(n.Tb+7-n.Wb-1)%7;(4==i||5==i&&tt(n.Xb%400-1))&&r++}return u(r,2)},"%w":function(n){return n.Tb},"%W":function(n){return u(Math.floor((n.Wb+7-(n.Tb+6)%7)/7),2)},"%y":function(n){return(n.Xb+1900).toString().substring(2)},"%Y":function(n){return n.Xb+1900},"%z":function(n){var r=0<=(n=n.Jc);return(r?"+":"-")+String("0000"+((n=Math.abs(n)/60)/60*100+n%60)).slice(-4)},"%Z":function(n){return n.Mc},"%%":function(){return"%"}},a=a.replace(/%%/g,"\x00\x00"),p)a.includes(f)&&(a=a.replace(RegExp(f,"g"),p[f](s)));return(f=function(n){var r=Array(X(n)+1);return W(n,r,0,r.length),r}(a=a.replace(/\0\0/g,"%"))).length>i?0:(function(n,i){r().set(n,i>>>0)}(f,n),f.length-1)}eg.fc();var ta=[null,ef,eb,eP,eR,eC,eL,eD,eN,ek,eU,eF,eB,ez,eV,eG,ej,eW,eX,eY,e1,e3,e4,e6,e5,e9],ts={b:function(n){return tl(n+24)+24},n:function(n){return(n=new eM(n)).uc()||(n.hc(!0),eE--),n.ic(!1),eS.push(n),n.sc(),n.vc()},ma:function(n){throw C("Unexpected exception thrown, this is not properly supported - aborting"),G=!0,n},x:function(){ty(0);var n=eS.pop();if(n.Hc()&&!n.kc()){var r=n.Dc();r&&ex(r)(n.Zb),eI(n.Zb)}eA=0},e:function(){var n=eA;if(!n)return te=0;var r=new eM(n);r.cc(n);var i=r.bc();if(!i)return te=0,n;for(var a=Array.prototype.slice.call(arguments),s=0;s<a.length;s++){var o=a[s];if(0===o||o===i)break;if(tT(o,i,r.Sb+16))return te=o,n}return te=i,n},l:function(){var n=eA;if(!n)return te=0;var r=new eM(n);r.cc(n);var i=r.bc();if(!i)return te=0,n;for(var a=Array.prototype.slice.call(arguments),s=0;s<a.length;s++){var o=a[s];if(0===o||o===i)break;if(tT(o,i,r.Sb+16))return te=o,n}return te=i,n},h:function(){var n=eA;if(!n)return te=0;var r=new eM(n);r.cc(n);var i=r.bc();if(!i)return te=0,n;for(var a=Array.prototype.slice.call(arguments),s=0;s<a.length;s++){var o=a[s];if(0===o||o===i)break;if(tT(o,i,r.Sb+16))return te=o,n}return te=i,n},t:eI,M:function(){var n=eS.pop();n||eo("no exception to throw");var r=n.Zb;throw n.kc()||(eS.push(n),n.ic(!0),n.hc(!1),eE++),eA=r,r},c:function(n,r,i){throw new eM(n).fc(r,i),eA=n,eE++,n},pa:function(){return eE},Fa:function(n){td(n,!T,1,!w),eg.pc()},T:function(n){E?postMessage({cmd:"cleanupThread",thread:n}):ed(n)},xa:eO,j:function(n){throw eA||(eA=n),n},H:eR,Ma:eC,ua:eL,wa:eD,oa:eN,Ka:ek,Ca:eU,Ja:eF,V:eB,va:ez,sa:eV,La:eG,ta:ej,Ta:function(){},X:function(){eo("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){eo("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(n,r,i,a){if(n==r)setTimeout(()=>eH(a));else if(E)postMessage({targetThread:n,cmd:"processProxyingQueue",queue:a});else{if(!(n=eg.Vb[n]))return;n.postMessage({cmd:"processProxyingQueue",queue:a})}return 1},Ea:function(){return -1},Pa:function(n,r){n=new Date(1e3*e$(n)),o()[r>>2>>>0]=n.getUTCSeconds(),o()[r+4>>2>>>0]=n.getUTCMinutes(),o()[r+8>>2>>>0]=n.getUTCHours(),o()[r+12>>2>>>0]=n.getUTCDate(),o()[r+16>>2>>>0]=n.getUTCMonth(),o()[r+20>>2>>>0]=n.getUTCFullYear()-1900,o()[r+24>>2>>>0]=n.getUTCDay(),n=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,o()[r+28>>2>>>0]=n},Qa:function(n,r){n=new Date(1e3*e$(n)),o()[r>>2>>>0]=n.getSeconds(),o()[r+4>>2>>>0]=n.getMinutes(),o()[r+8>>2>>>0]=n.getHours(),o()[r+12>>2>>>0]=n.getDate(),o()[r+16>>2>>>0]=n.getMonth(),o()[r+20>>2>>>0]=n.getFullYear()-1900,o()[r+24>>2>>>0]=n.getDay();var i=new Date(n.getFullYear(),0,1),a=(n.getTime()-i.getTime())/864e5|0;o()[r+28>>2>>>0]=a,o()[r+36>>2>>>0]=-60*n.getTimezoneOffset(),n=0|((a=new Date(n.getFullYear(),6,1).getTimezoneOffset())!=(i=i.getTimezoneOffset())&&n.getTimezoneOffset()==Math.min(i,a)),o()[r+32>>2>>>0]=n},Ra:function(n){var r=new Date(o()[n+20>>2>>>0]+1900,o()[n+16>>2>>>0],o()[n+12>>2>>>0],o()[n+8>>2>>>0],o()[n+4>>2>>>0],o()[n>>2>>>0],0),i=o()[n+32>>2>>>0],a=r.getTimezoneOffset(),s=new Date(r.getFullYear(),0,1),l=new Date(r.getFullYear(),6,1).getTimezoneOffset(),u=s.getTimezoneOffset(),c=Math.min(u,l);return 0>i?o()[n+32>>2>>>0]=Number(l!=u&&c==a):0<i!=(c==a)&&(l=Math.max(u,l),r.setTime(r.getTime()+6e4*((0<i?c:l)-a))),o()[n+24>>2>>>0]=r.getDay(),i=(r.getTime()-s.getTime())/864e5|0,o()[n+28>>2>>>0]=i,o()[n>>2>>>0]=r.getSeconds(),o()[n+4>>2>>>0]=r.getMinutes(),o()[n+8>>2>>>0]=r.getHours(),o()[n+12>>2>>>0]=r.getDate(),o()[n+16>>2>>>0]=r.getMonth(),r.getTime()/1e3|0},Aa:eW,Ba:eX,Sa:function n(r,i,a){n.Ac||(n.Ac=!0,eY(r,i,a))},y:function(){eo("")},U:function(){if(!S&&!T){var n="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";ew||(ew={}),ew[n]||(ew[n]=1,S&&(n="warning: "+n),C(n))}},ra:function(){return 4294901760},B:eT,Ia:function(n,r,i){s().copyWithin(n>>>0,r>>>0,r+i>>>0)},F:function(){return S?i(3993).cpus().length:navigator.hardwareConcurrency},Da:function(n,r,i){eJ.length=r,i>>=3;for(var a=0;a<r;a++)eJ[a]=u()[i+a>>>0];return(0>n?ec[-n-1]:ta[n]).apply(null,eJ)},qa:function(n){var r=s().length;if((n>>>=0)<=r||4294901760<n)return!1;for(var i=1;4>=i;i*=2){var a=r*(1+.2/i);a=Math.min(a,n+100663296);var o=Math;a=Math.max(n,a),o=o.min.call(o,4294901760,a+(65536-a%65536)%65536);e:{try{D.grow(o-k.byteLength+65535>>>16),q(D.buffer);var l=1;break e}catch(n){}l=void 0}if(l)return!0}return!1},Na:function(){throw"unwind"},Ga:e1,Ha:e3,J:em,I:e4,S:e6,ga:e5,R:e9,d:function(){return te},na:function n(a,s){n.lc||(n.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var n=new Uint8Array(1);return()=>(crypto.getRandomValues(n),n[0])}if(S)try{var r=i(Object(function(){var n=Error("Cannot find module 'crypto'");throw n.code="MODULE_NOT_FOUND",n}()));return()=>r.randomBytes(1)[0]}catch(n){}return()=>eo("randomDevice")}());for(var o=0;o<s;o++)r()[a+o>>0>>>0]=n.lc();return 0},ia:function(n,r,i){var a=tv();try{return ex(n)(r,i)}catch(n){if(tx(a),n!==n+0)throw n;ty(1,0)}},ja:function(n,r,i){var a=tv();try{return ex(n)(r,i)}catch(n){if(tx(a),n!==n+0)throw n;ty(1,0)}},K:function(n){var r=tv();try{return ex(n)()}catch(n){if(tx(r),n!==n+0)throw n;ty(1,0)}},f:function(n,r){var i=tv();try{return ex(n)(r)}catch(n){if(tx(i),n!==n+0)throw n;ty(1,0)}},P:function(n,r,i){var a=tv();try{return ex(n)(r,i)}catch(n){if(tx(a),n!==n+0)throw n;ty(1,0)}},Q:function(n,r,i){var a=tv();try{return ex(n)(r,i)}catch(n){if(tx(a),n!==n+0)throw n;ty(1,0)}},k:function(n,r,i){var a=tv();try{return ex(n)(r,i)}catch(n){if(tx(a),n!==n+0)throw n;ty(1,0)}},p:function(n,r,i,a){var s=tv();try{return ex(n)(r,i,a)}catch(n){if(tx(s),n!==n+0)throw n;ty(1,0)}},q:function(n,r,i,a,s){var o=tv();try{return ex(n)(r,i,a,s)}catch(n){if(tx(o),n!==n+0)throw n;ty(1,0)}},N:function(n,r,i,a,s,o){var l=tv();try{return ex(n)(r,i,a,s,o)}catch(n){if(tx(l),n!==n+0)throw n;ty(1,0)}},s:function(n,r,i,a,s,o){var l=tv();try{return ex(n)(r,i,a,s,o)}catch(n){if(tx(l),n!==n+0)throw n;ty(1,0)}},w:function(n,r,i,a,s,o,l){var u=tv();try{return ex(n)(r,i,a,s,o,l)}catch(n){if(tx(u),n!==n+0)throw n;ty(1,0)}},L:function(n,r,i,a,s,o,l,u){var c=tv();try{return ex(n)(r,i,a,s,o,l,u)}catch(n){if(tx(c),n!==n+0)throw n;ty(1,0)}},E:function(n,r,i,a,s,o,l,u,c,h,d,p){var f=tv();try{return ex(n)(r,i,a,s,o,l,u,c,h,d,p)}catch(n){if(tx(f),n!==n+0)throw n;ty(1,0)}},aa:function(n,r,i,a,s,o,l,u){var c=tv();try{return tL(n,r,i,a,s,o,l,u)}catch(n){if(tx(c),n!==n+0)throw n;ty(1,0)}},_:function(n,r,i,a,s,o,l){var u=tv();try{return tA(n,r,i,a,s,o,l)}catch(n){if(tx(u),n!==n+0)throw n;ty(1,0)}},Z:function(n,r,i,a,s){var o=tv();try{return tD(n,r,i,a,s)}catch(n){if(tx(o),n!==n+0)throw n;ty(1,0)}},ca:function(n,r,i,a){var s=tv();try{return tR(n,r,i,a)}catch(n){if(tx(s),n!==n+0)throw n;ty(1,0)}},$:function(n){var r=tv();try{return tE(n)}catch(n){if(tx(r),n!==n+0)throw n;ty(1,0)}},ba:function(n,r){var i=tv();try{return tC(n,r)}catch(n){if(tx(i),n!==n+0)throw n;ty(1,0)}},Y:function(n,r,i){var a=tv();try{return tM(n,r,i)}catch(n){if(tx(a),n!==n+0)throw n;ty(1,0)}},g:function(n){var r=tv();try{ex(n)()}catch(n){if(tx(r),n!==n+0)throw n;ty(1,0)}},r:function(n,r){var i=tv();try{ex(n)(r)}catch(n){if(tx(i),n!==n+0)throw n;ty(1,0)}},i:function(n,r,i){var a=tv();try{ex(n)(r,i)}catch(n){if(tx(a),n!==n+0)throw n;ty(1,0)}},ha:function(n,r,i,a){var s=tv();try{ex(n)(r,i,a)}catch(n){if(tx(s),n!==n+0)throw n;ty(1,0)}},m:function(n,r,i,a){var s=tv();try{ex(n)(r,i,a)}catch(n){if(tx(s),n!==n+0)throw n;ty(1,0)}},v:function(n,r,i,a,s){var o=tv();try{ex(n)(r,i,a,s)}catch(n){if(tx(o),n!==n+0)throw n;ty(1,0)}},u:function(n,r,i,a,s,o){var l=tv();try{ex(n)(r,i,a,s,o)}catch(n){if(tx(l),n!==n+0)throw n;ty(1,0)}},O:function(n,r,i,a,s,o,l){var u=tv();try{ex(n)(r,i,a,s,o,l)}catch(n){if(tx(u),n!==n+0)throw n;ty(1,0)}},A:function(n,r,i,a,s,o,l,u){var c=tv();try{ex(n)(r,i,a,s,o,l,u)}catch(n){if(tx(c),n!==n+0)throw n;ty(1,0)}},ka:function(n,r,i,a,s,o,l,u,c){var h=tv();try{ex(n)(r,i,a,s,o,l,u,c)}catch(n){if(tx(h),n!==n+0)throw n;ty(1,0)}},C:function(n,r,i,a,s,o,l,u,c,h,d){var p=tv();try{ex(n)(r,i,a,s,o,l,u,c,h,d)}catch(n){if(tx(p),n!==n+0)throw n;ty(1,0)}},D:function(n,r,i,a,s,o,l,u,c,h,d,p,f,m,g,_){var y=tv();try{ex(n)(r,i,a,s,o,l,u,c,h,d,p,f,m,g,_)}catch(n){if(tx(y),n!==n+0)throw n;ty(1,0)}},fa:function(n,r,i,a,s,o,l,u){var c=tv();try{tI(n,r,i,a,s,o,l,u)}catch(n){if(tx(c),n!==n+0)throw n;ty(1,0)}},da:function(n,r,i,a,s,o,l,u,c,h,d,p){var f=tv();try{tO(n,r,i,a,s,o,l,u,c,h,d,p)}catch(n){if(tx(f),n!==n+0)throw n;ty(1,0)}},ea:function(n,r,i,a,s,o){var l=tv();try{tP(n,r,i,a,s,o)}catch(n){if(tx(l),n!==n+0)throw n;ty(1,0)}},o:function(n){return n},a:D||c.wasmMemory,G:function(n){te=n},la:ti,z:function(n,r,i,a){return ti(n,r,i,a)}};(function(){function n(n,r){c.asm=n.exports,eg.qc.push(c.asm.sb),K=c.asm.ub,J.unshift(c.asm.Va),N=r,E||(ei--,c.monitorRunDependencies&&c.monitorRunDependencies(ei),0==ei&&(null!==ea&&(clearInterval(ea),ea=null),es&&(n=es,es=null,n())))}function r(r){n(r.instance,r.module)}function i(n){return(function(){if(!O&&(w||T)){if("function"==typeof fetch&&!er.startsWith("file://"))return fetch(er,{credentials:"same-origin"}).then(function(n){if(!n.ok)throw"failed to load wasm binary file at '"+er+"'";return n.arrayBuffer()}).catch(function(){return eu()});if(f)return new Promise(function(n,r){f(er,function(r){n(new Uint8Array(r))},r)})}return Promise.resolve().then(function(){return eu()})})().then(function(n){return WebAssembly.instantiate(n,a)}).then(function(n){return n}).then(n,function(n){C("failed to asynchronously prepare wasm: "+n),eo(n)})}var a={a:ts};if(E||(ei++,c.monitorRunDependencies&&c.monitorRunDependencies(ei)),c.instantiateWasm)try{return c.instantiateWasm(a,n)}catch(n){return C("Module.instantiateWasm callback failed with error: "+n),!1}(O||"function"!=typeof WebAssembly.instantiateStreaming||el()||er.startsWith("file://")||S||"function"!=typeof fetch?i(r):fetch(er,{credentials:"same-origin"}).then(function(n){return WebAssembly.instantiateStreaming(n,a).then(r,function(n){return C("wasm streaming compile failed: "+n),C("falling back to ArrayBuffer instantiation"),i(r)})})).catch(d)})(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.Va).apply(null,arguments)},c._OrtInit=function(){return(c._OrtInit=c.asm.Wa).apply(null,arguments)},c._OrtCreateSessionOptions=function(){return(c._OrtCreateSessionOptions=c.asm.Xa).apply(null,arguments)},c._OrtAppendExecutionProvider=function(){return(c._OrtAppendExecutionProvider=c.asm.Ya).apply(null,arguments)},c._OrtAddSessionConfigEntry=function(){return(c._OrtAddSessionConfigEntry=c.asm.Za).apply(null,arguments)},c._OrtReleaseSessionOptions=function(){return(c._OrtReleaseSessionOptions=c.asm._a).apply(null,arguments)},c._OrtCreateSession=function(){return(c._OrtCreateSession=c.asm.$a).apply(null,arguments)},c._OrtReleaseSession=function(){return(c._OrtReleaseSession=c.asm.ab).apply(null,arguments)},c._OrtGetInputCount=function(){return(c._OrtGetInputCount=c.asm.bb).apply(null,arguments)},c._OrtGetOutputCount=function(){return(c._OrtGetOutputCount=c.asm.cb).apply(null,arguments)},c._OrtGetInputName=function(){return(c._OrtGetInputName=c.asm.db).apply(null,arguments)},c._OrtGetOutputName=function(){return(c._OrtGetOutputName=c.asm.eb).apply(null,arguments)},c._OrtFree=function(){return(c._OrtFree=c.asm.fb).apply(null,arguments)},c._OrtCreateTensor=function(){return(c._OrtCreateTensor=c.asm.gb).apply(null,arguments)},c._OrtGetTensorData=function(){return(c._OrtGetTensorData=c.asm.hb).apply(null,arguments)},c._OrtReleaseTensor=function(){return(c._OrtReleaseTensor=c.asm.ib).apply(null,arguments)},c._OrtCreateRunOptions=function(){return(c._OrtCreateRunOptions=c.asm.jb).apply(null,arguments)},c._OrtAddRunConfigEntry=function(){return(c._OrtAddRunConfigEntry=c.asm.kb).apply(null,arguments)},c._OrtReleaseRunOptions=function(){return(c._OrtReleaseRunOptions=c.asm.lb).apply(null,arguments)},c._OrtRun=function(){return(c._OrtRun=c.asm.mb).apply(null,arguments)},c._OrtEndProfiling=function(){return(c._OrtEndProfiling=c.asm.nb).apply(null,arguments)};var to=c._pthread_self=function(){return(to=c._pthread_self=c.asm.ob).apply(null,arguments)},tl=c._malloc=function(){return(tl=c._malloc=c.asm.pb).apply(null,arguments)},tu=c._free=function(){return(tu=c._free=c.asm.qb).apply(null,arguments)},tc=c._fflush=function(){return(tc=c._fflush=c.asm.rb).apply(null,arguments)};c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm.sb).apply(null,arguments)};var th=c.___funcs_on_exit=function(){return(th=c.___funcs_on_exit=c.asm.tb).apply(null,arguments)},td=c.__emscripten_thread_init=function(){return(td=c.__emscripten_thread_init=c.asm.vb).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm.wb).apply(null,arguments)};var tp,tf=c._emscripten_run_in_main_runtime_thread_js=function(){return(tf=c._emscripten_run_in_main_runtime_thread_js=c.asm.xb).apply(null,arguments)},tm=c.__emscripten_proxy_execute_task_queue=function(){return(tm=c.__emscripten_proxy_execute_task_queue=c.asm.yb).apply(null,arguments)},tg=c.__emscripten_thread_free_data=function(){return(tg=c.__emscripten_thread_free_data=c.asm.zb).apply(null,arguments)},t_=c.__emscripten_thread_exit=function(){return(t_=c.__emscripten_thread_exit=c.asm.Ab).apply(null,arguments)},ty=c._setThrew=function(){return(ty=c._setThrew=c.asm.Bb).apply(null,arguments)},tb=c._emscripten_stack_set_limits=function(){return(tb=c._emscripten_stack_set_limits=c.asm.Cb).apply(null,arguments)},tv=c.stackSave=function(){return(tv=c.stackSave=c.asm.Db).apply(null,arguments)},tx=c.stackRestore=function(){return(tx=c.stackRestore=c.asm.Eb).apply(null,arguments)},tw=c.stackAlloc=function(){return(tw=c.stackAlloc=c.asm.Fb).apply(null,arguments)},tT=c.___cxa_can_catch=function(){return(tT=c.___cxa_can_catch=c.asm.Gb).apply(null,arguments)},tS=c.___cxa_is_pointer_type=function(){return(tS=c.___cxa_is_pointer_type=c.asm.Hb).apply(null,arguments)},tE=c.dynCall_j=function(){return(tE=c.dynCall_j=c.asm.Ib).apply(null,arguments)},tA=c.dynCall_iiiiij=function(){return(tA=c.dynCall_iiiiij=c.asm.Jb).apply(null,arguments)},tM=c.dynCall_jii=function(){return(tM=c.dynCall_jii=c.asm.Kb).apply(null,arguments)},tI=c.dynCall_viiiiij=function(){return(tI=c.dynCall_viiiiij=c.asm.Lb).apply(null,arguments)},tP=c.dynCall_vjji=function(){return(tP=c.dynCall_vjji=c.asm.Mb).apply(null,arguments)},tO=c.dynCall_viiijjjii=function(){return(tO=c.dynCall_viiijjjii=c.asm.Nb).apply(null,arguments)},tR=c.dynCall_iij=function(){return(tR=c.dynCall_iij=c.asm.Ob).apply(null,arguments)},tC=c.dynCall_ji=function(){return(tC=c.dynCall_ji=c.asm.Pb).apply(null,arguments)},tL=c.dynCall_iiiiiij=function(){return(tL=c.dynCall_iiiiiij=c.asm.Qb).apply(null,arguments)},tD=c.dynCall_iiij=function(){return(tD=c.dynCall_iiij=c.asm.Rb).apply(null,arguments)};function tN(){function n(){if(!tp&&(tp=!0,c.calledRun=!0,!G)&&(E||e_(J),h(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!E)){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var n=c.postRun.shift();ee.unshift(n)}e_(ee)}}if(!(0<ei)){if(E)h(c),E||e_(J),postMessage({cmd:"loaded"});else{if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)en();e_(Z),0<ei||(c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),n()},1)):n())}}}if(c.UTF8ToString=$,c.stringToUTF8=function(n,r,i){return W(n,s(),r,i)},c.lengthBytesUTF8=X,c.keepRuntimeAlive=et,c.wasmMemory=D,c.stackSave=tv,c.stackRestore=tx,c.stackAlloc=tw,c.ExitStatus=eh,c.PThread=eg,es=function n(){tp||tN(),tp||(es=n)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return tN(),n.ready});n.exports=s},932:(n,r,i)=>{var a,s=(a=(a="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(n){n=n||{},r||(r=void 0!==n?n:{}),r.ready=new Promise(function(n,r){s=n,o=r});var r,s,o,l,u,c,h,d,p,f=Object.assign({},r),m="./this.program",g=(n,r)=>{throw r},_="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof $hPtJY&&"object"==typeof $hPtJY.versions&&"string"==typeof $hPtJY.versions.node,v="";b?(v=y?i(908).dirname(v)+"/":"//",p=()=>{d||(h=i(1384),d=i(908))},l=function(n,r){return p(),n=d.normalize(n),h.readFileSync(n,r?void 0:"utf8")},c=n=>((n=l(n,!0)).buffer||(n=new Uint8Array(n)),n),u=(n,r,i)=>{p(),n=d.normalize(n),h.readFile(n,function(n,a){n?i(n):r(a.buffer)})},1<$hPtJY.argv.length&&(m=$hPtJY.argv[1].replace(/\\/g,"/")),$hPtJY.argv.slice(2),$hPtJY.on("uncaughtException",function(n){if(!(n instanceof Q))throw n}),$hPtJY.on("unhandledRejection",function(n){throw n}),g=(n,r)=>{if(S||0<j)throw $hPtJY.exitCode=n,r;r instanceof Q||T("exiting due to exception: "+r),$hPtJY.exit(n)},r.inspect=function(){return"[Emscripten Module object]"}):(_||y)&&(y?v=self.location.href:"undefined"!=typeof document&&document.currentScript&&(v=document.currentScript.src),a&&(v=a),v=0!==v.indexOf("blob:")?v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):"",l=n=>{var r=new XMLHttpRequest;return r.open("GET",n,!1),r.send(null),r.responseText},y&&(c=n=>{var r=new XMLHttpRequest;return r.open("GET",n,!1),r.responseType="arraybuffer",r.send(null),new Uint8Array(r.response)}),u=(n,r,i)=>{var a=new XMLHttpRequest;a.open("GET",n,!0),a.responseType="arraybuffer",a.onload=()=>{200==a.status||0==a.status&&a.response?r(a.response):i()},a.onerror=i,a.send(null)});var x,w=r.print||console.log.bind(console),T=r.printErr||console.warn.bind(console);Object.assign(r,f),f=null,r.thisProgram&&(m=r.thisProgram),r.quit&&(g=r.quit),r.wasmBinary&&(x=r.wasmBinary);var S=r.noExitRuntime||!1;"object"!=typeof WebAssembly&&Y("no native wasm support detected");var E,A,M,I,P,O,R=!1,C="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function L(n,r,i){var a=(r>>>=0)+i;for(i=r;n[i]&&!(i>=a);)++i;if(16<i-r&&n.buffer&&C)return C.decode(n.subarray(r,i));for(a="";r<i;){var s=n[r++];if(128&s){var o=63&n[r++];if(192==(224&s))a+=String.fromCharCode((31&s)<<6|o);else{var l=63&n[r++];65536>(s=224==(240&s)?(15&s)<<12|o<<6|l:(7&s)<<18|o<<12|l<<6|63&n[r++])?a+=String.fromCharCode(s):(s-=65536,a+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else a+=String.fromCharCode(s)}return a}function D(n,r){return(n>>>=0)?L(I,n,r):""}function N(n,r,i,a){if(!(0<a))return 0;var s=i>>>=0;a=i+a-1;for(var o=0;o<n.length;++o){var l=n.charCodeAt(o);if(55296<=l&&57343>=l&&(l=65536+((1023&l)<<10)|1023&n.charCodeAt(++o)),127>=l){if(i>=a)break;r[i++>>>0]=l}else{if(2047>=l){if(i+1>=a)break;r[i++>>>0]=192|l>>6}else{if(65535>=l){if(i+2>=a)break;r[i++>>>0]=224|l>>12}else{if(i+3>=a)break;r[i++>>>0]=240|l>>18,r[i++>>>0]=128|l>>12&63}r[i++>>>0]=128|l>>6&63}r[i++>>>0]=128|63&l}}return r[i>>>0]=0,i-s}function k(n){for(var r=0,i=0;i<n.length;++i){var a=n.charCodeAt(i);127>=a?r++:2047>=a?r+=2:55296<=a&&57343>=a?(r+=4,++i):r+=3}return r}function U(){var n=E.buffer;A=n,r.HEAP8=M=new Int8Array(n),r.HEAP16=new Int16Array(n),r.HEAP32=P=new Int32Array(n),r.HEAPU8=I=new Uint8Array(n),r.HEAPU16=new Uint16Array(n),r.HEAPU32=O=new Uint32Array(n),r.HEAPF32=new Float32Array(n),r.HEAPF64=new Float64Array(n)}var F,B=[],z=[],V=[],G=[],j=0;function H(){var n=r.preRun.shift();B.unshift(n)}var $,W=0,X=null,q=null;function Y(n){throw r.onAbort&&r.onAbort(n),T(n="Aborted("+n+")"),R=!0,n=new WebAssembly.RuntimeError(n+". Build with -sASSERTIONS for more info."),o(n),n}function K(){return $.startsWith("data:application/octet-stream;base64,")}if($="ort-wasm.wasm",!K()){var Z=$;$=r.locateFile?r.locateFile(Z,v):v+Z}function J(){var n=$;try{if(n==$&&x)return new Uint8Array(x);if(c)return c(n);throw"both async and sync fetching of the wasm failed"}catch(n){Y(n)}}function Q(n){this.name="ExitStatus",this.message="Program terminated with exit("+n+")",this.status=n}function ee(n){for(;0<n.length;)n.shift()(r)}var et=[],en=0,er=0;function ei(n){this.Db=n,this.zb=n-24,this.Ub=function(n){O[this.zb+4>>2>>>0]=n},this.Eb=function(){return O[this.zb+4>>2>>>0]},this.Sb=function(n){O[this.zb+8>>2>>>0]=n},this.Wb=function(){return O[this.zb+8>>2>>>0]},this.Tb=function(){P[this.zb>>2>>>0]=0},this.Ib=function(n){M[this.zb+12>>0>>>0]=n?1:0},this.Pb=function(){return 0!=M[this.zb+12>>0>>>0]},this.Jb=function(n){M[this.zb+13>>0>>>0]=n?1:0},this.Lb=function(){return 0!=M[this.zb+13>>0>>>0]},this.Rb=function(n,r){this.Fb(0),this.Ub(n),this.Sb(r),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){P[this.zb>>2>>>0]+=1},this.Xb=function(){var n=P[this.zb>>2>>>0];return P[this.zb>>2>>>0]=n-1,1===n},this.Fb=function(n){O[this.zb+16>>2>>>0]=n},this.Ob=function(){return O[this.zb+16>>2>>>0]},this.Qb=function(){if(eO(this.Eb()))return O[this.Db>>2>>>0];var n=this.Ob();return 0!==n?n:this.Db}}function ea(n){return ew(new ei(n).zb)}var es=[];function eo(n){var r=es[n];return r||(n>=es.length&&(es.length=n+1),es[n]=r=F.get(n)),r}function el(n){var r=k(n)+1,i=ex(r);return i&&N(n,M,i,r),i}var eu={};function ec(){if(!eh){var n,r={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(n in eu)void 0===eu[n]?delete r[n]:r[n]=eu[n];var i=[];for(n in r)i.push(n+"="+r[n]);eh=i}return eh}var eh,ed=[null,[],[]];function ep(n,r){var i=ed[n];0===r||10===r?((1===n?w:T)(L(i,0)),i.length=0):i.push(r)}var ef=0;function em(n){return 0==n%4&&(0!=n%100||0==n%400)}var eg=[31,29,31,30,31,30,31,31,30,31,30,31],e_=[31,28,31,30,31,30,31,31,30,31,30,31];function ey(n,r,i,a){function s(n,r,i){for(n="number"==typeof n?n.toString():n||"";n.length<r;)n=i[0]+n;return n}function o(n,r){return s(n,r,"0")}function l(n,r){var i;function a(n){return 0>n?-1:0<n?1:0}return 0===(i=a(n.getFullYear()-r.getFullYear()))&&0===(i=a(n.getMonth()-r.getMonth()))&&(i=a(n.getDate()-r.getDate())),i}function u(n){switch(n.getDay()){case 0:return new Date(n.getFullYear()-1,11,29);case 1:return n;case 2:return new Date(n.getFullYear(),0,3);case 3:return new Date(n.getFullYear(),0,2);case 4:return new Date(n.getFullYear(),0,1);case 5:return new Date(n.getFullYear()-1,11,31);case 6:return new Date(n.getFullYear()-1,11,30)}}function c(n){var r=n.Bb;for(n=new Date(new Date(n.Cb+1900,0,1).getTime());0<r;){var i=n.getMonth(),a=(em(n.getFullYear())?eg:e_)[i];if(!(r>a-n.getDate())){n.setDate(n.getDate()+r);break}r-=a-n.getDate()+1,n.setDate(1),11>i?n.setMonth(i+1):(n.setMonth(0),n.setFullYear(n.getFullYear()+1))}return i=new Date(n.getFullYear()+1,0,4),r=u(new Date(n.getFullYear(),0,4)),i=u(i),0>=l(r,n)?0>=l(i,n)?n.getFullYear()+1:n.getFullYear():n.getFullYear()-1}var h=P[a+40>>2>>>0];for(var d in a={$b:P[a>>2>>>0],Zb:P[a+4>>2>>>0],Gb:P[a+8>>2>>>0],Kb:P[a+12>>2>>>0],Hb:P[a+16>>2>>>0],Cb:P[a+20>>2>>>0],Ab:P[a+24>>2>>>0],Bb:P[a+28>>2>>>0],bc:P[a+32>>2>>>0],Yb:P[a+36>>2>>>0],ac:h?D(h):""},i=D(i),h={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})i=i.replace(RegExp(d,"g"),h[d]);var p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),f="January February March April May June July August September October November December".split(" ");for(d in h={"%a":function(n){return p[n.Ab].substring(0,3)},"%A":function(n){return p[n.Ab]},"%b":function(n){return f[n.Hb].substring(0,3)},"%B":function(n){return f[n.Hb]},"%C":function(n){return o((n.Cb+1900)/100|0,2)},"%d":function(n){return o(n.Kb,2)},"%e":function(n){return s(n.Kb,2," ")},"%g":function(n){return c(n).toString().substring(2)},"%G":function(n){return c(n)},"%H":function(n){return o(n.Gb,2)},"%I":function(n){return 0==(n=n.Gb)?n=12:12<n&&(n-=12),o(n,2)},"%j":function(n){for(var r=0,i=0;i<=n.Hb-1;r+=(em(n.Cb+1900)?eg:e_)[i++]);return o(n.Kb+r,3)},"%m":function(n){return o(n.Hb+1,2)},"%M":function(n){return o(n.Zb,2)},"%n":function(){return"\n"},"%p":function(n){return 0<=n.Gb&&12>n.Gb?"AM":"PM"},"%S":function(n){return o(n.$b,2)},"%t":function(){return"	"},"%u":function(n){return n.Ab||7},"%U":function(n){return o(Math.floor((n.Bb+7-n.Ab)/7),2)},"%V":function(n){var r=Math.floor((n.Bb+7-(n.Ab+6)%7)/7);if(2>=(n.Ab+371-n.Bb-2)%7&&r++,r)53==r&&(4==(i=(n.Ab+371-n.Bb)%7)||3==i&&em(n.Cb)||(r=1));else{r=52;var i=(n.Ab+7-n.Bb-1)%7;(4==i||5==i&&em(n.Cb%400-1))&&r++}return o(r,2)},"%w":function(n){return n.Ab},"%W":function(n){return o(Math.floor((n.Bb+7-(n.Ab+6)%7)/7),2)},"%y":function(n){return(n.Cb+1900).toString().substring(2)},"%Y":function(n){return n.Cb+1900},"%z":function(n){var r=0<=(n=n.Yb);return(r?"+":"-")+String("0000"+((n=Math.abs(n)/60)/60*100+n%60)).slice(-4)},"%Z":function(n){return n.ac},"%%":function(){return"%"}},i=i.replace(/%%/g,"\x00\x00"),h)i.includes(d)&&(i=i.replace(RegExp(d,"g"),h[d](a)));return(d=function(n){var r=Array(k(n)+1);return N(n,r,0,r.length),r}(i=i.replace(/\0\0/g,"%"))).length>r?0:(M.set(d,n>>>0),d.length-1)}var eb={a:function(n){return ex(n+24)+24},m:function(n){return(n=new ei(n)).Pb()||(n.Ib(!0),en--),n.Jb(!1),et.push(n),n.Nb(),n.Qb()},ia:function(n){throw T("Unexpected exception thrown, this is not properly supported - aborting"),R=!0,n},w:function(){eE(0);var n=et.pop();if(n.Xb()&&!n.Lb()){var r=n.Wb();r&&eo(r)(n.Db),ea(n.Db)}er=0},d:function(){var n=er;if(!n)return ef=0;var r=new ei(n);r.Fb(n);var i=r.Eb();if(!i)return ef=0,n;for(var a=Array.prototype.slice.call(arguments),s=0;s<a.length;s++){var o=a[s];if(0===o||o===i)break;if(eP(o,i,r.zb+16))return ef=o,n}return ef=i,n},k:function(){var n=er;if(!n)return ef=0;var r=new ei(n);r.Fb(n);var i=r.Eb();if(!i)return ef=0,n;for(var a=Array.prototype.slice.call(arguments),s=0;s<a.length;s++){var o=a[s];if(0===o||o===i)break;if(eP(o,i,r.zb+16))return ef=o,n}return ef=i,n},g:function(){var n=er;if(!n)return ef=0;var r=new ei(n);r.Fb(n);var i=r.Eb();if(!i)return ef=0,n;for(var a=Array.prototype.slice.call(arguments),s=0;s<a.length;s++){var o=a[s];if(0===o||o===i)break;if(eP(o,i,r.zb+16))return ef=o,n}return ef=i,n},s:ea,L:function(){var n=et.pop();n||Y("no exception to throw");var r=n.Db;throw n.Lb()||(et.push(n),n.Jb(!0),n.Ib(!1),en++),er=r,r},b:function(n,r,i){throw new ei(n).Rb(r,i),er=n,en++,n},la:function(){return en},i:function(n){throw er||(er=n),n},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){Y("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){Y("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(n,r){n=new Date(1e3*(O[n>>>2]+4294967296*P[n+4>>>2])),P[r>>2>>>0]=n.getUTCSeconds(),P[r+4>>2>>>0]=n.getUTCMinutes(),P[r+8>>2>>>0]=n.getUTCHours(),P[r+12>>2>>>0]=n.getUTCDate(),P[r+16>>2>>>0]=n.getUTCMonth(),P[r+20>>2>>>0]=n.getUTCFullYear()-1900,P[r+24>>2>>>0]=n.getUTCDay(),P[r+28>>2>>>0]=(n.getTime()-Date.UTC(n.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(n,r){n=new Date(1e3*(O[n>>>2]+4294967296*P[n+4>>>2])),P[r>>2>>>0]=n.getSeconds(),P[r+4>>2>>>0]=n.getMinutes(),P[r+8>>2>>>0]=n.getHours(),P[r+12>>2>>>0]=n.getDate(),P[r+16>>2>>>0]=n.getMonth(),P[r+20>>2>>>0]=n.getFullYear()-1900,P[r+24>>2>>>0]=n.getDay();var i=new Date(n.getFullYear(),0,1);P[r+28>>2>>>0]=(n.getTime()-i.getTime())/864e5|0,P[r+36>>2>>>0]=-60*n.getTimezoneOffset();var a=new Date(n.getFullYear(),6,1).getTimezoneOffset();i=i.getTimezoneOffset(),P[r+32>>2>>>0]=0|(a!=i&&n.getTimezoneOffset()==Math.min(i,a))},Fa:function(n){var r=new Date(P[n+20>>2>>>0]+1900,P[n+16>>2>>>0],P[n+12>>2>>>0],P[n+8>>2>>>0],P[n+4>>2>>>0],P[n>>2>>>0],0),i=P[n+32>>2>>>0],a=r.getTimezoneOffset(),s=new Date(r.getFullYear(),0,1),o=new Date(r.getFullYear(),6,1).getTimezoneOffset(),l=s.getTimezoneOffset(),u=Math.min(l,o);return 0>i?P[n+32>>2>>>0]=Number(o!=l&&u==a):0<i!=(u==a)&&(o=Math.max(l,o),r.setTime(r.getTime()+6e4*((0<i?u:o)-a))),P[n+24>>2>>>0]=r.getDay(),P[n+28>>2>>>0]=(r.getTime()-s.getTime())/864e5|0,P[n>>2>>>0]=r.getSeconds(),P[n+4>>2>>>0]=r.getMinutes(),P[n+8>>2>>>0]=r.getHours(),P[n+12>>2>>>0]=r.getDate(),P[n+16>>2>>>0]=r.getMonth(),r.getTime()/1e3|0},sa:function(){return -52},ta:function(){},Ga:function n(r,i,a){n.Vb||(n.Vb=!0,function(n,r,i){function a(n){return(n=n.toTimeString().match(/\(([A-Za-z ]+)\)$/))?n[1]:"GMT"}var s=(new Date).getFullYear(),o=new Date(s,0,1),l=new Date(s,6,1);s=o.getTimezoneOffset();var u=l.getTimezoneOffset();P[n>>2>>>0]=60*Math.max(s,u),P[r>>2>>>0]=Number(s!=u),n=a(o),r=a(l),n=el(n),r=el(r),u<s?(O[i>>2>>>0]=n,O[i+4>>2>>>0]=r):(O[i>>2>>>0]=r,O[i+4>>2>>>0]=n)}(r,i,a))},B:function(){Y("")},ma:function(){return 4294901760},I:b?()=>{var n=$hPtJY.hrtime();return 1e3*n[0]+n[1]/1e6}:()=>performance.now(),xa:function(n,r,i){I.copyWithin(n>>>0,r>>>0,r+i>>>0)},G:function(n){var r=I.length;if(4294901760<(n>>>=0))return!1;for(var i=1;4>=i;i*=2){var a=r*(1+.2/i);a=Math.min(a,n+100663296);var s=Math;a=Math.max(n,a),s=s.min.call(s,4294901760,a+(65536-a%65536)%65536);e:{try{E.grow(s-A.byteLength+65535>>>16),U();var o=1;break e}catch(n){}o=void 0}if(o)return!0}return!1},va:function(n,r){var i=0;return ec().forEach(function(a,s){var o=r+i;for(s=O[n+4*s>>2>>>0]=o,o=0;o<a.length;++o)M[s++>>0>>>0]=a.charCodeAt(o);M[s>>0>>>0]=0,i+=a.length+1}),0},wa:function(n,r){var i=ec();O[n>>2>>>0]=i.length;var a=0;return i.forEach(function(n){a+=n.length+1}),O[r>>2>>>0]=a,0},ba:function(n){S||0<j||(eS(),ee(V),eT(0),ed[1].length&&ep(1,10),ed[2].length&&ep(2,10)),S||0<j||(r.onExit&&r.onExit(n),R=!0),g(n,new Q(n))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(n,r,i,a){for(var s=0,o=0;o<i;o++){var l=O[r>>2>>>0],u=O[r+4>>2>>>0];r+=8;for(var c=0;c<u;c++)ep(n,I[l+c>>>0]);s+=u}return O[a>>2>>>0]=s,0},c:function(){return ef},ja:function n(r,a){n.Mb||(n.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var n=new Uint8Array(1);return()=>(crypto.getRandomValues(n),n[0])}if(b)try{var r=i(Object(function(){var n=Error("Cannot find module 'crypto'");throw n.code="MODULE_NOT_FOUND",n}()));return()=>r.randomBytes(1)[0]}catch(n){}return()=>Y("randomDevice")}());for(var s=0;s<a;s++)M[r+s>>0>>>0]=n.Mb();return 0},ea:function(n,r,i){var a=eA();try{return eo(n)(r,i)}catch(n){if(eM(a),n!==n+0)throw n;eE(1,0)}},fa:function(n,r,i){var a=eA();try{return eo(n)(r,i)}catch(n){if(eM(a),n!==n+0)throw n;eE(1,0)}},J:function(n){var r=eA();try{return eo(n)()}catch(n){if(eM(r),n!==n+0)throw n;eE(1,0)}},e:function(n,r){var i=eA();try{return eo(n)(r)}catch(n){if(eM(i),n!==n+0)throw n;eE(1,0)}},N:function(n,r,i){var a=eA();try{return eo(n)(r,i)}catch(n){if(eM(a),n!==n+0)throw n;eE(1,0)}},O:function(n,r,i){var a=eA();try{return eo(n)(r,i)}catch(n){if(eM(a),n!==n+0)throw n;eE(1,0)}},j:function(n,r,i){var a=eA();try{return eo(n)(r,i)}catch(n){if(eM(a),n!==n+0)throw n;eE(1,0)}},o:function(n,r,i,a){var s=eA();try{return eo(n)(r,i,a)}catch(n){if(eM(s),n!==n+0)throw n;eE(1,0)}},p:function(n,r,i,a,s){var o=eA();try{return eo(n)(r,i,a,s)}catch(n){if(eM(o),n!==n+0)throw n;eE(1,0)}},M:function(n,r,i,a,s,o){var l=eA();try{return eo(n)(r,i,a,s,o)}catch(n){if(eM(l),n!==n+0)throw n;eE(1,0)}},r:function(n,r,i,a,s,o){var l=eA();try{return eo(n)(r,i,a,s,o)}catch(n){if(eM(l),n!==n+0)throw n;eE(1,0)}},v:function(n,r,i,a,s,o,l){var u=eA();try{return eo(n)(r,i,a,s,o,l)}catch(n){if(eM(u),n!==n+0)throw n;eE(1,0)}},K:function(n,r,i,a,s,o,l,u){var c=eA();try{return eo(n)(r,i,a,s,o,l,u)}catch(n){if(eM(c),n!==n+0)throw n;eE(1,0)}},D:function(n,r,i,a,s,o,l,u,c,h,d,p){var f=eA();try{return eo(n)(r,i,a,s,o,l,u,c,h,d,p)}catch(n){if(eM(f),n!==n+0)throw n;eE(1,0)}},X:function(n,r,i,a,s,o,l,u){var c=eA();try{return eB(n,r,i,a,s,o,l,u)}catch(n){if(eM(c),n!==n+0)throw n;eE(1,0)}},V:function(n,r,i,a,s,o,l){var u=eA();try{return eC(n,r,i,a,s,o,l)}catch(n){if(eM(u),n!==n+0)throw n;eE(1,0)}},U:function(n,r,i,a,s){var o=eA();try{return ez(n,r,i,a,s)}catch(n){if(eM(o),n!==n+0)throw n;eE(1,0)}},Z:function(n,r,i,a){var s=eA();try{return eU(n,r,i,a)}catch(n){if(eM(s),n!==n+0)throw n;eE(1,0)}},W:function(n){var r=eA();try{return eR(n)}catch(n){if(eM(r),n!==n+0)throw n;eE(1,0)}},Y:function(n,r){var i=eA();try{return eF(n,r)}catch(n){if(eM(i),n!==n+0)throw n;eE(1,0)}},T:function(n,r,i){var a=eA();try{return eL(n,r,i)}catch(n){if(eM(a),n!==n+0)throw n;eE(1,0)}},f:function(n){var r=eA();try{eo(n)()}catch(n){if(eM(r),n!==n+0)throw n;eE(1,0)}},q:function(n,r){var i=eA();try{eo(n)(r)}catch(n){if(eM(i),n!==n+0)throw n;eE(1,0)}},h:function(n,r,i){var a=eA();try{eo(n)(r,i)}catch(n){if(eM(a),n!==n+0)throw n;eE(1,0)}},da:function(n,r,i,a){var s=eA();try{eo(n)(r,i,a)}catch(n){if(eM(s),n!==n+0)throw n;eE(1,0)}},l:function(n,r,i,a){var s=eA();try{eo(n)(r,i,a)}catch(n){if(eM(s),n!==n+0)throw n;eE(1,0)}},t:function(n,r,i,a,s){var o=eA();try{eo(n)(r,i,a,s)}catch(n){if(eM(o),n!==n+0)throw n;eE(1,0)}},u:function(n,r,i,a,s,o){var l=eA();try{eo(n)(r,i,a,s,o)}catch(n){if(eM(l),n!==n+0)throw n;eE(1,0)}},x:function(n,r,i,a,s,o,l){var u=eA();try{eo(n)(r,i,a,s,o,l)}catch(n){if(eM(u),n!==n+0)throw n;eE(1,0)}},z:function(n,r,i,a,s,o,l,u){var c=eA();try{eo(n)(r,i,a,s,o,l,u)}catch(n){if(eM(c),n!==n+0)throw n;eE(1,0)}},ga:function(n,r,i,a,s,o,l,u,c){var h=eA();try{eo(n)(r,i,a,s,o,l,u,c)}catch(n){if(eM(h),n!==n+0)throw n;eE(1,0)}},A:function(n,r,i,a,s,o,l,u,c,h,d){var p=eA();try{eo(n)(r,i,a,s,o,l,u,c,h,d)}catch(n){if(eM(p),n!==n+0)throw n;eE(1,0)}},C:function(n,r,i,a,s,o,l,u,c,h,d,p,f,m,g,_){var y=eA();try{eo(n)(r,i,a,s,o,l,u,c,h,d,p,f,m,g,_)}catch(n){if(eM(y),n!==n+0)throw n;eE(1,0)}},aa:function(n,r,i,a,s,o,l,u){var c=eA();try{eD(n,r,i,a,s,o,l,u)}catch(n){if(eM(c),n!==n+0)throw n;eE(1,0)}},_:function(n,r,i,a,s,o,l,u,c,h,d,p){var f=eA();try{ek(n,r,i,a,s,o,l,u,c,h,d,p)}catch(n){if(eM(f),n!==n+0)throw n;eE(1,0)}},$:function(n,r,i,a,s,o){var l=eA();try{eN(n,r,i,a,s,o)}catch(n){if(eM(l),n!==n+0)throw n;eE(1,0)}},n:function(n){return n},F:function(n){ef=n},ha:ey,y:function(n,r,i,a){return ey(n,r,i,a)}};(function(){function n(n){r.asm=n.exports,E=r.asm.Ka,U(),F=r.asm.ib,z.unshift(r.asm.La),W--,r.monitorRunDependencies&&r.monitorRunDependencies(W),0==W&&(null!==X&&(clearInterval(X),X=null),q&&(n=q,q=null,n()))}function i(r){n(r.instance)}function a(n){return(function(){if(!x&&(_||y)){if("function"==typeof fetch&&!$.startsWith("file://"))return fetch($,{credentials:"same-origin"}).then(function(n){if(!n.ok)throw"failed to load wasm binary file at '"+$+"'";return n.arrayBuffer()}).catch(function(){return J()});if(u)return new Promise(function(n,r){u($,function(r){n(new Uint8Array(r))},r)})}return Promise.resolve().then(function(){return J()})})().then(function(n){return WebAssembly.instantiate(n,s)}).then(function(n){return n}).then(n,function(n){T("failed to asynchronously prepare wasm: "+n),Y(n)})}var s={a:eb};if(W++,r.monitorRunDependencies&&r.monitorRunDependencies(W),r.instantiateWasm)try{return r.instantiateWasm(s,n)}catch(n){return T("Module.instantiateWasm callback failed with error: "+n),!1}(x||"function"!=typeof WebAssembly.instantiateStreaming||K()||$.startsWith("file://")||b||"function"!=typeof fetch?a(i):fetch($,{credentials:"same-origin"}).then(function(n){return WebAssembly.instantiateStreaming(n,s).then(i,function(n){return T("wasm streaming compile failed: "+n),T("falling back to ArrayBuffer instantiation"),a(i)})})).catch(o)})(),r.___wasm_call_ctors=function(){return(r.___wasm_call_ctors=r.asm.La).apply(null,arguments)},r._OrtInit=function(){return(r._OrtInit=r.asm.Ma).apply(null,arguments)},r._OrtCreateSessionOptions=function(){return(r._OrtCreateSessionOptions=r.asm.Na).apply(null,arguments)},r._OrtAppendExecutionProvider=function(){return(r._OrtAppendExecutionProvider=r.asm.Oa).apply(null,arguments)},r._OrtAddSessionConfigEntry=function(){return(r._OrtAddSessionConfigEntry=r.asm.Pa).apply(null,arguments)},r._OrtReleaseSessionOptions=function(){return(r._OrtReleaseSessionOptions=r.asm.Qa).apply(null,arguments)},r._OrtCreateSession=function(){return(r._OrtCreateSession=r.asm.Ra).apply(null,arguments)},r._OrtReleaseSession=function(){return(r._OrtReleaseSession=r.asm.Sa).apply(null,arguments)},r._OrtGetInputCount=function(){return(r._OrtGetInputCount=r.asm.Ta).apply(null,arguments)},r._OrtGetOutputCount=function(){return(r._OrtGetOutputCount=r.asm.Ua).apply(null,arguments)},r._OrtGetInputName=function(){return(r._OrtGetInputName=r.asm.Va).apply(null,arguments)},r._OrtGetOutputName=function(){return(r._OrtGetOutputName=r.asm.Wa).apply(null,arguments)},r._OrtFree=function(){return(r._OrtFree=r.asm.Xa).apply(null,arguments)},r._OrtCreateTensor=function(){return(r._OrtCreateTensor=r.asm.Ya).apply(null,arguments)},r._OrtGetTensorData=function(){return(r._OrtGetTensorData=r.asm.Za).apply(null,arguments)},r._OrtReleaseTensor=function(){return(r._OrtReleaseTensor=r.asm._a).apply(null,arguments)},r._OrtCreateRunOptions=function(){return(r._OrtCreateRunOptions=r.asm.$a).apply(null,arguments)},r._OrtAddRunConfigEntry=function(){return(r._OrtAddRunConfigEntry=r.asm.ab).apply(null,arguments)},r._OrtReleaseRunOptions=function(){return(r._OrtReleaseRunOptions=r.asm.bb).apply(null,arguments)},r._OrtRun=function(){return(r._OrtRun=r.asm.cb).apply(null,arguments)},r._OrtEndProfiling=function(){return(r._OrtEndProfiling=r.asm.db).apply(null,arguments)};var ev,ex=r._malloc=function(){return(ex=r._malloc=r.asm.eb).apply(null,arguments)},ew=r._free=function(){return(ew=r._free=r.asm.fb).apply(null,arguments)},eT=r._fflush=function(){return(eT=r._fflush=r.asm.gb).apply(null,arguments)},eS=r.___funcs_on_exit=function(){return(eS=r.___funcs_on_exit=r.asm.hb).apply(null,arguments)},eE=r._setThrew=function(){return(eE=r._setThrew=r.asm.jb).apply(null,arguments)},eA=r.stackSave=function(){return(eA=r.stackSave=r.asm.kb).apply(null,arguments)},eM=r.stackRestore=function(){return(eM=r.stackRestore=r.asm.lb).apply(null,arguments)},eI=r.stackAlloc=function(){return(eI=r.stackAlloc=r.asm.mb).apply(null,arguments)},eP=r.___cxa_can_catch=function(){return(eP=r.___cxa_can_catch=r.asm.nb).apply(null,arguments)},eO=r.___cxa_is_pointer_type=function(){return(eO=r.___cxa_is_pointer_type=r.asm.ob).apply(null,arguments)},eR=r.dynCall_j=function(){return(eR=r.dynCall_j=r.asm.pb).apply(null,arguments)},eC=r.dynCall_iiiiij=function(){return(eC=r.dynCall_iiiiij=r.asm.qb).apply(null,arguments)},eL=r.dynCall_jii=function(){return(eL=r.dynCall_jii=r.asm.rb).apply(null,arguments)},eD=r.dynCall_viiiiij=function(){return(eD=r.dynCall_viiiiij=r.asm.sb).apply(null,arguments)},eN=r.dynCall_vjji=function(){return(eN=r.dynCall_vjji=r.asm.tb).apply(null,arguments)},ek=r.dynCall_viiijjjii=function(){return(ek=r.dynCall_viiijjjii=r.asm.ub).apply(null,arguments)},eU=r.dynCall_iij=function(){return(eU=r.dynCall_iij=r.asm.vb).apply(null,arguments)},eF=r.dynCall_ji=function(){return(eF=r.dynCall_ji=r.asm.wb).apply(null,arguments)},eB=r.dynCall_iiiiiij=function(){return(eB=r.dynCall_iiiiiij=r.asm.xb).apply(null,arguments)},ez=r.dynCall_iiij=function(){return(ez=r.dynCall_iiij=r.asm.yb).apply(null,arguments)};function eV(){function n(){if(!ev&&(ev=!0,r.calledRun=!0,!R)){if(ee(z),s(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for("function"==typeof r.postRun&&(r.postRun=[r.postRun]);r.postRun.length;){var n=r.postRun.shift();G.unshift(n)}ee(G)}}if(!(0<W)){if(r.preRun)for("function"==typeof r.preRun&&(r.preRun=[r.preRun]);r.preRun.length;)H();ee(B),0<W||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),n()},1)):n())}}if(r.UTF8ToString=D,r.stringToUTF8=function(n,r,i){return N(n,I,r,i)},r.lengthBytesUTF8=k,r.stackSave=eA,r.stackRestore=eM,r.stackAlloc=eI,q=function n(){ev||eV(),ev||(q=n)},r.preInit)for("function"==typeof r.preInit&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return eV(),n.ready});n.exports=s},4537:n=>{n.exports=function(n,r){for(var i=Array(arguments.length-1),a=0,s=2,o=!0;s<arguments.length;)i[a++]=arguments[s++];return new Promise(function(s,l){i[a]=function(n){if(o){if(o=!1,n)l(n);else{for(var r=Array(arguments.length-1),i=0;i<r.length;)r[i++]=arguments[i];s.apply(null,r)}}};try{n.apply(r||null,i)}catch(n){o&&(o=!1,l(n))}})}},7419:(n,r)=>{var i=r;i.length=function(n){var r=n.length;if(!r)return 0;for(var i=0;--r%4>1&&"="===n.charAt(r);)++i;return Math.ceil(3*n.length)/4-i};for(var a=Array(64),s=Array(123),o=0;o<64;)s[a[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;i.encode=function(n,r,i){for(var s,o=null,l=[],u=0,c=0;r<i;){var h=n[r++];switch(c){case 0:l[u++]=a[h>>2],s=(3&h)<<4,c=1;break;case 1:l[u++]=a[s|h>>4],s=(15&h)<<2,c=2;break;case 2:l[u++]=a[s|h>>6],l[u++]=a[63&h],c=0}u>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,l)),u=0)}return c&&(l[u++]=a[s],l[u++]=61,1===c&&(l[u++]=61)),o?(u&&o.push(String.fromCharCode.apply(String,l.slice(0,u))),o.join("")):String.fromCharCode.apply(String,l.slice(0,u))};var l="invalid encoding";i.decode=function(n,r,i){for(var a,o=i,u=0,c=0;c<n.length;){var h=n.charCodeAt(c++);if(61===h&&u>1)break;if(void 0===(h=s[h]))throw Error(l);switch(u){case 0:a=h,u=1;break;case 1:r[i++]=a<<2|(48&h)>>4,a=h,u=2;break;case 2:r[i++]=(15&a)<<4|(60&h)>>2,a=h,u=3;break;case 3:r[i++]=(3&a)<<6|h,u=0}}if(1===u)throw Error(l);return i-o},i.test=function(n){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(n)}},9211:n=>{function r(){this._listeners={}}n.exports=r,r.prototype.on=function(n,r,i){return(this._listeners[n]||(this._listeners[n]=[])).push({fn:r,ctx:i||this}),this},r.prototype.off=function(n,r){if(void 0===n)this._listeners={};else if(void 0===r)this._listeners[n]=[];else for(var i=this._listeners[n],a=0;a<i.length;)i[a].fn===r?i.splice(a,1):++a;return this},r.prototype.emit=function(n){var r=this._listeners[n];if(r){for(var i=[],a=1;a<arguments.length;)i.push(arguments[a++]);for(a=0;a<r.length;)r[a].fn.apply(r[a++].ctx,i)}return this}},945:n=>{function r(n){return"undefined"!=typeof Float32Array?function(){var r=new Float32Array([-0]),i=new Uint8Array(r.buffer),a=128===i[3];function s(n,a,s){r[0]=n,a[s]=i[0],a[s+1]=i[1],a[s+2]=i[2],a[s+3]=i[3]}function o(n,a,s){r[0]=n,a[s]=i[3],a[s+1]=i[2],a[s+2]=i[1],a[s+3]=i[0]}function l(n,a){return i[0]=n[a],i[1]=n[a+1],i[2]=n[a+2],i[3]=n[a+3],r[0]}function u(n,a){return i[3]=n[a],i[2]=n[a+1],i[1]=n[a+2],i[0]=n[a+3],r[0]}n.writeFloatLE=a?s:o,n.writeFloatBE=a?o:s,n.readFloatLE=a?l:u,n.readFloatBE=a?u:l}():function(){function r(n,r,i,a){var s=r<0?1:0;if(s&&(r=-r),0===r)n(1/r>0?0:2147483648,i,a);else if(isNaN(r))n(2143289344,i,a);else if(r>34028234663852886e22)n((s<<31|2139095040)>>>0,i,a);else if(r<11754943508222875e-54)n((s<<31|Math.round(r/1401298464324817e-60))>>>0,i,a);else{var o=Math.floor(Math.log(r)/Math.LN2);n((s<<31|o+127<<23|8388607&Math.round(r*Math.pow(2,-o)*8388608))>>>0,i,a)}}function l(n,r,i){var a=n(r,i),s=2*(a>>31)+1,o=a>>>23&255,l=8388607&a;return 255===o?l?NaN:s*(1/0):0===o?1401298464324817e-60*s*l:s*Math.pow(2,o-150)*(l+8388608)}n.writeFloatLE=r.bind(null,i),n.writeFloatBE=r.bind(null,a),n.readFloatLE=l.bind(null,s),n.readFloatBE=l.bind(null,o)}(),"undefined"!=typeof Float64Array?function(){var r=new Float64Array([-0]),i=new Uint8Array(r.buffer),a=128===i[7];function s(n,a,s){r[0]=n,a[s]=i[0],a[s+1]=i[1],a[s+2]=i[2],a[s+3]=i[3],a[s+4]=i[4],a[s+5]=i[5],a[s+6]=i[6],a[s+7]=i[7]}function o(n,a,s){r[0]=n,a[s]=i[7],a[s+1]=i[6],a[s+2]=i[5],a[s+3]=i[4],a[s+4]=i[3],a[s+5]=i[2],a[s+6]=i[1],a[s+7]=i[0]}function l(n,a){return i[0]=n[a],i[1]=n[a+1],i[2]=n[a+2],i[3]=n[a+3],i[4]=n[a+4],i[5]=n[a+5],i[6]=n[a+6],i[7]=n[a+7],r[0]}function u(n,a){return i[7]=n[a],i[6]=n[a+1],i[5]=n[a+2],i[4]=n[a+3],i[3]=n[a+4],i[2]=n[a+5],i[1]=n[a+6],i[0]=n[a+7],r[0]}n.writeDoubleLE=a?s:o,n.writeDoubleBE=a?o:s,n.readDoubleLE=a?l:u,n.readDoubleBE=a?u:l}():function(){function r(n,r,i,a,s,o){var l,u=a<0?1:0;if(u&&(a=-a),0===a)n(0,s,o+r),n(1/a>0?0:2147483648,s,o+i);else if(isNaN(a))n(0,s,o+r),n(2146959360,s,o+i);else if(a>17976931348623157e292)n(0,s,o+r),n((u<<31|2146435072)>>>0,s,o+i);else if(a<22250738585072014e-324)n((l=a/5e-324)>>>0,s,o+r),n((u<<31|l/4294967296)>>>0,s,o+i);else{var c=Math.floor(Math.log(a)/Math.LN2);1024===c&&(c=1023),n(4503599627370496*(l=a*Math.pow(2,-c))>>>0,s,o+r),n((u<<31|c+1023<<20|1048576*l&1048575)>>>0,s,o+i)}}function l(n,r,i,a,s){var o=n(a,s+r),l=n(a,s+i),u=2*(l>>31)+1,c=l>>>20&2047,h=4294967296*(1048575&l)+o;return 2047===c?h?NaN:u*(1/0):0===c?5e-324*u*h:u*Math.pow(2,c-1075)*(h+4503599627370496)}n.writeDoubleLE=r.bind(null,i,0,4),n.writeDoubleBE=r.bind(null,a,4,0),n.readDoubleLE=l.bind(null,s,0,4),n.readDoubleBE=l.bind(null,o,4,0)}(),n}function i(n,r,i){r[i]=255&n,r[i+1]=n>>>8&255,r[i+2]=n>>>16&255,r[i+3]=n>>>24}function a(n,r,i){r[i]=n>>>24,r[i+1]=n>>>16&255,r[i+2]=n>>>8&255,r[i+3]=255&n}function s(n,r){return(n[r]|n[r+1]<<8|n[r+2]<<16|n[r+3]<<24)>>>0}function o(n,r){return(n[r]<<24|n[r+1]<<16|n[r+2]<<8|n[r+3])>>>0}n.exports=r(r)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}module.exports=inquire},6662:n=>{n.exports=function(n,r,i){var a=i||8192,s=a>>>1,o=null,l=a;return function(i){if(i<1||i>s)return n(i);l+i>a&&(o=n(a),l=0);var u=r.call(o,l,l+=i);return 7&l&&(l=1+(7|l)),u}}},4997:(n,r)=>{var i=r;i.length=function(n){for(var r=0,i=0,a=0;a<n.length;++a)(i=n.charCodeAt(a))<128?r+=1:i<2048?r+=2:55296==(64512&i)&&56320==(64512&n.charCodeAt(a+1))?(++a,r+=4):r+=3;return r},i.read=function(n,r,i){if(i-r<1)return"";for(var a,s=null,o=[],l=0;r<i;)(a=n[r++])<128?o[l++]=a:a>191&&a<224?o[l++]=(31&a)<<6|63&n[r++]:a>239&&a<365?(a=((7&a)<<18|(63&n[r++])<<12|(63&n[r++])<<6|63&n[r++])-65536,o[l++]=55296+(a>>10),o[l++]=56320+(1023&a)):o[l++]=(15&a)<<12|(63&n[r++])<<6|63&n[r++],l>8191&&((s||(s=[])).push(String.fromCharCode.apply(String,o)),l=0);return s?(l&&s.push(String.fromCharCode.apply(String,o.slice(0,l))),s.join("")):String.fromCharCode.apply(String,o.slice(0,l))},i.write=function(n,r,i){for(var a,s,o=i,l=0;l<n.length;++l)(a=n.charCodeAt(l))<128?r[i++]=a:(a<2048?r[i++]=a>>6|192:(55296==(64512&a)&&56320==(64512&(s=n.charCodeAt(l+1)))?(a=65536+((1023&a)<<10)+(1023&s),++l,r[i++]=a>>18|240,r[i++]=a>>12&63|128):r[i++]=a>>12|224,r[i++]=a>>6&63|128),r[i++]=63&a|128);return i-o}},3442:(n,r)=>{r.__esModule=!0;var i=function(){function n(r){if(!r)throw TypeError("Invalid argument; `value` has no value.");this.value=n.EMPTY,r&&n.isGuid(r)&&(this.value=r)}return n.isGuid=function(r){var i=r.toString();return r&&(r instanceof n||n.validator.test(i))},n.create=function(){return new n([n.gen(2),n.gen(1),n.gen(1),n.gen(1),n.gen(3)].join("-"))},n.createEmpty=function(){return new n("emptyguid")},n.parse=function(r){return new n(r)},n.raw=function(){return[n.gen(2),n.gen(1),n.gen(1),n.gen(1),n.gen(3)].join("-")},n.gen=function(n){for(var r="",i=0;i<n;i++)r+=(65536*(1+Math.random())|0).toString(16).substring(1);return r},n.prototype.equals=function(r){return n.isGuid(r)&&this.value===r.toString()},n.prototype.isEmpty=function(){return this.value===n.EMPTY},n.prototype.toString=function(){return this.value},n.prototype.toJSON=function(){return{value:this.value}},n.validator=RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),n.EMPTY="00000000-0000-0000-0000-000000000000",n}();r.Guid=i},3720:n=>{n.exports=i;var r=null;try{r=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(n){}function i(n,r,i){this.low=0|n,this.high=0|r,this.unsigned=!!i}function a(n){return!0===(n&&n.__isLong__)}i.prototype.__isLong__,Object.defineProperty(i.prototype,"__isLong__",{value:!0}),i.isLong=a;var s={},o={};function l(n,r){var i,a,l;return r?(l=0<=(n>>>=0)&&n<256)&&(a=o[n])?a:(i=c(n,(0|n)<0?-1:0,!0),l&&(o[n]=i),i):(l=-128<=(n|=0)&&n<128)&&(a=s[n])?a:(i=c(n,n<0?-1:0,!1),l&&(s[n]=i),i)}function u(n,r){if(isNaN(n))return r?b:y;if(r){if(n<0)return b;if(n>=m)return S}else{if(n<=-g)return E;if(n+1>=g)return T}return n<0?u(-n,r).neg():c(n%f|0,n/f|0,r)}function c(n,r,a){return new i(n,r,a)}i.fromInt=l,i.fromNumber=u,i.fromBits=c;var h=Math.pow;function d(n,r,i){if(0===n.length)throw Error("empty string");if("NaN"===n||"Infinity"===n||"+Infinity"===n||"-Infinity"===n)return y;if("number"==typeof r?(i=r,r=!1):r=!!r,(i=i||10)<2||36<i)throw RangeError("radix");if((a=n.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return d(n.substring(1),r,i).neg();for(var a,s=u(h(i,8)),o=y,l=0;l<n.length;l+=8){var c=Math.min(8,n.length-l),p=parseInt(n.substring(l,l+c),i);if(c<8){var f=u(h(i,c));o=o.mul(f).add(u(p))}else o=(o=o.mul(s)).add(u(p))}return o.unsigned=r,o}function p(n,r){return"number"==typeof n?u(n,r):"string"==typeof n?d(n,r):c(n.low,n.high,"boolean"==typeof r?r:n.unsigned)}i.fromString=d,i.fromValue=p;var f=4294967296,m=18446744073709552e3,g=18446744073709552e3/2,_=l(16777216),y=l(0);i.ZERO=y;var b=l(0,!0);i.UZERO=b;var v=l(1);i.ONE=v;var x=l(1,!0);i.UONE=x;var w=l(-1);i.NEG_ONE=w;var T=c(-1,2147483647,!1);i.MAX_VALUE=T;var S=c(-1,-1,!0);i.MAX_UNSIGNED_VALUE=S;var E=c(0,-2147483648,!1);i.MIN_VALUE=E;var A=i.prototype;A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},A.toString=function(n){if((n=n||10)<2||36<n)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(E)){var r=u(n),i=this.div(r),a=i.mul(r).sub(this);return i.toString(n)+a.toInt().toString(n)}return"-"+this.neg().toString(n)}for(var s=u(h(n,6),this.unsigned),o=this,l="";;){var c=o.div(s),d=(o.sub(c.mul(s)).toInt()>>>0).toString(n);if((o=c).isZero())return d+l;for(;d.length<6;)d="0"+d;l=""+d+l}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(E)?64:this.neg().getNumBitsAbs();for(var n=0!=this.high?this.high:this.low,r=31;r>0&&0==(n&1<<r);r--);return 0!=this.high?r+33:r+1},A.isZero=function(){return 0===this.high&&0===this.low},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return 1==(1&this.low)},A.isEven=function(){return 0==(1&this.low)},A.equals=function(n){return a(n)||(n=p(n)),(this.unsigned===n.unsigned||this.high>>>31!=1||n.high>>>31!=1)&&this.high===n.high&&this.low===n.low},A.eq=A.equals,A.notEquals=function(n){return!this.eq(n)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(n){return 0>this.comp(n)},A.lt=A.lessThan,A.lessThanOrEqual=function(n){return 0>=this.comp(n)},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(n){return this.comp(n)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(n){return this.comp(n)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(n){if(a(n)||(n=p(n)),this.eq(n))return 0;var r=this.isNegative(),i=n.isNegative();return r&&!i?-1:!r&&i?1:this.unsigned?n.high>>>0>this.high>>>0||n.high===this.high&&n.low>>>0>this.low>>>0?-1:1:this.sub(n).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(E)?E:this.not().add(v)},A.neg=A.negate,A.add=function(n){a(n)||(n=p(n));var r,i,s,o,l=this.high>>>16,u=65535&this.high,h=this.low>>>16,d=65535&this.low,f=n.high>>>16,m=65535&n.high,g=n.low>>>16;return o=0+(((s=0+((r=0+((i=0+(d+(65535&n.low)))>>>16)+(h+g))>>>16)+(u+m))>>>16)+(l+f)),c((r&=65535)<<16|(i&=65535),(o&=65535)<<16|(s&=65535),this.unsigned)},A.subtract=function(n){return a(n)||(n=p(n)),this.add(n.neg())},A.sub=A.subtract,A.multiply=function(n){if(this.isZero())return y;if(a(n)||(n=p(n)),r)return c(r.mul(this.low,this.high,n.low,n.high),r.get_high(),this.unsigned);if(n.isZero())return y;if(this.eq(E))return n.isOdd()?E:y;if(n.eq(E))return this.isOdd()?E:y;if(this.isNegative())return n.isNegative()?this.neg().mul(n.neg()):this.neg().mul(n).neg();if(n.isNegative())return this.mul(n.neg()).neg();if(this.lt(_)&&n.lt(_))return u(this.toNumber()*n.toNumber(),this.unsigned);var i,s,o,l=this.high>>>16,h=65535&this.high,d=this.low>>>16,f=65535&this.low,m=n.high>>>16,g=65535&n.high,b=n.low>>>16,v=65535&n.low,x=0;return o=0+((i=0+((s=0+f*v)>>>16)+d*v)>>>16),i&=65535,o+=(i+=f*b)>>>16,x+=(o+=h*v)>>>16,o&=65535,x+=(o+=d*b)>>>16,o&=65535,x+=((o+=f*g)>>>16)+(l*v+h*b+d*g+f*m),c((i&=65535)<<16|(s&=65535),(x&=65535)<<16|(o&=65535),this.unsigned)},A.mul=A.multiply,A.divide=function(n){if(a(n)||(n=p(n)),n.isZero())throw Error("division by zero");if(r)return this.unsigned||-2147483648!==this.high||-1!==n.low||-1!==n.high?c((this.unsigned?r.div_u:r.div_s)(this.low,this.high,n.low,n.high),r.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:y;if(this.unsigned){if(n.unsigned||(n=n.toUnsigned()),n.gt(this))return b;if(n.gt(this.shru(1)))return x;o=b}else{if(this.eq(E))return n.eq(v)||n.eq(w)?E:n.eq(E)?v:(i=this.shr(1).div(n).shl(1)).eq(y)?n.isNegative()?v:w:(s=this.sub(n.mul(i)),o=i.add(s.div(n)));if(n.eq(E))return this.unsigned?b:y;if(this.isNegative())return n.isNegative()?this.neg().div(n.neg()):this.neg().div(n).neg();if(n.isNegative())return this.div(n.neg()).neg();o=y}for(s=this;s.gte(n);){i=Math.max(1,Math.floor(s.toNumber()/n.toNumber()));for(var i,s,o,l=Math.ceil(Math.log(i)/Math.LN2),d=l<=48?1:h(2,l-48),f=u(i),m=f.mul(n);m.isNegative()||m.gt(s);)m=(f=u(i-=d,this.unsigned)).mul(n);f.isZero()&&(f=v),o=o.add(f),s=s.sub(m)}return o},A.div=A.divide,A.modulo=function(n){return a(n)||(n=p(n)),r?c((this.unsigned?r.rem_u:r.rem_s)(this.low,this.high,n.low,n.high),r.get_high(),this.unsigned):this.sub(this.div(n).mul(n))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return c(~this.low,~this.high,this.unsigned)},A.and=function(n){return a(n)||(n=p(n)),c(this.low&n.low,this.high&n.high,this.unsigned)},A.or=function(n){return a(n)||(n=p(n)),c(this.low|n.low,this.high|n.high,this.unsigned)},A.xor=function(n){return a(n)||(n=p(n)),c(this.low^n.low,this.high^n.high,this.unsigned)},A.shiftLeft=function(n){return a(n)&&(n=n.toInt()),0==(n&=63)?this:n<32?c(this.low<<n,this.high<<n|this.low>>>32-n,this.unsigned):c(0,this.low<<n-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(n){return a(n)&&(n=n.toInt()),0==(n&=63)?this:n<32?c(this.low>>>n|this.high<<32-n,this.high>>n,this.unsigned):c(this.high>>n-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(n){if(a(n)&&(n=n.toInt()),0==(n&=63))return this;var r=this.high;return n<32?c(this.low>>>n|r<<32-n,r>>>n,this.unsigned):c(32===n?r:r>>>n-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},A.toBytes=function(n){return n?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var n=this.high,r=this.low;return[255&r,r>>>8&255,r>>>16&255,r>>>24,255&n,n>>>8&255,n>>>16&255,n>>>24]},A.toBytesBE=function(){var n=this.high,r=this.low;return[n>>>24,n>>>16&255,n>>>8&255,255&n,r>>>24,r>>>16&255,r>>>8&255,255&r]},i.fromBytes=function(n,r,a){return a?i.fromBytesLE(n,r):i.fromBytesBE(n,r)},i.fromBytesLE=function(n,r){return new i(n[0]|n[1]<<8|n[2]<<16|n[3]<<24,n[4]|n[5]<<8|n[6]<<16|n[7]<<24,r)},i.fromBytesBE=function(n,r){return new i(n[4]<<24|n[5]<<16|n[6]<<8|n[7],n[0]<<24|n[1]<<16|n[2]<<8|n[3],r)}},1446:(n,r,i)=>{var a,s,o,l=i(2100),u=l.Reader,c=l.Writer,h=l.util,d=l.roots.default||(l.roots.default={});d.onnx=((o={}).Version=((s=Object.create(a={}))[a[0]="_START_VERSION"]=0,s[a[1]="IR_VERSION_2017_10_10"]=1,s[a[2]="IR_VERSION_2017_10_30"]=2,s[a[3]="IR_VERSION_2017_11_3"]=3,s[a[4]="IR_VERSION_2019_1_22"]=4,s[a[5]="IR_VERSION"]=5,s),o.AttributeProto=function(){function n(n){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.name="",n.prototype.refAttrName="",n.prototype.docString="",n.prototype.type=0,n.prototype.f=0,n.prototype.i=h.Long?h.Long.fromBits(0,0,!1):0,n.prototype.s=h.newBuffer([]),n.prototype.t=null,n.prototype.g=null,n.prototype.floats=h.emptyArray,n.prototype.ints=h.emptyArray,n.prototype.strings=h.emptyArray,n.prototype.tensors=h.emptyArray,n.prototype.graphs=h.emptyArray,n.create=function(r){return new n(r)},n.encode=function(n,r){if(r||(r=c.create()),null!=n.name&&n.hasOwnProperty("name")&&r.uint32(10).string(n.name),null!=n.f&&n.hasOwnProperty("f")&&r.uint32(21).float(n.f),null!=n.i&&n.hasOwnProperty("i")&&r.uint32(24).int64(n.i),null!=n.s&&n.hasOwnProperty("s")&&r.uint32(34).bytes(n.s),null!=n.t&&n.hasOwnProperty("t")&&d.onnx.TensorProto.encode(n.t,r.uint32(42).fork()).ldelim(),null!=n.g&&n.hasOwnProperty("g")&&d.onnx.GraphProto.encode(n.g,r.uint32(50).fork()).ldelim(),null!=n.floats&&n.floats.length){r.uint32(58).fork();for(var i=0;i<n.floats.length;++i)r.float(n.floats[i]);r.ldelim()}if(null!=n.ints&&n.ints.length){for(r.uint32(66).fork(),i=0;i<n.ints.length;++i)r.int64(n.ints[i]);r.ldelim()}if(null!=n.strings&&n.strings.length)for(i=0;i<n.strings.length;++i)r.uint32(74).bytes(n.strings[i]);if(null!=n.tensors&&n.tensors.length)for(i=0;i<n.tensors.length;++i)d.onnx.TensorProto.encode(n.tensors[i],r.uint32(82).fork()).ldelim();if(null!=n.graphs&&n.graphs.length)for(i=0;i<n.graphs.length;++i)d.onnx.GraphProto.encode(n.graphs[i],r.uint32(90).fork()).ldelim();return null!=n.docString&&n.hasOwnProperty("docString")&&r.uint32(106).string(n.docString),null!=n.type&&n.hasOwnProperty("type")&&r.uint32(160).int32(n.type),null!=n.refAttrName&&n.hasOwnProperty("refAttrName")&&r.uint32(170).string(n.refAttrName),r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.AttributeProto;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.name=n.string();break;case 21:a.refAttrName=n.string();break;case 13:a.docString=n.string();break;case 20:a.type=n.int32();break;case 2:a.f=n.float();break;case 3:a.i=n.int64();break;case 4:a.s=n.bytes();break;case 5:a.t=d.onnx.TensorProto.decode(n,n.uint32());break;case 6:a.g=d.onnx.GraphProto.decode(n,n.uint32());break;case 7:if(a.floats&&a.floats.length||(a.floats=[]),2==(7&s))for(var o=n.uint32()+n.pos;n.pos<o;)a.floats.push(n.float());else a.floats.push(n.float());break;case 8:if(a.ints&&a.ints.length||(a.ints=[]),2==(7&s))for(o=n.uint32()+n.pos;n.pos<o;)a.ints.push(n.int64());else a.ints.push(n.int64());break;case 9:a.strings&&a.strings.length||(a.strings=[]),a.strings.push(n.bytes());break;case 10:a.tensors&&a.tensors.length||(a.tensors=[]),a.tensors.push(d.onnx.TensorProto.decode(n,n.uint32()));break;case 11:a.graphs&&a.graphs.length||(a.graphs=[]),a.graphs.push(d.onnx.GraphProto.decode(n,n.uint32()));break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){if("object"!=typeof n||null===n)return"object expected";if(null!=n.name&&n.hasOwnProperty("name")&&!h.isString(n.name))return"name: string expected";if(null!=n.refAttrName&&n.hasOwnProperty("refAttrName")&&!h.isString(n.refAttrName))return"refAttrName: string expected";if(null!=n.docString&&n.hasOwnProperty("docString")&&!h.isString(n.docString))return"docString: string expected";if(null!=n.type&&n.hasOwnProperty("type"))switch(n.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=n.f&&n.hasOwnProperty("f")&&"number"!=typeof n.f)return"f: number expected";if(null!=n.i&&n.hasOwnProperty("i")&&!(h.isInteger(n.i)||n.i&&h.isInteger(n.i.low)&&h.isInteger(n.i.high)))return"i: integer|Long expected";if(null!=n.s&&n.hasOwnProperty("s")&&!(n.s&&"number"==typeof n.s.length||h.isString(n.s)))return"s: buffer expected";if(null!=n.t&&n.hasOwnProperty("t")&&(r=d.onnx.TensorProto.verify(n.t)))return"t."+r;if(null!=n.g&&n.hasOwnProperty("g")&&(r=d.onnx.GraphProto.verify(n.g)))return"g."+r;if(null!=n.floats&&n.hasOwnProperty("floats")){if(!Array.isArray(n.floats))return"floats: array expected";for(var r,i=0;i<n.floats.length;++i)if("number"!=typeof n.floats[i])return"floats: number[] expected"}if(null!=n.ints&&n.hasOwnProperty("ints")){if(!Array.isArray(n.ints))return"ints: array expected";for(i=0;i<n.ints.length;++i)if(!(h.isInteger(n.ints[i])||n.ints[i]&&h.isInteger(n.ints[i].low)&&h.isInteger(n.ints[i].high)))return"ints: integer|Long[] expected"}if(null!=n.strings&&n.hasOwnProperty("strings")){if(!Array.isArray(n.strings))return"strings: array expected";for(i=0;i<n.strings.length;++i)if(!(n.strings[i]&&"number"==typeof n.strings[i].length||h.isString(n.strings[i])))return"strings: buffer[] expected"}if(null!=n.tensors&&n.hasOwnProperty("tensors")){if(!Array.isArray(n.tensors))return"tensors: array expected";for(i=0;i<n.tensors.length;++i)if(r=d.onnx.TensorProto.verify(n.tensors[i]))return"tensors."+r}if(null!=n.graphs&&n.hasOwnProperty("graphs")){if(!Array.isArray(n.graphs))return"graphs: array expected";for(i=0;i<n.graphs.length;++i)if(r=d.onnx.GraphProto.verify(n.graphs[i]))return"graphs."+r}return null},n.fromObject=function(n){if(n instanceof d.onnx.AttributeProto)return n;var r=new d.onnx.AttributeProto;switch(null!=n.name&&(r.name=String(n.name)),null!=n.refAttrName&&(r.refAttrName=String(n.refAttrName)),null!=n.docString&&(r.docString=String(n.docString)),n.type){case"UNDEFINED":case 0:r.type=0;break;case"FLOAT":case 1:r.type=1;break;case"INT":case 2:r.type=2;break;case"STRING":case 3:r.type=3;break;case"TENSOR":case 4:r.type=4;break;case"GRAPH":case 5:r.type=5;break;case"FLOATS":case 6:r.type=6;break;case"INTS":case 7:r.type=7;break;case"STRINGS":case 8:r.type=8;break;case"TENSORS":case 9:r.type=9;break;case"GRAPHS":case 10:r.type=10}if(null!=n.f&&(r.f=Number(n.f)),null!=n.i&&(h.Long?(r.i=h.Long.fromValue(n.i)).unsigned=!1:"string"==typeof n.i?r.i=parseInt(n.i,10):"number"==typeof n.i?r.i=n.i:"object"==typeof n.i&&(r.i=new h.LongBits(n.i.low>>>0,n.i.high>>>0).toNumber())),null!=n.s&&("string"==typeof n.s?h.base64.decode(n.s,r.s=h.newBuffer(h.base64.length(n.s)),0):n.s.length&&(r.s=n.s)),null!=n.t){if("object"!=typeof n.t)throw TypeError(".onnx.AttributeProto.t: object expected");r.t=d.onnx.TensorProto.fromObject(n.t)}if(null!=n.g){if("object"!=typeof n.g)throw TypeError(".onnx.AttributeProto.g: object expected");r.g=d.onnx.GraphProto.fromObject(n.g)}if(n.floats){if(!Array.isArray(n.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");r.floats=[];for(var i=0;i<n.floats.length;++i)r.floats[i]=Number(n.floats[i])}if(n.ints){if(!Array.isArray(n.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(r.ints=[],i=0;i<n.ints.length;++i)h.Long?(r.ints[i]=h.Long.fromValue(n.ints[i])).unsigned=!1:"string"==typeof n.ints[i]?r.ints[i]=parseInt(n.ints[i],10):"number"==typeof n.ints[i]?r.ints[i]=n.ints[i]:"object"==typeof n.ints[i]&&(r.ints[i]=new h.LongBits(n.ints[i].low>>>0,n.ints[i].high>>>0).toNumber())}if(n.strings){if(!Array.isArray(n.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(r.strings=[],i=0;i<n.strings.length;++i)"string"==typeof n.strings[i]?h.base64.decode(n.strings[i],r.strings[i]=h.newBuffer(h.base64.length(n.strings[i])),0):n.strings[i].length&&(r.strings[i]=n.strings[i])}if(n.tensors){if(!Array.isArray(n.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(r.tensors=[],i=0;i<n.tensors.length;++i){if("object"!=typeof n.tensors[i])throw TypeError(".onnx.AttributeProto.tensors: object expected");r.tensors[i]=d.onnx.TensorProto.fromObject(n.tensors[i])}}if(n.graphs){if(!Array.isArray(n.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(r.graphs=[],i=0;i<n.graphs.length;++i){if("object"!=typeof n.graphs[i])throw TypeError(".onnx.AttributeProto.graphs: object expected");r.graphs[i]=d.onnx.GraphProto.fromObject(n.graphs[i])}}return r},n.toObject=function(n,r){r||(r={});var i={};if((r.arrays||r.defaults)&&(i.floats=[],i.ints=[],i.strings=[],i.tensors=[],i.graphs=[]),r.defaults){if(i.name="",i.f=0,h.Long){var a=new h.Long(0,0,!1);i.i=r.longs===String?a.toString():r.longs===Number?a.toNumber():a}else i.i=r.longs===String?"0":0;r.bytes===String?i.s="":(i.s=[],r.bytes!==Array&&(i.s=h.newBuffer(i.s))),i.t=null,i.g=null,i.docString="",i.type=r.enums===String?"UNDEFINED":0,i.refAttrName=""}if(null!=n.name&&n.hasOwnProperty("name")&&(i.name=n.name),null!=n.f&&n.hasOwnProperty("f")&&(i.f=r.json&&!isFinite(n.f)?String(n.f):n.f),null!=n.i&&n.hasOwnProperty("i")&&("number"==typeof n.i?i.i=r.longs===String?String(n.i):n.i:i.i=r.longs===String?h.Long.prototype.toString.call(n.i):r.longs===Number?new h.LongBits(n.i.low>>>0,n.i.high>>>0).toNumber():n.i),null!=n.s&&n.hasOwnProperty("s")&&(i.s=r.bytes===String?h.base64.encode(n.s,0,n.s.length):r.bytes===Array?Array.prototype.slice.call(n.s):n.s),null!=n.t&&n.hasOwnProperty("t")&&(i.t=d.onnx.TensorProto.toObject(n.t,r)),null!=n.g&&n.hasOwnProperty("g")&&(i.g=d.onnx.GraphProto.toObject(n.g,r)),n.floats&&n.floats.length){i.floats=[];for(var s=0;s<n.floats.length;++s)i.floats[s]=r.json&&!isFinite(n.floats[s])?String(n.floats[s]):n.floats[s]}if(n.ints&&n.ints.length)for(i.ints=[],s=0;s<n.ints.length;++s)"number"==typeof n.ints[s]?i.ints[s]=r.longs===String?String(n.ints[s]):n.ints[s]:i.ints[s]=r.longs===String?h.Long.prototype.toString.call(n.ints[s]):r.longs===Number?new h.LongBits(n.ints[s].low>>>0,n.ints[s].high>>>0).toNumber():n.ints[s];if(n.strings&&n.strings.length)for(i.strings=[],s=0;s<n.strings.length;++s)i.strings[s]=r.bytes===String?h.base64.encode(n.strings[s],0,n.strings[s].length):r.bytes===Array?Array.prototype.slice.call(n.strings[s]):n.strings[s];if(n.tensors&&n.tensors.length)for(i.tensors=[],s=0;s<n.tensors.length;++s)i.tensors[s]=d.onnx.TensorProto.toObject(n.tensors[s],r);if(n.graphs&&n.graphs.length)for(i.graphs=[],s=0;s<n.graphs.length;++s)i.graphs[s]=d.onnx.GraphProto.toObject(n.graphs[s],r);return null!=n.docString&&n.hasOwnProperty("docString")&&(i.docString=n.docString),null!=n.type&&n.hasOwnProperty("type")&&(i.type=r.enums===String?d.onnx.AttributeProto.AttributeType[n.type]:n.type),null!=n.refAttrName&&n.hasOwnProperty("refAttrName")&&(i.refAttrName=n.refAttrName),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n.AttributeType=function(){var n={},r=Object.create(n);return r[n[0]="UNDEFINED"]=0,r[n[1]="FLOAT"]=1,r[n[2]="INT"]=2,r[n[3]="STRING"]=3,r[n[4]="TENSOR"]=4,r[n[5]="GRAPH"]=5,r[n[6]="FLOATS"]=6,r[n[7]="INTS"]=7,r[n[8]="STRINGS"]=8,r[n[9]="TENSORS"]=9,r[n[10]="GRAPHS"]=10,r}(),n}(),o.ValueInfoProto=function(){function n(n){if(n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.name="",n.prototype.type=null,n.prototype.docString="",n.create=function(r){return new n(r)},n.encode=function(n,r){return r||(r=c.create()),null!=n.name&&n.hasOwnProperty("name")&&r.uint32(10).string(n.name),null!=n.type&&n.hasOwnProperty("type")&&d.onnx.TypeProto.encode(n.type,r.uint32(18).fork()).ldelim(),null!=n.docString&&n.hasOwnProperty("docString")&&r.uint32(26).string(n.docString),r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.ValueInfoProto;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.name=n.string();break;case 2:a.type=d.onnx.TypeProto.decode(n,n.uint32());break;case 3:a.docString=n.string();break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){if("object"!=typeof n||null===n)return"object expected";if(null!=n.name&&n.hasOwnProperty("name")&&!h.isString(n.name))return"name: string expected";if(null!=n.type&&n.hasOwnProperty("type")){var r=d.onnx.TypeProto.verify(n.type);if(r)return"type."+r}return null!=n.docString&&n.hasOwnProperty("docString")&&!h.isString(n.docString)?"docString: string expected":null},n.fromObject=function(n){if(n instanceof d.onnx.ValueInfoProto)return n;var r=new d.onnx.ValueInfoProto;if(null!=n.name&&(r.name=String(n.name)),null!=n.type){if("object"!=typeof n.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");r.type=d.onnx.TypeProto.fromObject(n.type)}return null!=n.docString&&(r.docString=String(n.docString)),r},n.toObject=function(n,r){r||(r={});var i={};return r.defaults&&(i.name="",i.type=null,i.docString=""),null!=n.name&&n.hasOwnProperty("name")&&(i.name=n.name),null!=n.type&&n.hasOwnProperty("type")&&(i.type=d.onnx.TypeProto.toObject(n.type,r)),null!=n.docString&&n.hasOwnProperty("docString")&&(i.docString=n.docString),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n}(),o.NodeProto=function(){function n(n){if(this.input=[],this.output=[],this.attribute=[],n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.input=h.emptyArray,n.prototype.output=h.emptyArray,n.prototype.name="",n.prototype.opType="",n.prototype.domain="",n.prototype.attribute=h.emptyArray,n.prototype.docString="",n.create=function(r){return new n(r)},n.encode=function(n,r){if(r||(r=c.create()),null!=n.input&&n.input.length)for(var i=0;i<n.input.length;++i)r.uint32(10).string(n.input[i]);if(null!=n.output&&n.output.length)for(i=0;i<n.output.length;++i)r.uint32(18).string(n.output[i]);if(null!=n.name&&n.hasOwnProperty("name")&&r.uint32(26).string(n.name),null!=n.opType&&n.hasOwnProperty("opType")&&r.uint32(34).string(n.opType),null!=n.attribute&&n.attribute.length)for(i=0;i<n.attribute.length;++i)d.onnx.AttributeProto.encode(n.attribute[i],r.uint32(42).fork()).ldelim();return null!=n.docString&&n.hasOwnProperty("docString")&&r.uint32(50).string(n.docString),null!=n.domain&&n.hasOwnProperty("domain")&&r.uint32(58).string(n.domain),r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.NodeProto;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.input&&a.input.length||(a.input=[]),a.input.push(n.string());break;case 2:a.output&&a.output.length||(a.output=[]),a.output.push(n.string());break;case 3:a.name=n.string();break;case 4:a.opType=n.string();break;case 7:a.domain=n.string();break;case 5:a.attribute&&a.attribute.length||(a.attribute=[]),a.attribute.push(d.onnx.AttributeProto.decode(n,n.uint32()));break;case 6:a.docString=n.string();break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){if("object"!=typeof n||null===n)return"object expected";if(null!=n.input&&n.hasOwnProperty("input")){if(!Array.isArray(n.input))return"input: array expected";for(var r=0;r<n.input.length;++r)if(!h.isString(n.input[r]))return"input: string[] expected"}if(null!=n.output&&n.hasOwnProperty("output")){if(!Array.isArray(n.output))return"output: array expected";for(r=0;r<n.output.length;++r)if(!h.isString(n.output[r]))return"output: string[] expected"}if(null!=n.name&&n.hasOwnProperty("name")&&!h.isString(n.name))return"name: string expected";if(null!=n.opType&&n.hasOwnProperty("opType")&&!h.isString(n.opType))return"opType: string expected";if(null!=n.domain&&n.hasOwnProperty("domain")&&!h.isString(n.domain))return"domain: string expected";if(null!=n.attribute&&n.hasOwnProperty("attribute")){if(!Array.isArray(n.attribute))return"attribute: array expected";for(r=0;r<n.attribute.length;++r){var i=d.onnx.AttributeProto.verify(n.attribute[r]);if(i)return"attribute."+i}}return null!=n.docString&&n.hasOwnProperty("docString")&&!h.isString(n.docString)?"docString: string expected":null},n.fromObject=function(n){if(n instanceof d.onnx.NodeProto)return n;var r=new d.onnx.NodeProto;if(n.input){if(!Array.isArray(n.input))throw TypeError(".onnx.NodeProto.input: array expected");r.input=[];for(var i=0;i<n.input.length;++i)r.input[i]=String(n.input[i])}if(n.output){if(!Array.isArray(n.output))throw TypeError(".onnx.NodeProto.output: array expected");for(r.output=[],i=0;i<n.output.length;++i)r.output[i]=String(n.output[i])}if(null!=n.name&&(r.name=String(n.name)),null!=n.opType&&(r.opType=String(n.opType)),null!=n.domain&&(r.domain=String(n.domain)),n.attribute){if(!Array.isArray(n.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(r.attribute=[],i=0;i<n.attribute.length;++i){if("object"!=typeof n.attribute[i])throw TypeError(".onnx.NodeProto.attribute: object expected");r.attribute[i]=d.onnx.AttributeProto.fromObject(n.attribute[i])}}return null!=n.docString&&(r.docString=String(n.docString)),r},n.toObject=function(n,r){r||(r={});var i={};if((r.arrays||r.defaults)&&(i.input=[],i.output=[],i.attribute=[]),r.defaults&&(i.name="",i.opType="",i.docString="",i.domain=""),n.input&&n.input.length){i.input=[];for(var a=0;a<n.input.length;++a)i.input[a]=n.input[a]}if(n.output&&n.output.length)for(i.output=[],a=0;a<n.output.length;++a)i.output[a]=n.output[a];if(null!=n.name&&n.hasOwnProperty("name")&&(i.name=n.name),null!=n.opType&&n.hasOwnProperty("opType")&&(i.opType=n.opType),n.attribute&&n.attribute.length)for(i.attribute=[],a=0;a<n.attribute.length;++a)i.attribute[a]=d.onnx.AttributeProto.toObject(n.attribute[a],r);return null!=n.docString&&n.hasOwnProperty("docString")&&(i.docString=n.docString),null!=n.domain&&n.hasOwnProperty("domain")&&(i.domain=n.domain),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n}(),o.ModelProto=function(){function n(n){if(this.opsetImport=[],this.metadataProps=[],n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.irVersion=h.Long?h.Long.fromBits(0,0,!1):0,n.prototype.opsetImport=h.emptyArray,n.prototype.producerName="",n.prototype.producerVersion="",n.prototype.domain="",n.prototype.modelVersion=h.Long?h.Long.fromBits(0,0,!1):0,n.prototype.docString="",n.prototype.graph=null,n.prototype.metadataProps=h.emptyArray,n.create=function(r){return new n(r)},n.encode=function(n,r){if(r||(r=c.create()),null!=n.irVersion&&n.hasOwnProperty("irVersion")&&r.uint32(8).int64(n.irVersion),null!=n.producerName&&n.hasOwnProperty("producerName")&&r.uint32(18).string(n.producerName),null!=n.producerVersion&&n.hasOwnProperty("producerVersion")&&r.uint32(26).string(n.producerVersion),null!=n.domain&&n.hasOwnProperty("domain")&&r.uint32(34).string(n.domain),null!=n.modelVersion&&n.hasOwnProperty("modelVersion")&&r.uint32(40).int64(n.modelVersion),null!=n.docString&&n.hasOwnProperty("docString")&&r.uint32(50).string(n.docString),null!=n.graph&&n.hasOwnProperty("graph")&&d.onnx.GraphProto.encode(n.graph,r.uint32(58).fork()).ldelim(),null!=n.opsetImport&&n.opsetImport.length)for(var i=0;i<n.opsetImport.length;++i)d.onnx.OperatorSetIdProto.encode(n.opsetImport[i],r.uint32(66).fork()).ldelim();if(null!=n.metadataProps&&n.metadataProps.length)for(i=0;i<n.metadataProps.length;++i)d.onnx.StringStringEntryProto.encode(n.metadataProps[i],r.uint32(114).fork()).ldelim();return r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.ModelProto;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.irVersion=n.int64();break;case 8:a.opsetImport&&a.opsetImport.length||(a.opsetImport=[]),a.opsetImport.push(d.onnx.OperatorSetIdProto.decode(n,n.uint32()));break;case 2:a.producerName=n.string();break;case 3:a.producerVersion=n.string();break;case 4:a.domain=n.string();break;case 5:a.modelVersion=n.int64();break;case 6:a.docString=n.string();break;case 7:a.graph=d.onnx.GraphProto.decode(n,n.uint32());break;case 14:a.metadataProps&&a.metadataProps.length||(a.metadataProps=[]),a.metadataProps.push(d.onnx.StringStringEntryProto.decode(n,n.uint32()));break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){if("object"!=typeof n||null===n)return"object expected";if(null!=n.irVersion&&n.hasOwnProperty("irVersion")&&!(h.isInteger(n.irVersion)||n.irVersion&&h.isInteger(n.irVersion.low)&&h.isInteger(n.irVersion.high)))return"irVersion: integer|Long expected";if(null!=n.opsetImport&&n.hasOwnProperty("opsetImport")){if(!Array.isArray(n.opsetImport))return"opsetImport: array expected";for(var r,i=0;i<n.opsetImport.length;++i)if(r=d.onnx.OperatorSetIdProto.verify(n.opsetImport[i]))return"opsetImport."+r}if(null!=n.producerName&&n.hasOwnProperty("producerName")&&!h.isString(n.producerName))return"producerName: string expected";if(null!=n.producerVersion&&n.hasOwnProperty("producerVersion")&&!h.isString(n.producerVersion))return"producerVersion: string expected";if(null!=n.domain&&n.hasOwnProperty("domain")&&!h.isString(n.domain))return"domain: string expected";if(null!=n.modelVersion&&n.hasOwnProperty("modelVersion")&&!(h.isInteger(n.modelVersion)||n.modelVersion&&h.isInteger(n.modelVersion.low)&&h.isInteger(n.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=n.docString&&n.hasOwnProperty("docString")&&!h.isString(n.docString))return"docString: string expected";if(null!=n.graph&&n.hasOwnProperty("graph")&&(r=d.onnx.GraphProto.verify(n.graph)))return"graph."+r;if(null!=n.metadataProps&&n.hasOwnProperty("metadataProps")){if(!Array.isArray(n.metadataProps))return"metadataProps: array expected";for(i=0;i<n.metadataProps.length;++i)if(r=d.onnx.StringStringEntryProto.verify(n.metadataProps[i]))return"metadataProps."+r}return null},n.fromObject=function(n){if(n instanceof d.onnx.ModelProto)return n;var r=new d.onnx.ModelProto;if(null!=n.irVersion&&(h.Long?(r.irVersion=h.Long.fromValue(n.irVersion)).unsigned=!1:"string"==typeof n.irVersion?r.irVersion=parseInt(n.irVersion,10):"number"==typeof n.irVersion?r.irVersion=n.irVersion:"object"==typeof n.irVersion&&(r.irVersion=new h.LongBits(n.irVersion.low>>>0,n.irVersion.high>>>0).toNumber())),n.opsetImport){if(!Array.isArray(n.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");r.opsetImport=[];for(var i=0;i<n.opsetImport.length;++i){if("object"!=typeof n.opsetImport[i])throw TypeError(".onnx.ModelProto.opsetImport: object expected");r.opsetImport[i]=d.onnx.OperatorSetIdProto.fromObject(n.opsetImport[i])}}if(null!=n.producerName&&(r.producerName=String(n.producerName)),null!=n.producerVersion&&(r.producerVersion=String(n.producerVersion)),null!=n.domain&&(r.domain=String(n.domain)),null!=n.modelVersion&&(h.Long?(r.modelVersion=h.Long.fromValue(n.modelVersion)).unsigned=!1:"string"==typeof n.modelVersion?r.modelVersion=parseInt(n.modelVersion,10):"number"==typeof n.modelVersion?r.modelVersion=n.modelVersion:"object"==typeof n.modelVersion&&(r.modelVersion=new h.LongBits(n.modelVersion.low>>>0,n.modelVersion.high>>>0).toNumber())),null!=n.docString&&(r.docString=String(n.docString)),null!=n.graph){if("object"!=typeof n.graph)throw TypeError(".onnx.ModelProto.graph: object expected");r.graph=d.onnx.GraphProto.fromObject(n.graph)}if(n.metadataProps){if(!Array.isArray(n.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(r.metadataProps=[],i=0;i<n.metadataProps.length;++i){if("object"!=typeof n.metadataProps[i])throw TypeError(".onnx.ModelProto.metadataProps: object expected");r.metadataProps[i]=d.onnx.StringStringEntryProto.fromObject(n.metadataProps[i])}}return r},n.toObject=function(n,r){r||(r={});var i={};if((r.arrays||r.defaults)&&(i.opsetImport=[],i.metadataProps=[]),r.defaults){if(h.Long){var a=new h.Long(0,0,!1);i.irVersion=r.longs===String?a.toString():r.longs===Number?a.toNumber():a}else i.irVersion=r.longs===String?"0":0;i.producerName="",i.producerVersion="",i.domain="",h.Long?(a=new h.Long(0,0,!1),i.modelVersion=r.longs===String?a.toString():r.longs===Number?a.toNumber():a):i.modelVersion=r.longs===String?"0":0,i.docString="",i.graph=null}if(null!=n.irVersion&&n.hasOwnProperty("irVersion")&&("number"==typeof n.irVersion?i.irVersion=r.longs===String?String(n.irVersion):n.irVersion:i.irVersion=r.longs===String?h.Long.prototype.toString.call(n.irVersion):r.longs===Number?new h.LongBits(n.irVersion.low>>>0,n.irVersion.high>>>0).toNumber():n.irVersion),null!=n.producerName&&n.hasOwnProperty("producerName")&&(i.producerName=n.producerName),null!=n.producerVersion&&n.hasOwnProperty("producerVersion")&&(i.producerVersion=n.producerVersion),null!=n.domain&&n.hasOwnProperty("domain")&&(i.domain=n.domain),null!=n.modelVersion&&n.hasOwnProperty("modelVersion")&&("number"==typeof n.modelVersion?i.modelVersion=r.longs===String?String(n.modelVersion):n.modelVersion:i.modelVersion=r.longs===String?h.Long.prototype.toString.call(n.modelVersion):r.longs===Number?new h.LongBits(n.modelVersion.low>>>0,n.modelVersion.high>>>0).toNumber():n.modelVersion),null!=n.docString&&n.hasOwnProperty("docString")&&(i.docString=n.docString),null!=n.graph&&n.hasOwnProperty("graph")&&(i.graph=d.onnx.GraphProto.toObject(n.graph,r)),n.opsetImport&&n.opsetImport.length){i.opsetImport=[];for(var s=0;s<n.opsetImport.length;++s)i.opsetImport[s]=d.onnx.OperatorSetIdProto.toObject(n.opsetImport[s],r)}if(n.metadataProps&&n.metadataProps.length)for(i.metadataProps=[],s=0;s<n.metadataProps.length;++s)i.metadataProps[s]=d.onnx.StringStringEntryProto.toObject(n.metadataProps[s],r);return i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n}(),o.StringStringEntryProto=function(){function n(n){if(n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.key="",n.prototype.value="",n.create=function(r){return new n(r)},n.encode=function(n,r){return r||(r=c.create()),null!=n.key&&n.hasOwnProperty("key")&&r.uint32(10).string(n.key),null!=n.value&&n.hasOwnProperty("value")&&r.uint32(18).string(n.value),r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.StringStringEntryProto;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.key=n.string();break;case 2:a.value=n.string();break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){return"object"!=typeof n||null===n?"object expected":null!=n.key&&n.hasOwnProperty("key")&&!h.isString(n.key)?"key: string expected":null!=n.value&&n.hasOwnProperty("value")&&!h.isString(n.value)?"value: string expected":null},n.fromObject=function(n){if(n instanceof d.onnx.StringStringEntryProto)return n;var r=new d.onnx.StringStringEntryProto;return null!=n.key&&(r.key=String(n.key)),null!=n.value&&(r.value=String(n.value)),r},n.toObject=function(n,r){r||(r={});var i={};return r.defaults&&(i.key="",i.value=""),null!=n.key&&n.hasOwnProperty("key")&&(i.key=n.key),null!=n.value&&n.hasOwnProperty("value")&&(i.value=n.value),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n}(),o.TensorAnnotation=function(){function n(n){if(this.quantParameterTensorNames=[],n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.tensorName="",n.prototype.quantParameterTensorNames=h.emptyArray,n.create=function(r){return new n(r)},n.encode=function(n,r){if(r||(r=c.create()),null!=n.tensorName&&n.hasOwnProperty("tensorName")&&r.uint32(10).string(n.tensorName),null!=n.quantParameterTensorNames&&n.quantParameterTensorNames.length)for(var i=0;i<n.quantParameterTensorNames.length;++i)d.onnx.StringStringEntryProto.encode(n.quantParameterTensorNames[i],r.uint32(18).fork()).ldelim();return r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.TensorAnnotation;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.tensorName=n.string();break;case 2:a.quantParameterTensorNames&&a.quantParameterTensorNames.length||(a.quantParameterTensorNames=[]),a.quantParameterTensorNames.push(d.onnx.StringStringEntryProto.decode(n,n.uint32()));break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){if("object"!=typeof n||null===n)return"object expected";if(null!=n.tensorName&&n.hasOwnProperty("tensorName")&&!h.isString(n.tensorName))return"tensorName: string expected";if(null!=n.quantParameterTensorNames&&n.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(n.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var r=0;r<n.quantParameterTensorNames.length;++r){var i=d.onnx.StringStringEntryProto.verify(n.quantParameterTensorNames[r]);if(i)return"quantParameterTensorNames."+i}}return null},n.fromObject=function(n){if(n instanceof d.onnx.TensorAnnotation)return n;var r=new d.onnx.TensorAnnotation;if(null!=n.tensorName&&(r.tensorName=String(n.tensorName)),n.quantParameterTensorNames){if(!Array.isArray(n.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");r.quantParameterTensorNames=[];for(var i=0;i<n.quantParameterTensorNames.length;++i){if("object"!=typeof n.quantParameterTensorNames[i])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");r.quantParameterTensorNames[i]=d.onnx.StringStringEntryProto.fromObject(n.quantParameterTensorNames[i])}}return r},n.toObject=function(n,r){r||(r={});var i={};if((r.arrays||r.defaults)&&(i.quantParameterTensorNames=[]),r.defaults&&(i.tensorName=""),null!=n.tensorName&&n.hasOwnProperty("tensorName")&&(i.tensorName=n.tensorName),n.quantParameterTensorNames&&n.quantParameterTensorNames.length){i.quantParameterTensorNames=[];for(var a=0;a<n.quantParameterTensorNames.length;++a)i.quantParameterTensorNames[a]=d.onnx.StringStringEntryProto.toObject(n.quantParameterTensorNames[a],r)}return i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n}(),o.GraphProto=function(){function n(n){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.node=h.emptyArray,n.prototype.name="",n.prototype.initializer=h.emptyArray,n.prototype.docString="",n.prototype.input=h.emptyArray,n.prototype.output=h.emptyArray,n.prototype.valueInfo=h.emptyArray,n.prototype.quantizationAnnotation=h.emptyArray,n.create=function(r){return new n(r)},n.encode=function(n,r){if(r||(r=c.create()),null!=n.node&&n.node.length)for(var i=0;i<n.node.length;++i)d.onnx.NodeProto.encode(n.node[i],r.uint32(10).fork()).ldelim();if(null!=n.name&&n.hasOwnProperty("name")&&r.uint32(18).string(n.name),null!=n.initializer&&n.initializer.length)for(i=0;i<n.initializer.length;++i)d.onnx.TensorProto.encode(n.initializer[i],r.uint32(42).fork()).ldelim();if(null!=n.docString&&n.hasOwnProperty("docString")&&r.uint32(82).string(n.docString),null!=n.input&&n.input.length)for(i=0;i<n.input.length;++i)d.onnx.ValueInfoProto.encode(n.input[i],r.uint32(90).fork()).ldelim();if(null!=n.output&&n.output.length)for(i=0;i<n.output.length;++i)d.onnx.ValueInfoProto.encode(n.output[i],r.uint32(98).fork()).ldelim();if(null!=n.valueInfo&&n.valueInfo.length)for(i=0;i<n.valueInfo.length;++i)d.onnx.ValueInfoProto.encode(n.valueInfo[i],r.uint32(106).fork()).ldelim();if(null!=n.quantizationAnnotation&&n.quantizationAnnotation.length)for(i=0;i<n.quantizationAnnotation.length;++i)d.onnx.TensorAnnotation.encode(n.quantizationAnnotation[i],r.uint32(114).fork()).ldelim();return r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.GraphProto;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.node&&a.node.length||(a.node=[]),a.node.push(d.onnx.NodeProto.decode(n,n.uint32()));break;case 2:a.name=n.string();break;case 5:a.initializer&&a.initializer.length||(a.initializer=[]),a.initializer.push(d.onnx.TensorProto.decode(n,n.uint32()));break;case 10:a.docString=n.string();break;case 11:a.input&&a.input.length||(a.input=[]),a.input.push(d.onnx.ValueInfoProto.decode(n,n.uint32()));break;case 12:a.output&&a.output.length||(a.output=[]),a.output.push(d.onnx.ValueInfoProto.decode(n,n.uint32()));break;case 13:a.valueInfo&&a.valueInfo.length||(a.valueInfo=[]),a.valueInfo.push(d.onnx.ValueInfoProto.decode(n,n.uint32()));break;case 14:a.quantizationAnnotation&&a.quantizationAnnotation.length||(a.quantizationAnnotation=[]),a.quantizationAnnotation.push(d.onnx.TensorAnnotation.decode(n,n.uint32()));break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){if("object"!=typeof n||null===n)return"object expected";if(null!=n.node&&n.hasOwnProperty("node")){if(!Array.isArray(n.node))return"node: array expected";for(var r,i=0;i<n.node.length;++i)if(r=d.onnx.NodeProto.verify(n.node[i]))return"node."+r}if(null!=n.name&&n.hasOwnProperty("name")&&!h.isString(n.name))return"name: string expected";if(null!=n.initializer&&n.hasOwnProperty("initializer")){if(!Array.isArray(n.initializer))return"initializer: array expected";for(i=0;i<n.initializer.length;++i)if(r=d.onnx.TensorProto.verify(n.initializer[i]))return"initializer."+r}if(null!=n.docString&&n.hasOwnProperty("docString")&&!h.isString(n.docString))return"docString: string expected";if(null!=n.input&&n.hasOwnProperty("input")){if(!Array.isArray(n.input))return"input: array expected";for(i=0;i<n.input.length;++i)if(r=d.onnx.ValueInfoProto.verify(n.input[i]))return"input."+r}if(null!=n.output&&n.hasOwnProperty("output")){if(!Array.isArray(n.output))return"output: array expected";for(i=0;i<n.output.length;++i)if(r=d.onnx.ValueInfoProto.verify(n.output[i]))return"output."+r}if(null!=n.valueInfo&&n.hasOwnProperty("valueInfo")){if(!Array.isArray(n.valueInfo))return"valueInfo: array expected";for(i=0;i<n.valueInfo.length;++i)if(r=d.onnx.ValueInfoProto.verify(n.valueInfo[i]))return"valueInfo."+r}if(null!=n.quantizationAnnotation&&n.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(n.quantizationAnnotation))return"quantizationAnnotation: array expected";for(i=0;i<n.quantizationAnnotation.length;++i)if(r=d.onnx.TensorAnnotation.verify(n.quantizationAnnotation[i]))return"quantizationAnnotation."+r}return null},n.fromObject=function(n){if(n instanceof d.onnx.GraphProto)return n;var r=new d.onnx.GraphProto;if(n.node){if(!Array.isArray(n.node))throw TypeError(".onnx.GraphProto.node: array expected");r.node=[];for(var i=0;i<n.node.length;++i){if("object"!=typeof n.node[i])throw TypeError(".onnx.GraphProto.node: object expected");r.node[i]=d.onnx.NodeProto.fromObject(n.node[i])}}if(null!=n.name&&(r.name=String(n.name)),n.initializer){if(!Array.isArray(n.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(r.initializer=[],i=0;i<n.initializer.length;++i){if("object"!=typeof n.initializer[i])throw TypeError(".onnx.GraphProto.initializer: object expected");r.initializer[i]=d.onnx.TensorProto.fromObject(n.initializer[i])}}if(null!=n.docString&&(r.docString=String(n.docString)),n.input){if(!Array.isArray(n.input))throw TypeError(".onnx.GraphProto.input: array expected");for(r.input=[],i=0;i<n.input.length;++i){if("object"!=typeof n.input[i])throw TypeError(".onnx.GraphProto.input: object expected");r.input[i]=d.onnx.ValueInfoProto.fromObject(n.input[i])}}if(n.output){if(!Array.isArray(n.output))throw TypeError(".onnx.GraphProto.output: array expected");for(r.output=[],i=0;i<n.output.length;++i){if("object"!=typeof n.output[i])throw TypeError(".onnx.GraphProto.output: object expected");r.output[i]=d.onnx.ValueInfoProto.fromObject(n.output[i])}}if(n.valueInfo){if(!Array.isArray(n.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(r.valueInfo=[],i=0;i<n.valueInfo.length;++i){if("object"!=typeof n.valueInfo[i])throw TypeError(".onnx.GraphProto.valueInfo: object expected");r.valueInfo[i]=d.onnx.ValueInfoProto.fromObject(n.valueInfo[i])}}if(n.quantizationAnnotation){if(!Array.isArray(n.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(r.quantizationAnnotation=[],i=0;i<n.quantizationAnnotation.length;++i){if("object"!=typeof n.quantizationAnnotation[i])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");r.quantizationAnnotation[i]=d.onnx.TensorAnnotation.fromObject(n.quantizationAnnotation[i])}}return r},n.toObject=function(n,r){r||(r={});var i={};if((r.arrays||r.defaults)&&(i.node=[],i.initializer=[],i.input=[],i.output=[],i.valueInfo=[],i.quantizationAnnotation=[]),r.defaults&&(i.name="",i.docString=""),n.node&&n.node.length){i.node=[];for(var a=0;a<n.node.length;++a)i.node[a]=d.onnx.NodeProto.toObject(n.node[a],r)}if(null!=n.name&&n.hasOwnProperty("name")&&(i.name=n.name),n.initializer&&n.initializer.length)for(i.initializer=[],a=0;a<n.initializer.length;++a)i.initializer[a]=d.onnx.TensorProto.toObject(n.initializer[a],r);if(null!=n.docString&&n.hasOwnProperty("docString")&&(i.docString=n.docString),n.input&&n.input.length)for(i.input=[],a=0;a<n.input.length;++a)i.input[a]=d.onnx.ValueInfoProto.toObject(n.input[a],r);if(n.output&&n.output.length)for(i.output=[],a=0;a<n.output.length;++a)i.output[a]=d.onnx.ValueInfoProto.toObject(n.output[a],r);if(n.valueInfo&&n.valueInfo.length)for(i.valueInfo=[],a=0;a<n.valueInfo.length;++a)i.valueInfo[a]=d.onnx.ValueInfoProto.toObject(n.valueInfo[a],r);if(n.quantizationAnnotation&&n.quantizationAnnotation.length)for(i.quantizationAnnotation=[],a=0;a<n.quantizationAnnotation.length;++a)i.quantizationAnnotation[a]=d.onnx.TensorAnnotation.toObject(n.quantizationAnnotation[a],r);return i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n}(),o.TensorProto=function(){function n(n){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.dims=h.emptyArray,n.prototype.dataType=0,n.prototype.segment=null,n.prototype.floatData=h.emptyArray,n.prototype.int32Data=h.emptyArray,n.prototype.stringData=h.emptyArray,n.prototype.int64Data=h.emptyArray,n.prototype.name="",n.prototype.docString="",n.prototype.rawData=h.newBuffer([]),n.prototype.externalData=h.emptyArray,n.prototype.dataLocation=0,n.prototype.doubleData=h.emptyArray,n.prototype.uint64Data=h.emptyArray,n.create=function(r){return new n(r)},n.encode=function(n,r){if(r||(r=c.create()),null!=n.dims&&n.dims.length){r.uint32(10).fork();for(var i=0;i<n.dims.length;++i)r.int64(n.dims[i]);r.ldelim()}if(null!=n.dataType&&n.hasOwnProperty("dataType")&&r.uint32(16).int32(n.dataType),null!=n.segment&&n.hasOwnProperty("segment")&&d.onnx.TensorProto.Segment.encode(n.segment,r.uint32(26).fork()).ldelim(),null!=n.floatData&&n.floatData.length){for(r.uint32(34).fork(),i=0;i<n.floatData.length;++i)r.float(n.floatData[i]);r.ldelim()}if(null!=n.int32Data&&n.int32Data.length){for(r.uint32(42).fork(),i=0;i<n.int32Data.length;++i)r.int32(n.int32Data[i]);r.ldelim()}if(null!=n.stringData&&n.stringData.length)for(i=0;i<n.stringData.length;++i)r.uint32(50).bytes(n.stringData[i]);if(null!=n.int64Data&&n.int64Data.length){for(r.uint32(58).fork(),i=0;i<n.int64Data.length;++i)r.int64(n.int64Data[i]);r.ldelim()}if(null!=n.name&&n.hasOwnProperty("name")&&r.uint32(66).string(n.name),null!=n.rawData&&n.hasOwnProperty("rawData")&&r.uint32(74).bytes(n.rawData),null!=n.doubleData&&n.doubleData.length){for(r.uint32(82).fork(),i=0;i<n.doubleData.length;++i)r.double(n.doubleData[i]);r.ldelim()}if(null!=n.uint64Data&&n.uint64Data.length){for(r.uint32(90).fork(),i=0;i<n.uint64Data.length;++i)r.uint64(n.uint64Data[i]);r.ldelim()}if(null!=n.docString&&n.hasOwnProperty("docString")&&r.uint32(98).string(n.docString),null!=n.externalData&&n.externalData.length)for(i=0;i<n.externalData.length;++i)d.onnx.StringStringEntryProto.encode(n.externalData[i],r.uint32(106).fork()).ldelim();return null!=n.dataLocation&&n.hasOwnProperty("dataLocation")&&r.uint32(112).int32(n.dataLocation),r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.TensorProto;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:if(a.dims&&a.dims.length||(a.dims=[]),2==(7&s))for(var o=n.uint32()+n.pos;n.pos<o;)a.dims.push(n.int64());else a.dims.push(n.int64());break;case 2:a.dataType=n.int32();break;case 3:a.segment=d.onnx.TensorProto.Segment.decode(n,n.uint32());break;case 4:if(a.floatData&&a.floatData.length||(a.floatData=[]),2==(7&s))for(o=n.uint32()+n.pos;n.pos<o;)a.floatData.push(n.float());else a.floatData.push(n.float());break;case 5:if(a.int32Data&&a.int32Data.length||(a.int32Data=[]),2==(7&s))for(o=n.uint32()+n.pos;n.pos<o;)a.int32Data.push(n.int32());else a.int32Data.push(n.int32());break;case 6:a.stringData&&a.stringData.length||(a.stringData=[]),a.stringData.push(n.bytes());break;case 7:if(a.int64Data&&a.int64Data.length||(a.int64Data=[]),2==(7&s))for(o=n.uint32()+n.pos;n.pos<o;)a.int64Data.push(n.int64());else a.int64Data.push(n.int64());break;case 8:a.name=n.string();break;case 12:a.docString=n.string();break;case 9:a.rawData=n.bytes();break;case 13:a.externalData&&a.externalData.length||(a.externalData=[]),a.externalData.push(d.onnx.StringStringEntryProto.decode(n,n.uint32()));break;case 14:a.dataLocation=n.int32();break;case 10:if(a.doubleData&&a.doubleData.length||(a.doubleData=[]),2==(7&s))for(o=n.uint32()+n.pos;n.pos<o;)a.doubleData.push(n.double());else a.doubleData.push(n.double());break;case 11:if(a.uint64Data&&a.uint64Data.length||(a.uint64Data=[]),2==(7&s))for(o=n.uint32()+n.pos;n.pos<o;)a.uint64Data.push(n.uint64());else a.uint64Data.push(n.uint64());break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){if("object"!=typeof n||null===n)return"object expected";if(null!=n.dims&&n.hasOwnProperty("dims")){if(!Array.isArray(n.dims))return"dims: array expected";for(var r,i=0;i<n.dims.length;++i)if(!(h.isInteger(n.dims[i])||n.dims[i]&&h.isInteger(n.dims[i].low)&&h.isInteger(n.dims[i].high)))return"dims: integer|Long[] expected"}if(null!=n.dataType&&n.hasOwnProperty("dataType")&&!h.isInteger(n.dataType))return"dataType: integer expected";if(null!=n.segment&&n.hasOwnProperty("segment")&&(r=d.onnx.TensorProto.Segment.verify(n.segment)))return"segment."+r;if(null!=n.floatData&&n.hasOwnProperty("floatData")){if(!Array.isArray(n.floatData))return"floatData: array expected";for(i=0;i<n.floatData.length;++i)if("number"!=typeof n.floatData[i])return"floatData: number[] expected"}if(null!=n.int32Data&&n.hasOwnProperty("int32Data")){if(!Array.isArray(n.int32Data))return"int32Data: array expected";for(i=0;i<n.int32Data.length;++i)if(!h.isInteger(n.int32Data[i]))return"int32Data: integer[] expected"}if(null!=n.stringData&&n.hasOwnProperty("stringData")){if(!Array.isArray(n.stringData))return"stringData: array expected";for(i=0;i<n.stringData.length;++i)if(!(n.stringData[i]&&"number"==typeof n.stringData[i].length||h.isString(n.stringData[i])))return"stringData: buffer[] expected"}if(null!=n.int64Data&&n.hasOwnProperty("int64Data")){if(!Array.isArray(n.int64Data))return"int64Data: array expected";for(i=0;i<n.int64Data.length;++i)if(!(h.isInteger(n.int64Data[i])||n.int64Data[i]&&h.isInteger(n.int64Data[i].low)&&h.isInteger(n.int64Data[i].high)))return"int64Data: integer|Long[] expected"}if(null!=n.name&&n.hasOwnProperty("name")&&!h.isString(n.name))return"name: string expected";if(null!=n.docString&&n.hasOwnProperty("docString")&&!h.isString(n.docString))return"docString: string expected";if(null!=n.rawData&&n.hasOwnProperty("rawData")&&!(n.rawData&&"number"==typeof n.rawData.length||h.isString(n.rawData)))return"rawData: buffer expected";if(null!=n.externalData&&n.hasOwnProperty("externalData")){if(!Array.isArray(n.externalData))return"externalData: array expected";for(i=0;i<n.externalData.length;++i)if(r=d.onnx.StringStringEntryProto.verify(n.externalData[i]))return"externalData."+r}if(null!=n.dataLocation&&n.hasOwnProperty("dataLocation"))switch(n.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=n.doubleData&&n.hasOwnProperty("doubleData")){if(!Array.isArray(n.doubleData))return"doubleData: array expected";for(i=0;i<n.doubleData.length;++i)if("number"!=typeof n.doubleData[i])return"doubleData: number[] expected"}if(null!=n.uint64Data&&n.hasOwnProperty("uint64Data")){if(!Array.isArray(n.uint64Data))return"uint64Data: array expected";for(i=0;i<n.uint64Data.length;++i)if(!(h.isInteger(n.uint64Data[i])||n.uint64Data[i]&&h.isInteger(n.uint64Data[i].low)&&h.isInteger(n.uint64Data[i].high)))return"uint64Data: integer|Long[] expected"}return null},n.fromObject=function(n){if(n instanceof d.onnx.TensorProto)return n;var r=new d.onnx.TensorProto;if(n.dims){if(!Array.isArray(n.dims))throw TypeError(".onnx.TensorProto.dims: array expected");r.dims=[];for(var i=0;i<n.dims.length;++i)h.Long?(r.dims[i]=h.Long.fromValue(n.dims[i])).unsigned=!1:"string"==typeof n.dims[i]?r.dims[i]=parseInt(n.dims[i],10):"number"==typeof n.dims[i]?r.dims[i]=n.dims[i]:"object"==typeof n.dims[i]&&(r.dims[i]=new h.LongBits(n.dims[i].low>>>0,n.dims[i].high>>>0).toNumber())}if(null!=n.dataType&&(r.dataType=0|n.dataType),null!=n.segment){if("object"!=typeof n.segment)throw TypeError(".onnx.TensorProto.segment: object expected");r.segment=d.onnx.TensorProto.Segment.fromObject(n.segment)}if(n.floatData){if(!Array.isArray(n.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(r.floatData=[],i=0;i<n.floatData.length;++i)r.floatData[i]=Number(n.floatData[i])}if(n.int32Data){if(!Array.isArray(n.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(r.int32Data=[],i=0;i<n.int32Data.length;++i)r.int32Data[i]=0|n.int32Data[i]}if(n.stringData){if(!Array.isArray(n.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(r.stringData=[],i=0;i<n.stringData.length;++i)"string"==typeof n.stringData[i]?h.base64.decode(n.stringData[i],r.stringData[i]=h.newBuffer(h.base64.length(n.stringData[i])),0):n.stringData[i].length&&(r.stringData[i]=n.stringData[i])}if(n.int64Data){if(!Array.isArray(n.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(r.int64Data=[],i=0;i<n.int64Data.length;++i)h.Long?(r.int64Data[i]=h.Long.fromValue(n.int64Data[i])).unsigned=!1:"string"==typeof n.int64Data[i]?r.int64Data[i]=parseInt(n.int64Data[i],10):"number"==typeof n.int64Data[i]?r.int64Data[i]=n.int64Data[i]:"object"==typeof n.int64Data[i]&&(r.int64Data[i]=new h.LongBits(n.int64Data[i].low>>>0,n.int64Data[i].high>>>0).toNumber())}if(null!=n.name&&(r.name=String(n.name)),null!=n.docString&&(r.docString=String(n.docString)),null!=n.rawData&&("string"==typeof n.rawData?h.base64.decode(n.rawData,r.rawData=h.newBuffer(h.base64.length(n.rawData)),0):n.rawData.length&&(r.rawData=n.rawData)),n.externalData){if(!Array.isArray(n.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(r.externalData=[],i=0;i<n.externalData.length;++i){if("object"!=typeof n.externalData[i])throw TypeError(".onnx.TensorProto.externalData: object expected");r.externalData[i]=d.onnx.StringStringEntryProto.fromObject(n.externalData[i])}}switch(n.dataLocation){case"DEFAULT":case 0:r.dataLocation=0;break;case"EXTERNAL":case 1:r.dataLocation=1}if(n.doubleData){if(!Array.isArray(n.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(r.doubleData=[],i=0;i<n.doubleData.length;++i)r.doubleData[i]=Number(n.doubleData[i])}if(n.uint64Data){if(!Array.isArray(n.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(r.uint64Data=[],i=0;i<n.uint64Data.length;++i)h.Long?(r.uint64Data[i]=h.Long.fromValue(n.uint64Data[i])).unsigned=!0:"string"==typeof n.uint64Data[i]?r.uint64Data[i]=parseInt(n.uint64Data[i],10):"number"==typeof n.uint64Data[i]?r.uint64Data[i]=n.uint64Data[i]:"object"==typeof n.uint64Data[i]&&(r.uint64Data[i]=new h.LongBits(n.uint64Data[i].low>>>0,n.uint64Data[i].high>>>0).toNumber(!0))}return r},n.toObject=function(n,r){r||(r={});var i={};if((r.arrays||r.defaults)&&(i.dims=[],i.floatData=[],i.int32Data=[],i.stringData=[],i.int64Data=[],i.doubleData=[],i.uint64Data=[],i.externalData=[]),r.defaults&&(i.dataType=0,i.segment=null,i.name="",r.bytes===String?i.rawData="":(i.rawData=[],r.bytes!==Array&&(i.rawData=h.newBuffer(i.rawData))),i.docString="",i.dataLocation=r.enums===String?"DEFAULT":0),n.dims&&n.dims.length){i.dims=[];for(var a=0;a<n.dims.length;++a)"number"==typeof n.dims[a]?i.dims[a]=r.longs===String?String(n.dims[a]):n.dims[a]:i.dims[a]=r.longs===String?h.Long.prototype.toString.call(n.dims[a]):r.longs===Number?new h.LongBits(n.dims[a].low>>>0,n.dims[a].high>>>0).toNumber():n.dims[a]}if(null!=n.dataType&&n.hasOwnProperty("dataType")&&(i.dataType=n.dataType),null!=n.segment&&n.hasOwnProperty("segment")&&(i.segment=d.onnx.TensorProto.Segment.toObject(n.segment,r)),n.floatData&&n.floatData.length)for(i.floatData=[],a=0;a<n.floatData.length;++a)i.floatData[a]=r.json&&!isFinite(n.floatData[a])?String(n.floatData[a]):n.floatData[a];if(n.int32Data&&n.int32Data.length)for(i.int32Data=[],a=0;a<n.int32Data.length;++a)i.int32Data[a]=n.int32Data[a];if(n.stringData&&n.stringData.length)for(i.stringData=[],a=0;a<n.stringData.length;++a)i.stringData[a]=r.bytes===String?h.base64.encode(n.stringData[a],0,n.stringData[a].length):r.bytes===Array?Array.prototype.slice.call(n.stringData[a]):n.stringData[a];if(n.int64Data&&n.int64Data.length)for(i.int64Data=[],a=0;a<n.int64Data.length;++a)"number"==typeof n.int64Data[a]?i.int64Data[a]=r.longs===String?String(n.int64Data[a]):n.int64Data[a]:i.int64Data[a]=r.longs===String?h.Long.prototype.toString.call(n.int64Data[a]):r.longs===Number?new h.LongBits(n.int64Data[a].low>>>0,n.int64Data[a].high>>>0).toNumber():n.int64Data[a];if(null!=n.name&&n.hasOwnProperty("name")&&(i.name=n.name),null!=n.rawData&&n.hasOwnProperty("rawData")&&(i.rawData=r.bytes===String?h.base64.encode(n.rawData,0,n.rawData.length):r.bytes===Array?Array.prototype.slice.call(n.rawData):n.rawData),n.doubleData&&n.doubleData.length)for(i.doubleData=[],a=0;a<n.doubleData.length;++a)i.doubleData[a]=r.json&&!isFinite(n.doubleData[a])?String(n.doubleData[a]):n.doubleData[a];if(n.uint64Data&&n.uint64Data.length)for(i.uint64Data=[],a=0;a<n.uint64Data.length;++a)"number"==typeof n.uint64Data[a]?i.uint64Data[a]=r.longs===String?String(n.uint64Data[a]):n.uint64Data[a]:i.uint64Data[a]=r.longs===String?h.Long.prototype.toString.call(n.uint64Data[a]):r.longs===Number?new h.LongBits(n.uint64Data[a].low>>>0,n.uint64Data[a].high>>>0).toNumber(!0):n.uint64Data[a];if(null!=n.docString&&n.hasOwnProperty("docString")&&(i.docString=n.docString),n.externalData&&n.externalData.length)for(i.externalData=[],a=0;a<n.externalData.length;++a)i.externalData[a]=d.onnx.StringStringEntryProto.toObject(n.externalData[a],r);return null!=n.dataLocation&&n.hasOwnProperty("dataLocation")&&(i.dataLocation=r.enums===String?d.onnx.TensorProto.DataLocation[n.dataLocation]:n.dataLocation),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n.DataType=function(){var n={},r=Object.create(n);return r[n[0]="UNDEFINED"]=0,r[n[1]="FLOAT"]=1,r[n[2]="UINT8"]=2,r[n[3]="INT8"]=3,r[n[4]="UINT16"]=4,r[n[5]="INT16"]=5,r[n[6]="INT32"]=6,r[n[7]="INT64"]=7,r[n[8]="STRING"]=8,r[n[9]="BOOL"]=9,r[n[10]="FLOAT16"]=10,r[n[11]="DOUBLE"]=11,r[n[12]="UINT32"]=12,r[n[13]="UINT64"]=13,r[n[14]="COMPLEX64"]=14,r[n[15]="COMPLEX128"]=15,r[n[16]="BFLOAT16"]=16,r}(),n.Segment=function(){function n(n){if(n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.begin=h.Long?h.Long.fromBits(0,0,!1):0,n.prototype.end=h.Long?h.Long.fromBits(0,0,!1):0,n.create=function(r){return new n(r)},n.encode=function(n,r){return r||(r=c.create()),null!=n.begin&&n.hasOwnProperty("begin")&&r.uint32(8).int64(n.begin),null!=n.end&&n.hasOwnProperty("end")&&r.uint32(16).int64(n.end),r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.TensorProto.Segment;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.begin=n.int64();break;case 2:a.end=n.int64();break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){return"object"!=typeof n||null===n?"object expected":null!=n.begin&&n.hasOwnProperty("begin")&&!(h.isInteger(n.begin)||n.begin&&h.isInteger(n.begin.low)&&h.isInteger(n.begin.high))?"begin: integer|Long expected":null!=n.end&&n.hasOwnProperty("end")&&!(h.isInteger(n.end)||n.end&&h.isInteger(n.end.low)&&h.isInteger(n.end.high))?"end: integer|Long expected":null},n.fromObject=function(n){if(n instanceof d.onnx.TensorProto.Segment)return n;var r=new d.onnx.TensorProto.Segment;return null!=n.begin&&(h.Long?(r.begin=h.Long.fromValue(n.begin)).unsigned=!1:"string"==typeof n.begin?r.begin=parseInt(n.begin,10):"number"==typeof n.begin?r.begin=n.begin:"object"==typeof n.begin&&(r.begin=new h.LongBits(n.begin.low>>>0,n.begin.high>>>0).toNumber())),null!=n.end&&(h.Long?(r.end=h.Long.fromValue(n.end)).unsigned=!1:"string"==typeof n.end?r.end=parseInt(n.end,10):"number"==typeof n.end?r.end=n.end:"object"==typeof n.end&&(r.end=new h.LongBits(n.end.low>>>0,n.end.high>>>0).toNumber())),r},n.toObject=function(n,r){r||(r={});var i={};if(r.defaults){if(h.Long){var a=new h.Long(0,0,!1);i.begin=r.longs===String?a.toString():r.longs===Number?a.toNumber():a}else i.begin=r.longs===String?"0":0;h.Long?(a=new h.Long(0,0,!1),i.end=r.longs===String?a.toString():r.longs===Number?a.toNumber():a):i.end=r.longs===String?"0":0}return null!=n.begin&&n.hasOwnProperty("begin")&&("number"==typeof n.begin?i.begin=r.longs===String?String(n.begin):n.begin:i.begin=r.longs===String?h.Long.prototype.toString.call(n.begin):r.longs===Number?new h.LongBits(n.begin.low>>>0,n.begin.high>>>0).toNumber():n.begin),null!=n.end&&n.hasOwnProperty("end")&&("number"==typeof n.end?i.end=r.longs===String?String(n.end):n.end:i.end=r.longs===String?h.Long.prototype.toString.call(n.end):r.longs===Number?new h.LongBits(n.end.low>>>0,n.end.high>>>0).toNumber():n.end),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n}(),n.DataLocation=function(){var n={},r=Object.create(n);return r[n[0]="DEFAULT"]=0,r[n[1]="EXTERNAL"]=1,r}(),n}(),o.TensorShapeProto=function(){function n(n){if(this.dim=[],n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.dim=h.emptyArray,n.create=function(r){return new n(r)},n.encode=function(n,r){if(r||(r=c.create()),null!=n.dim&&n.dim.length)for(var i=0;i<n.dim.length;++i)d.onnx.TensorShapeProto.Dimension.encode(n.dim[i],r.uint32(10).fork()).ldelim();return r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.TensorShapeProto;n.pos<i;){var s=n.uint32();s>>>3==1?(a.dim&&a.dim.length||(a.dim=[]),a.dim.push(d.onnx.TensorShapeProto.Dimension.decode(n,n.uint32()))):n.skipType(7&s)}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){if("object"!=typeof n||null===n)return"object expected";if(null!=n.dim&&n.hasOwnProperty("dim")){if(!Array.isArray(n.dim))return"dim: array expected";for(var r=0;r<n.dim.length;++r){var i=d.onnx.TensorShapeProto.Dimension.verify(n.dim[r]);if(i)return"dim."+i}}return null},n.fromObject=function(n){if(n instanceof d.onnx.TensorShapeProto)return n;var r=new d.onnx.TensorShapeProto;if(n.dim){if(!Array.isArray(n.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");r.dim=[];for(var i=0;i<n.dim.length;++i){if("object"!=typeof n.dim[i])throw TypeError(".onnx.TensorShapeProto.dim: object expected");r.dim[i]=d.onnx.TensorShapeProto.Dimension.fromObject(n.dim[i])}}return r},n.toObject=function(n,r){r||(r={});var i={};if((r.arrays||r.defaults)&&(i.dim=[]),n.dim&&n.dim.length){i.dim=[];for(var a=0;a<n.dim.length;++a)i.dim[a]=d.onnx.TensorShapeProto.Dimension.toObject(n.dim[a],r)}return i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n.Dimension=function(){var n;function r(n){if(n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return r.prototype.dimValue=h.Long?h.Long.fromBits(0,0,!1):0,r.prototype.dimParam="",r.prototype.denotation="",Object.defineProperty(r.prototype,"value",{get:h.oneOfGetter(n=["dimValue","dimParam"]),set:h.oneOfSetter(n)}),r.create=function(n){return new r(n)},r.encode=function(n,r){return r||(r=c.create()),null!=n.dimValue&&n.hasOwnProperty("dimValue")&&r.uint32(8).int64(n.dimValue),null!=n.dimParam&&n.hasOwnProperty("dimParam")&&r.uint32(18).string(n.dimParam),null!=n.denotation&&n.hasOwnProperty("denotation")&&r.uint32(26).string(n.denotation),r},r.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},r.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.TensorShapeProto.Dimension;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.dimValue=n.int64();break;case 2:a.dimParam=n.string();break;case 3:a.denotation=n.string();break;default:n.skipType(7&s)}}return a},r.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},r.verify=function(n){if("object"!=typeof n||null===n)return"object expected";var r={};if(null!=n.dimValue&&n.hasOwnProperty("dimValue")&&(r.value=1,!(h.isInteger(n.dimValue)||n.dimValue&&h.isInteger(n.dimValue.low)&&h.isInteger(n.dimValue.high))))return"dimValue: integer|Long expected";if(null!=n.dimParam&&n.hasOwnProperty("dimParam")){if(1===r.value)return"value: multiple values";if(r.value=1,!h.isString(n.dimParam))return"dimParam: string expected"}return null!=n.denotation&&n.hasOwnProperty("denotation")&&!h.isString(n.denotation)?"denotation: string expected":null},r.fromObject=function(n){if(n instanceof d.onnx.TensorShapeProto.Dimension)return n;var r=new d.onnx.TensorShapeProto.Dimension;return null!=n.dimValue&&(h.Long?(r.dimValue=h.Long.fromValue(n.dimValue)).unsigned=!1:"string"==typeof n.dimValue?r.dimValue=parseInt(n.dimValue,10):"number"==typeof n.dimValue?r.dimValue=n.dimValue:"object"==typeof n.dimValue&&(r.dimValue=new h.LongBits(n.dimValue.low>>>0,n.dimValue.high>>>0).toNumber())),null!=n.dimParam&&(r.dimParam=String(n.dimParam)),null!=n.denotation&&(r.denotation=String(n.denotation)),r},r.toObject=function(n,r){r||(r={});var i={};return r.defaults&&(i.denotation=""),null!=n.dimValue&&n.hasOwnProperty("dimValue")&&("number"==typeof n.dimValue?i.dimValue=r.longs===String?String(n.dimValue):n.dimValue:i.dimValue=r.longs===String?h.Long.prototype.toString.call(n.dimValue):r.longs===Number?new h.LongBits(n.dimValue.low>>>0,n.dimValue.high>>>0).toNumber():n.dimValue,r.oneofs&&(i.value="dimValue")),null!=n.dimParam&&n.hasOwnProperty("dimParam")&&(i.dimParam=n.dimParam,r.oneofs&&(i.value="dimParam")),null!=n.denotation&&n.hasOwnProperty("denotation")&&(i.denotation=n.denotation),i},r.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},r}(),n}(),o.TypeProto=function(){var n;function r(n){if(n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return r.prototype.tensorType=null,r.prototype.denotation="",Object.defineProperty(r.prototype,"value",{get:h.oneOfGetter(n=["tensorType"]),set:h.oneOfSetter(n)}),r.create=function(n){return new r(n)},r.encode=function(n,r){return r||(r=c.create()),null!=n.tensorType&&n.hasOwnProperty("tensorType")&&d.onnx.TypeProto.Tensor.encode(n.tensorType,r.uint32(10).fork()).ldelim(),null!=n.denotation&&n.hasOwnProperty("denotation")&&r.uint32(50).string(n.denotation),r},r.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},r.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.TypeProto;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.tensorType=d.onnx.TypeProto.Tensor.decode(n,n.uint32());break;case 6:a.denotation=n.string();break;default:n.skipType(7&s)}}return a},r.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},r.verify=function(n){if("object"!=typeof n||null===n)return"object expected";if(null!=n.tensorType&&n.hasOwnProperty("tensorType")){var r=d.onnx.TypeProto.Tensor.verify(n.tensorType);if(r)return"tensorType."+r}return null!=n.denotation&&n.hasOwnProperty("denotation")&&!h.isString(n.denotation)?"denotation: string expected":null},r.fromObject=function(n){if(n instanceof d.onnx.TypeProto)return n;var r=new d.onnx.TypeProto;if(null!=n.tensorType){if("object"!=typeof n.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");r.tensorType=d.onnx.TypeProto.Tensor.fromObject(n.tensorType)}return null!=n.denotation&&(r.denotation=String(n.denotation)),r},r.toObject=function(n,r){r||(r={});var i={};return r.defaults&&(i.denotation=""),null!=n.tensorType&&n.hasOwnProperty("tensorType")&&(i.tensorType=d.onnx.TypeProto.Tensor.toObject(n.tensorType,r),r.oneofs&&(i.value="tensorType")),null!=n.denotation&&n.hasOwnProperty("denotation")&&(i.denotation=n.denotation),i},r.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},r.Tensor=function(){function n(n){if(n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.elemType=0,n.prototype.shape=null,n.create=function(r){return new n(r)},n.encode=function(n,r){return r||(r=c.create()),null!=n.elemType&&n.hasOwnProperty("elemType")&&r.uint32(8).int32(n.elemType),null!=n.shape&&n.hasOwnProperty("shape")&&d.onnx.TensorShapeProto.encode(n.shape,r.uint32(18).fork()).ldelim(),r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.TypeProto.Tensor;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.elemType=n.int32();break;case 2:a.shape=d.onnx.TensorShapeProto.decode(n,n.uint32());break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){if("object"!=typeof n||null===n)return"object expected";if(null!=n.elemType&&n.hasOwnProperty("elemType")&&!h.isInteger(n.elemType))return"elemType: integer expected";if(null!=n.shape&&n.hasOwnProperty("shape")){var r=d.onnx.TensorShapeProto.verify(n.shape);if(r)return"shape."+r}return null},n.fromObject=function(n){if(n instanceof d.onnx.TypeProto.Tensor)return n;var r=new d.onnx.TypeProto.Tensor;if(null!=n.elemType&&(r.elemType=0|n.elemType),null!=n.shape){if("object"!=typeof n.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");r.shape=d.onnx.TensorShapeProto.fromObject(n.shape)}return r},n.toObject=function(n,r){r||(r={});var i={};return r.defaults&&(i.elemType=0,i.shape=null),null!=n.elemType&&n.hasOwnProperty("elemType")&&(i.elemType=n.elemType),null!=n.shape&&n.hasOwnProperty("shape")&&(i.shape=d.onnx.TensorShapeProto.toObject(n.shape,r)),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n}(),r}(),o.OperatorSetIdProto=function(){function n(n){if(n)for(var r=Object.keys(n),i=0;i<r.length;++i)null!=n[r[i]]&&(this[r[i]]=n[r[i]])}return n.prototype.domain="",n.prototype.version=h.Long?h.Long.fromBits(0,0,!1):0,n.create=function(r){return new n(r)},n.encode=function(n,r){return r||(r=c.create()),null!=n.domain&&n.hasOwnProperty("domain")&&r.uint32(10).string(n.domain),null!=n.version&&n.hasOwnProperty("version")&&r.uint32(16).int64(n.version),r},n.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},n.decode=function(n,r){n instanceof u||(n=u.create(n));for(var i=void 0===r?n.len:n.pos+r,a=new d.onnx.OperatorSetIdProto;n.pos<i;){var s=n.uint32();switch(s>>>3){case 1:a.domain=n.string();break;case 2:a.version=n.int64();break;default:n.skipType(7&s)}}return a},n.decodeDelimited=function(n){return n instanceof u||(n=new u(n)),this.decode(n,n.uint32())},n.verify=function(n){return"object"!=typeof n||null===n?"object expected":null!=n.domain&&n.hasOwnProperty("domain")&&!h.isString(n.domain)?"domain: string expected":null!=n.version&&n.hasOwnProperty("version")&&!(h.isInteger(n.version)||n.version&&h.isInteger(n.version.low)&&h.isInteger(n.version.high))?"version: integer|Long expected":null},n.fromObject=function(n){if(n instanceof d.onnx.OperatorSetIdProto)return n;var r=new d.onnx.OperatorSetIdProto;return null!=n.domain&&(r.domain=String(n.domain)),null!=n.version&&(h.Long?(r.version=h.Long.fromValue(n.version)).unsigned=!1:"string"==typeof n.version?r.version=parseInt(n.version,10):"number"==typeof n.version?r.version=n.version:"object"==typeof n.version&&(r.version=new h.LongBits(n.version.low>>>0,n.version.high>>>0).toNumber())),r},n.toObject=function(n,r){r||(r={});var i={};if(r.defaults){if(i.domain="",h.Long){var a=new h.Long(0,0,!1);i.version=r.longs===String?a.toString():r.longs===Number?a.toNumber():a}else i.version=r.longs===String?"0":0}return null!=n.domain&&n.hasOwnProperty("domain")&&(i.domain=n.domain),null!=n.version&&n.hasOwnProperty("version")&&("number"==typeof n.version?i.version=r.longs===String?String(n.version):n.version:i.version=r.longs===String?h.Long.prototype.toString.call(n.version):r.longs===Number?new h.LongBits(n.version.low>>>0,n.version.high>>>0).toNumber():n.version),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,l.util.toJSONOptions)},n}(),o),n.exports=d},2100:(n,r,i)=>{n.exports=i(9482)},9482:(n,r,i)=>{var a=r;function s(){a.util._configure(),a.Writer._configure(a.BufferWriter),a.Reader._configure(a.BufferReader)}a.build="minimal",a.Writer=i(1173),a.BufferWriter=i(3155),a.Reader=i(1408),a.BufferReader=i(593),a.util=i(9693),a.rpc=i(5994),a.roots=i(5054),a.configure=s,s()},1408:(n,r,i)=>{n.exports=c;var a,s=i(9693),o=s.LongBits,l=s.utf8;function u(n,r){return RangeError("index out of range: "+n.pos+" + "+(r||1)+" > "+n.len)}function c(n){this.buf=n,this.pos=0,this.len=n.length}var h,d="undefined"!=typeof Uint8Array?function(n){if(n instanceof Uint8Array||Array.isArray(n))return new c(n);throw Error("illegal buffer")}:function(n){if(Array.isArray(n))return new c(n);throw Error("illegal buffer")},p=function(){return s.Buffer?function(n){return(c.create=function(n){return s.Buffer.isBuffer(n)?new a(n):d(n)})(n)}:d};function f(){var n=new o(0,0),r=0;if(!(this.len-this.pos>4)){for(;r<3;++r){if(this.pos>=this.len)throw u(this);if(n.lo=(n.lo|(127&this.buf[this.pos])<<7*r)>>>0,this.buf[this.pos++]<128)return n}return n.lo=(n.lo|(127&this.buf[this.pos++])<<7*r)>>>0,n}for(;r<4;++r)if(n.lo=(n.lo|(127&this.buf[this.pos])<<7*r)>>>0,this.buf[this.pos++]<128)return n;if(n.lo=(n.lo|(127&this.buf[this.pos])<<28)>>>0,n.hi=(n.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return n;if(r=0,this.len-this.pos>4){for(;r<5;++r)if(n.hi=(n.hi|(127&this.buf[this.pos])<<7*r+3)>>>0,this.buf[this.pos++]<128)return n}else for(;r<5;++r){if(this.pos>=this.len)throw u(this);if(n.hi=(n.hi|(127&this.buf[this.pos])<<7*r+3)>>>0,this.buf[this.pos++]<128)return n}throw Error("invalid varint encoding")}function m(n,r){return(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0}function g(){if(this.pos+8>this.len)throw u(this,8);return new o(m(this.buf,this.pos+=4),m(this.buf,this.pos+=4))}c.create=p(),c.prototype._slice=s.Array.prototype.subarray||s.Array.prototype.slice,c.prototype.uint32=(h=4294967295,function(){if(h=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(h=(h|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(h=(h|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(h=(h|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(h=(h|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return h;if((this.pos+=5)>this.len)throw this.pos=this.len,u(this,10);return h}),c.prototype.int32=function(){return 0|this.uint32()},c.prototype.sint32=function(){var n=this.uint32();return n>>>1^-(1&n)|0},c.prototype.bool=function(){return 0!==this.uint32()},c.prototype.fixed32=function(){if(this.pos+4>this.len)throw u(this,4);return m(this.buf,this.pos+=4)},c.prototype.sfixed32=function(){if(this.pos+4>this.len)throw u(this,4);return 0|m(this.buf,this.pos+=4)},c.prototype.float=function(){if(this.pos+4>this.len)throw u(this,4);var n=s.float.readFloatLE(this.buf,this.pos);return this.pos+=4,n},c.prototype.double=function(){if(this.pos+8>this.len)throw u(this,4);var n=s.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,n},c.prototype.bytes=function(){var n=this.uint32(),r=this.pos,i=this.pos+n;if(i>this.len)throw u(this,n);return this.pos+=n,Array.isArray(this.buf)?this.buf.slice(r,i):r===i?new this.buf.constructor(0):this._slice.call(this.buf,r,i)},c.prototype.string=function(){var n=this.bytes();return l.read(n,0,n.length)},c.prototype.skip=function(n){if("number"==typeof n){if(this.pos+n>this.len)throw u(this,n);this.pos+=n}else do if(this.pos>=this.len)throw u(this);while(128&this.buf[this.pos++])return this},c.prototype.skipType=function(n){switch(n){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(n=7&this.uint32());)this.skipType(n);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+n+" at offset "+this.pos)}return this},c._configure=function(n){a=n,c.create=p(),a._configure();var r=s.Long?"toLong":"toNumber";s.merge(c.prototype,{int64:function(){return f.call(this)[r](!1)},uint64:function(){return f.call(this)[r](!0)},sint64:function(){return f.call(this).zzDecode()[r](!1)},fixed64:function(){return g.call(this)[r](!0)},sfixed64:function(){return g.call(this)[r](!1)}})}},593:(n,r,i)=>{n.exports=o;var a=i(1408);(o.prototype=Object.create(a.prototype)).constructor=o;var s=i(9693);function o(n){a.call(this,n)}o._configure=function(){s.Buffer&&(o.prototype._slice=s.Buffer.prototype.slice)},o.prototype.string=function(){var n=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+n,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+n,this.len))},o._configure()},5054:n=>{n.exports={}},5994:(n,r,i)=>{r.Service=i(7948)},7948:(n,r,i)=>{n.exports=s;var a=i(9693);function s(n,r,i){if("function"!=typeof n)throw TypeError("rpcImpl must be a function");a.EventEmitter.call(this),this.rpcImpl=n,this.requestDelimited=!!r,this.responseDelimited=!!i}(s.prototype=Object.create(a.EventEmitter.prototype)).constructor=s,s.prototype.rpcCall=function n(r,i,s,o,l){if(!o)throw TypeError("request must be specified");var u=this;if(!l)return a.asPromise(n,u,r,i,s,o);if(u.rpcImpl)try{return u.rpcImpl(r,i[u.requestDelimited?"encodeDelimited":"encode"](o).finish(),function(n,i){if(n)return u.emit("error",n,r),l(n);if(null!==i){if(!(i instanceof s))try{i=s[u.responseDelimited?"decodeDelimited":"decode"](i)}catch(n){return u.emit("error",n,r),l(n)}return u.emit("data",i,r),l(null,i)}u.end(!0)})}catch(n){return u.emit("error",n,r),void setTimeout(function(){l(n)},0)}else setTimeout(function(){l(Error("already ended"))},0)},s.prototype.end=function(n){return this.rpcImpl&&(n||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(n,r,i)=>{n.exports=s;var a=i(9693);function s(n,r){this.lo=n>>>0,this.hi=r>>>0}var o=s.zero=new s(0,0);o.toNumber=function(){return 0},o.zzEncode=o.zzDecode=function(){return this},o.length=function(){return 1};var l=s.zeroHash="\x00\x00\x00\x00\x00\x00\x00\x00";s.fromNumber=function(n){if(0===n)return o;var r=n<0;r&&(n=-n);var i=n>>>0,a=(n-i)/4294967296>>>0;return r&&(a=~a>>>0,i=~i>>>0,++i>4294967295&&(i=0,++a>4294967295&&(a=0))),new s(i,a)},s.from=function(n){if("number"==typeof n)return s.fromNumber(n);if(a.isString(n)){if(!a.Long)return s.fromNumber(parseInt(n,10));n=a.Long.fromString(n)}return n.low||n.high?new s(n.low>>>0,n.high>>>0):o},s.prototype.toNumber=function(n){if(!n&&this.hi>>>31){var r=1+~this.lo>>>0,i=~this.hi>>>0;return r||(i=i+1>>>0),-(r+4294967296*i)}return this.lo+4294967296*this.hi},s.prototype.toLong=function(n){return a.Long?new a.Long(0|this.lo,0|this.hi,!!n):{low:0|this.lo,high:0|this.hi,unsigned:!!n}};var u=String.prototype.charCodeAt;s.fromHash=function(n){return n===l?o:new s((u.call(n,0)|u.call(n,1)<<8|u.call(n,2)<<16|u.call(n,3)<<24)>>>0,(u.call(n,4)|u.call(n,5)<<8|u.call(n,6)<<16|u.call(n,7)<<24)>>>0)},s.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},s.prototype.zzEncode=function(){var n=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^n)>>>0,this.lo=(this.lo<<1^n)>>>0,this},s.prototype.zzDecode=function(){var n=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^n)>>>0,this.hi=(this.hi>>>1^n)>>>0,this},s.prototype.length=function(){var n=this.lo,r=(this.lo>>>28|this.hi<<4)>>>0,i=this.hi>>>24;return 0===i?0===r?n<16384?n<128?1:2:n<2097152?3:4:r<16384?r<128?5:6:r<2097152?7:8:i<128?9:10}},9693:function(n,r,i){var a=r;function s(n,r,i){for(var a=Object.keys(r),s=0;s<a.length;++s)void 0!==n[a[s]]&&i||(n[a[s]]=r[a[s]]);return n}function o(n){function r(n,i){if(!(this instanceof r))return new r(n,i);Object.defineProperty(this,"message",{get:function(){return n}}),Error.captureStackTrace?Error.captureStackTrace(this,r):Object.defineProperty(this,"stack",{value:Error().stack||""}),i&&s(this,i)}return(r.prototype=Object.create(Error.prototype)).constructor=r,Object.defineProperty(r.prototype,"name",{get:function(){return n}}),r.prototype.toString=function(){return this.name+": "+this.message},r}a.asPromise=i(4537),a.base64=i(7419),a.EventEmitter=i(9211),a.float=i(945),a.inquire=i(7199),a.utf8=i(4997),a.pool=i(6662),a.LongBits=i(1945),a.isNode=!!(void 0!==i.g&&i.g&&i.g.process&&i.g.process.versions&&i.g.process.versions.node),a.global=a.isNode&&i.g||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,a.emptyArray=Object.freeze?Object.freeze([]):[],a.emptyObject=Object.freeze?Object.freeze({}):{},a.isInteger=Number.isInteger||function(n){return"number"==typeof n&&isFinite(n)&&Math.floor(n)===n},a.isString=function(n){return"string"==typeof n||n instanceof String},a.isObject=function(n){return n&&"object"==typeof n},a.isset=a.isSet=function(n,r){var i=n[r];return!(null==i||!n.hasOwnProperty(r))&&("object"!=typeof i||(Array.isArray(i)?i.length:Object.keys(i).length)>0)},a.Buffer=function(){try{var n=a.inquire("buffer").Buffer;return n.prototype.utf8Write?n:null}catch(n){return null}}(),a._Buffer_from=null,a._Buffer_allocUnsafe=null,a.newBuffer=function(n){return"number"==typeof n?a.Buffer?a._Buffer_allocUnsafe(n):new a.Array(n):a.Buffer?a._Buffer_from(n):"undefined"==typeof Uint8Array?n:new Uint8Array(n)},a.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,a.Long=a.global.dcodeIO&&a.global.dcodeIO.Long||a.global.Long||a.inquire("long"),a.key2Re=/^true|false|0|1$/,a.key32Re=/^-?(?:0|[1-9][0-9]*)$/,a.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,a.longToHash=function(n){return n?a.LongBits.from(n).toHash():a.LongBits.zeroHash},a.longFromHash=function(n,r){var i=a.LongBits.fromHash(n);return a.Long?a.Long.fromBits(i.lo,i.hi,r):i.toNumber(!!r)},a.merge=s,a.lcFirst=function(n){return n.charAt(0).toLowerCase()+n.substring(1)},a.newError=o,a.ProtocolError=o("ProtocolError"),a.oneOfGetter=function(n){for(var r={},i=0;i<n.length;++i)r[n[i]]=1;return function(){for(var n=Object.keys(this),i=n.length-1;i>-1;--i)if(1===r[n[i]]&&void 0!==this[n[i]]&&null!==this[n[i]])return n[i]}},a.oneOfSetter=function(n){return function(r){for(var i=0;i<n.length;++i)n[i]!==r&&delete this[n[i]]}},a.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},a._configure=function(){var n=a.Buffer;n?(a._Buffer_from=n.from!==Uint8Array.from&&n.from||function(r,i){return new n(r,i)},a._Buffer_allocUnsafe=n.allocUnsafe||function(r){return new n(r)}):a._Buffer_from=a._Buffer_allocUnsafe=null}},1173:(n,r,i)=>{n.exports=p;var a,s=i(9693),o=s.LongBits,l=s.base64,u=s.utf8;function c(n,r,i){this.fn=n,this.len=r,this.next=void 0,this.val=i}function h(){}function d(n){this.head=n.head,this.tail=n.tail,this.len=n.len,this.next=n.states}function p(){this.len=0,this.head=new c(h,0,0),this.tail=this.head,this.states=null}var f=function(){return s.Buffer?function(){return(p.create=function(){return new a})()}:function(){return new p}};function m(n,r,i){r[i]=255&n}function g(n,r){this.len=n,this.next=void 0,this.val=r}function _(n,r,i){for(;n.hi;)r[i++]=127&n.lo|128,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;n.lo>127;)r[i++]=127&n.lo|128,n.lo=n.lo>>>7;r[i++]=n.lo}function y(n,r,i){r[i]=255&n,r[i+1]=n>>>8&255,r[i+2]=n>>>16&255,r[i+3]=n>>>24}p.create=f(),p.alloc=function(n){return new s.Array(n)},s.Array!==Array&&(p.alloc=s.pool(p.alloc,s.Array.prototype.subarray)),p.prototype._push=function(n,r,i){return this.tail=this.tail.next=new c(n,r,i),this.len+=r,this},g.prototype=Object.create(c.prototype),g.prototype.fn=function(n,r,i){for(;n>127;)r[i++]=127&n|128,n>>>=7;r[i]=n},p.prototype.uint32=function(n){return this.len+=(this.tail=this.tail.next=new g((n>>>=0)<128?1:n<16384?2:n<2097152?3:n<268435456?4:5,n)).len,this},p.prototype.int32=function(n){return n<0?this._push(_,10,o.fromNumber(n)):this.uint32(n)},p.prototype.sint32=function(n){return this.uint32((n<<1^n>>31)>>>0)},p.prototype.uint64=function(n){var r=o.from(n);return this._push(_,r.length(),r)},p.prototype.int64=p.prototype.uint64,p.prototype.sint64=function(n){var r=o.from(n).zzEncode();return this._push(_,r.length(),r)},p.prototype.bool=function(n){return this._push(m,1,n?1:0)},p.prototype.fixed32=function(n){return this._push(y,4,n>>>0)},p.prototype.sfixed32=p.prototype.fixed32,p.prototype.fixed64=function(n){var r=o.from(n);return this._push(y,4,r.lo)._push(y,4,r.hi)},p.prototype.sfixed64=p.prototype.fixed64,p.prototype.float=function(n){return this._push(s.float.writeFloatLE,4,n)},p.prototype.double=function(n){return this._push(s.float.writeDoubleLE,8,n)};var b=s.Array.prototype.set?function(n,r,i){r.set(n,i)}:function(n,r,i){for(var a=0;a<n.length;++a)r[i+a]=n[a]};p.prototype.bytes=function(n){var r=n.length>>>0;if(!r)return this._push(m,1,0);if(s.isString(n)){var i=p.alloc(r=l.length(n));l.decode(n,i,0),n=i}return this.uint32(r)._push(b,r,n)},p.prototype.string=function(n){var r=u.length(n);return r?this.uint32(r)._push(u.write,r,n):this._push(m,1,0)},p.prototype.fork=function(){return this.states=new d(this),this.head=this.tail=new c(h,0,0),this.len=0,this},p.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new c(h,0,0),this.len=0),this},p.prototype.ldelim=function(){var n=this.head,r=this.tail,i=this.len;return this.reset().uint32(i),i&&(this.tail.next=n.next,this.tail=r,this.len+=i),this},p.prototype.finish=function(){for(var n=this.head.next,r=this.constructor.alloc(this.len),i=0;n;)n.fn(n.val,r,i),i+=n.len,n=n.next;return r},p._configure=function(n){a=n,p.create=f(),a._configure()}},3155:(n,r,i)=>{n.exports=o;var a=i(1173);(o.prototype=Object.create(a.prototype)).constructor=o;var s=i(9693);function o(){a.call(this)}function l(n,r,i){n.length<40?s.utf8.write(n,r,i):r.utf8Write?r.utf8Write(n,i):r.write(n,i)}o._configure=function(){o.alloc=s._Buffer_allocUnsafe,o.writeBytesBuffer=s.Buffer&&s.Buffer.prototype instanceof Uint8Array&&"set"===s.Buffer.prototype.set.name?function(n,r,i){r.set(n,i)}:function(n,r,i){if(n.copy)n.copy(r,i,0,n.length);else for(var a=0;a<n.length;)r[i++]=n[a++]}},o.prototype.bytes=function(n){s.isString(n)&&(n=s._Buffer_from(n,"base64"));var r=n.length>>>0;return this.uint32(r),r&&this._push(o.writeBytesBuffer,r,n),this},o.prototype.string=function(n){var r=s.Buffer.byteLength(n);return this.uint32(r),r&&this._push(l,r,n),this},o._configure()},7714:(n,r,i)=>{r.R=void 0;let a=i(6919),s=i(7448);r.R=new class{async init(){}async createSessionHandler(n,r){let i=new a.Session(r);return await i.loadModel(n),new s.OnnxjsSessionHandler(i)}}},4200:(n,r,i)=>{r.c8=r.rX=void 0;let a=i(1670),s=i(5381),o=i(2157),l=i(2306);r.rX=()=>{if(("number"!=typeof a.env.wasm.initTimeout||a.env.wasm.initTimeout<0)&&(a.env.wasm.initTimeout=0),"boolean"!=typeof a.env.wasm.simd&&(a.env.wasm.simd=!0),"boolean"!=typeof a.env.wasm.proxy&&(a.env.wasm.proxy=!1),"number"!=typeof a.env.wasm.numThreads||!Number.isInteger(a.env.wasm.numThreads)||a.env.wasm.numThreads<=0){let n="undefined"==typeof navigator?(0,s.cpus)().length:navigator.hardwareConcurrency;a.env.wasm.numThreads=Math.min(4,Math.ceil((n||1)/2))}},r.c8=new class{async init(){(0,r.rX)(),await (0,o.initWasm)()}async createSessionHandler(n,r){let i=new l.OnnxruntimeWebAssemblySessionHandler;return await i.loadModel(n,r),Promise.resolve(i)}}},6018:function(n,r,i){var a=this&&this.__createBinding||(Object.create?function(n,r,i,a){void 0===a&&(a=i);var s=Object.getOwnPropertyDescriptor(r,i);s&&!("get"in s?!r.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return r[i]}}),Object.defineProperty(n,a,s)}:function(n,r,i,a){void 0===a&&(a=i),n[a]=r[i]}),s=this&&this.__exportStar||function(n,r){for(var i in n)"default"===i||Object.prototype.hasOwnProperty.call(r,i)||a(r,n,i)};Object.defineProperty(r,"__esModule",{value:!0}),s(i(1670),r);let o=i(1670);{let n=i(7714).R;(0,o.registerBackend)("webgl",n,-10)}{let n=i(4200).c8;(0,o.registerBackend)("cpu",n,10),(0,o.registerBackend)("wasm",n,10),(0,o.registerBackend)("xnnpack",n,9)}},246:(n,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createAttributeWithCacheKey=void 0;class i{constructor(n){Object.assign(this,n)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(n=>`${this[n]}`).join(";")),this._cacheKey}}r.createAttributeWithCacheKey=n=>new i(n)},7778:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Attribute=void 0;let a=i(1446),s=i(9395),o=i(9162),l=i(2517);var u=s.onnxruntime.experimental.fbs;class c{constructor(n){if(this._attributes=new Map,null!=n){for(let r of n)r instanceof a.onnx.AttributeProto?this._attributes.set(r.name,[c.getValue(r),c.getType(r)]):r instanceof u.Attribute&&this._attributes.set(r.name(),[c.getValue(r),c.getType(r)]);if(this._attributes.size<n.length)throw Error("duplicated attribute names")}}set(n,r,i){this._attributes.set(n,[i,r])}delete(n){this._attributes.delete(n)}getFloat(n,r){return this.get(n,"float",r)}getInt(n,r){return this.get(n,"int",r)}getString(n,r){return this.get(n,"string",r)}getTensor(n,r){return this.get(n,"tensor",r)}getFloats(n,r){return this.get(n,"floats",r)}getInts(n,r){return this.get(n,"ints",r)}getStrings(n,r){return this.get(n,"strings",r)}getTensors(n,r){return this.get(n,"tensors",r)}get(n,r,i){let a=this._attributes.get(n);if(void 0===a){if(void 0!==i)return i;throw Error(`required attribute not found: ${n}`)}if(a[1]!==r)throw Error(`type mismatch: expected ${r} but got ${a[1]}`);return a[0]}static getType(n){let r=n instanceof a.onnx.AttributeProto?n.type:n.type();switch(r){case a.onnx.AttributeProto.AttributeType.FLOAT:return"float";case a.onnx.AttributeProto.AttributeType.INT:return"int";case a.onnx.AttributeProto.AttributeType.STRING:return"string";case a.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case a.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case a.onnx.AttributeProto.AttributeType.INTS:return"ints";case a.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case a.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw Error(`attribute type is not supported yet: ${a.onnx.AttributeProto.AttributeType[r]}`)}}static getValue(n){let r=n instanceof a.onnx.AttributeProto?n.type:n.type();if(r===a.onnx.AttributeProto.AttributeType.GRAPH||r===a.onnx.AttributeProto.AttributeType.GRAPHS)throw Error("graph attribute is not supported yet");let i=this.getValueNoCheck(n);if(r===a.onnx.AttributeProto.AttributeType.INT&&l.LongUtil.isLong(i))return l.LongUtil.longToNumber(i);if(r===a.onnx.AttributeProto.AttributeType.INTS){let n=i,r=Array(n.length);for(let i=0;i<n.length;i++){let a=n[i];r[i]=l.LongUtil.longToNumber(a)}return r}if(r===a.onnx.AttributeProto.AttributeType.TENSOR)return n instanceof a.onnx.AttributeProto?o.Tensor.fromProto(i):o.Tensor.fromOrtTensor(i);if(r===a.onnx.AttributeProto.AttributeType.TENSORS){if(n instanceof a.onnx.AttributeProto)return i.map(n=>o.Tensor.fromProto(n));if(n instanceof u.Attribute)return i.map(n=>o.Tensor.fromOrtTensor(n))}if(r===a.onnx.AttributeProto.AttributeType.STRING&&n instanceof a.onnx.AttributeProto){let n=i;return(0,l.decodeUtf8String)(n)}return r===a.onnx.AttributeProto.AttributeType.STRINGS&&n instanceof a.onnx.AttributeProto?i.map(l.decodeUtf8String):i}static getValueNoCheck(n){return n instanceof a.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(n):this.getValueNoCheckFromOrtFormat(n)}static getValueNoCheckFromOnnxFormat(n){switch(n.type){case a.onnx.AttributeProto.AttributeType.FLOAT:return n.f;case a.onnx.AttributeProto.AttributeType.INT:return n.i;case a.onnx.AttributeProto.AttributeType.STRING:return n.s;case a.onnx.AttributeProto.AttributeType.TENSOR:return n.t;case a.onnx.AttributeProto.AttributeType.GRAPH:return n.g;case a.onnx.AttributeProto.AttributeType.FLOATS:return n.floats;case a.onnx.AttributeProto.AttributeType.INTS:return n.ints;case a.onnx.AttributeProto.AttributeType.STRINGS:return n.strings;case a.onnx.AttributeProto.AttributeType.TENSORS:return n.tensors;case a.onnx.AttributeProto.AttributeType.GRAPHS:return n.graphs;default:throw Error(`unsupported attribute type: ${a.onnx.AttributeProto.AttributeType[n.type]}`)}}static getValueNoCheckFromOrtFormat(n){switch(n.type()){case u.AttributeType.FLOAT:return n.f();case u.AttributeType.INT:return n.i();case u.AttributeType.STRING:return n.s();case u.AttributeType.TENSOR:return n.t();case u.AttributeType.GRAPH:return n.g();case u.AttributeType.FLOATS:return n.floatsArray();case u.AttributeType.INTS:{let r=[];for(let i=0;i<n.intsLength();i++)r.push(n.ints(i));return r}case u.AttributeType.STRINGS:{let r=[];for(let i=0;i<n.stringsLength();i++)r.push(n.strings(i));return r}case u.AttributeType.TENSORS:{let r=[];for(let i=0;i<n.tensorsLength();i++)r.push(n.tensors(i));return r}default:throw Error(`unsupported attribute type: ${u.AttributeType[n.type()]}`)}}}r.Attribute=c},7091:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.resolveBackend=r.backend=void 0;let a=i(5038),s=new Map;async function o(n){let i=r.backend;if(void 0!==i[n]&&function(n){let r=n;return"initialize"in r&&"function"==typeof r.initialize&&"createSessionHandler"in r&&"function"==typeof r.createSessionHandler&&"dispose"in r&&"function"==typeof r.dispose}(i[n])){let r=i[n],a=r.initialize();if("object"==typeof a&&"then"in a&&(a=await a),a)return s.set(n,r),r}}r.backend={webgl:new a.WebGLBackend},r.resolveBackend=async function n(r){if(!r)return n(["webgl"]);{let n="string"==typeof r?[r]:r;for(let r of n){let n=s.get(r);if(n)return n;let i=await o(r);if(i)return i}}throw Error("no available backend to use")}},5038:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.WebGLBackend=void 0;let a=i(1670),s=i(6231),o=i(6416),l=i(7305);r.WebGLBackend=class{get contextId(){return a.env.webgl.contextId}set contextId(n){a.env.webgl.contextId=n}get matmulMaxBatchSize(){return a.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(n){a.env.webgl.matmulMaxBatchSize=n}get textureCacheMode(){return a.env.webgl.textureCacheMode}set textureCacheMode(n){a.env.webgl.textureCacheMode=n}get pack(){return a.env.webgl.pack}set pack(n){a.env.webgl.pack=n}get async(){return a.env.webgl.async}set async(n){a.env.webgl.async=n}initialize(){try{return this.glContext=(0,l.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),s.Logger.setWithEnv(a.env),s.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(n){return s.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${n}`),!1}}createSessionHandler(n){return new o.WebGLSessionHandler(this,n)}dispose(){this.glContext.dispose()}}},5107:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.CoordsGlslLib=void 0;let a=i(2517),s=i(8520),o=i(5060),l=i(7859),u=i(9390);class c extends s.GlslLib{constructor(n){super(n)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new s.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new s.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){let n=this.context.outputTextureLayout;return n.isPacked?this.getPackedOutputSamplingSnippet(n):this.getUnpackedOutputSamplingSnippet(n)}getPackedOutputSamplingSnippet(n){let r=n.unpackedShape,i=[n.width,n.height],a={},l="getOutputCoords";switch(r.length){case 0:a[l]=this.getOutputScalarCoords();break;case 1:a[l]=this.getOutputPacked1DCoords(r,i);break;case 2:a[l]=this.getOutputPacked2DCoords(r,i);break;case 3:a[l]=this.getOutputPacked3DCoords(r,i);break;default:a[l]=this.getOutputPackedNDCoords(r,i)}let u=`
      void setOutput(vec4 val) {
        ${(0,o.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return a.floatTextureSetRGBA=new s.GlslLibRoutine(u),a}getUnpackedOutputSamplingSnippet(n){let r=n.unpackedShape,i=[n.width,n.height],a={},l="getOutputCoords";switch(r.length){case 0:a[l]=this.getOutputScalarCoords();break;case 1:a[l]=this.getOutputUnpacked1DCoords(r,i);break;case 2:a[l]=this.getOutputUnpacked2DCoords(r,i);break;case 3:a[l]=this.getOutputUnpacked3DCoords(r,i);break;case 4:a[l]=this.getOutputUnpacked4DCoords(r,i);break;case 5:a[l]=this.getOutputUnpacked5DCoords(r,i);break;case 6:a[l]=this.getOutputUnpacked6DCoords(r,i);break;default:throw Error(`Unsupported output dimensionality: ${r.length}`)}let u=`
        void setOutput(float val) {
          ${(0,o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return a.floatTextureSetR=new s.GlslLibRoutine(u),a}getOutputScalarCoords(){return new s.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(n,r){let i=r,a="";return a=1===i[0]?`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${i[1]}.0);
          }
        `:1===i[1]?`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${i[0]}.0);
          }
        `:`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${i[0]}, ${i[1]}));
          return 2 * (resTexRC.y * ${i[0]} + resTexRC.x);
        }
      `,new s.GlslLibRoutine(a)}getOutputPacked2DCoords(n,r){let i="";if(a.ArrayUtil.arraysEqual(n,r))return i=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${r[0]}, ${r[1]}));
        }
      `,new s.GlslLibRoutine(i);let o=r,l=Math.ceil(n[1]/2);return i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));

          int index = resTexRC.y * ${o[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${l}) * 2;
          int c = 2 * (index / ${l});

          return ivec2(r, c);
        }
      `,new s.GlslLibRoutine(i)}getOutputPacked3DCoords(n,r){let i=[r[0],r[1]],a=Math.ceil(n[2]/2),o=a*Math.ceil(n[1]/2),l=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;

          int b = index / ${o};
          index -= b * ${o};

          // reverse r and c order for packed texture
          int r = imod(index, ${a}) * 2;
          int c = 2 * (index / ${a});

          return ivec3(b, r, c);
        }
      `;return new s.GlslLibRoutine(l)}getOutputPackedNDCoords(n,r){let i=[r[0],r[1]],a=Math.ceil(n[n.length-1]/2),o=a*Math.ceil(n[n.length-2]/2),l=o,u="",c="b, r, c";for(let r=2;r<n.length-1;r++)l*=n[n.length-r-1],u=`
      int b${r} = index / ${l};
      index -= b${r} * ${l};
    `+u,c=`b${r}, `+c;let h=`
      ivec${n.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.y * ${i[0]} + resTexRC.x;

        ${u}

        int b = index / ${o};
        index -= b * ${o};

        // reverse r and c order for packed texture
        int r = imod(index, ${a}) * 2;
        int c = 2 * (index / ${a});

        return ivec${n.length}(${c});
      }
    `;return new s.GlslLibRoutine(h)}getOutputUnpacked1DCoords(n,r){let i=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          return resTexRC.y * ${r[0]} + resTexRC.x;
        }
      `;return new s.GlslLibRoutine(i)}getOutputUnpacked2DCoords(n,r){let i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          int r = index / ${n[1]};
          int c = index - r * ${n[1]};
          return ivec2(r, c);
        }
      `;return new s.GlslLibRoutine(i)}getOutputUnpacked3DCoords(n,r){let i="",a=n.length,o=null;a<2&&(o=[]),(o=Array(a-1))[a-2]=n[a-1];for(let r=a-3;r>=0;--r)o[r]=o[r+1]*n[r+1];let l=["r","c","d"],u=o.map((n,r)=>`int ${l[r]} = index / ${n}; ${r===o.length-1?`int ${l[r+1]} = index - ${l[r]} * ${n}`:`index -= ${l[r]} * ${n}`};`).join("");return i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${u}
          return ivec3(r, c, d);
        }
      `,new s.GlslLibRoutine(i)}getOutputUnpacked4DCoords(n,r){let i="",a=n.length,o=null;a<2&&(o=[]),(o=Array(a-1))[a-2]=n[a-1];for(let r=a-3;r>=0;--r)o[r]=o[r+1]*n[r+1];let l=["r","c","d","d2"],u=o.map((n,r)=>`int ${l[r]} = index / ${n}; ${r===o.length-1?`int ${l[r+1]} = index - ${l[r]} * ${n}`:`index -= ${l[r]} * ${n}`};`).join("");return i=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${u}
          return ivec4(r, c, d, d2);
        }
      `,new s.GlslLibRoutine(i)}getOutputUnpacked5DCoords(n,r){let i="",a=n.length,o=null;a<2&&(o=[]),(o=Array(a-1))[a-2]=n[a-1];for(let r=a-3;r>=0;--r)o[r]=o[r+1]*n[r+1];let l=["r","c","d","d2","d3"],u=o.map((n,r)=>`int ${l[r]} = index / ${n}; ${r===o.length-1?`int ${l[r+1]} = index - ${l[r]} * ${n}`:`index -= ${l[r]} * ${n}`};`).join("");return i=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${u}
          return ivec5(r, c, d, d2, d3);
        }
      `,new s.GlslLibRoutine(i)}getOutputUnpacked6DCoords(n,r){let i="",a=n.length,o=null;a<2&&(o=[]),(o=Array(a-1))[a-2]=n[a-1];for(let r=a-3;r>=0;--r)o[r]=o[r+1]*n[r+1];let l=["r","c","d","d2","d3","d4"],u=o.map((n,r)=>`int ${l[r]} = index / ${n}; ${r===o.length-1?`int ${l[r+1]} = index - ${l[r]} * ${n}`:`index -= ${l[r]} * ${n}`};`).join("");return i=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${r[0]}, ${r[1]}));
         int index = resTexRC.y * ${r[0]} + resTexRC.x;
         ${u}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new s.GlslLibRoutine(i)}getCommonUtilFuncs(){let n={},r="uvFromFlat";n[r]=new s.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),n[r="packedUVfrom1D"]=new s.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),n[r="packedUVfrom2D"]=new s.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),n[r="packedUVfrom3D"]=new s.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),r="sampleTexture";let i=(0,o.getGlsl)(this.context.glContext.version);return n[r]=new s.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${i.texture2D}(textureSampler, uv).r;
        }`),n}getInputsSamplingSnippets(){let n={},r=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((i,a)=>{let s=this.context.inputTextureLayouts[a],o=(0,u.generateShaderFuncNameFromInputSamplerName)(i);s.isPacked?n[o]=this.getPackedSamplerFromInput(o,i,s):n[o]=this.getUnpackedSamplerFromInput(o,i,s);let l=(0,u.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(i);s.unpackedShape.length<=r.unpackedShape.length&&(s.isPacked?n[l]=this.getPackedSamplerAtOutputCoords(l,s,r,i):n[l]=this.getUnpackedSamplerAtOutputCoords(l,s,r,i))}),n}getPackedSamplerAtOutputCoords(n,r,i,o){let l;let c=r.unpackedShape,h=i.unpackedShape,d=o,p=(0,u.generateShaderFuncNameFromInputSamplerName)(d),f=c.length,m=h.length,g=a.BroadcastUtil.getBroadcastDims(c,h),_=(0,u.getCoordsDataType)(m),y=m-f,b=(0,u.getGlChannels)();l=0===f?"":m<2&&g.length>=1?"coords = 0;":g.map(n=>`coords.${b[n+y]} = 0;`).join("\n");let v="";v=m<2&&f>0?"coords":c.map((n,r)=>`coords.${b[r+y]}`).join(", ");let x="return outputValue;",w=1===a.ShapeUtil.size(c),T=1===a.ShapeUtil.size(h);if(1!==f||w||T){if(w&&!T)x=1===m?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(g.length){let n=f-2,r=f-1;g.indexOf(n)>-1&&g.indexOf(r)>-1?x="return vec4(outputValue.x);":g.indexOf(n)>-1?x="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":g.indexOf(r)>-1&&(x="return vec4(outputValue.xx, outputValue.zz);")}}else x="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";let S=`
      vec4 ${n}() {
        ${_} coords = getOutputCoords();
        
        int lastDim = coords.${b[m-1]};
        coords.${b[m-1]} = coords.${b[m-2]};
        coords.${b[m-2]} = lastDim;
      
        ${l}
        vec4 outputValue = ${p}(${v});
        ${x}
      }
    `;return new s.GlslLibRoutine(S,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(n,r,i,o){let l;let c=[i.width,i.height],h=[r.width,r.height],d=r.unpackedShape.length,p=i.unpackedShape.length,f=r.unpackedShape,m=i.unpackedShape,g=(0,u.generateShaderFuncNameFromInputSamplerName)(o);if(d===p&&a.ArrayUtil.arraysEqual(h,c)){let r=`
          float ${n}() {
            return sampleTexture(${o}, TexCoords);
          }
        `;return new s.GlslLibRoutine(r,["coordinates.sampleTexture"])}let _=(0,u.getCoordsDataType)(p),y=a.BroadcastUtil.getBroadcastDims(f,m),b=p-d,v=(0,u.getGlChannels)();l=0===d?"":p<2&&y.length>=1?"coords = 0;":y.map(n=>`coords.${v[n+b]} = 0;`).join("\n");let x="";x=p<2&&d>0?"coords":r.unpackedShape.map((n,r)=>`coords.${v[r+b]}`).join(", ");let w=`
        float ${n}() {
          ${_} coords = getOutputCoords();
          ${l}
          return ${g}(${x});
        }
      `;return new s.GlslLibRoutine(w,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(n,r,i){switch(i.unpackedShape.length){case 0:return this.getPackedSamplerScalar(n,r);case 1:return this.getPackedSampler1D(n,r,i);case 2:return this.getPackedSampler2D(n,r,i);case 3:return this.getPackedSampler3D(n,r,i);default:return this.getPackedSamplerND(n,r,i)}}getUnpackedSamplerFromInput(n,r,i){let a=i.unpackedShape;switch(a.length){case 0:return this.getUnpackedSamplerScalar(n,r,i);case 1:return this.getUnpackedSampler1D(n,r,i);case 2:return this.getUnpackedSampler2D(n,r,i);case 3:return this.getUnpackedSampler3D(n,r,i);case 4:return this.getUnpackedSampler4D(n,r,i);case 5:return this.getUnpackedSampler5D(n,r,i);case 6:return this.getUnpackedSampler6D(n,r,i);default:throw Error(`Unsupported dimension ${a.length}-D`)}}getPackedSamplerScalar(n,r){let i=`
          vec4 ${n}() {
            return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${r}, halfCR);
          }
        `;return new s.GlslLibRoutine(i)}getPackedSampler1D(n,r,i){let a=[i.width,i.height],l=[a[1],a[0]],u=(0,o.getGlsl)(this.context.glContext.version),c=`vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
      ${l[0]}, ${l[1]}, index);
      return ${u.texture2D}(${r}, uv);
    }`;return new s.GlslLibRoutine(c,["coordinates.packedUVfrom1D"])}getPackedSampler2D(n,r,i){let l=i.unpackedShape,u=[i.width,i.height],c=(0,o.getGlsl)(this.context.glContext.version),h=u[0],d=u[1];if(null!=u&&a.ArrayUtil.arraysEqual(l,u)){let i=`vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${h}.0);
        return ${c.texture2D}(${r}, uv);
      }`;return new s.GlslLibRoutine(i)}let p=u,f=Math.ceil(l[1]/2),m=`vec4 ${n}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${f}, row, col);
      return ${c.texture2D}(${r}, uv);
    }`;return new s.GlslLibRoutine(m,["coordinates.packedUVfrom2D"])}getPackedSampler3D(n,r,i){let a=i.unpackedShape,l=[i.width,i.height],c=[l[0],l[1]],h=(0,o.getGlsl)(this.context.glContext.version);if(1===a[0]){let o=a.slice(1),l=[1,2],c=(0,u.squeezeInputShape)(a,o),h=["b","row","col"],d=JSON.parse(JSON.stringify(i));d.unpackedShape=c;let p=this.getPackedSamplerFromInput(n,r,d),f=`${p.routineBody}
      vec4 ${n}(int b, int row, int col) {
        return ${n}(${(0,u.getSqueezedParams)(h,l)});
      } `;return new s.GlslLibRoutine(f,p.dependencies)}let d=c[0],p=c[1],f=Math.ceil(a[2]/2),m=`vec4 ${n}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${d}, ${f*Math.ceil(a[1]/2)}, ${f}, b, row, col);
      return ${h.texture2D}(${r}, uv);}`;return new s.GlslLibRoutine(m,["coordinates.packedUVfrom3D"])}getPackedSamplerND(n,r,i){let a=i.unpackedShape,l=a.length,u=[i.width,i.height],c=(0,o.getGlsl)(this.context.glContext.version),h=[u[0],u[1]],d=h[1],p=h[0],f=Math.ceil(a[l-1]/2),m=f*Math.ceil(a[l-2]/2),g="int b, int row, int col",_=`b * ${m} + (row / 2) * ${f} + (col / 2)`;for(let n=2;n<l-1;n++)g=`int b${n}, `+g,m*=a[l-n-1],_=`b${n} * ${m} + `+_;let y=`vec4 ${n}(${g}) {
      int index = ${_};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${d});
      return ${c.texture2D}(${r}, uv);
    }`;return new s.GlslLibRoutine(y)}getUnpackedSamplerScalar(n,r,i){let[a,o]=[i.width,i.height];if(1===a&&1===o){let i=`
          float ${n}() {
            return sampleTexture(${r}, halfCR);
          }
        `;return new s.GlslLibRoutine(i,["coordinates.sampleTexture"])}let l=`
        float ${n}() {
          int offset_${r} = coordsToOffset(TexCoords, ${a}, ${o});
          vec2 uv = uvFromFlat(${a}, ${o}, offset_${r});
          return sampleTexture(${r}, uv);
        }
      `;return new s.GlslLibRoutine(l,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(n,r,i){let a=i.width,o=i.height;if(1===o&&1===a){let i=`
        float ${n}(int index) {
          return sampleTexture(${r}, halfCR);
        }
      `;return new s.GlslLibRoutine(i,["coordinates.sampleTexture"])}if(1===o){let i=`
          float ${n}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${a}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new s.GlslLibRoutine(i,["coordinates.sampleTexture"])}if(1===a){let i=`
          float ${n}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new s.GlslLibRoutine(i,["coordinates.sampleTexture"])}let l=`
        float ${n}(int index) {
          vec2 uv = uvFromFlat(${a}, ${o}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new s.GlslLibRoutine(l,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(n,r,i){let o=i.unpackedShape,c=[i.height,i.width];if(null!=c&&a.ArrayUtil.arraysEqual(o,c)){let i=`
          float ${n}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${c[1]}.0, ${c[0]}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new s.GlslLibRoutine(i,["coordinates.sampleTexture"])}let{newShape:h,keptDims:d}=(0,l.squeezeShape)(o),p=h;if(p.length<o.length){let a=(0,u.squeezeInputShape)(o,p),l=JSON.parse(JSON.stringify(i));l.unpackedShape=a;let c=["col","row"],h=`
          ${this.getUnpackedSamplerFromInput(n,r,l).routineBody}
          float ${n}(int row, int col) {
            return ${n}(${(0,u.getSqueezedParams)(c,d)});
          }
        `;return new s.GlslLibRoutine(h,["coordinates.sampleTexture"])}let f=c[1],m=c[0];if(1===m){let i=`
          float ${n}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${f}, ${m});
            float index = dot(vec3(row, col, offset_${r}), vec3(${o[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new s.GlslLibRoutine(i,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===f){let i=`
          float ${n}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${f}, ${m});
            float index = dot(vec3(row, col, offset_${r}), vec3(${o[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${m}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new s.GlslLibRoutine(i,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let g=`
        float ${n}(int row, int col) {
          int index = col * ${o[1]} + row;
          vec2 uv = uvFromFlat(${f}, ${m}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new s.GlslLibRoutine(g,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(n,r,i){let a=i.unpackedShape,o=a[1]*a[2],c=a[2],{newShape:h,keptDims:d}=(0,l.squeezeShape)(a),p=h;if(p.length<a.length){let o=(0,u.squeezeInputShape)(a,p),l=["batch","col","row"],c=JSON.parse(JSON.stringify(i));c.unpackedShape=o;let h=this.getUnpackedSamplerFromInput(n,r,c),f=d.reverse(),m=`
          ${h.routineBody}
          float ${n}(int batch, int row, int col) {
            return ${n}(${(0,u.getSqueezedParams)(l,f)});
          }
        `;return new s.GlslLibRoutine(m,h.dependencies)}let f=`
          float ${n}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${o} + col * ${c} + row;
            vec2 uv = uvFromFlat(${i.width}, ${i.height}, index);
            return sampleTexture(${r}, uv);
          }
      `;return new s.GlslLibRoutine(f,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(n,r,i){let a=i.unpackedShape,o=a[3],l=a[2]*o,u=`
        float ${n}(int row, int col, int depth, int depth2) {
          int index = row * ${a[1]*l} + col * ${l} +
              depth2 * ${o} + depth;
          vec2 uv = uvFromFlat(${i.width}, ${i.height}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new s.GlslLibRoutine(u,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(n,r,i){let a=i.unpackedShape,o=a[4],c=a[3]*o,h=a[2]*c,d=a[1]*h,{newShape:p,keptDims:f}=(0,l.squeezeShape)(a);if(p.length<a.length){let o=(0,u.squeezeInputShape)(a,p),l=["row","col","depth","depth2","depth3"],c=JSON.parse(JSON.stringify(i));c.unpackedShape=o;let h=`
          ${this.getUnpackedSamplerFromInput(n,r,c).routineBody}
          float ${n}(int row, int col, int depth, int depth2, int depth3) {
            return ${n}(${(0,u.getSqueezedParams)(l,f)});
          }
        `;return new s.GlslLibRoutine(h,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let m=`
        float ${n}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${d} + col * ${h} + depth * ${c} +
          depth3 * ${o} + depth2;
          vec2 uv = uvFromFlat(${i.width}, ${i.height}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new s.GlslLibRoutine(m,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(n,r,i){let a=i.unpackedShape,o=a[5],c=a[4]*o,h=a[3]*c,d=a[2]*h,p=a[1]*d,{newShape:f,keptDims:m}=(0,l.squeezeShape)(a);if(f.length<a.length){let o=(0,u.squeezeInputShape)(a,f),l=["row","col","depth","depth2","depth3","depth4"],c=JSON.parse(JSON.stringify(i));c.unpackedShape=o;let h=`
            ${this.getUnpackedSamplerFromInput(n,r,c).routineBody}
            float ${n}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${n}(${(0,u.getSqueezedParams)(l,m)});
            }
          `;return new s.GlslLibRoutine(h,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let g=`
          float ${n}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p} + col * ${d} + depth * ${h} +
            depth2 * ${c} + depth3 * ${o} + depth4;
            vec2 uv = uvFromFlat(${i.width}, ${i.height}, index);
            return sampleTexture(${r}, uv);
          }
        `;return new s.GlslLibRoutine(g,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let n=this.context.outputTextureLayout,r=n.shape.length,i=n.strides,a=n.width,o=n.height,l=[];for(let n=0;n<r-1;++n)l.push(`
        c[${n}] = offset / ${i[n]};`),l.push(`
        offset -= c[${n}] * ${i[n]};`);l.push(`
        c[${r-1}] = offset;`);let u=`
      void toVec(vec2 texCoords, out int c[${r}]) {
        int offset = coordsToOffset(texCoords, ${a}, ${o});
        ${l.join("")}
      }
      void toVec(int offset, out int c[${r}]) {
        ${l.join("")}
      }
    `;return{toVec:new s.GlslLibRoutine(u,["coordinates.coordsToOffset"])}}valueFrom(){let n={};return this.context.programInfo.inputNames.forEach((r,i)=>{let a=this.context.inputTextureLayouts[i],o=(a.unpackedShape.length>0?a.unpackedShape:a.shape).length,l=`_${r}`;n[l]=new s.GlslLibRoutine(this.getValueFromSingle(r,o,a.width,a.height,!1),[`shapeUtils.indicesToOffset${l}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),n[l+="_T"]=new s.GlslLibRoutine(this.getValueFromSingle(r,o,a.width,a.height,!0),[`shapeUtils.indicesToOffset${l}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),n}getValueFromSingle(n,r,i,a,s){let l=`_${n}`;return s&&(l+="_T"),`
        float ${l}(int m[${r}]) {
          int offset = indicesToOffset${l}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${a});
          float value = getColorAsFloat(${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${n}, coords));
          return value;
        }
        `}getPackedValueFrom(n,r,i,a,s){let l=`_${n}_Pack`;return s&&(l+="_T"),`
        vec4 ${l}(int m[${r}]) {
          int offset = indicesToOffset_${n}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${a});
          return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${n}, coords);
        }
        `}}r.CoordsGlslLib=c},8520:(n,r)=>{var i;Object.defineProperty(r,"__esModule",{value:!0}),r.TopologicalSortGlslRoutines=r.GlslLibRoutineNode=r.GlslLibRoutine=r.GlslLib=r.GlslContext=r.FunctionType=void 0,(i=r.FunctionType||(r.FunctionType={}))[i.ValueBased=0]="ValueBased",i[i.Positional=1]="Positional",r.GlslContext=class{constructor(n,r,i,a){this.glContext=n,this.programInfo=r,this.inputTextureLayouts=i,this.outputTextureLayout=a}},r.GlslLib=class{constructor(n){this.context=n}},r.GlslLibRoutine=class{constructor(n,r){this.routineBody=n,this.dependencies=r}},r.GlslLibRoutineNode=class{constructor(n,r,i){this.name=n,this.dependencies=i||[],r&&(this.routineBody=r)}addDependency(n){n&&this.dependencies.push(n)}},r.TopologicalSortGlslRoutines=class{static returnOrderedNodes(n){if(!n||0===n.length)return[];if(1===n.length)return n;let r=new Set,i=new Set,a=[];return this.createOrderedNodes(n,r,i,a),a}static createOrderedNodes(n,r,i,a){for(let s=0;s<n.length;++s)this.dfsTraverse(n[s],r,i,a)}static dfsTraverse(n,r,i,a){if(!n||i.has(n.name))return;if(r.has(n.name))throw Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");r.add(n.name);let s=n.dependencies;if(s&&s.length>0)for(let n=0;n<s.length;++n)this.dfsTraverse(s[n],r,i,a);a.push(n),i.add(n.name),r.delete(n.name)}}},7341:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.EncodingGlslLib=void 0;let a=i(8520);class s extends a.GlslLib{constructor(n){super(n)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new a.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new a.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){let n=s.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new a.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${n}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let n=s.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new a.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${n}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let n=new ArrayBuffer(4),r=new Uint32Array(n),i=new Uint8Array(n);if(r[0]=3735928559,239===i[0])return!0;if(222===i[0])return!1;throw Error("unknown endianness")}}r.EncodingGlslLib=s},9894:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.FragColorGlslLib=void 0;let a=i(8520),s=i(5060);class o extends a.GlslLib{constructor(n){super(n)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){let n=(0,s.getGlsl)(this.context.glContext.version);return{setFragColor:new a.GlslLibRoutine(`
        void setFragColor(float value) {
            ${n.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new a.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}r.FragColorGlslLib=o},2848:(n,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.replaceInlines=void 0;let i=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;r.replaceInlines=function(n){let r;let a={};for(;null!==(r=i.exec(n));){let n=r[3].split(",").map(n=>{let r=n.trim().split(" ");return r&&2===r.length?{type:r[0],name:r[1]}:null}).filter(n=>null!==n);a[r[2]]={params:n,body:r[4]}}for(let i in a){let s="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",i),o=RegExp(s,"gm");for(;null!==(r=o.exec(n));){let s=r[1],o=r[2],l=r[3].split(","),u=s?`${s} ${o};`:"",c=a[i].body,h="";a[i].params.forEach((n,r)=>{n&&(h+=`${n.type} ${n.name} = ${l[r]};
`)}),c=(c=`${h}
 ${c}`).replace("return",`${o} = `);let d=`
      ${u}
      {
        ${c}
      }
      `;n=n.replace(r[0],d)}}return n.replace(i,"")}},8879:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.GlslPreprocessor=void 0;let a=i(8520),s=i(2848),o=i(5483),l=i(5060);r.GlslPreprocessor=class{constructor(n,r,i,s){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new a.GlslContext(n,r,i,s),Object.keys(o.glslRegistry).forEach(n=>{let r=new o.glslRegistry[n](this.context);this.libs[n]=r});let l=this.glslLibRoutineDependencyGraph;for(let n in this.libs){let r=this.libs[n].getFunctions();for(let i in r){let s;let o=n+"."+i;l[o]?(s=l[o]).routineBody=r[i].routineBody:(s=new a.GlslLibRoutineNode(o,r[i].routineBody),l[o]=s);let u=r[i].dependencies;if(u)for(let n=0;n<u.length;++n)if(l[u[n]])s.addDependency(l[u[n]]);else{let r=new a.GlslLibRoutineNode(u[n]);l[u[n]]=r,s.addDependency(r)}}}}preprocess(){let n=this.context.programInfo,r=n.shaderSource;return this.context.programInfo.hasMain||(r=`${r}
      ${(0,l.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),r=(0,s.replaceInlines)(r),`${(0,l.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(n.inputNames,n.variables)}
    ${this.getImports(r)}
    ${r}`}getImports(n){let r=this.selectGlslLibRoutinesToBeIncluded(n);if(0===r.length)return"";let i="";for(let n=0;n<r.length;++n){if(!r[n].routineBody)throw Error(`Missing body for the Glsl Library routine: ${r[n].name}`);i+=r[n].routineBody+"\n"}return i}selectGlslLibRoutinesToBeIncluded(n){let r=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(i=>{let a=i.split(".")[1];-1!==n.indexOf(a)&&r.push(this.glslLibRoutineDependencyGraph[i])}),a.TopologicalSortGlslRoutines.returnOrderedNodes(r)}getUniforms(n,r){let i=[];if(n)for(let r of n)i.push(`uniform sampler2D ${r};`);if(r)for(let n of r)i.push(`uniform ${n.type} ${n.name}${n.arrayLength?`[${n.arrayLength}]`:""};`);return i.join("\n")}}},5483:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.glslRegistry=void 0;let a=i(5107),s=i(7341),o=i(9894),l=i(2655),u=i(3891);r.glslRegistry={encoding:s.EncodingGlslLib,fragcolor:o.FragColorGlslLib,vec:u.VecGlslLib,shapeUtils:l.ShapeUtilsGlslLib,coordinates:a.CoordsGlslLib}},2655:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.ShapeUtilsGlslLib=void 0;let a=i(8520);class s extends a.GlslLib{constructor(n){super(n)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){let n=this.context.outputTextureLayout.shape.length,r={};return this.context.programInfo.inputNames.forEach((i,s)=>{let o=this.context.inputTextureLayouts[s].unpackedShape;if(o.length<=n){let s=o.length,l=n-s,u=`bcastIndices_${i}`,c="";for(let n=0;n<s;++n)c+=`
          realIndices[${n}] = int( mod(float(bcastedIndices[${l+n}]), ${o[n]}.0) );
          `;let h=`
        void ${u} (int bcastedIndices[${n}], out int realIndices[${s}]) {
          ${c}
        }
        `;r[u]=new a.GlslLibRoutine(h)}}),r}bcastMatmulIndex(){let n=this.context.outputTextureLayout.shape.length,r={};return this.context.programInfo.inputNames.forEach((i,s)=>{let o=this.context.inputTextureLayouts[s].shape;if(!(o.length<2||o.length>n)){let s=o.length,l=n-s,u=`bcastMatmulIndices_${i}`,c="";for(let n=0;n<s-2;++n)c+=`
          realIndices[${n}] = int( mod(float(bcastedIndices[${l+n}]), ${o[n]}.0) );
          `;let h=`
        void ${u}(int bcastedIndices[${n}], out int realIndices[${s}]) {
          ${c}
          realIndices[${s-1}] = bcastedIndices[${n-1}];
          realIndices[${s-2}] = bcastedIndices[${n-2}];
        }
        `;r[u]=new a.GlslLibRoutine(h)}}),r}indicesToOffset(){let n={};return this.context.programInfo.inputNames.forEach((r,i)=>{let o=this.context.inputTextureLayouts[i].shape,l=this.context.inputTextureLayouts[i].strides,u=o.length,c=`indicesToOffset_${r}`;n[c]=new a.GlslLibRoutine(s.indexToOffsetSingle(c,u,l)),n[c=`indicesToOffset_${r}_T`]=new a.GlslLibRoutine(s.indexToOffsetSingle(c,u,l.slice().reverse()))}),n}static indexToOffsetSingle(n,r,i){let a="";for(let n=r-1;n>=0;--n)a+=`
        offset += indices[${n}] * ${i[n]};
        `;return`
      int ${n}(int indices[${r}]) {
        int offset = 0;
        ${a}
        return offset;
      }
      `}offsetToIndices(){let n={};return this.context.programInfo.inputNames.forEach((r,i)=>{let o=this.context.inputTextureLayouts[i].shape,l=this.context.inputTextureLayouts[i].strides,u=o.length,c=`offsetToIndices_${r}`;n[c]=new a.GlslLibRoutine(s.offsetToIndicesSingle(c,u,l)),n[c=`offsetToIndices_${r}_T`]=new a.GlslLibRoutine(s.offsetToIndicesSingle(c,u,l.slice().reverse()))}),n}static offsetToIndicesSingle(n,r,i){let a=[];for(let n=0;n<r-1;++n)a.push(`
      indices[${n}] = offset / ${i[n]};`),a.push(`
        offset -= indices[${n}] * ${i[n]};`);return a.push(`
      indices[${r-1}] = offset;`),`
      void ${n}(int offset, out int indices[${r}]) {
        ${a.join("")}
      }
      `}incrementIndices(){let n={};return this.context.programInfo.inputNames.forEach((r,i)=>{let s=this.context.inputTextureLayouts[i].shape,o=s.length,l=`incrementIndices_${r}`,u="";for(let n=0;n<o;++n)u+=`
        shape[${n}] = ${s[n]};`;let c=`
        void ${l}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${u};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;n[l]=new a.GlslLibRoutine(c)}),n}}r.ShapeUtilsGlslLib=s},5060:(n,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.getDefaultFragShaderMain=r.getFragShaderPreamble=r.getVertexShaderSource=r.getGlsl=void 0;let i={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},a={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function s(n){return 1===n?i:a}r.getGlsl=s,r.getVertexShaderSource=function(n){let r=s(n);return`${r.version}
      precision highp float;
      ${r.attribute} vec3 position;
      ${r.attribute} vec2 textureCoord;

      ${r.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},r.getFragShaderPreamble=function(n){let r=s(n);return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFrag} vec2 TexCoords;
    ${r.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},r.getDefaultFragShaderMain=function(n,r){return`
  void main() {
    int indices[${r}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${s(n).output} = result;
  }
  `}},3891:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.VecGlslLib=void 0;let a=i(8520);class s extends a.GlslLib{constructor(n){super(n)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){let n=this.context.outputTextureLayout.shape.length,r={add:"+=",sub:"-=",mul:"*=",div:"/="},i={};for(let s in r){let o=`${s}Vec`,l="";for(let i=0;i<n;++i)l+=`
          dest[${i}] ${r[s]} src[${i}];
          `;let u=`
        void ${o}(int src[${n}], out int dest[${n}]) {
          ${l}
        }
        `;i[o]=new a.GlslLibRoutine(u)}return i}copyVec(){let n=this.context.outputTextureLayout.shape.length,r="";for(let i=0;i<n;++i)r+=`
        dest[${i}] = src[${i}];
        `;let i=`
      void copyVec(int src[${n}], out int dest[${n}]) {
        ${r}
      }
      `;return{copyVec:new a.GlslLibRoutine(i)}}setVecItem(){let n=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index =${n} + index;
        if (index == 0)
            m[0] = value;
        `;for(let i=1;i<n-1;++i)r+=`
        else if (index == ${i})
            m[${i}] = value;
            `;r+=`
        else
            m[${n-1}] = value;
        `;let i=`
      void setVecItem(out int m[${n}], int index, int value) {
        ${r}
      }
        `;return{setVecItem:new a.GlslLibRoutine(i)}}getVecItem(){let n=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index = ${n} + index;
        if (index == 0)
            return m[0];
      `;for(let i=1;i<n-1;++i)r+=`
        else if (index == ${i})
            return m[${i}];
      `;r+=`
        else
            return m[${n-1}];
        `;let i=`
      int getVecItem(int m[${n}], int index) {
        ${r}
      }
    `;return{getVecItem:new a.GlslLibRoutine(i)}}}r.VecGlslLib=s},8316:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.WebGLInferenceHandler=void 0;let a=i(6231),s=i(9162),o=i(2517),l=i(2403),u=i(7019),c=i(8710),h=i(5611),d=i(4057),p=i(2039);r.WebGLInferenceHandler=class{constructor(n){this.session=n,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(n,r){return(0,d.calculateTextureWidthAndHeight)(this.session.layoutStrategy,n,r)}executeProgram(n,r){if(r.length<n.inputNames.length)throw Error(`Input size mustn't be less than ${n.inputNames.length}.`);if(n.inputNames.length!==n.inputTypes.length)throw Error("input names size does not match input types");let i=[];for(let a=0;a<n.inputNames.length;++a)i[a]=this.getOrCreateTextureData(r[a],n.inputTypes[a]);let a=((n,r)=>{let i=r.map(n=>`${n.unpackedShape.join(",")};${n.width}x${n.height}`).join("_"),a=n.name;return n.cacheHint&&(a+="["+n.cacheHint+"]"),a+=":"+i})(n,i),s=this.session.programManager.getArtifact(a),o=s?s.programInfo:"function"==typeof n.get?n.get():n,l=(0,d.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o.output.dims,o.output.textureType),u=this.createTextureData(l,o.output.type);return s||(s=this.session.programManager.build(o,i,u),this.session.programManager.setArtifact(a,s)),this.runProgram(s,i,u),u}run(n,r){return this.executeProgram(n,r).tensor}runProgram(n,r,i){for(let i=0;i<r.length;++i)if(!!r[i].isPacked!=(n.programInfo.inputTypes[i]===p.TextureType.packed))throw Error(`input[${i}] property packed inconsistent`);if(!!i.isPacked!=(n.programInfo.output.textureType===p.TextureType.packed))throw Error("output property packed inconsistent");this.session.programManager.run(n,r,i)}getOrCreateTextureData(n,r){let i=this.getTextureData(n.dataId,r===p.TextureType.packed);if(!i&&(i=this.getTextureData(n.dataId,r!==p.TextureType.packed)))return r===p.TextureType.packed?this.pack(i):this.unpack(i);if(!i){let a=(0,d.createTextureLayoutFromTextureType)(this.session.layoutStrategy,n.dims,r);if(r===p.TextureType.packedLastDimension){let i=1,a=4,s=n.dims;if(4===s.length){let o=[s[0],Math.ceil(s[1]*s[2]*s[3]/a)],l=(0,d.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o,r),u=n.numberData;if(s[1]*s[2]*s[3]%a!=0){let r=s[0],o=s[1]*s[2]*s[3],l=Math.ceil(o*i/a)*a;u=new Float32Array(r*l);for(let a=0;a<r;++a){let r=a*o,s=a*l+a%i*o;u.set(n.numberData.subarray(r,r+o),s)}}return this.createTextureData(l,n.type,u,n,1)}}if(r===p.TextureType.packed){let r=(0,d.createTextureLayoutFromShape)(this.session.layoutStrategy,n.dims,1,[],{reverseWH:!0}),a=this.createTextureData(r,n.type,n.numberData,n,1);i=this.pack(a)}else i=this.createTextureData(a,n.type,n.numberData,n,1)}return i}createTextureDataFromLayoutBindTensor(n,r,i,a){return this.createTextureData(n,r,i,a,1)}createTextureData(n,r,i,s,o){a.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(n)}]`);let l=this.session.textureManager.createTextureFromLayout(r,n,i,o);return this.createTextureDataFromTexture(n,r,l,s)}reshapeUnpacked(n,r){let i=this.getOrCreateTextureData(n,p.TextureType.unpacked),a={channels:i.channels,height:i.height,width:i.width,shape:0!==r.length?r:[1],strides:o.ShapeUtil.computeStrides(r),unpackedShape:r};return this.createTextureDataFromTexture(a,n.type,i.texture).tensor}reshapePacked(n,r){let i=this.getOrCreateTextureData(n,p.TextureType.packed);if((0,u.isReshapeCheap)(n.dims,r)){let a={channels:i.channels,height:i.height,width:i.width,shape:0!==r.length?r:[1],strides:o.ShapeUtil.computeStrides(r),unpackedShape:r,isPacked:!0};return this.createTextureDataFromTexture(a,n.type,i.texture).tensor}let a=(0,u.processDims3D)(n.dims),s=(0,u.processDims3D)(r),l=this.reshapePacked(n,a),c=this.run((0,u.createPackedReshape3DProgramInfoLoader)(this,l,s),[l]);return this.reshapePacked(c,r)}cast(n,r){let i=this.getOrCreateTextureData(n,p.TextureType.unpacked);return this.createTextureDataFromTexture(i,r,i.texture).tensor}createTextureDataFromTexture(n,r,i,a,o){let l=Object.assign(Object.assign({},n),{tensor:a||new s.Tensor(n.unpackedShape,r,n=>this.readTexture(l),async n=>this.readTextureAsync(l),void 0,o),texture:i});return this.setTextureData(l.tensor.dataId,l,n.isPacked),l}getTextureData(n,r=!1){return this.session.isInitializer(n)?this.session.getTextureData(n,r):r?this.packedTextureDataCache.get(n):this.unpackedTextureDataCache.get(n)}setTextureData(n,r,i=!1){this.session.isInitializer(n)?this.session.setTextureData(n,r,i):(i?this.packedTextureDataCache:this.unpackedTextureDataCache).set(n,r)}isTextureLayoutCached(n,r=!1){return!!this.getTextureData(n.dataId,r)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(n=>this.session.textureManager.releaseTexture(n)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(n=>this.session.textureManager.releaseTexture(n)),this.unpackedTextureDataCache=new Map}readTexture(n){return n.isPacked?this.readTexture(this.unpack(n)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(n,n.tensor.type,n.channels):this.session.textureManager.readUint8TextureAsFloat((0,c.encodeAsUint8)(this,n))}async readTextureAsync(n){return n.isPacked?this.readTextureAsync(this.unpack(n)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(n,n.tensor.type,n.channels):this.session.textureManager.readUint8TextureAsFloat((0,c.encodeAsUint8)(this,n))}pack(n){return this.executeProgram((0,l.createPackProgramInfoLoader)(this,n.tensor),[n.tensor])}unpack(n){return this.executeProgram((0,h.createUnpackProgramInfoLoader)(this,n.tensor),[n.tensor])}}},1640:function(n,r,i){var a=this&&this.__createBinding||(Object.create?function(n,r,i,a){void 0===a&&(a=i);var s=Object.getOwnPropertyDescriptor(r,i);s&&!("get"in s?!r.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return r[i]}}),Object.defineProperty(n,a,s)}:function(n,r,i,a){void 0===a&&(a=i),n[a]=r[i]}),s=this&&this.__setModuleDefault||(Object.create?function(n,r){Object.defineProperty(n,"default",{enumerable:!0,value:r})}:function(n,r){n.default=r}),o=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var r={};if(null!=n)for(var i in n)"default"!==i&&Object.prototype.hasOwnProperty.call(n,i)&&a(r,n,i);return s(r,n),r};Object.defineProperty(r,"__esModule",{value:!0}),r.WEBGL_OP_RESOLVE_RULES=void 0;let l=i(2898),u=o(i(7839)),c=i(4196),h=i(2069),d=i(8138),p=i(9663),f=i(5193),m=i(7992),g=i(1253),_=i(4776),y=i(6572),b=i(3346),v=i(5623),x=i(2870),w=i(2143),T=i(4939),S=i(718),E=i(2268),A=i(8117),M=i(2278),I=i(5524),P=i(5975),O=i(3933),R=i(6558),C=i(5723),L=i(3738),D=o(i(4909)),N=i(8428),k=i(9793);r.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",D.abs],["Acos","","7+",D.acos],["Add","","7+",u.add],["And","","7+",u.and],["Asin","","7+",D.asin],["Atan","","7+",D.atan],["AveragePool","","7+",w.averagePool,w.parseAveragePoolAttributes],["BatchNormalization","","7+",l.batchNormalization,l.parseBatchNormalizationAttributes],["Cast","","6+",c.cast,c.parseCastAttributes],["Ceil","","6+",D.ceil],["Clip","","6-10",D.clip,D.parseClipAttributes],["Clip","","11+",D.clipV11],["Concat","","4+",h.concat,h.parseConcatAttributes],["Conv","","1+",d.conv,d.parseConvAttributes],["ConvTranspose","","1+",p.convTranspose,p.parseConvTransposeAttributes],["Cos","","7+",D.cos],["Div","","7+",u.div],["Dropout","","7+",D.identity],["DepthToSpace","","1+",f.depthToSpace,f.parseDepthToSpaceAttributes],["Equal","","7+",u.equal],["Elu","","6+",D.elu,D.parseEluAttributes],["Exp","","6+",D.exp],["Flatten","","1+",m.flatten,m.parseFlattenAttributes],["Floor","","6+",D.floor],["FusedConv","com.microsoft","1+",d.conv,d.parseConvAttributes],["Gather","","1+",g.gather,g.parseGatherAttributes],["Gemm","","7-10",_.gemm,_.parseGemmAttributesV7],["Gemm","","11+",_.gemm,_.parseGemmAttributesV11],["GlobalAveragePool","","1+",w.globalAveragePool,w.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",w.globalMaxPool],["Greater","","7+",u.greater],["Identity","","1+",D.identity],["ImageScaler","","1+",y.imageScaler,y.parseImageScalerAttributes],["InstanceNormalization","","6+",b.instanceNormalization,b.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",D.leakyRelu,D.parseLeakyReluAttributes],["Less","","7+",u.less],["Log","","6+",D.log],["MatMul","","1+",v.matMul,v.parseMatMulAttributes],["MaxPool","","1+",w.maxPool,w.parseMaxPoolAttributes],["Mul","","7+",u.mul],["Neg","","6+",D.neg],["Not","","1+",D.not],["Or","","7+",u.or],["Pad","","2-10",x.padV2,x.parsePadAttributesV2],["Pad","","11+",x.padV11,x.parsePadAttributesV11],["Pow","","7+",u.pow],["PRelu","","7+",u.pRelu],["ReduceLogSum","","1+",T.reduceLogSum,T.parseReduceAttributes],["ReduceMax","","1+",T.reduceMax,T.parseReduceAttributes],["ReduceMean","","1+",T.reduceMean,T.parseReduceAttributes],["ReduceMin","","1+",T.reduceMin,T.parseReduceAttributes],["ReduceProd","","1+",T.reduceProd,T.parseReduceAttributes],["ReduceSum","","1-12",T.reduceSum,T.parseReduceAttributes],["ReduceSumSquare","","1+",T.reduceLogSumSquare,T.parseReduceAttributes],["Relu","","6+",D.relu],["Reshape","","5+",S.reshape],["Resize","","10",E.resize,E.parseResizeAttributesV10],["Resize","","11+",E.resize,E.parseResizeAttributesV11],["Shape","","1+",A.shape],["Sigmoid","","6+",D.sigmoid],["Sin","","7+",D.sin],["Slice","","10+",M.sliceV10],["Slice","","1-9",M.slice,M.parseSliceAttributes],["Softmax","","1-12",I.softmax,I.parseSoftmaxAttributes],["Softmax","","13+",I.softmaxV13,I.parseSoftmaxAttributesV13],["Split","","2-12",P.split,P.parseSplitAttributes],["Sqrt","","6+",D.sqrt],["Squeeze","","1-12",O.squeeze,O.parseSqueezeAttributes],["Squeeze","","13+",O.squeezeV13],["Sub","","7+",u.sub],["Sum","","6+",R.sum],["Tan","","7+",D.tan],["Tanh","","6+",D.tanh],["Tile","","6+",C.tile],["Transpose","","1+",L.transpose,L.parseTransposeAttributes],["Upsample","","7-8",k.upsample,k.parseUpsampleAttributesV7],["Upsample","","9",k.upsample,k.parseUpsampleAttributesV9],["Unsqueeze","","1-12",N.unsqueeze,N.parseUnsqueezeAttributes],["Unsqueeze","","13+",N.unsqueezeV13],["Xor","","7+",u.xor]]},2898:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseBatchNormalizationAttributes=r.batchNormalization=void 0;let a=i(246),s=i(5060),o=i(2039),l={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]};r.batchNormalization=(n,r,i)=>(c(r),[n.run(Object.assign(Object.assign({},l),{cacheHint:i.cacheKey,get:()=>u(n,r,i)}),r)]),r.parseBatchNormalizationAttributes=n=>{let r=n.attributes.getFloat("epsilon",1e-5),i=n.attributes.getFloat("momentum",.9),s=n.attributes.getInt("spatial",1);return(0,a.createAttributeWithCacheKey)({epsilon:r,momentum:i,spatial:s})};let u=(n,r,i)=>{let a=(0,s.getGlsl)(n.session.backend.glContext.version),u=r[0].dims.length,[c,h]=n.calculateTextureWidthAndHeight(r[1].dims,o.TextureType.unpacked),d=`
  float process(int[${u}] indices) {
    vec2 position = offsetToCoords(indices[1], ${c}, ${h});
    float scale = getColorAsFloat(${a.texture2D}(Scale, position));
    float mean = getColorAsFloat(${a.texture2D}(Mean, position));
    float variance = getColorAsFloat(${a.texture2D}(Variance, position));
    float b = getColorAsFloat(${a.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${i.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},l),{output:{dims:r[0].dims,type:r[0].type,textureType:o.TextureType.unpacked},shaderSource:d})},c=n=>{if(!n||5!==n.length)throw Error("BatchNormalization requires 5 inputs.");let r=n[0],i=n[1],a=n[2],s=n[3],o=n[4];if(r.dims.length<3||1!==i.dims.length||1!==a.dims.length||1!==s.dims.length||1!==o.dims.length||i.dims[0]!==r.dims[1]||a.dims[0]!==r.dims[1]||s.dims[0]!==r.dims[1]||o.dims[0]!==r.dims[1])throw Error("invalid input shape.");if("float32"!==r.type&&"float64"!==r.type||"float32"!==i.type&&"float64"!==i.type||"float32"!==a.type&&"float64"!==a.type||"float32"!==s.type&&"float64"!==s.type||"float32"!==o.type&&"float64"!==o.type)throw Error("invalid input tensor types.")}},7839:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.xor=r.sub=r.pRelu=r.pow=r.or=r.mul=r.less=r.greater=r.equal=r.div=r.and=r.add=r.glslPRelu=r.glslPow=r.glslXor=r.glslOr=r.glslAnd=r.glslLess=r.glslGreater=r.glslEqual=r.glslSub=r.glslMul=r.glslDiv=r.glslAdd=void 0;let a=i(2517),s=i(8520),o=i(5060),l=i(2039);function u(){let n="add_";return{body:`
  float ${n}(float a, float b) {
    return a + b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:n,type:s.FunctionType.ValueBased}}function c(){let n="div_";return{body:`
  float ${n}(float a, float b) {
    return a / b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:n,type:s.FunctionType.ValueBased}}function h(){let n="mul_";return{body:`
  float ${n}(float a, float b) {
    return a * b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:n,type:s.FunctionType.ValueBased}}function d(){let n="sub_";return{body:`
  float ${n}(float a, float b) {
    return a - b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:n,type:s.FunctionType.ValueBased}}function p(){let n="equal_";return{body:`
  float ${n}(float a, float b) {
    return float(a == b);
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:n,type:s.FunctionType.ValueBased}}function f(){let n="greater_";return{body:`
  float ${n}(float a, float b) {
    return float(a > b);
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:n,type:s.FunctionType.ValueBased}}function m(){let n="less_";return{body:`
  float ${n}(float a, float b) {
    return float(a < b);
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:n,type:s.FunctionType.ValueBased}}function g(){let n="and_";return{body:`
  float ${n}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:n,type:s.FunctionType.ValueBased}}function _(){let n="or_";return{body:`
  float ${n}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:n,type:s.FunctionType.ValueBased}}function y(){let n="xor_";return{body:`
  float ${n}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:n,type:s.FunctionType.ValueBased}}function b(){return function(n){let r=`${n}_`;return{body:`
  float ${r}(float a, float b) {
    return ${n}(a, b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return ${n}(v1, v2);
  }
  `,name:r,type:s.FunctionType.ValueBased}}("pow")}function v(){let n="prelu_";return{body:`
  float ${n}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:n,type:s.FunctionType.ValueBased}}r.glslAdd=u,r.glslDiv=c,r.glslMul=h,r.glslSub=d,r.glslEqual=p,r.glslGreater=f,r.glslLess=m,r.glslAnd=g,r.glslOr=_,r.glslXor=y,r.glslPow=b,r.glslPRelu=v;let x=(n,r,i,a=r[0].type,s)=>{let o=n.session.pack?l.TextureType.packed:l.TextureType.unpacked;return{name:i.name,inputNames:["A","B"],inputTypes:[o,o],cacheHint:s,get:()=>w(n,r,i,a)}},w=(n,r,i,s=r[0].type)=>{let u=n.session.pack?l.TextureType.packed:l.TextureType.unpacked,c=!a.ShapeUtil.areEqual(r[0].dims,r[1].dims),h=r[0].dims,d=n.session.pack;if(c){let l=a.BroadcastUtil.calcShape(r[0].dims,r[1].dims,!1);if(!l)throw Error("Can't perform binary op on the given tensors");h=l;let c=h.length,p=0!==r[0].dims.length?r[0].dims.length:1,f=0!==r[1].dims.length?r[1].dims.length:1,m=0!==r[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",g=0!==r[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",_=(0,o.getGlsl)(n.session.backend.glContext.version),y=d?`
      ${i.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${i.name}(a, b);
        ${_.output} = result;
      }`:`
      ${i.body}
      float process(int indices[${c}]) {
        int aindices[${p}];
        int bindices[${f}];
        ${m}
        ${g}
        return ${i.name}(_A(aindices), _B(bindices));
      }`;return{name:i.name,inputNames:["A","B"],inputTypes:[u,u],output:{dims:h,type:s,textureType:u},shaderSource:y,hasMain:d}}let p=(0,o.getGlsl)(n.session.backend.glContext.version),f=`
    ${i.body}
    void main() {
      vec4 v1 = ${p.texture2D}(A, TexCoords);
      vec4 v2 = ${p.texture2D}(B, TexCoords);
      vec4 result = ${i.name}(v1, v2);
      ${p.output} = result;
    }
    `;return{name:i.name,inputNames:["A","B"],inputTypes:[u,u],output:{dims:r[0].dims,type:s,textureType:u},shaderSource:f,hasMain:!0}};r.add=(n,r)=>[n.run(x(n,r,u()),r)],r.and=(n,r)=>[n.run(x(n,r,g(),"bool"),r)],r.div=(n,r)=>[n.run(x(n,r,c()),r)],r.equal=(n,r)=>[n.run(x(n,r,p(),"bool"),r)],r.greater=(n,r)=>[n.run(x(n,r,f(),"bool"),r)],r.less=(n,r)=>[n.run(x(n,r,m(),"bool"),r)],r.mul=(n,r)=>[n.run(x(n,r,h()),r)],r.or=(n,r)=>[n.run(x(n,r,_(),"bool"),r)],r.pow=(n,r)=>[n.run(x(n,r,b()),r)],r.pRelu=(n,r)=>[n.run(x(n,r,v()),r)],r.sub=(n,r)=>[n.run(x(n,r,d()),r)],r.xor=(n,r)=>[n.run(x(n,r,y(),"bool"),r)]},4196:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseCastAttributes=r.cast=void 0;let a=i(2517);r.cast=(n,r,i)=>(s(r),[n.cast(r[0],i)]),r.parseCastAttributes=n=>a.ProtoUtil.tensorDataTypeFromProto(n.attributes.getInt("to"));let s=n=>{if(!n||1!==n.length)throw Error("Cast requires 1 input.");if("string"===n[0].type)throw Error("Invalid input type.")}},1163:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createPackedConcatProgramInfoLoader=void 0;let a=i(5060),s=i(2039),o=i(9390),l=i(2827);r.createPackedConcatProgramInfoLoader=(n,r,i)=>{var c,h;let d=(c=r.length,h=i.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:c},(n,r)=>`X${r}`),inputTypes:Array(c).fill(s.TextureType.packed),cacheHint:h});return Object.assign(Object.assign({},d),{get:()=>((n,r,i,c)=>{let h=i[0].dims.slice();if(c>=h.length||c<-1*h.length)throw Error("axis specified for concat doesn't match input dimensionality");c<0&&(c=h.length+c);let d=h.slice(0);for(let n=1;n<i.length;n++){let r=i[n].dims.slice();for(let n=0;n<h.length;n++)if(n===c)d[c]+=r[n];else if(h[n]!==r[n])throw Error("non concat dimensions must match")}let p=d.length,f=(0,l.getChannels)("coords",p),m=(0,o.getCoordsDataType)(p),g=(0,l.unpackFromChannel)(),_=i.map(n=>n.dims),y=(0,o.getGlChannels)(p),b=Array(_.length-1);b[0]=_[0][c];for(let n=1;n<b.length;n++)b[n]=b[n-1]+_[n][c];let v=y[c],x=y.slice(-2),w=y.join(),T=`if (${v} < ${b[0]}) {
        return getChannel(
            getX0(${w}), vec2(${x.join()}));
        }`;for(let n=1;n<b.length;n++){let r=b[n-1];T+=`
            if (${v} < ${b[n]}  && ${v} >= ${b[n-1]}) {
              return getChannel(
                getX${n}(${u(y,v,r)}),
                vec2(${u(x,v,r)}));
            }`}let S=b.length,E=b[b.length-1];T+=`
            return getChannel(
              getX${S}(${u(y,v,E)}),
              vec2(${u(x,v,E)}));`;let A=(0,a.getGlsl)(n.session.backend.glContext.version),M=`
          ${g}
          float getValue(${y.map(n=>"int "+n)}) {
            ${T}
          }

          void main() {
            ${m} coords = getOutputCoords();
            int lastDim = coords.${y[p-1]};
            coords.${y[p-1]} = coords.${y[p-2]};
            coords.${y[p-2]} = lastDim;

            vec4 result = vec4(getValue(${f}), 0., 0., 0.);

            ${f[p-1]} = ${f[p-1]} + 1;
            if (${f[p-1]} < ${d[p-1]}) {
              result.g = getValue(${f});
            }

            ${f[p-2]} = ${f[p-2]} + 1;
            if (${f[p-2]} < ${d[p-2]}) {
              result.a = getValue(${f});
            }

            ${f[p-1]} = ${f[p-1]} - 1;
            if (${f[p-2]} < ${d[p-2]} &&
                ${f[p-1]} < ${d[p-1]}) {
              result.b = getValue(${f});
            }
            ${A.output} = result;
          }
        `;return Object.assign(Object.assign({},r),{output:{dims:d,type:i[0].type,textureType:s.TextureType.packed},shaderSource:M,hasMain:!0})})(n,d,r,i.axis)})};let u=(n,r,i)=>{let a=n.indexOf(r);return n.map((n,r)=>r===a?`${n} - ${i}`:n).join()}},2069:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseConcatAttributes=r.concat=void 0;let a=i(246),s=i(2039),o=i(1163);r.concat=(n,r,i)=>(p(r),n.session.pack&&r[0].dims.length>1?[n.run((0,o.createPackedConcatProgramInfoLoader)(n,r,i),r)]:[n.run(l(n,r,i),r)]);let l=(n,r,i)=>{var a,o;let l=(a=r.length,o=i.cacheKey,{name:"Concat",inputNames:Array.from({length:a},(n,r)=>`X${r}`),inputTypes:Array(a).fill(s.TextureType.unpacked),cacheHint:o});return Object.assign(Object.assign({},l),{get:()=>((n,r,i,a)=>{let o=i[0].dims.slice();if(a>=o.length||a<-1*o.length)throw Error("axis specified for concat doesn't match input dimensionality");a<0&&(a=o.length+a);let l=o.slice(0);for(let n=1;n<i.length;n++){let r=i[n].dims.slice();for(let n=0;n<o.length;n++)if(n===a)l[a]+=r[n];else if(o[n]!==r[n])throw Error("non concat dimensions must match")}let p=l.length,f=Array(i.length),m=0;for(let n=0;n<f.length;++n)m+=i[n].dims[a],f[n]=m;let g="";g=i.length<5?u(f):c(f);let _=`
        ${h(i.length,p)}
        ${d(f)}
        ${g}
        float process(int indices[${p}]) {
          int textureIndex = getTextureWhereDataResides (indices[${a}]);

          if(textureIndex != 0) {
            indices[${a}] = indices[${a}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},r),{output:{dims:l,type:i[0].type,textureType:s.TextureType.unpacked},shaderSource:_})})(0,l,r,i.axis)})},u=n=>`int getTextureWhereDataResides(int index) {
      ${n.map((n,r)=>`if(index<${n}) {return ${r};}
`).join("")}
    }`,c=n=>u(n),h=(n,r)=>{let i=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${r}]) {`];for(let r=0;r<n;++r)0===r?i.push(`	if (textureIndex == ${r}) { return _X${r}(indices); }`):r===n-1?i.push(`	else { return _X${r}(indices); }`):i.push(`	else if (textureIndex == ${r}) { return _X${r}(indices); }`);return i.push("	}"),i.join("\n")},d=n=>{let r=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let i=0;i<n.length;++i)0===i?r.push(`	if (index == ${i}) { return ${n[i]}; }`):i===n.length-1?r.push(`	else { return ${n[i]}; }`):r.push(`	else if (index == ${i}) { return ${n[i]}; }`);return r.push("	}"),r.join("\n")};r.parseConcatAttributes=n=>(0,a.createAttributeWithCacheKey)({axis:n.attributes.getInt("axis")});let p=n=>{if(!n||n.length<1)throw Error("too few inputs");let r=n[0].type,i=n[0].dims.length;if("string"===r)throw Error("string tensor is not supported yet");for(let a of n){if(a.type!==r)throw Error("input tensors should be one type");if(a.dims.length!==i)throw Error("input tensors should have the same shape")}}},4770:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createUnpackedGroupedConvProgramInfoLoader=void 0;let a=i(6231),s=i(5060),o=i(2039),l=i(8138),u=i(2823);r.createUnpackedGroupedConvProgramInfoLoader=(n,r,i)=>{var c,h;let d=(c=r.length>2,h=i.cacheKey,{name:"GroupedConv",inputNames:c?["X","W","Bias"]:["X","W"],inputTypes:c?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:h});return Object.assign(Object.assign({},d),{get:()=>((n,r,i,c)=>{let h=r.length>2?"value += getBias(output_channel);":"",d=r[0].dims.slice(),p=r[1].dims.slice(),f=p[0]/c.group;a.Logger.verbose("GroupedConv",`autpPad:${c.autoPad}, dilations:${c.dilations}, group:${c.group}, kernelShape:${c.kernelShape}, pads:${c.pads}, strides:${c.strides}`);let m=(0,l.calculateOutputShape)(d,p,c.dilations,c.pads,c.strides),g=(0,s.getGlsl)(n.session.backend.glContext.version),{activationFunction:_,applyActivation:y}=(0,u.getActivationSnippet)(c),b=`
  const ivec2 strides = ivec2(${c.strides[0]}, ${c.strides[1]});
  const ivec2 pads = ivec2(${c.pads[0]}, ${c.pads[1]});
  ${_}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${f};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {
      int input_channel = group_id * ${p[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${c.dilations[0]};

        if (xHeight < 0 || xHeight >= ${d[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${c.dilations[1]};
          if (xWidth < 0 || xWidth >= ${d[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${h}
    ${y}
    ${g.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},i),{output:{dims:m,type:r[0].type,textureType:o.TextureType.unpacked},shaderSource:b,hasMain:!0})})(n,r,d,i)})}},1386:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.conv2DPacked=r.conv2DPackedPointwise=void 0;let a=i(8138),s=i(8555),o=i(708);r.conv2DPackedPointwise=(n,r,i)=>{let s=r[0].dims,l=r[1].dims,u=(0,a.calculateOutputShape)(s,l,i.dilations,i.pads,i.strides),c=n.reshapePacked(r[0],[s[1],s[2]*s[3]]),h=n.reshapePacked(r[1],[l[0],l[1]]),d=r.length>2?[h,c,r[2]]:[h,c],p=n.run((0,o.createPackedMatmulProgramInfoLoader)(n,d,i),d);return n.reshapePacked(p,u)},r.conv2DPacked=(n,r,i)=>{let l=r[0].dims,u=r[1].dims,c=(0,a.calculateOutputShape)(l,u,i.dilations,i.pads,i.strides),h=n.run((0,s.createPackedIm2ColProgramInfoLoader)(n,r[0],r[1],c,i),[r[0]]),d=n.reshapePacked(r[1],[u[0],u[1]*u[2]*u[3]]),p=3===r.length?[d,h,r[2]]:[d,h],f=n.run((0,o.createPackedMatmulProgramInfoLoader)(n,p,i),p);return n.reshapePacked(f,c)}},9663:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseConvTransposeAttributes=r.convTranspose=void 0;let a=i(246),s=i(5060),o=i(2039),l=i(2823),u=(n,r,i,a,s,o)=>(n-1)*r+i+(a-1)*s+1-o,c=(n,r,i,a,s)=>{let o=Math.floor(n/2);"SAME_UPPER"===r?(i[a]=o,i[s]=n-o):"SAME_LOWER"===r&&(i[a]=n-o,i[s]=o)};r.convTranspose=(n,r,i)=>(f(r,i),h(n,r,i));let h=(n,r,i)=>{let a=p(i,r);return[d(n,r,a)]},d=(n,r,i)=>n.run(((n,r,i)=>{var a,u;let c=(a=r.length>2,u=i.cacheKey,{name:"ConvTranspose",inputNames:a?["X","W","B"]:["X","W"],inputTypes:a?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:u});return Object.assign(Object.assign({},c),{get:()=>((n,r,i,a)=>{let u=r.length>2?"getB(output_channel)":"0.0",c=r[0].dims,h=r[1].dims,d=h[1],p=h[0]/a.group,f=[r[0].dims[0],r[1].dims[1]*a.group,...a.outputShape],m=(0,s.getGlsl)(n.session.backend.glContext.version),{activationFunction:g,applyActivation:_}=(0,l.getActivationSnippet)(a),y=`
  const ivec2 strides = ivec2(${a.strides[0]}, ${a.strides[1]});
  const ivec2 pads = ivec2(${a.pads[0]}, ${a.pads[1]});
  ${g}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${d};
    int wOutChannel = output_channel - group_id * ${d};

    float value = ${u};
    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {
      int input_channel = group_id * ${p} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${h[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${h[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${a.dilations[0]}, wHOff * ${a.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${c[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${c[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${_}
    ${m.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},i),{output:{dims:f,type:r[0].type,textureType:o.TextureType.unpacked},shaderSource:y,hasMain:!0})})(n,r,c,i)})})(n,r,i),r),p=(n,r)=>{let i=n.kernelShape.slice();if(0===n.kernelShape.length)for(let n=2;n<r[1].dims.length;++n)i.push(r[1].dims[n]);let a=n.pads.slice(),s=n.outputShape.slice();((n,r,i,a,s,o,l,h)=>{let d=n.length-2,p=0===h.length;for(let f=0;f<d;++f){let m=p?n[f+2]*o[f]:h[f],g=u(n[f+2],o[f],s[f],r[f],i[f],m);c(g,a,s,f,f+d),p&&h.push(o[f]*(n[f+2]-1)+l[f]+(r[f]-1)*i[f]+1-s[f]-s[f+d])}})(r[0].dims,i,n.dilations,n.autoPad,a,n.strides,n.outputPadding,s);let o=Object.assign({},n);return Object.assign(o,{kernelShape:i,pads:a,outputShape:s,cacheKey:n.cacheKey}),o};r.parseConvTransposeAttributes=n=>{let r=n.attributes,i=(0,l.parseInternalActivationAttributes)(r),s=r.getString("auto_pad","NOTSET"),o=r.getInts("dilations",[1,1]),u=r.getInt("group",1),c=r.getInts("kernel_shape",[]),h=r.getInts("output_padding",[0,0]),d=r.getInts("output_shape",[]),p=r.getInts("pads",[0,0,0,0]),f=r.getInts("strides",[1,1]);return(0,a.createAttributeWithCacheKey)(Object.assign({autoPad:s,dilations:o,group:u,kernelShape:c,outputPadding:h,outputShape:d,pads:p,strides:f},i))};let f=(n,r)=>{if(!n||2!==n.length&&3!==n.length)throw Error("Conv requires 2 or 3 inputs");if(4!==n[0].dims.length||4!==n[1].dims.length)throw Error("currently only support 2-dimensional conv");if(n[0].dims[1]!==n[1].dims[0])throw Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=n[1].dims[1]*r.group;if(3===n.length&&(1!==n[2].dims.length||n[2].dims[0]!==i))throw Error("invalid bias");let a=n[0].dims.length-2;if(r.dilations.length!==a)throw Error(`dilations should be ${a}D`);if(r.strides.length!==a)throw Error(`strides should be ${a}D`);if(r.pads.length!==2*a)throw Error(`pads should be ${2*a}D`);if(r.outputPadding.length!==a)throw Error(`output_padding should be ${a}D`);if(0!==r.kernelShape.length&&r.kernelShape.length!==n[1].dims.length-2)throw Error("invalid kernel shape");if(0!==r.outputShape.length&&r.outputShape.length!==n[0].dims.length-2)throw Error("invalid output shape");if("float32"!==n[0].type||"float32"!==n[1].type)throw Error("ConvTranspose input(X,W) should be float tensor");if(3===n.length&&"float32"!==n[2].type)throw Error("ConvTranspose input(bias) should be float tensor")}},8138:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseConvAttributes=r.conv=r.calculateOutputShape=void 0;let a=i(246),s=i(2517),o=i(4770),l=i(1386),u=i(9828),c=i(2823),h=i(3248),d=i(5623);r.calculateOutputShape=(n,r,i,a,s)=>{let o=n[0],l=n.slice(2),u=l.length,c=r[0],h=r.slice(2).map((n,r)=>n+(n-1)*(i[r]-1)),d=l.map((n,r)=>n+a[r]+a[r+u]).map((n,r)=>Math.floor((n-h[r]+s[r])/s[r]));return[o,c].concat(...d)},r.conv=(n,r,i)=>(_(r,i),p(n,r,i));let p=(n,r,i)=>{let a=g(i,r),s=n.session.pack,u=1===a.kernelShape[0]&&1===a.kernelShape[1];return a.group>1?[n.run((0,o.createUnpackedGroupedConvProgramInfoLoader)(n,r,a),r)]:u&&s?[f(n,r,a)]:s&&4===r[0].dims.length&&1===r[0].dims[0]&&!u?[(0,l.conv2DPacked)(n,r,a)]:[m(n,r,a)]},f=(n,i,a)=>{let s=i[0].dims,o=i[1].dims,l=(0,r.calculateOutputShape)(s,o,a.dilations,a.pads,a.strides),u=n.reshapeUnpacked(i[0],[s[1],s[2]*s[3]]),c=n.reshapeUnpacked(i[1],[o[0],o[1]]),h=i.length>2?[c,u,i[2]]:[c,u],p=n.run((0,d.createMatmulProgramInfoLoader)(h,a),h);return n.reshapeUnpacked(p,l)},m=(n,i,a)=>{let s=i[0].dims,o=i[1].dims,l=(0,r.calculateOutputShape)(s,o,a.dilations,a.pads,a.strides),c=n.run((0,h.createIm2ColProgramInfoLoader)(n,i[0],i[1],l,a),[i[0]]),d=3===i.length?[c,i[1],i[2]]:[c,i[1]];return n.run((0,u.createDotProductProgramInfoLoader)(n,i,l,a),d)},g=(n,r)=>{let i=n.kernelShape.slice();if(0===n.kernelShape.length)for(let n=2;n<r[1].dims.length;++n)i.push(r[1].dims[n]);let a=n.pads.slice();s.PoolConvUtil.adjustPadsBasedOnAutoPad(r[0].dims,n.strides,n.dilations,i,a,n.autoPad);let o=Object.assign({},n);return Object.assign(o,{kernelShape:i,pads:a,cacheKey:n.cacheKey}),o};r.parseConvAttributes=n=>{let r=n.attributes,i=(0,c.parseInternalActivationAttributes)(r),s=r.getString("auto_pad","NOTSET"),o=r.getInts("dilations",[1,1]),l=r.getInt("group",1),u=r.getInts("kernel_shape",[]),h=r.getInts("pads",[0,0,0,0]),d=r.getInts("strides",[1,1]);return(0,a.createAttributeWithCacheKey)(Object.assign({autoPad:s,dilations:o,group:l,kernelShape:u,pads:h,strides:d},i))};let _=(n,r)=>{if(!n||2!==n.length&&3!==n.length)throw Error("Conv requires 2 or 3 inputs");if(4!==n[0].dims.length||4!==n[1].dims.length)throw Error("currently only support 2-dimensional conv");if(n[0].dims[1]!==n[1].dims[1]*r.group)throw Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===n.length&&(1!==n[2].dims.length||n[1].dims[0]!==n[2].dims[0]))throw Error("invalid bias");let i=n[0].dims.length-2;if(r.dilations.length!==i)throw Error(`dilations should be ${i}D`);if(r.strides.length!==i)throw Error(`strides should be ${i}D`);if(r.pads.length!==2*i)throw Error(`pads should be ${2*i}D`);if(0!==r.kernelShape.length&&r.kernelShape.length!==n[1].dims.length-2)throw Error("invalid kernel shape");if("float32"!==n[0].type||"float32"!==n[1].type)throw Error("Conv input(X,W) should be float tensor");if(3===n.length&&"float32"!==n[2].type)throw Error("Conv input(bias) should be float tensor")}},5193:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseDepthToSpaceAttributes=r.depthToSpace=void 0;let a=i(3738);r.depthToSpace=(n,r,i)=>{s(r);let o=i.blocksize,l=o*o,u="DCR"===i.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],c="DCR"===i.mode?[r[0].dims[0],o,o,r[0].dims[1]/l,r[0].dims[2],r[0].dims[3]]:[r[0].dims[0],r[0].dims[1]/l,o,o,r[0].dims[2],r[0].dims[3]],h=n.reshapeUnpacked(r[0],c),d={perm:u,cacheKey:`${u}`},[p]=(0,a.transpose)(n,[h],d),f=[r[0].dims[0],r[0].dims[1]/l,r[0].dims[2]*o,r[0].dims[3]*o];return[n.reshapeUnpacked(p,f)]},r.parseDepthToSpaceAttributes=n=>{let r=n.attributes.getInt("blocksize");if(r<1)throw Error(`blocksize must be >= 1, but got : ${r} for DepthToSpace`);let i=n.attributes.getString("mode","DCR");if("DCR"!==i&&"CRD"!==i)throw Error(`unrecognized mode: ${i} for DepthToSpace`);return{mode:i,blocksize:r}};let s=n=>{if(1!==n.length)throw Error(`DepthToSpace expect 1 inputs, but got ${n.length}`);if("string"===n[0].type||4!==n[0].dims.length)throw TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createDotProductProgramInfoLoader=void 0;let a=i(2517),s=i(5060),o=i(2039),l=i(2823),u=i(3248);r.createDotProductProgramInfoLoader=(n,r,i,c)=>{var h,d;let p=(h=r.length>2,d=c,{name:"ConvDotProduct",inputNames:h?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:h?[o.TextureType.unpacked,o.TextureType.packedLastDimension,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.packedLastDimension],cacheKey:d.activationCacheKey});return Object.assign(Object.assign({},p),{get:()=>((n,r,i,c,h)=>{let d=i[0].dims,p=i[1].dims,f=[p[0],Math.ceil(d[1]*p[2]*p[3]/4)],m=(0,u.calculateIm2ColDims)(d,p,c),[g,_]=n.calculateTextureWidthAndHeight(f,o.TextureType.packedLastDimension),y=a.ShapeUtil.computeStrides(m),[b,v]=n.calculateTextureWidthAndHeight(m,o.TextureType.packedLastDimension),x=c.length,w=i.length<3?"0.0":"_B(b)",T=Math.ceil(d[1]*p[2]*p[3]/4),{activationFunction:S,applyActivation:E}=(0,l.getActivationSnippet)(h),A=(0,s.getGlsl)(n.session.backend.glContext.version),M=`
${S}
float process(int indices[${x}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${y[0]} + im2col[1] * ${y[1]} + im2col[2] * ${y[2]};
  int kernelOffset = indices[1] * ${f[1]};
  float value = ${w};
  for (int i = 0; i < ${T}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${b}, ${v});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${g}, ${_});
    value += dot(${A.texture2D}(Im2Col, im2colCoords), ${A.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${E}
  return value;
}`;return Object.assign(Object.assign({},r),{output:{dims:c,type:i[0].type,textureType:o.TextureType.unpacked},shaderSource:M})})(n,p,r,i,c)})}},7992:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseFlattenAttributes=r.flatten=void 0;let a=i(2517);r.flatten=(n,r,i)=>{s(r,i);let o=a.ShapeUtil.flattenShape(r[0].dims,i);return[n.reshapeUnpacked(r[0],o)]},r.parseFlattenAttributes=n=>n.attributes.getInt("axis",1);let s=(n,r)=>{if(!n||1!==n.length)throw Error("Flatten requires 1 input.");let i=n[0].dims.length;if(0===i)throw Error("scalar tensor is not supported.");if(r<-i||r>i)throw Error("Invalid axis");if("string"===n[0].type)throw Error("string tensor is not supported.")}},2823:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseInternalActivationAttributes=r.getActivationSnippet=void 0;let a=i(2517),s=i(4909);r.getActivationSnippet=function(n){let r;switch(n.activation){case"Relu":r=(0,s.glslRelu)();break;case"Sigmoid":r=(0,s.glslSigmoid)();break;case"Clip":r=(0,s.glslClip)(n.clipMin,n.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let i=r.name;return{activationFunction:r.body,applyActivation:`value = ${i}_(value);`}},r.parseInternalActivationAttributes=n=>{let r=n.getString("activation","");if("Clip"===r){let[i,s]=n.getFloats("activation_params",[a.MIN_CLIP,a.MAX_CLIP]);return{activation:r,clipMax:s,clipMin:i,activationCacheKey:`${r}:${i},${s}`}}return{activation:r,activationCacheKey:r}}},1253:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseGatherAttributes=r.gather=void 0;let a=i(246),s=i(782),o=i(2517),l=i(2039);r.gather=(n,r,i)=>(h(r,i.axis),[n.run(c(n,r,i),r)]),r.parseGatherAttributes=n=>(0,a.createAttributeWithCacheKey)({axis:n.attributes.getInt("axis",0)});let u={name:"Gather",inputNames:["A","B"],inputTypes:[l.TextureType.unpacked,l.TextureType.unpacked]},c=(n,r,i)=>{let a=Object.assign(Object.assign({},u),{cacheHint:i.cacheKey});return Object.assign(Object.assign({},a),{get:()=>((n,r,i,a)=>{let s=i[0].dims.slice(),u=i[1].dims.slice(),c=Array(s.length+u.length-1);a=o.ShapeUtil.normalizeAxis(a,s.length);let h=[];for(let n=0;n<c.length;n++)n<a?(c[n]=s[n],h.push(`inputIdx[${n}] = outputIdx[${n}];`)):n<a+u.length?(c[n]=u[n-a],h.push(`indexDataIdx[${n-a}] = outputIdx[${n}];`)):(c[n]=s[n-u.length+1],h.push(`inputIdx[${n-u.length+1}] = outputIdx[${n}];`));let d=`
      float process(int outputIdx[${c.length||1}]) {
        int inputIdx[${s.length}];
        int indexDataIdx[${u.length||1}];
        indexDataIdx[0] = 0;
        ${h.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${a}] = idx < 0 ? idx + ${s[a]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},r),{output:{dims:c,type:i[0].type,textureType:l.TextureType.unpacked},shaderSource:d})})(0,a,r,i.axis)})},h=(n,r)=>{if(!n||2!==n.length)throw Error("Gather requires 2 inputs.");let i=n[0].dims.length;if(i<1)throw Error("Invalid input shape.");if(r<-i||r>i-1)throw Error("Invalid axis.");if(-1===s.NUMBER_TYPES.indexOf(n[0].type)||"int32"!==n[1].type&&"int16"!==n[1].type)throw Error("Invaid input type.")}},4776:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseGemmAttributesV11=r.parseGemmAttributesV7=r.gemm=void 0;let a=i(246),s=i(2517),o=i(2039);r.gemm=(n,r,i)=>(h(r,i),[n.run(u(r,i),r)]);let l=(n,r)=>{let i=0!==n.attributes.getInt("transA",0),s=0!==n.attributes.getInt("transB",0),o=n.attributes.getFloat("alpha",1),l=n.attributes.getFloat("beta",1);return(0,a.createAttributeWithCacheKey)({transA:i,transB:s,alpha:o,beta:l,isOptionalC:r})};r.parseGemmAttributesV7=n=>l(n,!1),r.parseGemmAttributesV11=n=>l(n,!0);let u=(n,r)=>{let i={name:"Gemm",inputNames:3===n.length?["A","B","C"]:["A","B"],inputTypes:3===n.length?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],key:r.cacheKey};return Object.assign(Object.assign({},i),{get:()=>c(i,n,r)})},c=(n,r,i)=>{let a=r[0].dims.slice(),l=r[1].dims.slice(),[u,c]=s.GemmUtil.getShapeOfGemmResult(a,i.transA,l,i.transB,3===r.length?r[2].dims:void 0),h=[u,c];if(!h)throw Error("Can't use gemm on the given tensors");let d=a[a.length-1],p="";i.transA&&(d=a[0]),i.transA&&i.transB?p="value += _A_T(a) * _B_T(b);":i.transA&&!i.transB?p="value += _A_T(a) * _B(b);":!i.transA&&i.transB?p="value += _A(a) * _B_T(b);":i.transA||i.transB||(p="value += _A(a) * _B(b);");let f=h.length,m=`
      float process(int indices[${f}]) {
          int a[${f}];
          int b[${f}];
          ${3===r.length?`int c[${r[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3===r.length?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${d}; ++k) {
              a[${f-1}] = k;
              b[${f-2}] = k;
              ${p}
          }

          value = value * alpha;
          ${3===r.length?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},n),{output:{dims:h,type:r[0].type,textureType:o.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:i.alpha},{name:"beta",type:"float",data:i.beta}],shaderSource:m})},h=(n,r)=>{if(!n)throw Error("Input is missing");if(r.isOptionalC&&(n.length<2||n.length>3))throw Error("Invaid input shape.");if(!r.isOptionalC&&3!==n.length)throw Error("Gemm requires 3 inputs");if(3===n.length&&1!==n[2].dims.length&&2!==n[2].dims.length)throw Error("Invalid input shape of C");if("float32"!==n[0].type&&"float64"!==n[0].type||"float32"!==n[1].type&&"float64"!==n[1].type||3===n.length&&"float32"!==n[2].type&&"float64"!==n[2].type)throw Error("Invalid input type.");if(n[0].type!==n[1].type||3===n.length&&n[0].type!==n[2].type)throw Error("Input types are mismatched")}},8555:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createPackedIm2ColProgramInfoLoader=void 0;let a=i(5060),s=i(2039),o=i(2827);r.createPackedIm2ColProgramInfoLoader=(n,r,i,l,u)=>{var c;let h=(c=u.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[s.TextureType.packed],cacheHint:c});return Object.assign(Object.assign({},h),{get:()=>((n,r,i,l,u,c)=>{let h=i.dims,d=l.dims,p=u.length,f=[d[1]*d[2]*d[3],u[2]*u[3]],m=d[2]*d[3],g=(0,o.unpackFromChannel)(),_=(0,a.getGlsl)(n.session.backend.glContext.version),y="";for(let n=0;n<=1;n++)for(let r=0;r<=1;r++)y+=`
            blockIndex = rc.x + ${r};
            pos = rc.y + ${n};

            if(blockIndex < ${f[1]} && pos < ${f[0]}) {
              offsetY = int(blockIndex / (${u[p-1]})) * ${c.strides[0]} -
                ${c.pads[0]};
              d0 = offsetY + ${c.dilations[0]} * (imod(pos, ${m}) / ${d[2]});

              if(d0 < ${h[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${u[p-1]}) * ${c.strides[1]} -
                  ${c.pads[1]};
                d1 = offsetX + ${c.dilations[1]} * imod(imod(pos, ${m}), ${d[2]});

                if(d1 < ${h[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${m}.);
                    innerDims = vec2(d0, d1);
                    result[${2*n+r}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let b=`
      ${g}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${y}
          ${_.output} = result;
      }
            `;return Object.assign(Object.assign({},r),{output:{dims:f,type:i.type,textureType:s.TextureType.packed},shaderSource:b,hasMain:!0})})(n,h,r,i,l,u)})}},3248:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.calculateIm2ColDims=r.createIm2ColProgramInfoLoader=void 0;let a=i(2039);r.createIm2ColProgramInfoLoader=(n,i,s,o,l)=>{var u;let c=(u=l.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[a.TextureType.unpacked],cacheHint:u});return Object.assign(Object.assign({},c),{get:()=>((n,i,s,o,l,u)=>{let c=s.dims,h=o.dims,d=l.length,p=(0,r.calculateIm2ColDims)(c,h,l,4),f=`
        const int XC = ${c[1]};
        const int XH = ${c[2]};
        const int XW = ${c[3]};
        const int KH = ${u.kernelShape[0]};
        const int KW = ${u.kernelShape[1]};
        const int dilationH = ${u.dilations[0]};
        const int dilationW = ${u.dilations[1]};
        const int strideH = ${u.strides[0]};
        const int strideW = ${u.strides[1]};
        const int padH = ${u.pads[0]};
        const int padW = ${u.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${d}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${c.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},i),{output:{dims:p,type:s.type,textureType:a.TextureType.packedLastDimension},shaderSource:f})})(0,c,i,s,o,l)})},r.calculateIm2ColDims=(n,r,i,a=4)=>[i[0],i[2],i[3],Math.ceil(n[1]*r[2]*r[3]/a)]},6572:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseImageScalerAttributes=r.imageScaler=void 0;let a=i(246),s=i(2039);r.imageScaler=(n,r,i)=>(c(r),[n.run(l(n,r,i),r)]),r.parseImageScalerAttributes=n=>{let r=n.attributes.getFloat("scale"),i=n.attributes.getFloats("bias");return(0,a.createAttributeWithCacheKey)({scale:r,bias:i})};let o={name:"ImageScaler",inputNames:["X"],inputTypes:[s.TextureType.unpacked]},l=(n,r,i)=>{let a=Object.assign(Object.assign({},o),{cacheHint:i.cacheKey});return Object.assign(Object.assign({},a),{get:()=>((n,r,i,a)=>{let o=i[0].dims.slice(),l=o.length,c=`
      ${u(a.bias.length)}
      float process(int indices[${l}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},r),{output:{dims:o,type:i[0].type,textureType:s.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:a.bias.length,data:a.bias},{name:"scale",type:"float",data:a.scale}],shaderSource:c})})(0,a,r,i)})},u=n=>{let r=[`float getBias(float bias[${n}], int channel) {`];for(let i=0;i<n;++i)0===i?r.push(`	if (channel == ${i}) { return bias[${i}]; }`):i===n-1?r.push(`	else { return bias[${i}]; }`):r.push(`	else if (channel == ${i}) { return bias[${i}]; }`);return r.push("	}"),r.join("\n")},c=n=>{if(!n||1!==n.length)throw Error("ImageScaler requires 1 input.");if(4!==n[0].dims.length)throw Error("Invalid input shape.");if("float32"!==n[0].type&&"float64"!==n[0].type)throw Error("Invalid input type.")}},3346:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseInstanceNormalizationAttributes=r.instanceNormalization=void 0;let a=i(5060),s=i(2039);r.instanceNormalization=(n,r,i)=>{h(r);let a=n.run(l(r[0]),r);return[n.run(c(n,r[0],i,a.dims),[r[0],a,r[1],r[2]])]},r.parseInstanceNormalizationAttributes=n=>n.attributes.getFloat("epsilon",1e-5);let o={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[s.TextureType.unpacked]},l=n=>Object.assign(Object.assign({},o),{get:()=>((n,r)=>{let i=r.dims.slice(),a=i[1],o=i[2]*i[3],l=[i[0],a],u=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o});
        temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o});

        return v;
      }`;return Object.assign(Object.assign({},n),{output:{dims:l,type:r.type,textureType:s.TextureType.packedLastDimension},shaderSource:u})})(o,n)}),u={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[s.TextureType.unpacked,s.TextureType.packedLastDimension,s.TextureType.unpacked,s.TextureType.unpacked]},c=(n,r,i,o)=>{let l=Object.assign(Object.assign({},u),{cacheHint:`${i}`});return Object.assign(Object.assign({},l),{get:()=>((n,r,i,o,l)=>{let u=(0,a.getGlsl)(n.session.backend.glContext.version),[c,h]=n.calculateTextureWidthAndHeight(l,s.TextureType.packedLastDimension),[d,p]=[c/4,h],f=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${d}, ${p});
        return ${u.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},r),{output:{dims:i.dims,type:i.type,textureType:s.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:o}],shaderSource:f})})(n,l,r,i,o)})},h=n=>{if(!n||3!==n.length)throw Error("InstanceNormalization requires 3 inputs.");let r=n[0],i=n[1],a=n[2];if(r.dims.length<3||1!==i.dims.length||1!==a.dims.length)throw Error("Invalid input shape.");if(i.dims[0]!==r.dims[1]||a.dims[0]!==r.dims[1])throw Error("Input shapes are mismatched.");if("float32"!==r.type&&"float64"!==r.type||"float32"!==i.type&&"float64"!==i.type||"float32"!==a.type&&"float64"!==a.type)throw Error("Invalid input type.");if(4!==n[0].dims.length)throw Error("Only support 4-D input shape.")}},708:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createPackedMatmulProgramInfoLoader=void 0;let a=i(2517),s=i(5060),o=i(2039),l=i(9390),u=i(2823),c=i(5623);r.createPackedMatmulProgramInfoLoader=(n,r,i)=>{var h,d;let p=(h=r.length>2,d=i.activationCacheKey,{name:"MatMul (packed)",inputNames:h?["A","B","Bias"]:["A","B"],inputTypes:h?[o.TextureType.packed,o.TextureType.packed,o.TextureType.packed]:[o.TextureType.packed,o.TextureType.packed],cacheHint:d});return Object.assign(Object.assign({},p),{get:()=>((n,r,i,h)=>{let d=i.length>2,p=d?"value += getBiasForMatmul();":"",f=i[0].dims,m=i[1].dims,g=a.BroadcastUtil.calcShape(f,m,!0),_=!a.ShapeUtil.areEqual(i[0].dims,i[1].dims);if(!g)throw Error("Can't use matmul on the given tensors");let y=f[f.length-1],b=Math.ceil(y/2),v=f.length,x=m.length,w=(0,s.getGlsl)(n.session.backend.glContext.version),T=(0,l.getCoordsDataType)(g.length),S=g.length,E=(0,l.getGlChannels)(),{activationFunction:A,applyActivation:M}=(0,u.getActivationSnippet)(h),I=d?`${(0,c.getBiasForMatmul)(T,E,i[2].dims,g,!0)}`:"",P=_?`${function(n,r,i,s){let o=[],l=[],u=i[0].dims,c=i[1].dims,h=u.length,d=c.length,p=s.length,f=p-h,m=p-d;(o=u.map((n,i)=>`coords.${r[i+f]}`))[h-1]="i*2",o.join(", "),(l=c.map((n,i)=>`coords.${r[i+m]}`))[d-2]="i*2",l.join(", ");let g=a.BroadcastUtil.getBroadcastDims(u,s),_=a.BroadcastUtil.getBroadcastDims(c,s),y=g.map(n=>`coords.${r[n+f]} = 0;`).join("\n"),b=_.map(n=>`coords.${r[n+m]} = 0;`).join("\n"),v=`int lastDim = coords.${r[p-1]};
  coords.${r[p-1]} = coords.${r[p-2]};
  coords.${r[p-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${n} coords = getOutputCoords();
  ${v}
  ${y}
  vec4 outputValue = getA(${o});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${n} coords = getOutputCoords();
  ${v}
  ${b}
  vec4 outputValue = getB(${l});
  return outputValue;
}`}(T,E,i,g)}`:"",O=_?"getAAtOutCoordsMatmul(i)":`getA(${function(n,r){let i="";for(let a=0;a<r-2;a++)i+=`rc.${n[a]}, `;return i+`rc.${n[r-2]}, i*2`}(E,v)})`,R=_?"getBAtOutCoordsMatmul(i)":`getB(${function(n,r){let i="";for(let a=0;a<r-2;a++)i+=`rc.${n[a]}, `;return i+`i*2, rc.${n[r-1]}`}(E,x)})`,C=`
            ${P}
            ${I}
            ${A}
            void main() {
              ${_?"":`${T} rc =
          getOutputCoords(); int lastDim = rc.${E[S-1]}; rc.${E[S-1]} =
          rc.${E[S-2]}; rc.${E[S-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${b}; i++) {
                vec4 a = ${O};
                vec4 b = ${R};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${p}
              ${M}
              ${w.output} = value;
            }`;return Object.assign(Object.assign({},r),{output:{dims:g,type:i[0].type,textureType:o.TextureType.packed},shaderSource:C,hasMain:!0})})(n,p,r,i)})}},5623:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.getBiasForMatmul=r.createMatmulProgramInfoLoader=r.parseMatMulAttributes=r.matMul=void 0;let a=i(2517),s=i(2039),o=i(9390),l=i(2823),u=i(708);function c(n,r){var i,u;let c=(i=n.length>2,u=r.activationCacheKey,{name:"MatMul",inputNames:i?["A","B","Bias"]:["A","B"],inputTypes:i?[s.TextureType.unpacked,s.TextureType.unpacked,s.TextureType.unpacked]:[s.TextureType.unpacked,s.TextureType.unpacked],cacheHint:u});return Object.assign(Object.assign({},c),{get:()=>(function(n,r,i){let u=r[0].dims,c=r[1].dims,h=a.BroadcastUtil.calcShape(u,c,!0);if(!h)throw Error("Can't use matmul on the given tensors");let p=(0,o.getCoordsDataType)(h.length),f=(0,o.getGlChannels)(),{activationFunction:m,applyActivation:g}=(0,l.getActivationSnippet)(i),_=r.length>2,y=_?"value += getBiasForMatmul();":"",b=_?`${d(p,f,r[2].dims,h,!1)}`:"",v=h.length,x=u.length,w=c.length,T=`
    ${m}
    ${b}
    float process(int indices[${v}]) {
        int a[${x}];
        int b[${w}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${u[u.length-1]}; ++k) {
            a[${x-1}] = k;
            b[${w-2}] = k;
            value += _A(a) * _B(b);
        }
        ${y}
        ${g}
        return value;
    }`;return Object.assign(Object.assign({},n),{output:{dims:h,type:r[0].type,textureType:s.TextureType.unpacked},shaderSource:T})})(c,n,r)})}r.matMul=(n,r,i)=>(h(r),n.session.pack?[n.run((0,u.createPackedMatmulProgramInfoLoader)(n,r,i),r)]:[n.run(c(r,i),r)]),r.parseMatMulAttributes=n=>(0,l.parseInternalActivationAttributes)(n.attributes),r.createMatmulProgramInfoLoader=c;let h=n=>{if(!n||2!==n.length)throw Error("MatMul requires 2 inputs.");if(n[0].dims[n[0].dims.length-1]!==n[1].dims[n[1].dims.length-2])throw Error("shared dimension does not match.");if("float32"!==n[0].type&&"float64"!==n[0].type||"float32"!==n[1].type&&"float64"!==n[1].type)throw Error("inputs should be float type");if(n[0].type!==n[1].type)throw Error("inputs types should match")};function d(n,r,i,s,o){let l="",u=i.length,c=s.length,h=c-u;l=c<2&&u>0?"coords":i.map((n,i)=>`coords.${r[i+h]}`).join(", ");let d=a.BroadcastUtil.getBroadcastDims(i,s).map(n=>`coords.${r[n+h]} = 0;`).join("\n"),p="vec4(outputValue.xx, outputValue.yy)";return 1===a.ShapeUtil.size(i)&&(p="vec4(outputValue.x)"),o?`
vec4 getBiasForMatmul() {
  ${n} coords = getOutputCoords();
  ${d}
  vec4 outputValue = getBias(${l});
  return ${p};
}`:`
float getBiasForMatmul() {
  ${n} coords = getOutputCoords();
  ${d}
  return getBias(coords.x);
}`}r.getBiasForMatmul=d},2403:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createPackProgramInfoLoader=void 0;let a=i(5060),s=i(2039),o=i(9390),l=i(2827),u={name:"pack",inputNames:["A"],inputTypes:[s.TextureType.unpackedReversed]};r.createPackProgramInfoLoader=(n,r)=>Object.assign(Object.assign({},u),{get:()=>((n,r)=>{var i,c,h,d;let p;let f=(0,a.getGlsl)(n.session.backend.glContext.version),m=r.dims,g=m.length,_=r.dims.length,y=(0,o.getCoordsDataType)(_),b=(0,l.getChannels)("rc",_),v=(i=_,c=b,h=m[m.length-2],d=m[m.length-1],0===i||1===i?"":`
    int r = ${c[i-2]};
    int c = ${c[i-1]};
    int rp1 = ${c[i-2]} + 1;
    int cp1 = ${c[i-1]} + 1;
    bool rEdge = rp1 >= ${d};
    bool cEdge = cp1 >= ${h};
    `);p=0===g?[1,1]:1===g?[m[0],1]:[m[_-1],m[_-2]];let x=function(n,r,i){if(0===n)return"false";if(1===n)return`rc > ${r[0]}`;let a="";for(let s=n-2;s<n;s++)a+=`${i[s]} >= ${r[s-n+2]}`,s<n-1&&(a+="||");return a}(_,p,b),w=function(n,r){let i=n.length;if(0===i)return"getA(), 0, 0, 0";if(1===i)return`getA(rc),
            rc + 1 >= ${n[0]} ? 0. : getA(rc + 1),
            0, 0`;let a="";if(i>2)for(let n=0;n<i-2;++n)a+=`${r[n]},`;return`getA(${a}r, c),
          rEdge ? 0. : getA(${a}rp1, c),
          cEdge ? 0. : getA(${a}r, cp1),
          rEdge || cEdge ? 0. : getA(${a}rp1, cp1)`}(m,b),T=`
        void main() {
          ${y} rc = getOutputCoords();

          if(${x}) {
            ${f.output} = vec4(0);
          } else {
            ${v}

            ${f.output} = vec4(${w});
          }
        }
      `;return Object.assign(Object.assign({},u),{hasMain:!0,output:{dims:r.dims,type:r.type,textureType:s.TextureType.packed},shaderSource:T})})(n,r)})},2827:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.unpackFromChannel=r.getChannels=r.getVecChannels=void 0;let a=i(9390);function s(n,r){return(0,a.getGlChannels)(r).map(r=>`${n}.${r}`)}r.getVecChannels=s,r.getChannels=function(n,r){return 1===r?[n]:s(n,r)},r.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},2870:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parsePadAttributesV11=r.padV11=r.parsePadAttributesV2=r.padV2=void 0;let a=i(246),s=i(2517),o=i(5060),l=i(2039),u={name:"Pad",inputNames:["A"],inputTypes:[l.TextureType.unpacked]};r.padV2=(n,r,i)=>(d(r),[n.run(Object.assign(Object.assign({},u),{cacheHint:i.cacheKey,get:()=>h(n,r[0],i)}),r)]),r.parsePadAttributesV2=n=>{let r=n.attributes.getString("mode","constant"),i=n.attributes.getFloat("value",0),s=n.attributes.getInts("pads");return(0,a.createAttributeWithCacheKey)({mode:r,value:i,pads:s})},r.padV11=(n,i,a)=>{p(i);let s=c(n,i,a);return(0,r.padV2)(n,[i[0]],s)},r.parsePadAttributesV11=n=>n.attributes.getString("mode","constant");let c=(n,r,i)=>{if(!n.session.isInitializer(r[1].dataId)||r.length>=3&&!n.session.isInitializer(r[2].dataId))throw Error("dynamic pad attributes are not allowed");let s=Array.from(r[1].integerData),o=r.length>=3?r[2].floatData[0]:0;return(0,a.createAttributeWithCacheKey)({mode:i,pads:s,value:o})},h=(n,r,i)=>{let a=s.ShapeUtil.padShape(r.dims.slice(),i.pads),o=a.length,u=`
      ${f(n,r,i)}
      float process(int[${o}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[l.TextureType.unpacked],output:{dims:a,type:r.type,textureType:l.TextureType.unpacked},shaderSource:u}},d=n=>{if(!n||1!==n.length)throw Error("Pad requires 1 input");if("float32"!==n[0].type&&"float64"!==n[0].type)throw Error("Invalid input type.")},p=n=>{if(!n||2!==n.length&&3!==n.length)throw Error("Pad requires 2 or 3 inputs");if("int32"!==n[1].type||n.length>=3&&"string"===n[2].type)throw Error("Invalid input type.")},f=(n,r,i)=>{let a=(0,o.getGlsl)(n.session.backend.glContext.version),[u,c]=n.calculateTextureWidthAndHeight(r.dims,l.TextureType.unpacked),h=s.ShapeUtil.computeStrides(r.dims);switch(i.mode){case"constant":return m(a,r.dims,h,u,c,i.pads,i.value);case"reflect":return g(a,r.dims,h,u,c,i.pads);case"edge":return _(a,r.dims,h,u,c,i.pads);default:throw Error("Invalid mode")}},m=(n,r,i,a,s,o,l)=>{let u=r.length,c="";for(let n=u-1;n>=0;--n)c+=`
        k = m[${n}] - ${o[n]};
        if (k < 0)  return constant;
        if (k >= ${r[n]}) return constant;
        offset += k * ${i[n]};
        `;return`
      float padA(int m[${u}]) {
        const float constant = float(${l});
        int offset = 0;
        int k = 0;
        ${c}
        vec2 coords = offsetToCoords(offset, ${a}, ${s});
        float value = getColorAsFloat(${n.texture2D}(A, coords));
        return value;
      }
      `},g=(n,r,i,a,s,o)=>{let l=r.length,u="";for(let n=l-1;n>=0;--n)u+=`
        k = m[${n}] - ${o[n]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(r[n]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${r[n]}) { k = _2n_1 - k; }
        }
        offset += k * ${i[n]};
        `;return`
      float padA(int m[${l}]) {
        int offset = 0;
        int k = 0;
        ${u}
        vec2 coords = offsetToCoords(offset, ${a}, ${s});
        float value = getColorAsFloat(${n.texture2D}(A, coords));
        return value;
      }
      `},_=(n,r,i,a,s,o)=>{let l=r.length,u="";for(let n=l-1;n>=0;--n)u+=`
        k = m[${n}] - ${o[n]};
        if (k < 0)  k = 0;
        if (k >= ${r[n]}) k = ${r[n]-1};
        offset += k * ${i[n]};
      `;return`
      float padA(int m[${l}]) {
        int offset = 0;
        int k = 0;
        ${u}
        vec2 coords = offsetToCoords(offset, ${a}, ${s});
        float value = getColorAsFloat(${n.texture2D}(A, coords));
        return value;
      }
      `}},2143:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.globalMaxPool=r.parseMaxPoolAttributes=r.maxPool=r.parseGlobalAveragePoolAttributes=r.globalAveragePool=r.parseAveragePoolAttributes=r.averagePool=void 0;let a=i(246),s=i(2517),o=i(2039);r.averagePool=(n,r,i)=>{p(r);let a={name:"AveragePool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:i.cacheKey};return[n.run(Object.assign(Object.assign({},a),{get:()=>l(r,a,!1,i)}),r)]},r.parseAveragePoolAttributes=n=>{let r=n.attributes.getString("auto_pad","NOTSET"),i=n.attributes.getInt("ceil_mode",0),s=0!==n.attributes.getInt("count_include_pad",0),o=n.attributes.getInts("kernel_shape"),l=n.attributes.getInts("strides",[]),u=n.attributes.getInts("pads",[]);if(0!==i)throw Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,a.createAttributeWithCacheKey)({autoPad:r,ceilMode:i,countIncludePad:s,kernelShape:o,strides:l,pads:u})};let l=(n,r,i,a)=>{let[l,u]=c(n,a,i),h=s.ShapeUtil.size(l.kernelShape),d="";l.countIncludePad?d+=`value /= float(${h});`:d+=`value /= float(${h} - pad);`;let p=`
        ${f(n[0].dims,l,"value += _X(x);",d,"0.0")}
      `;return Object.assign(Object.assign({},r),{output:{dims:u,type:n[0].type,textureType:o.TextureType.unpacked},shaderSource:p})};r.globalAveragePool=(n,r,i)=>{p(r);let a={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:`${i.countIncludePad}`};return[n.run(Object.assign(Object.assign({},a),{get:()=>l(r,a,!0,i)}),r)]},r.parseGlobalAveragePoolAttributes=n=>{let r=0!==n.attributes.getInt("count_include_pad",0);return(0,a.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:r,kernelShape:[],strides:[],pads:[]})},r.maxPool=(n,r,i)=>{p(r);let a={name:"MaxPool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:i.cacheKey};return[n.run(Object.assign(Object.assign({},a),{get:()=>u(r,a,!1,i)}),r)]},r.parseMaxPoolAttributes=n=>{let r=n.attributes.getString("auto_pad","NOTSET"),i=n.attributes.getInt("ceil_mode",0),s=n.attributes.getInts("kernel_shape"),o=n.attributes.getInts("strides",[]),l=n.attributes.getInts("pads",[]),u=n.attributes.getInt("storage_order",0),c=n.attributes.getInts("dilations",[]);if(0!==u)throw Error("column major storage order is not yet supported for MaxPool");if(0!==i)throw Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,a.createAttributeWithCacheKey)({autoPad:r,ceilMode:i,countIncludePad:!1,kernelShape:s,strides:o,pads:l,storageOrder:u,dilations:c})};let u=(n,r,i,a)=>{let[s,l]=c(n,a,i),u=`
      ${f(n[0].dims,s,"\n      value = max(_X(x), value);\n    ","","-1e5")}
    `;return Object.assign(Object.assign({},r),{output:{dims:l,type:n[0].type,textureType:o.TextureType.unpacked},shaderSource:u})},c=(n,r,i)=>{let a=n[0].dims.slice(),o=Object.hasOwnProperty.call(r,"dilations"),l=r.kernelShape.slice(),u=r.strides.slice(),c=o?r.dilations.slice():[],h=r.pads.slice();s.PoolConvUtil.adjustPoolAttributes(i,a,l,u,c,h);let d=s.PoolConvUtil.computePoolOutputShape(i,a,u,c,l,h,r.autoPad),p=Object.assign({},r);return o?Object.assign(p,{kernelShape:l,strides:u,pads:h,dilations:c,cacheKey:r.cacheKey}):Object.assign(p,{kernelShape:l,strides:u,pads:h,cacheKey:r.cacheKey}),[p,d]},h={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},d={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[o.TextureType.unpacked]};r.globalMaxPool=(n,r)=>(p(r),[n.run(Object.assign(Object.assign({},d),{get:()=>u(r,d,!0,h)}),r)]);let p=n=>{if(!n||1!==n.length)throw Error("Pool ops requires 1 input.");if("float32"!==n[0].type&&"float64"!==n[0].type)throw Error("Invalid input type.")},f=(n,r,i,a,o)=>{let l=n.length;if(r.kernelShape.length<=2){let s=r.kernelShape[r.kernelShape.length-1],u=r.strides[r.strides.length-1],c=r.pads[r.pads.length/2-1],h=r.pads[r.pads.length-1],d=n[l-1],p="",f="",m="";if(p=c+h!==0?`
          for (int i = 0; i < ${s}; i++) {
            x[${l} - 1] = indices[${l} - 1] * ${u} - ${c} + i;
            if (x[${l} - 1] < 0 || x[${l} - 1] >= ${d}) {
              pad++;
              continue;
            }
            ${i}
          }`:`
          for (int i = 0; i < ${s}; i++) {
            x[${l} - 1] = indices[${l} - 1] * ${u} - ${c} + i;
            ${i}
          }`,2===r.kernelShape.length){let i=r.kernelShape[r.kernelShape.length-2],a=r.strides[r.strides.length-2],o=r.pads[r.pads.length/2-2],u=r.pads[r.pads.length-2],c=n[l-2];f=o+u!==0?`
            for (int j = 0; j < ${i}; j++) {
              x[${l} - 2] = indices[${l} - 2] * ${a} - ${o} + j;
              if (x[${l} - 2] < 0 || x[${l} - 2] >= ${c}) {
                pad+= ${s};
                continue;
              }
          `:`
            for (int j = 0; j < ${i}; j++) {
              x[${l} - 2] = indices[${l} - 2] * ${a} - ${o} + j;
            `,m="\n          }\n        "}return`
        float process(int indices[${l}]) {
          int x[${l}];
          copyVec(indices, x);

          float value = ${o};
          int pad = 0;
          ${f}
          ${p}
          ${m}
          ${a}
          return value;
        }
      `}{let u=s.ShapeUtil.size(r.kernelShape),c=s.ShapeUtil.computeStrides(r.kernelShape),h=c.length,d=r.pads.length,p=g(h),f=m(n,"inputDims"),_=m(r.pads,"pads"),y=m(c,"kernelStrides"),b=m(r.strides,"strides"),v="";return v=r.pads.reduce((n,r)=>n+r)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${i}
          }`:`
          }
          ${i}
        `,`
        ${p}
        float process(int indices[${l}]) {
          int x[${l}];
          copyVec(indices, x);
          int offset[${h}];
          int pads[${d}];
          int inputDims[${l}];
          int kernelStrides[${h}];
          int strides[${h}];
          ${_}
          ${f}
          ${b}
          ${y}

          float value = ${o};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${u}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${l} - ${h}; j < ${l}; j++) {
              x[j] = indices[j] * strides[j - ${l} + ${h}]
                + offset[j - ${l} + ${h}] - pads[j - 2];
              ${v}
          }
          ${a}

          return value;
        }
      `}},m=(n,r)=>{let i="";for(let a=0;a<n.length;a++)i+=`
      ${r}[${a}] = ${n[a]};
    `;return i},g=n=>`
  void offsetToIndices(int offset, int[${n}] strides, out int[${n}] indices) {
    if (${n} == 0) {
      return;
    }
    for (int i = 0; i < ${n} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${n} - 1] = offset;
  }`},4939:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.reduceLogSumSquare=r.reduceLogSum=r.reduceProd=r.reduceMin=r.reduceMax=r.reduceMean=r.reduceSum=r.parseReduceAttributes=void 0;let a=i(246),s=i(782),o=i(2517),l=i(2039),u=(n,r,i,a,s)=>{h(r);let o={name:a,inputNames:["A"],inputTypes:[l.TextureType.unpacked]};return[n.run(Object.assign(Object.assign({},o),{cacheHint:i.cacheKey,get:()=>c(n,r,i,a,s,o)}),r)]};r.parseReduceAttributes=n=>{let r=n.attributes.getInts("axes",[]),i=1===n.attributes.getInt("keepdims",1);return(0,a.createAttributeWithCacheKey)({axes:r,keepDims:i})};let c=(n,r,i,a,s,u)=>{let c=[],h=r[0].dims.length||1,d=[],p=o.ShapeUtil.normalizeAxes(i.axes,r[0].dims.length),f=s(r,p),m=f[1];for(let n=0;n<r[0].dims.length;n++)p.indexOf(n)>=0||0===p.length?(i.keepDims&&c.push(1),m=`
          for(int j${n} = 0; j${n} < ${r[0].dims[n]}; j${n}++) {
            inputIdx[${n}] = j${n};
            ${m}
          }`):(d.push(`inputIdx[${n}] = outputIdx[${c.length}];`),c.push(r[0].dims[n]));let g=`
      float process(int outputIdx[${c.length||1}]) {
        float value;                 // final result
        int inputIdx[${h}];      // addressing input data
        ${d.join("\n")}
        ${f[0]}       // init ops for reduce max/min
        ${m}
        ${f[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},u),{output:{dims:c,type:r[0].type,textureType:l.TextureType.unpacked},shaderSource:g})},h=n=>{if(!n||1!==n.length)throw Error("Reduce op requires 1 input.");if(-1===s.NUMBER_TYPES.indexOf(n[0].type))throw Error("Invalid input type.")};r.reduceSum=(n,r,i)=>u(n,r,i,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),r.reduceMean=(n,r,i)=>u(n,r,i,"ReduceMean",(n,r)=>{let i=1;for(let a=0;a<n[0].dims.length;a++)(r.indexOf(a)>=0||0===r.length)&&(i*=n[0].dims[a]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${i}.;`]}),r.reduceMax=(n,r,i)=>u(n,r,i,"ReduceMax",(n,r)=>{let i=[];for(let a=0;a<n[0].dims.length;a++)(r.indexOf(a)>=0||0===r.length)&&i.push(`inputIdx[${a}] = 0;`);return[`${i.join("\n")}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),r.reduceMin=(n,r,i)=>u(n,r,i,"ReduceMin",(n,r)=>{let i=[];for(let a=0;a<n[0].dims.length;a++)(r.indexOf(a)>=0||0===r.length)&&i.push(`inputIdx[${a}] = 0;`);return[`${i.join("\n")}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),r.reduceProd=(n,r,i)=>u(n,r,i,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),r.reduceLogSum=(n,r,i)=>u(n,r,i,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),r.reduceLogSumSquare=(n,r,i)=>u(n,r,i,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7019:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.isReshapeCheap=r.processDims3D=r.createPackedReshape3DProgramInfoLoader=void 0;let a=i(2517),s=i(5060),o=i(2039),l=i(2827);r.createPackedReshape3DProgramInfoLoader=(n,r,i)=>{var u;let c=(u=i,{name:"Reshape (packed)",inputTypes:[o.TextureType.packed],inputNames:["A"],cacheHint:`${u}`});return Object.assign(Object.assign({},c),{get:()=>((n,r,i,u)=>{let c=r.dims,h=u,d="";for(let n=0;n<4;n++){let r="";switch(n){case 0:r="outputCoords = rc;";break;case 1:r="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:r="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:r="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw Error()}d+=`
        ${r}
        ${n>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${n}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${n>0?"}":""}
      `}let p=(0,s.getGlsl)(n.session.backend.glContext.version),f=`
      ${function(n){let r=a.ShapeUtil.computeStrides(n),i=["b","r","c"],s="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${r.map((n,a)=>`int ${i[a]} = ${s} / ${n}; ${a===r.length-1?`int ${i[a+1]} = ${s} - ${i[a]} * ${n}`:`index -= ${i[a]} * ${n}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(c)}
      ${function(n){let r=a.ShapeUtil.computeStrides(n);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${r[0]} + coords.z * ${r[1]} + coords.y;
  }
`}(h)}
      ${(0,l.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${h[2]};
        int cols = ${h[1]};

        ${d}
        ${p.output} = result;
      }
    `;return Object.assign(Object.assign({},i),{output:{dims:h,type:r.type,textureType:o.TextureType.packed},shaderSource:f,hasMain:!0})})(n,r,c,i)})},r.processDims3D=function(n){if(0===n.length)return[1,1,1];let r=1;for(let i=0;i<n.length-2;++i)r*=n[i];return[r,n.length>1?n[n.length-2]:1,n[n.length-1]]},r.isReshapeCheap=function(n,r){return 0===n.length||0===r.length||(n.length<2||r.length<2?n[n.length-1]===r[r.length-1]:n[n.length-1]===r[r.length-1]&&n[n.length-2]===r[r.length-2])}},718:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.reshape=void 0;let a=i(2517);r.reshape=(n,r)=>{let i=a.ShapeUtil.calculateReshapedDims(r[0].dims,r[1].integerData);return n.session.pack?[n.reshapePacked(r[0],i)]:[n.reshapeUnpacked(r[0],i)]}},2268:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseResizeAttributesV11=r.parseResizeAttributesV10=r.resize=void 0;let a=i(5060),s=i(2039),o=i(9390),l=i(2827),u=i(9793),c={name:"Resize",inputNames:["A"],inputTypes:[s.TextureType.packed]};r.resize=(n,r,i)=>((0,u.validateInputs)(r,i),[n.run(Object.assign(Object.assign({},c),{cacheHint:i.cacheKey,get:()=>h(n,r,i)}),r)]),r.parseResizeAttributesV10=n=>(0,u.parseUpsampleAttributes)(n,10),r.parseResizeAttributesV11=n=>(0,u.parseUpsampleAttributes)(n,11);let h=(n,r,i)=>{let u=(0,a.getGlsl)(n.session.backend.glContext.version),[h,p]=d(r,i);if(h.every(n=>1===n)&&"tf_crop_and_resize"!==i.coordinateTransformMode)return Object.assign(Object.assign({},c),{output:{dims:p,type:r[0].type,textureType:s.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${u.texture2D}(X, TexCoords);
                    ${u.output} = v;
                }`});let f=p.length;if(f<2)throw Error(`output dimension should be at least 2, but got ${f}`);let m=p[f-2],g=p[f-1],_=r[0].dims;if(f!==_.length)throw Error(`output dimension should match input ${_.length}, but got ${f}`);let y=_[f-2],b=_[f-1],v=h[f-2],x=h[f-1],w="";if("linear"!==i.mode)throw Error(`resize (packed) does not support mode: '${i.mode}'`);switch(i.coordinateTransformMode){case"asymmetric":w="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":w="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":w=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${g}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${m}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${g}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${m}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":w=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${g}.0 - 1.0, ${m}.0 - 1.0, ${g}.0 - 1.0,
                            ${m}.0 - 1.0);
                        vec4 original = vec4(${b}.0 - 1.0, ${y}.0 - 1.0, ${b}.0 - 1.0,
                            ${y}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw Error(`resize (packed) does not support coordinateTransformMode:                                 '${i.coordinateTransformMode}'`)}let T=(0,o.getCoordsDataType)(f),S=`
            const vec2 inputWH = vec2(${y}.0, ${b}.0);
            const vec4 scaleWHWH = vec4(float(${v}), float(${x}), float(${v}), float(${x}));
            ${(0,l.unpackFromChannel)()}
            ${w}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${T} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${m-1};
                bool hasNextCol = rc.z < ${g-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${u.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},c),{output:{dims:p,type:r[0].type,textureType:s.TextureType.packed},hasMain:!0,shaderSource:S})},d=(n,r)=>{let i=n[0].dims,a,s=r.scales;if(0===s.length){let o=n[r.scalesInputIdx];if(o&&0!==o.size){if(n[r.sizesInputIdx])throw Error("Only one of scales or sizes must be provided as input.");s=p(o,r.mode,r.isResize)}else{let o=n[r.sizesInputIdx];if(!o||0===o.size)throw Error("Either scales or sizes MUST be provided as input.");s=f(a=Array.from(o.integerData),i,r.mode,r.isResize)}}else if(n[r.sizesInputIdx])throw Error("Only one of scales or sizes must be provided as input.");let o=a||i.map((n,r)=>Math.floor(n*s[r]));return[s,o]},p=(n,r,i)=>{let a=Array.from(n.floatData);return(0,u.scalesValidation)(a,r,i),a},f=(n,r,i,a)=>{let s=r.length,o=Array(s);for(let i=0,a=s;i<a;i++)if(0===r[i]){if(0!==n[i])throw Error("Input dim is zero but required output dim is non-zero.");o[i]=1}else o[i]=n[i]/r[i];return(0,u.scalesValidation)(o,i,a),o}},8117:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.shape=void 0;let a=i(9162);r.shape=(n,r)=>(s(r),[new a.Tensor([r[0].dims.length],"int32",void 0,void 0,new Int32Array(r[0].dims))]);let s=n=>{if(!n||1!==n.length)throw Error("Shape requires 1 input.")}},2278:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.sliceV10=r.parseSliceAttributes=r.slice=void 0;let a=i(246),s=i(782),o=i(2517),l=i(2039),u={name:"Slice",inputNames:["A"],inputTypes:[l.TextureType.unpacked]};r.slice=(n,r,i)=>(h(r),[n.run(Object.assign(Object.assign({},u),{cacheHint:i.cacheKey,get:()=>c(n,r[0],i)}),r)]),r.parseSliceAttributes=n=>{let r=n.attributes.getInts("starts"),i=n.attributes.getInts("ends"),s=n.attributes.getInts("axes",[]);return(0,a.createAttributeWithCacheKey)({starts:r,ends:i,axes:s})};let c=(n,r,i)=>{let a=0===i.axes.length?r.dims.slice(0).map((n,r)=>r):i.axes,s=o.ShapeUtil.normalizeAxes(a,r.dims.length),c=i.starts.map((n,i)=>n>r.dims[s[i]]-1?r.dims[s[i]]:o.ShapeUtil.normalizeAxis(n,r.dims[s[i]])),h=i.ends.map((n,i)=>n>r.dims[s[i]]-1?r.dims[s[i]]:o.ShapeUtil.normalizeAxis(n,r.dims[s[i]])),d=r.dims.slice(),p=[];for(let n=0;n<s.length;n++)d[s[n]]=h[n]-c[n],c[n]>0&&p.push(`outputIdx[${s[n]}] += ${c[n]};`);let f=`
      float process(int outputIdx[${d.length}]) {
        ${p.join("\n      ")}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},u),{output:{dims:d,type:r.type,textureType:l.TextureType.unpacked},shaderSource:f})},h=n=>{if(!n||1!==n.length)throw Error("Slice requires 1 input.");if(-1===s.NUMBER_TYPES.indexOf(n[0].type))throw Error("Invalid input type.")};r.sliceV10=(n,r)=>{p(r);let i=d(n,r);return[n.run(Object.assign(Object.assign({},u),{cacheHint:i.cacheKey,get:()=>c(n,r[0],i)}),[r[0]])]};let d=(n,r)=>{if(!n.session.isInitializer(r[1].dataId)||!n.session.isInitializer(r[2].dataId)||r.length>=4&&!n.session.isInitializer(r[3].dataId)||r.length>=5&&!n.session.isInitializer(r[4].dataId))throw Error("dynamic slice attributes are not allowed");if(r.length>=5&&r[4].integerData.some(n=>1!==n))throw Error("currently non-1 steps is not supported for Slice");let i=Array.from(r[1].integerData),a=Array.from(r[2].integerData),s=r.length>=4?Array.from(r[3].integerData):[];return{starts:i,ends:a,axes:s,cacheKey:`${s};${i};${a}`}},p=n=>{if(!n||n.length<3||n.length>5)throw Error("Invalid input number.");if("int32"!==n[1].type||1!==n[1].dims.length||"int32"!==n[2].type||1!==n[2].dims.length||n.length>=4&&("int32"!==n[3].type||1!==n[3].dims.length)||n.length>=5&&("int32"!==n[4].type||1!==n[4].dims.length))throw Error("Invalid input type.")}},5524:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.softmaxV13=r.parseSoftmaxAttributesV13=r.parseSoftmaxAttributes=r.softmax=void 0;let a=i(246),s=i(2517),o=i(5060),l=i(2039),u=i(3738),c={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[l.TextureType.unpacked]},h={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[l.TextureType.unpacked,l.TextureType.unpacked]},d={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[l.TextureType.unpacked,l.TextureType.unpacked,l.TextureType.unpacked]};r.softmax=(n,r,i)=>{_(r);let a=r[0].dims.slice(),o=s.ShapeUtil.normalizeAxis(i.axis,a.length),l=s.ShapeUtil.sizeToDimension(a,o),u=s.ShapeUtil.sizeFromDimension(a,o);return p(n,r,i,l,u)},r.parseSoftmaxAttributes=n=>(0,a.createAttributeWithCacheKey)({axis:n.attributes.getInt("axis",1)}),r.parseSoftmaxAttributesV13=n=>(0,a.createAttributeWithCacheKey)({axis:n.attributes.getInt("axis",-1)}),r.softmaxV13=(n,r,i)=>{_(r);let o=r[0].dims.slice(),l=s.ShapeUtil.normalizeAxis(i.axis,o.length),c=o.length,h=l!==c-1,d=[],f,m=[],g=[];h&&((m=Array.from({length:c}).map((n,r)=>r))[l]=c-1,m[c-1]=l,m.map(n=>d.push(o[n])),f=(0,a.createAttributeWithCacheKey)({perm:m}),g=(0,u.transpose)(n,r,f));let y=h?s.ShapeUtil.sizeToDimension(d,c-1):s.ShapeUtil.sizeToDimension(o,c-1),b=h?s.ShapeUtil.sizeFromDimension(d,c-1):s.ShapeUtil.sizeFromDimension(o,c-1),v=p(n,h?g:r,i,y,b);return h?(0,u.transpose)(n,v,f):v};let p=(n,r,i,a,s)=>{let o=f(n,r[0],a,s,[a]),l=n.run(Object.assign(Object.assign({},c),{cacheHint:i.cacheKey,get:()=>o}),r),u=m(n,r[0],a,s,o.output.dims,[a]),p=n.run(Object.assign(Object.assign({},h),{cacheHint:i.cacheKey,get:()=>u}),[r[0],l]),_=g(n,r[0],a,s,o.output.dims,u.output.dims);return[n.run(Object.assign(Object.assign({},d),{cacheHint:i.cacheKey,get:()=>_}),[r[0],l,p])]},f=(n,r,i,a,s)=>{let[u,h]=n.calculateTextureWidthAndHeight(r.dims,l.TextureType.unpacked),d=s.length;if(i<1||a<1)throw Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length)throw Error("Dimensionality of the output should be 1");if(s[0]!==i)throw Error("Shape of the output should be equal to logical row count");let p=(0,o.getGlsl)(n.session.backend.glContext.version),f=`
      float process(int[${d}] indices) {
        int logical_row_start_offset = indices[0] * ${a};

        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${u},
        ${h} )));
        for(int i=1; i<${a}; ++i)
        {
          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${u}, ${h})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},c),{output:{dims:s,type:r.type,textureType:l.TextureType.unpacked},shaderSource:f})},m=(n,r,i,a,s,u)=>{let[c,d]=n.calculateTextureWidthAndHeight(r.dims,l.TextureType.unpacked),p=u.length;if(i<1||a<1)throw Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==u.length)throw Error("Dimensionality of the output should be 1");if(u[0]!==i)throw Error("Shape of the output should be equal to logical row count");if(1!==s.length)throw Error("Dimensionality of the intermediate results should be 1");if(s[0]!==i)throw Error("Shape of the intermediate results should be equal to logical row count");let f=`
      float process(int[${p}] indices) {
        int logical_row_start_offset = indices[0] * ${a};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${a}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,o.getGlsl)(n.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${c}, ${d}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},h),{output:{dims:u,type:r.type,textureType:l.TextureType.unpacked},shaderSource:f})},g=(n,r,i,a,s,o)=>{let[u,c]=n.calculateTextureWidthAndHeight(r.dims,l.TextureType.unpacked),h=r.dims.length;if(i<1||a<1)throw Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length||1!==o.length)throw Error("Dimensionality of the intermediate results should be 1");if(s[0]!==i||o[0]!==i)throw Error("Shape of the intermediate results should be equal to logical row count");let p=`
      float process(int[${h}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${u}, ${c});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${a};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},d),{output:{dims:r.dims,type:r.type,textureType:l.TextureType.unpacked},shaderSource:p})},_=n=>{if(!n||1!==n.length)throw Error("Softmax requires 1 input.");if("float32"!==n[0].type&&"float64"!==n[0].type)throw Error("Invalid input type")}},5975:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseSplitAttributes=r.split=void 0;let a=i(246),s=i(2517),o=i(2039),l={name:"Split",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};r.split=(n,r,i)=>{h(r);let a=s.ShapeUtil.normalizeAxis(i.axis,r[0].dims.length),o=u(n,r,a,i),d=[];for(let s=0;s<o;++s)d.push(n.run(Object.assign(Object.assign({},l),{cacheHint:`${i.cacheKey};${s}`,get:()=>c(n,r[0],i,a,s)}),r));return d},r.parseSplitAttributes=n=>{let r=n.attributes.getInt("axis",0),i=n.attributes.getInts("split",[]),s=n.outputs.length;return(0,a.createAttributeWithCacheKey)({axis:r,split:i,numOutputs:s})};let u=(n,r,i,a)=>{let[,o]=s.SplitUtil.splitShape(r[0].dims,i,a.split,a.numOutputs);return o.length},c=(n,r,i,a,u)=>{let[c,h]=s.SplitUtil.splitShape(r.dims,a,i.split,i.numOutputs),d=h[u],p=c[u],f=`
      float process(int indices[${p.length}]) {
        indices[${a}] += ${d};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},l),{cacheHint:`${i.cacheKey}:${u}`,output:{dims:p,type:r.type,textureType:o.TextureType.unpacked},shaderSource:f})},h=n=>{if(!n||1!==n.length)throw Error("Split requires one input.");if("int8"!==n[0].type&&"uint8"!==n[0].type&&"int16"!==n[0].type&&"uint16"!==n[0].type&&"int32"!==n[0].type&&"uint32"!==n[0].type&&"float32"!==n[0].type&&"float64"!==n[0].type&&"bool"!==n[0].type)throw Error("Invalid input type.")}},3933:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseSqueezeAttributes=r.squeezeV13=r.squeeze=void 0;let a=i(2517);r.squeeze=(n,r,i)=>{s(r);let o=a.ShapeUtil.squeezeShape(r[0].dims,i);return[n.reshapeUnpacked(r[0],o)]},r.squeezeV13=(n,i)=>(o(i),(0,r.squeeze)(n,[i[0]],Array.from(i[1].integerData))),r.parseSqueezeAttributes=n=>n.attributes.getInts("axes");let s=n=>{if(!n||1!==n.length)throw Error("Squeeze requires 1 input.");if("string"===n[0].type)throw Error("invalid input tensor types.")},o=n=>{if(!n||2!==n.length)throw Error("Squeeze requires 2 inputs.");if("int32"!==n[1].type)throw Error("Invalid input type.")}},6558:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.sum=void 0;let a=i(5060),s=i(2039);r.sum=(n,r)=>{l(r);let i={name:"Sum",inputNames:r.map((n,r)=>`X${r}`),inputTypes:Array(r.length).fill(s.TextureType.unpacked)};return[n.run(Object.assign(Object.assign({},i),{get:()=>o(n,r,i)}),r)]};let o=(n,r,i)=>{let o=(0,a.getGlsl)(n.session.backend.glContext.version),l=r[0].dims.slice(),u=`
      void main() {
        vec4 result = ${r.map((n,r)=>`${o.texture2D}(X${r},TexCoords)`).join(" + ")};
        ${o.output} = result;
      }
    `;return Object.assign(Object.assign({},i),{output:{dims:l,type:r[0].type,textureType:s.TextureType.unpacked},hasMain:!0,shaderSource:u})},l=n=>{if(!n||0===n.length)throw Error("Sum requires inputs.");let r=n[0].dims.length;for(let i=1;i<n.length;i++){if(r!==n[i].dims.length)throw Error("Input shapes are mismatched.");for(let a=0;a<r;a++)if(n[0].dims[a]!==n[i].dims[a])throw Error("Input shapes are not matched.")}if("float32"!==n[0].type&&"float64"!==n[0].type)throw Error("Invalid input type.");for(let r=1;r<n.length;r++)if(n[0].type!==n[r].type)throw Error("Input types are not matched.")}},5723:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.tile=void 0;let a=i(782),s=i(2039);r.tile=(n,r)=>{l(r);let i={name:"Tile",inputNames:["A"],inputTypes:[s.TextureType.unpacked]};return[n.run(Object.assign(Object.assign({},i),{get:()=>o(n,r,i)}),r)]};let o=(n,r,i)=>{let a=r[0].dims.slice(),o=Array(a.length),l=[];for(let n=0;n<a.length;n++)o[n]=a[n]*r[1].numberData[n],l.push(`inputIdx[${n}] = int(mod(float(outputIdx[${n}]), ${a[n]}.));`);let u=o.length,c=`
      float process(int outputIdx[${u}]) {
        int inputIdx[${u}];
        ${l.join("\n")}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},i),{output:{dims:o,type:r[0].type,textureType:s.TextureType.unpacked},shaderSource:c})},l=n=>{if(!n||2!==n.length)throw Error("Tile requires 2 input.");if(1!==n[1].dims.length)throw Error("The second input shape must 1 dimension.");if(n[1].dims[0]!==n[0].dims.length)throw Error("Invalid input shape.");if(-1===a.NUMBER_TYPES.indexOf(n[0].type))throw Error("Invalid input type.");if("int32"!==n[1].type&&"int16"!==n[1].type)throw Error("Invalid repeat type.")}},3738:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseTransposeAttributes=r.transpose=void 0;let a=i(246),s=i(2517),o=i(2039),l={name:"Transpose",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};r.transpose=(n,r,i)=>(p(r),[n.run(Object.assign(Object.assign({},l),{cacheHint:i.cacheKey,get:()=>u(n,r[0],i.perm)}),r)]),r.parseTransposeAttributes=n=>(0,a.createAttributeWithCacheKey)({perm:n.attributes.getInts("perm",[])});let u=(n,r,i)=>{let a=r.dims;i=c(a,i);let s=h(a,i),u=a.length,p=`
      ${d("perm",i,u)}
      float process(int indices[${u}]) {
        int a[${u}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},l),{output:{dims:s,type:r.type,textureType:o.TextureType.unpacked},shaderSource:p})},c=(n,r)=>(r&&r.length!==n.length&&(r=[...n.keys()].reverse()),r),h=(n,r)=>(r=c(n,r),s.ShapeUtil.sortBasedOnPerm(n,r)),d=(n,r,i)=>{let a=[];a.push(`void ${n}(out int a[${i}], int src[${i}]) {`);for(let n=0;n<i;++n)a.push(`	a[${r[n]}]=src[${n}];`);return a.push("	}"),a.join("\n")},p=n=>{if(!n||1!==n.length)throw Error("Transpose requires 1 input.");if("float32"!==n[0].type&&"float64"!==n[0].type)throw Error("input should be float tensor")}},8710:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.encodeAsUint8=void 0;let a=i(5060),s=i(2039);r.encodeAsUint8=(n,r)=>{let i=r.shape,o=(0,a.getGlsl)(n.session.backend.glContext.version),l=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${o.texture2D}(X,TexCoords).r;
      ${o.output} = encodeAsUint8(value);
    }`,u={name:"Uint8Encode",inputTypes:[s.TextureType.unpacked],inputNames:["X"],output:{dims:i,type:r.tensor.type,textureType:s.TextureType.downloadUint8AsFloat},shaderSource:l,hasMain:!0};return n.executeProgram(u,[r.tensor])}},4909:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.tanh=r.tan=r.sqrt=r.sin=r.sigmoid=r.relu=r.not=r.neg=r.log=r.parseLeakyReluAttributes=r.leakyRelu=r.identity=r.floor=r.exp=r.parseEluAttributes=r.elu=r.cos=r.ceil=r.clipV11=r.parseClipAttributes=r.clip=r.atan=r.asin=r.acos=r.abs=r.glslTanh=r.glslTan=r.glslSqrt=r.glslSigmoid=r.glslRelu=r.glslSin=r.glslNot=r.glslNeg=r.glslLog=r.glslLeakyRelu=r.glslIdentity=r.glslClip=r.glslFloor=r.glslExp=r.glslElu=r.glslCos=r.glslCeil=r.glslAtan=r.glslAsin=r.glslAcos=r.glslAbs=void 0;let a=i(246),s=i(2517),o=i(8520),l=i(5060),u=i(2039);function c(){return R("abs")}function h(){return R("acos")}function d(){return R("asin")}function p(){return R("atan")}function f(){return R("ceil")}function m(){return R("cos")}function g(n){let r="elu";return{body:`
  const float alpha = float(${n});

  float ${r}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:o.FunctionType.ValueBased}}function _(){return R("exp")}function y(){return R("floor")}function b(n,r){let i="clip";return{body:`
  const float min = float(${n});
  const float max = float(${r});

  float ${i}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${i}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:i,type:o.FunctionType.ValueBased}}function v(){let n="indentity";return{body:`
  float ${n}_(float a) {
    return a;
  }
  vec4 ${n}_(vec4 v) {
    return v;
  }
  `,name:n,type:o.FunctionType.ValueBased}}function x(n){let r="leakyRelu";return{body:`
  const float alpha = float(${n});

  float ${r}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:o.FunctionType.ValueBased}}function w(){return R("log")}function T(){let n="neg";return{body:`
  float ${n}_(float a) {
    return -a;
  }
  vec4 ${n}_(vec4 v) {
    return -v;
  }
  `,name:n,type:o.FunctionType.ValueBased}}function S(){let n="not";return{body:`
  float ${n}_(float a) {
    return float( ! bool(a) );
  }
  bool ${n}_(bool a) {
    return !a;
  }
  vec4 ${n}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${n}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:n,type:o.FunctionType.ValueBased}}function E(){return R("sin")}function A(){let n="relu";return{body:`
  float ${n}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${n}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:n,type:o.FunctionType.ValueBased}}function M(){let n="sigmoid";return{body:`
  float ${n}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${n}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:n,type:o.FunctionType.ValueBased}}function I(){return R("sqrt")}function P(){return R("tan")}function O(){let n="tanh";return{body:`
  float ${n}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${n}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:n,type:o.FunctionType.ValueBased}}function R(n){return{body:`
  float ${n}_(float a) {
    return ${n}(a);
  }
  vec4 ${n}_(vec4 v) {
    return ${n}(v);
  }
  `,name:n,type:o.FunctionType.ValueBased}}r.glslAbs=c,r.glslAcos=h,r.glslAsin=d,r.glslAtan=p,r.glslCeil=f,r.glslCos=m,r.glslElu=g,r.glslExp=_,r.glslFloor=y,r.glslClip=b,r.glslIdentity=v,r.glslLeakyRelu=x,r.glslLog=w,r.glslNeg=T,r.glslNot=S,r.glslSin=E,r.glslRelu=A,r.glslSigmoid=M,r.glslSqrt=I,r.glslTan=P,r.glslTanh=O;let C=(n,r,i,a)=>{let s=n.session.pack?u.TextureType.packed:u.TextureType.unpacked,o={name:i.name,inputTypes:[s],inputNames:["A"],cacheHint:a};return Object.assign(Object.assign({},o),{get:()=>((n,r,i,a)=>{let s=n.session.pack?u.TextureType.packed:u.TextureType.unpacked,o=(0,l.getGlsl)(n.session.backend.glContext.version);return Object.assign(Object.assign({},r),{output:{dims:i.dims,type:i.type,textureType:s},shaderSource:`
     ${a.body}
     void main() {
       vec4 v = ${o.texture2D}(A, TexCoords);
       v = ${a.name}_(v);
       ${o.output} = v;
     }
     `,hasMain:!0})})(n,o,r,i)})};r.abs=(n,r)=>[n.run(C(n,r[0],c()),r)],r.acos=(n,r)=>[n.run(C(n,r[0],h()),r)],r.asin=(n,r)=>[n.run(C(n,r[0],d()),r)],r.atan=(n,r)=>[n.run(C(n,r[0],p()),r)],r.clip=(n,r,i)=>[n.run(C(n,r[0],b(i.min,i.max),i.cacheKey),r)],r.parseClipAttributes=n=>(0,a.createAttributeWithCacheKey)({min:n.attributes.getFloat("min",s.MIN_CLIP),max:n.attributes.getFloat("max",s.MAX_CLIP)}),r.clipV11=(n,i)=>{let a=L(n,i);return(0,r.clip)(n,[i[0]],a)};let L=(n,r)=>{if(r.length>=3&&(!n.session.isInitializer(r[1].dataId)||!n.session.isInitializer(r[2].dataId)))throw Error("dynamic clip attributes are not allowed");let i=r.length>=3?r[1].numberData[0]:s.MIN_CLIP,o=r.length>=3?r[2].numberData[0]:s.MAX_CLIP;return(0,a.createAttributeWithCacheKey)({min:i,max:o})};r.ceil=(n,r)=>[n.run(C(n,r[0],f()),r)],r.cos=(n,r)=>[n.run(C(n,r[0],m()),r)],r.elu=(n,r,i)=>[n.run(C(n,r[0],g(i.alpha),i.cacheKey),r)],r.parseEluAttributes=n=>(0,a.createAttributeWithCacheKey)({alpha:n.attributes.getFloat("alpha",1)}),r.exp=(n,r)=>[n.run(C(n,r[0],_()),r)],r.floor=(n,r)=>[n.run(C(n,r[0],y()),r)],r.identity=(n,r)=>[n.run(C(n,r[0],v()),r)],r.leakyRelu=(n,r,i)=>[n.run(C(n,r[0],x(i.alpha),i.cacheKey),r)],r.parseLeakyReluAttributes=n=>(0,a.createAttributeWithCacheKey)({alpha:n.attributes.getFloat("alpha",.01)}),r.log=(n,r)=>[n.run(C(n,r[0],w()),r)],r.neg=(n,r)=>[n.run(C(n,r[0],T()),r)],r.not=(n,r)=>[n.run(C(n,r[0],S()),r)],r.relu=(n,r)=>[n.run(C(n,r[0],A()),r)],r.sigmoid=(n,r)=>[n.run(C(n,r[0],M()),r)],r.sin=(n,r)=>[n.run(C(n,r[0],E()),r)],r.sqrt=(n,r)=>[n.run(C(n,r[0],I()),r)],r.tan=(n,r)=>[n.run(C(n,r[0],P()),r)],r.tanh=(n,r)=>[n.run(C(n,r[0],O()),r)]},5611:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createUnpackProgramInfoLoader=r.createUnpackProgramInfo=void 0;let a=i(5060),s=i(2039),o=i(9390),l=i(2827),u={name:"unpack",inputNames:["A"],inputTypes:[s.TextureType.packed]};r.createUnpackProgramInfo=(n,r)=>{let i=r.dims.length,c=(0,l.getChannels)("rc",i),h=c.slice(-2),d=(0,o.getCoordsDataType)(i),p=(0,l.unpackFromChannel)(),f=0===r.dims.length?"":function(n,r){if(1===n)return"rc";let i="";for(let a=0;a<n;a++)i+=r[a],a<n-1&&(i+=",");return i}(i,c),m=i<=1?"rc":`vec2(${h.join(",")})`,g=`
    ${p}
    void main() {
      ${d} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${f});

       ${(0,a.getGlsl)(n.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${m}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},u),{hasMain:!0,output:{dims:r.dims,type:r.type,textureType:s.TextureType.unpacked},shaderSource:g})},r.createUnpackProgramInfoLoader=(n,i)=>Object.assign(Object.assign({},u),{get:()=>(0,r.createUnpackProgramInfo)(n,i)})},8428:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.parseUnsqueezeAttributes=r.unsqueezeV13=r.unsqueeze=void 0;let a=i(2517);r.unsqueeze=(n,r,i)=>{s(r);let o=a.ShapeUtil.unsqueezeShape(r[0].dims,i);return[n.reshapeUnpacked(r[0],o)]},r.unsqueezeV13=(n,i)=>(o(i),(0,r.unsqueeze)(n,[i[0]],Array.from(i[1].integerData))),r.parseUnsqueezeAttributes=n=>n.attributes.getInts("axes");let s=n=>{if(!n||1!==n.length)throw Error("Unsqueeze requires 1 input.");if("string"===n[0].type)throw Error("invalid input tensor types.")},o=n=>{if(!n||2!==n.length)throw Error("Unsqueeze requires 2 inputs.");if("int32"!==n[1].type)throw Error("Invalid input type.")}},9793:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.scalesValidation=r.validateInputs=r.parseUpsampleAttributes=r.parseUpsampleAttributesV9=r.parseUpsampleAttributesV7=r.upsample=void 0;let a=i(246),s=i(5060),o=i(2039),l={name:"Upsample",inputNames:["X"],inputTypes:[o.TextureType.unpacked]};r.upsample=(n,i,a)=>((0,r.validateInputs)(i,a),[n.run(Object.assign(Object.assign({},l),{cacheHint:a.cacheKey,get:()=>u(n,i,a)}),i)]),r.parseUpsampleAttributesV7=n=>(0,r.parseUpsampleAttributes)(n,7),r.parseUpsampleAttributesV9=n=>(0,r.parseUpsampleAttributes)(n,9),r.parseUpsampleAttributes=(n,i)=>{let s=i>=10,o=n.attributes.getString("mode","nearest");if("nearest"!==o&&"linear"!==o&&(i<11||"cubic"!==o))throw Error(`unrecognized mode: ${o}`);let l=[];i<9&&(l=n.attributes.getFloats("scales"),(0,r.scalesValidation)(l,o,s));let u=n.attributes.getFloat("extrapolation_value",0),c=i>10?n.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(c))throw Error(`coordinate_transform_mode '${c}' is not supported`);let h="tf_crop_and_resize"===c,d=h,p="nearest"===o&&i>=11?n.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(p))throw Error(`nearest_mode '${p}' is not supported`);let f=n.attributes.getFloat("cubic_coeff_a",-.75),m=0!==n.attributes.getInt("exclude_outside",0);if(m&&"cubic"!==o)throw Error("exclude_outside can be set to 1 only when mode is CUBIC.");let g=i<11||"nearest"===o&&"asymmetric"===c&&"floor"===p,_=0,y=0,b=0;return i>10?n.inputs.length>2?(_=1,y=2,b=3):(y=1,b=2):9===i&&(y=1),(0,a.createAttributeWithCacheKey)({opset:i,isResize:s,mode:o,scales:l,extrapolationValue:u,coordinateTransformMode:c,useExtrapolation:d,needRoiInput:h,nearestMode:p,cubicCoefficientA:f,excludeOutside:m,useNearest2xOptimization:g,roiInputIdx:_,scalesInputIdx:y,sizesInputIdx:b})};let u=(n,r,i)=>{let a=(0,s.getGlsl)(n.session.backend.glContext.version),[u,c]=n.calculateTextureWidthAndHeight(r[0].dims,o.TextureType.unpacked),h=r[0].dims.map((n,r)=>Math.floor(n*i.scales[r])),[d,p]=n.calculateTextureWidthAndHeight(h,o.TextureType.unpacked),f=h.length,m=Array(f),g=Array(f),_=`
      int output_pitches[${f}];
      int input_pitches[${f}];
      `;for(let n=f-1;n>=0;n--)m[n]=n===f-1?1:m[n+1]*h[n+1],g[n]=n===f-1?1:g[n+1]*r[0].dims[n+1],_+=`
        output_pitches[${n}] = ${m[n]};
        input_pitches[${n}] = ${g[n]};
        `;let y=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${u}, ${c});
        float value = getColorAsFloat(${a.texture2D}(X, coords));
        return value;
      }
      `,b="nearest"===i.mode?`
    ${y}
    float process(int indices[${f}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${d}, ${p});

      ${_}

      int d, m;
      for (int dim = 0; dim < ${f}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:4===f?`
    ${y}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${d}, ${p});

      ${_}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${r[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${y}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${d}, ${p});

      ${_}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${r[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},l),{output:{dims:h,type:r[0].type,textureType:o.TextureType.unpacked},shaderSource:b,variables:[{name:"scales",type:"int",arrayLength:i.scales.length,data:i.scales.map(n=>Math.ceil(n))}]})};r.validateInputs=(n,r)=>{if(!n||r.opset<9&&1!==n.length||r.opset>=9&&r.opset<11&&2!==n.length||r.opset>=11&&n.length<2)throw Error("invalid inputs.");if(r.scales.length>0&&n[0].dims.length!==r.scales.length)throw Error("Invalid input shape.");if("string"===n[0].type)throw Error("Invalid input tensor types.")},r.scalesValidation=(n,r,i)=>{if(i){for(let r of n)if(r<=0)throw Error("Scale value should be greater than 0.")}else for(let r of n)if(r<1)throw Error("Scale value should be greater than or equal to 1.");if(!("linear"!==r&&"cubic"!==r||2===n.length||4===n.length&&1===n[0]&&1===n[1]))throw Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${i?"Resize":"Upsample"} opeartor.`)}},1958:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.ProgramManager=void 0;let a=i(1670),s=i(6231),o=i(8879),l=i(5060);r.ProgramManager=class{constructor(n,r,i){this.profiler=n,this.glContext=r,this.textureLayoutStrategy=i,this.repo=new Map,this.attributesBound=!1}getArtifact(n){return this.repo.get(n)}setArtifact(n,r){this.repo.set(n,r)}run(n,r,i){var a;this.profiler.event("op",`ProgramManager.run ${null!==(a=n.programInfo.name)&&void 0!==a?a:"unknown kernel"}`,()=>{var a;let o=this.glContext.gl,l=n.program;o.useProgram(l);try{this.bindOutput(i),this.attributesBound||this.bindAttributes(n.attribLocations),this.bindUniforms(n.uniformLocations,null!==(a=n.programInfo.variables)&&void 0!==a?a:[],r)}catch(r){throw s.Logger.error("ProgramManager",n.programInfo.shaderSource),r}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(n=>this.glContext.deleteProgram(n.program))}build(n,r,i){return this.profiler.event("backend","ProgramManager.build",()=>{let a=new o.GlslPreprocessor(this.glContext,n,r,i),s=a.preprocess(),l=this.compile(s);return{programInfo:n,program:l,uniformLocations:this.getUniformLocations(l,a.context.programInfo.inputNames,a.context.programInfo.variables),attribLocations:this.getAttribLocations(l)}})}compile(n){if(!this.vertexShader){s.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let n=(0,l.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(n,this.glContext.gl.VERTEX_SHADER)}a.env.debug&&s.Logger.verbose("ProrgramManager",`FragShader:
${n}
`);let r=this.glContext.compileShader(n,this.glContext.gl.FRAGMENT_SHADER),i=this.glContext.createProgram(this.vertexShader,r);return this.glContext.deleteShader(r),i}bindOutput(n){let r=n.width,i=n.height;s.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${r}/${i}, shape=${n.shape}, type=${n.tensor.type}`),this.glContext.attachFramebuffer(n.texture,r,i)}bindAttributes(n){let r=n.position,i=n.textureCoord;this.glContext.setVertexAttributes(r,i),this.attributesBound=!0}bindUniforms(n,r,i){var a;let s=this.glContext.gl,o=0;for(let{name:l,type:u,location:c,arrayLength:h}of n){let n=null===(a=r.find(n=>n.name===l))||void 0===a?void 0:a.data;if("sampler2D"!==u&&!n)throw Error(`variable '${l}' does not have data defined in program info`);switch(u){case"sampler2D":this.bindTexture(i[o],c,o),o++;break;case"float":h?s.uniform1fv(c,n):s.uniform1f(c,n);break;case"int":h?s.uniform1iv(c,n):s.uniform1i(c,n);break;default:throw Error(`Uniform not implemented: ${u}`)}}}bindTexture(n,r,i){this.glContext.bindTextureToUniform(n.texture,i,r)}getAttribLocations(n){return{position:this.getAttribLocation(n,"position"),textureCoord:this.getAttribLocation(n,"textureCoord")}}getUniformLocations(n,r,i){let a=[];if(r)for(let i of r)a.push({name:i,type:"sampler2D",location:this.getUniformLocation(n,i)});if(i)for(let r of i)a.push(Object.assign(Object.assign({},r),{location:this.getUniformLocation(n,r.name)}));return a}getUniformLocation(n,r){let i=this.glContext.gl.getUniformLocation(n,r);if(null===i)throw Error(`Uniform ${r} not found.`);return i}getAttribLocation(n,r){return this.glContext.gl.getAttribLocation(n,r)}}},6416:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.WebGLSessionHandler=void 0;let a=i(6231),s=i(1047),o=i(8316),l=i(1640),u=i(1958),c=i(7859),h=i(5702);r.WebGLSessionHandler=class{constructor(n,r){this.backend=n,this.context=r,this.layoutStrategy=new c.PreferLogicalStrategy(n.glContext.maxTextureSize),this.programManager=new u.ProgramManager(this.context.profiler,n.glContext,this.layoutStrategy),this.textureManager=new h.TextureManager(n.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===n.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=n.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new o.WebGLInferenceHandler(this)}onGraphInitialized(n){let r=n.getValues().filter(n=>-1===n.from&&n.tensor).map(n=>n.tensor.dataId);this.initializers=new Set(r)}isInitializer(n){return!!this.initializers&&this.initializers.has(n)}addInitializer(n){this.initializers.add(n)}getTextureData(n,r){return r?this.packedTextureDataCache.get(n):this.unpackedTextureDataCache.get(n)}setTextureData(n,r,i=!1){a.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),i?this.packedTextureDataCache.set(n,r):this.unpackedTextureDataCache.set(n,r)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(n=>this.textureManager.releaseTexture(n,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(n=>this.textureManager.releaseTexture(n,!0)),this.unpackedTextureDataCache=new Map}resolve(n,r,i){let a=(0,s.resolveOperator)(n,r,l.WEBGL_OP_RESOLVE_RULES);return{impl:a.opImpl,context:a.opInit?a.opInit(n,i):n}}}},7769:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Uint8DataEncoder=r.RGBAFloatDataEncoder=r.RedFloat32DataEncoder=void 0;let a=i(6231);r.RedFloat32DataEncoder=class{constructor(n,r=1){if(1===r)this.internalFormat=n.R32F,this.format=n.RED,this.textureType=n.FLOAT,this.channelSize=r;else{if(4!==r)throw Error(`Invalid number of channels: ${r}`);this.internalFormat=n.RGBA32F,this.format=n.RGBA,this.textureType=n.FLOAT,this.channelSize=r}}encode(n,r){let i,s;return n.constructor!==Float32Array&&(a.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),s=new Float32Array(n)),r*this.channelSize>n.length?(a.Logger.warning("Encoder","Source data too small. Allocating larger array"),s=n,i=this.allocate(r*this.channelSize),s.forEach((n,r)=>i[r]=n)):i=s=n,i}allocate(n){return new Float32Array(4*n)}decode(n,r){return 1===this.channelSize?n.filter((n,r)=>r%4==0).subarray(0,r):n.subarray(0,r)}},r.RGBAFloatDataEncoder=class{constructor(n,r=1,i){if(1!==r&&4!==r)throw Error(`Invalid number of channels: ${r}`);this.internalFormat=n.RGBA,this.format=n.RGBA,this.channelSize=r,this.textureType=i||n.FLOAT}encode(n,r){let i=n;return 1===this.channelSize&&(a.Logger.verbose("Encoder","Exploding into a larger array"),i=this.allocate(r),n.forEach((n,r)=>i[4*r]=n)),i}allocate(n){return new Float32Array(4*n)}decode(n,r){return 1===this.channelSize?n.filter((n,r)=>r%4==0).subarray(0,r):n.subarray(0,r)}},r.Uint8DataEncoder=class{constructor(n,r=1){if(this.channelSize=4,1===r)this.internalFormat=n.ALPHA,this.format=n.ALPHA,this.textureType=n.UNSIGNED_BYTE,this.channelSize=r;else{if(4!==r)throw Error(`Invalid number of channels: ${r}`);this.internalFormat=n.RGBA,this.format=n.RGBA,this.textureType=n.UNSIGNED_BYTE,this.channelSize=r}}encode(n,r){return new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}allocate(n){return new Uint8Array(n*this.channelSize)}decode(n,r){if(n instanceof Uint8Array)return n.subarray(0,r);throw Error(`Invalid array type: ${n.constructor}`)}}},7859:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.getBatchDim=r.sizeToSquarishShape=r.getRowsCols=r.sizeFromShape=r.isInt=r.parseAxisParam=r.squeezeShape=r.PreferLogicalStrategy=r.AlwaysKeepOriginalSizeStrategy=void 0;let a=i(6231),s=i(2517);function o(n,r){let i=[],a=[],s=null!=r&&Array.isArray(r)&&0===r.length,o=null==r||s?null:l(r,n).sort(),u=0;for(let r=0;r<n.length;++r){if(null!=o){if(o[u]===r&&1!==n[r])throw Error(`Can't squeeze axis ${r} since its dim '${n[r]}' is not 1`);(null==o[u]||o[u]>r)&&1===n[r]&&(i.push(n[r]),a.push(r)),o[u]<=r&&u++}1!==n[r]&&(i.push(n[r]),a.push(r))}return{newShape:i,keptDims:a}}function l(n,r){let i=r.length;return n=null==n?r.map((n,r)=>r):[].concat(n),(0,s.assert)(n.every(n=>n>=-i&&n<i),()=>`All values in axis param must be in range [-${i}, ${i}) but got axis ${n}`),(0,s.assert)(n.every(u),()=>`All values in axis param must be integers but got axis ${n}`),n.map(n=>n<0?i+n:n)}function u(n){return n%1==0}function c(n){if(0===n.length)return 1;let r=n[0];for(let i=1;i<n.length;i++)r*=n[i];return r}function h(n){let r=Math.ceil(Math.sqrt(n));return[r,Math.ceil(n/r)]}r.AlwaysKeepOriginalSizeStrategy=class{constructor(n){this.maxTextureSize=n}computeTextureWH(n,r){if(0===n.length)return[1,1];let i=this.maxTextureSize;if(r&&void 0!==r.breakAxis){let s=r.breakAxis>=n.length?1:n.slice(r.breakAxis).reduce((n,r)=>n*r),o=r.breakAxis<=0?1:n.slice(0,r.breakAxis).reduce((n,r)=>n*r);if(!(s>i||o>i))return[s,o];a.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${n}, breakAxis:${r.breakAxis}`)}let s=n.reduce((n,r)=>n*r),o=Math.floor(Math.sqrt(s));for(;o<i&&o<s&&s%o!=0;o++);if(o>=i||s%o!=0)throw Error(`The given dimensions are outside this GPU's boundaries: ${n}`);return[o,s/o]}},r.PreferLogicalStrategy=class{constructor(n){this.maxTextureSize=n}computeTextureWH(n,r){let i=this.computeTexture(n,r);return r&&r.isPacked&&(i[0]/=2,i[1]/=2),r&&r.reverseWH?[i[1],i[0]]:i}computeTexture(n,r){let i=r&&r.isPacked;if(0===n.length)return i?[2,2]:[1,1];let s=this.maxTextureSize;if(r&&void 0!==r.breakAxis){let i=r.breakAxis>=n.length?1:n.slice(r.breakAxis).reduce((n,r)=>n*r),o=r.breakAxis<=0?1:n.slice(0,r.breakAxis).reduce((n,r)=>n*r);if(!(i>s||o>s))return[i,o];a.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${n}, breakAxis:${r.breakAxis}`)}let l=n.slice(0);if(i&&(s*=2,1===(l=l.map((n,r)=>r>=l.length-2?l[r]%2==0?l[r]:l[r]+1:l[r])).length&&(l=[2,l[0]])),2!==l.length){let n=o(l);l=n.newShape}let u=c(l);return l.length<=1&&u<=s?[1,u]:2===l.length&&l[0]<=s&&l[1]<=s?l:3===l.length&&l[0]*l[1]<=s&&l[2]<=s?[l[0]*l[1],l[2]]:3===l.length&&l[0]<=s&&l[1]*l[2]<=s?[l[0],l[1]*l[2]]:4===l.length&&l[0]*l[1]*l[2]<=s&&l[3]<=s?[l[0]*l[1]*l[2],l[3]]:4===l.length&&l[0]<=s&&l[1]*l[2]*l[3]<=s?[l[0],l[1]*l[2]*l[3]]:i?h(u/4).map(n=>2*n):h(u)}},r.squeezeShape=o,r.parseAxisParam=l,r.isInt=u,r.sizeFromShape=c,r.getRowsCols=function(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]},r.sizeToSquarishShape=h,r.getBatchDim=function(n,r=2){return c(n.slice(0,n.length-r))}},4057:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createTextureLayoutFromShape=r.calculateTextureWidthAndHeight=r.createTextureLayoutFromTextureType=void 0;let a=i(2517),s=i(2039);r.createTextureLayoutFromTextureType=(n,i,a)=>{let o=a===s.TextureType.unpacked||a===s.TextureType.unpackedReversed?1:4,l=a===s.TextureType.packed,u=a===s.TextureType.unpackedReversed||a===s.TextureType.packed,c=a===s.TextureType.packedLastDimension?i.length-1:void 0,h=a===s.TextureType.packedLastDimension?i.map((n,r)=>r===i.length-1?4*n:n):void 0;return(0,r.createTextureLayoutFromShape)(n,i,o,h,{isPacked:l,reverseWH:u,breakAxis:c})},r.calculateTextureWidthAndHeight=(n,i,a)=>{let s=(0,r.createTextureLayoutFromTextureType)(n,i,a);return[s.width,s.height]},r.createTextureLayoutFromShape=(n,r,i=1,s,o)=>{let l=!(!o||!o.isPacked),[u,c]=n.computeTextureWH(l&&s||r,o),h=r.length,d=r.slice(0);if(0===h&&(d=[1]),1===i)s=r;else if(l){if(4!==i)throw Error("a packed texture must be 4-channel");s=r,h>0&&(d[h-1]=Math.ceil(d[h-1]/2)),h>1&&(d[h-2]=Math.ceil(d[h-2]/2))}else if(!s)throw Error("Unpacked shape is needed when using channels > 1");return{width:u,height:c,channels:i,isPacked:l,shape:d,strides:a.ShapeUtil.computeStrides(d),unpackedShape:s,reversedWH:o&&o.reverseWH}}},5702:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.TextureManager=void 0;let a=i(6231);r.TextureManager=class{constructor(n,r,i,a){this.glContext=n,this.layoutStrategy=r,this.profiler=i,this.config=a,this.pendingRead=new Map,a.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(n,r,i,s){let o,l;let u=this.toEncoderType(n),c=this.glContext.getEncoder(u,r.channels||1,s);if(r.isPacked&&1===s)throw Error("not implemented");let h=r.width,d=r.height;if(this.config.reuseTextures){o=`${h}x${d}_${c.format}_${c.internalFormat}_${c.textureType}`,(l=this.inUseTextures.get(o))||(l=[],this.inUseTextures.set(o,l));let r=this.idleTextures.get(o);if(r&&r.length>0){let a=r.pop();return l.push(a),1===s&&this.glContext.updateTexture(a,h,d,c,this.toTextureData(n,i)),a}}a.Logger.verbose("TextureManager",`Creating new texture of size ${r.width}x${r.height}`);let p=this.glContext.allocateTexture(h,d,c,this.toTextureData(n,i));return this.config.reuseTextures&&(l.push(p),this.textureLookup.set(p,o)),p}readTexture(n,r,i){return i||(i=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let a=n.shape.reduce((n,r)=>n*r)*i,s=this.glContext.readTexture(n.texture,n.width,n.height,a,this.toEncoderType(r),i);return this.toTensorData(r,s)})}async readTextureAsync(n,r,i){let a=n.tensor.dataId;if(i||(i=1),this.pendingRead.has(a)){let n=this.pendingRead.get(a);return new Promise(r=>null==n?void 0:n.push(r))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(a,[]);let s=n.shape.reduce((n,r)=>n*r)*i;await this.glContext.createAndWaitForFence();let o=this.glContext.readTexture(n.texture,n.width,n.height,s,this.toEncoderType(r),i),l=this.toTensorData(r,o),u=this.pendingRead.get(a);return this.pendingRead.delete(a),null==u||u.forEach(n=>n(l)),l})}readUint8TextureAsFloat(n){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let r=n.shape.reduce((n,r)=>n*r),i=this.glContext.readTexture(n.texture,n.width,n.height,4*r,"byte",4);return new Float32Array(i.buffer,i.byteOffset,r)})}releaseTexture(n,r){let i;if(this.config.reuseTextures&&(i=this.textureLookup.get(n.texture))){r&&this.textureLookup.delete(i);let a=this.inUseTextures.get(i);if(a){let r=a.indexOf(n.texture);if(-1!==r){a.splice(r,1);let s=this.idleTextures.get(i);s||(s=[],this.idleTextures.set(i,s)),s.push(n.texture)}}}i&&!r||(a.Logger.verbose("TextureManager",`Deleting texture of size ${n.width}x${n.height}`),this.glContext.deleteTexture(n.texture))}toTensorData(n,r){switch(n){case"int16":return r instanceof Int16Array?r:Int16Array.from(r);case"int32":return r instanceof Int32Array?r:Int32Array.from(r);case"int8":return r instanceof Int8Array?r:Int8Array.from(r);case"uint16":return r instanceof Uint16Array?r:Uint16Array.from(r);case"uint32":return r instanceof Uint32Array?r:Uint32Array.from(r);case"uint8":case"bool":return r instanceof Uint8Array?r:Uint8Array.from(r);case"float32":return r instanceof Float32Array?r:Float32Array.from(r);case"float64":return r instanceof Float64Array?r:Float64Array.from(r);default:throw Error(`TensorData type ${n} is not supported`)}}toTextureData(n,r){if(r)return r instanceof Float32Array?r:new Float32Array(r)}toEncoderType(n){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(n,r)=>{var i;Object.defineProperty(r,"__esModule",{value:!0}),r.TextureType=void 0,(i=r.TextureType||(r.TextureType={}))[i.unpacked=0]="unpacked",i[i.unpackedReversed=1]="unpackedReversed",i[i.packed=2]="packed",i[i.downloadUint8AsFloat=3]="downloadUint8AsFloat",i[i.packedLastDimension=4]="packedLastDimension"},9390:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.getGlChannels=r.getCoordsDataType=r.getSqueezedParams=r.squeezeInputShape=r.generateShaderFuncNameFromInputSamplerNameAtOutCoords=r.generateShaderFuncNameFromInputSamplerName=r.repeatedTry=r.getPackedShape=void 0;let a=i(2517);r.getPackedShape=function(n){let r=n.length;return n.slice(0,r-1).concat(n[r-1]/4)},r.repeatedTry=async function(n,r=n=>0,i){return new Promise((a,s)=>{let o=0,l=()=>{if(n())return void a();o++;let u=r(o);null!=i&&o>=i?s():setTimeout(l,u)};l()})},r.generateShaderFuncNameFromInputSamplerName=function(n){return(0,a.assert)(void 0!==n&&0!==n.length,()=>"empty string found for sampler name"),"get"+n.charAt(0).toUpperCase()+n.slice(1)},r.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(n){return(0,a.assert)(void 0!==n&&0!==n.length,()=>"empty string found for sampler name"),"get"+n.charAt(0).toUpperCase()+n.slice(1)+"AtOutCoords"},r.squeezeInputShape=function(n,r){return JSON.parse(JSON.stringify(n)),r},r.getSqueezedParams=function(n,r){return r.map(r=>n[r]).join(", ")},r.getCoordsDataType=function(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)},r.getGlChannels=function(n=6){return["x","y","z","w","u","v"].slice(0,n)}},7305:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.createNewWebGLContext=r.createWebGLContext=void 0;let a=i(6231),s=i(1713),o={};function l(n){let r;let i=function(){if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas)throw TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}let n=document.createElement("canvas");return n.width=1,n.height=1,n}(),o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!n||"webgl2"===n)&&(r=i.getContext("webgl2",o)))try{return new s.WebGLContext(r,2)}catch(n){a.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`)}if((!n||"webgl"===n)&&(r=i.getContext("webgl",o)||i.getContext("experimental-webgl",o)))try{return new s.WebGLContext(r,1)}catch(n){a.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`)}throw Error("WebGL is not supported")}r.createWebGLContext=function n(r){let i;(!r||"webgl2"===r)&&"webgl2"in o?i=o.webgl2:(!r||"webgl"===r)&&"webgl"in o&&(i=o.webgl),i=i||l(r),r=r||1===i.version?"webgl":"webgl2";let a=i.gl;return o[r]=i,a.isContextLost()?(delete o[r],n(r)):(a.disable(a.DEPTH_TEST),a.disable(a.STENCIL_TEST),a.disable(a.BLEND),a.disable(a.DITHER),a.disable(a.POLYGON_OFFSET_FILL),a.disable(a.SAMPLE_COVERAGE),a.enable(a.SCISSOR_TEST),a.enable(a.CULL_FACE),a.cullFace(a.BACK),i)},r.createNewWebGLContext=l},1713:function(n,r,i){var a=this&&this.__createBinding||(Object.create?function(n,r,i,a){void 0===a&&(a=i);var s=Object.getOwnPropertyDescriptor(r,i);s&&!("get"in s?!r.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return r[i]}}),Object.defineProperty(n,a,s)}:function(n,r,i,a){void 0===a&&(a=i),n[a]=r[i]}),s=this&&this.__setModuleDefault||(Object.create?function(n,r){Object.defineProperty(n,"default",{enumerable:!0,value:r})}:function(n,r){n.default=r}),o=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var r={};if(null!=n)for(var i in n)"default"!==i&&Object.prototype.hasOwnProperty.call(n,i)&&a(r,n,i);return s(r,n),r};Object.defineProperty(r,"__esModule",{value:!0}),r.WebGLContext=r.linearSearchLastTrue=void 0;let l=i(1670),u=o(i(7769)),c=i(9390);function h(n){let r=0;for(;r<n.length&&n[r]();++r);return r-1}r.linearSearchLastTrue=h,r.WebGLContext=class{constructor(n,r){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=n,this.version=r,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(n,r,i,a){let s=this.gl,o=s.createTexture();s.bindTexture(s.TEXTURE_2D,o),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE);let l=a?i.encode(a,n*r):null;return s.texImage2D(s.TEXTURE_2D,0,i.internalFormat,n,r,0,i.format,i.textureType,l),this.checkError(),o}updateTexture(n,r,i,a,s){let o=this.gl;o.bindTexture(o.TEXTURE_2D,n);let l=a.encode(s,r*i);o.texSubImage2D(o.TEXTURE_2D,0,0,0,r,i,a.format,a.textureType,l),this.checkError()}attachFramebuffer(n,r,i){let a=this.gl;a.bindTexture(a.TEXTURE_2D,n),a.bindFramebuffer(a.FRAMEBUFFER,this.framebuffer),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,n,0),this.checkError(),a.viewport(0,0,r,i),a.scissor(0,0,r,i)}readTexture(n,r,i,a,s,o){let l=this.gl;o||(o=1),this.frameBufferBound||this.attachFramebuffer(n,r,i);let u=this.getEncoder(s,o),c=u.allocate(r*i);return l.bindTexture(l.TEXTURE_2D,n),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,n,0),l.readPixels(0,0,r,i,l.RGBA,u.textureType,c),this.checkError(),u.decode(c,a)}isFramebufferReady(){return!0}getActiveTexture(){let n=this.gl;return"TEXTURE"+(n.getParameter(this.gl.ACTIVE_TEXTURE)-n.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(n,r){let i=this.gl;i.vertexAttribPointer(n,3,i.FLOAT,!1,20,0),i.enableVertexAttribArray(n),-1!==r&&(i.vertexAttribPointer(r,2,i.FLOAT,!1,20,12),i.enableVertexAttribArray(r)),this.checkError()}createProgram(n,r){let i=this.gl,a=i.createProgram();return i.attachShader(a,n),i.attachShader(a,r),i.linkProgram(a),a}compileShader(n,r){let i=this.gl,a=i.createShader(r);if(!a)throw Error(`createShader() returned null with type ${r}`);if(i.shaderSource(a,n),i.compileShader(a),!1===i.getShaderParameter(a,i.COMPILE_STATUS))throw Error(`Failed to compile shader: ${i.getShaderInfoLog(a)}
Shader source:
${n}`);return a}deleteShader(n){this.gl.deleteShader(n)}bindTextureToUniform(n,r,i){let a=this.gl;a.activeTexture(a.TEXTURE0+r),this.checkError(),a.bindTexture(a.TEXTURE_2D,n),this.checkError(),a.uniform1i(i,r),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(l.env.debug){let n=this.gl,r=n.getError(),i="";switch(r){case n.NO_ERROR:return;case n.INVALID_ENUM:i="INVALID_ENUM";break;case n.INVALID_VALUE:i="INVALID_VALUE";break;case n.INVALID_OPERATION:i="INVALID_OPERATION";break;case n.INVALID_FRAMEBUFFER_OPERATION:i="INVALID_FRAMEBUFFER_OPERATION";break;case n.OUT_OF_MEMORY:i="OUT_OF_MEMORY";break;case n.CONTEXT_LOST_WEBGL:i="CONTEXT_LOST_WEBGL";break;default:i=`Unknown WebGL Error: ${r.toString(16)}`}throw Error(i)}}deleteTexture(n){this.gl.deleteTexture(n)}deleteProgram(n){this.gl.deleteProgram(n)}getEncoder(n,r,i=0){if(2===this.version)return new u.RedFloat32DataEncoder(this.gl,r);switch(n){case"float":return 1===i||this.isRenderFloat32Supported?new u.RGBAFloatDataEncoder(this.gl,r):new u.RGBAFloatDataEncoder(this.gl,r,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw Error("not implemented");case"byte":return new u.Uint8DataEncoder(this.gl,r);default:throw Error(`Invalid dataType: ${n}`)}}clearActiveTextures(){let n=this.gl;for(let r=0;r<this.maxTextureImageUnits;++r)n.activeTexture(n.TEXTURE0+r),n.bindTexture(n.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let n=this.gl;n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteFramebuffer(this.framebuffer),n.bindBuffer(n.ARRAY_BUFFER,null),n.deleteBuffer(this.vertexbuffer),n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null),n.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let n=this.gl,r=n.createBuffer();if(!r)throw Error("createBuffer() returned null");let i=this.createDefaultGeometry();return n.bindBuffer(n.ARRAY_BUFFER,r),n.bufferData(n.ARRAY_BUFFER,i,n.STATIC_DRAW),this.checkError(),r}createFramebuffer(){let n=this.gl.createFramebuffer();if(!n)throw Error("createFramebuffer returned null");return n}queryVitalParameters(){let n=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=n.getParameter(n.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let n=this.gl,r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);let i=2===this.version?n.RGBA32F:n.RGBA;n.texImage2D(n.TEXTURE_2D,0,i,1,1,0,n.RGBA,n.FLOAT,null);let a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);let s=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(a),s}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let n,r,i,a,s;let o=this.gl;try{n=o.createTexture(),r=o.createFramebuffer(),o.bindTexture(o.TEXTURE_2D,n);let l=2===this.version?o.RGBA32F:o.RGBA;return o.texImage2D(o.TEXTURE_2D,0,l,1,1,0,o.RGBA,o.FLOAT,null),o.bindFramebuffer(o.FRAMEBUFFER,r),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,n,0),o.enable(o.BLEND),!!(i=o.createShader(o.VERTEX_SHADER))&&(o.shaderSource(i,"void main(){}"),o.compileShader(i),!!(a=o.createShader(o.FRAGMENT_SHADER))&&(o.shaderSource(a,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),o.compileShader(a),!!(s=o.createProgram())&&(o.attachShader(s,i),o.attachShader(s,a),o.linkProgram(s),o.useProgram(s),o.drawArrays(o.POINTS,0,1),o.getError()===o.NO_ERROR)))}finally{o.disable(o.BLEND),s&&o.deleteProgram(s),i&&o.deleteShader(i),a&&o.deleteShader(a),r&&(o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(r)),n&&(o.bindTexture(o.TEXTURE_2D,null),o.deleteTexture(n))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){let n=this.gl,r=this.disjointTimerQueryWebgl2Extension,i=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,i),i}throw Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw Error("WebGL1 profiling currently not supported");{let n=this.gl,r=this.disjointTimerQueryWebgl2Extension;n.endQuery(r.TIME_ELAPSED_EXT)}}isTimerResultAvailable(n){let r=!1,i=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw Error("WebGL1 profiling currently not supported");{let a=this.gl,s=this.disjointTimerQueryWebgl2Extension;r=a.getQueryParameter(n,a.QUERY_RESULT_AVAILABLE),i=a.getParameter(s.GPU_DISJOINT_EXT)}return r&&!i}getTimerResult(n){let r=0;if(2!==this.version)throw Error("WebGL1 profiling currently not supported");{let i=this.gl;r=i.getQueryParameter(n,i.QUERY_RESULT),i.deleteQuery(n)}return r/1e6}async waitForQueryAndGetTime(n){return await (0,c.repeatedTry)(()=>this.isTimerResultAvailable(n)),this.getTimerResult(n)}async createAndWaitForFence(){let n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let r;let i=n,a=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);return n.flush(),r=null===a?()=>!0:()=>{let n=i.clientWaitSync(a,0,0);return n===i.ALREADY_SIGNALED||n===i.CONDITION_SATISFIED},{query:a,isFencePassed:r}}async pollFence(n){return new Promise(r=>{this.addItemToPoll(()=>n.isFencePassed(),()=>r())})}pollItems(){let n=h(this.itemsToPoll.map(n=>n.isDoneFn));for(let r=0;r<=n;++r){let{resolveFn:n}=this.itemsToPoll[r];n()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}async addItemToPoll(n,r){this.itemsToPoll.push({isDoneFn:n,resolveFn:r}),this.itemsToPoll.length>1||await (0,c.repeatedTry)(()=>(this.pollItems(),0===this.itemsToPoll.length))}}},1036:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.ExecutionPlan=void 0;let a=i(6231);class s{constructor(n,r){this.op=n,this.node=r}}r.ExecutionPlan=class{constructor(n,r,i){this.graph=n,this.profiler=i,this.initialize(r)}initialize(n){this.profiler.event("session","ExecutionPlan.initialize",()=>{let r=this.graph.getNodes();if(r.length!==n.length)throw Error("The size of nodes and OPs do not match.");this._ops=n.map((n,i)=>new s(n,r[i])),this.reset(),this._starter=[],this._ops.forEach((n,r)=>{let i=!0;for(let r of n.node.inputs)if(!this._values[r]&&-1===this.graph.getInputIndices().indexOf(r)){i=!1;break}i&&this._starter.push(r)})})}reset(){this._values=this.graph.getValues().map(n=>n.tensor)}async execute(n,r){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let i=n.createInferenceHandler(),s=this.graph.getInputIndices();if(r.length!==s.length)throw Error(`number of input tensors don't match the number of inputs to the model: actual: ${r.length} expected: ${s.length}`);r.forEach((n,r)=>{let i=s[r];this._values[i]=n});let o=this._starter.slice(0),l=this.graph.getValues(),u=this.graph.getNodes(),c=0;for(;c<o.length;){let n=o[c++],r=this._ops[n],s=r.node.inputs.map(n=>this._values[n]);if(-1!==s.indexOf(void 0))throw Error(`unresolved input detected: op: ${r.node}`);let h=s;a.Logger.verbose("ExecPlan",`Runing op:${r.node.name} (${h.map((n,i)=>`'${r.node.inputs[i]}': ${n.type}[${n.dims.join(",")}]`).join(", ")})`);let d=await this.profiler.event("node",r.node.name,async()=>r.op.impl(i,h,r.op.context));if(d.length!==r.node.outputs.length)throw Error("the size of output does not match model definition.");d.forEach((n,i)=>{let a=r.node.outputs[i];if(this._values[a])throw Error(`output [${a}] already has value: op:${r.node.name}`);this._values[a]=n});let p=new Set;d.forEach((n,i)=>{let a=r.node.outputs[i];for(let n of l[a].to){let r=u[n],i=!0;for(let n of r.inputs)if(!this._values[n]){i=!1;break}i&&p.add(n)}}),o.push(...p)}let h=[];for(let n=0;n<this.graph.getOutputIndices().length;n++){let r=this.graph.getOutputIndices()[n],i=this._values[r];if(void 0===i)throw Error(`required output [${r}] does not have value`);0===r?await i.getData():i.data,h.push(i)}return a.Logger.verbose("ExecPlan","disposing of inferenceHandler"),i.dispose(),h})}}},7070:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Graph=void 0;let a=i(1446),s=i(7778),o=i(9395),l=i(9162),u=i(2517);var c=o.onnxruntime.experimental.fbs;r.Graph={from:(n,r)=>new p(n,r)};class h{constructor(n){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,n&&(this.type=u.ProtoUtil.tensorValueTypeFromProto(n.type.tensorType))}get from(){return this._from}get to(){return this._to}}class d{constructor(n,r){n instanceof a.onnx.NodeProto?(this.name=n.name,this.opType=n.opType,this.attributes=new s.Attribute(n.attribute)):n instanceof c.Node&&(this.name=null!=r?r:n.name(),this.opType=n.opType(),this.attributes=new s.Attribute(u.ProtoUtil.tensorAttributesFromORTFormat(n))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class p{constructor(n,r){if(!n)throw TypeError("graph is empty");this.buildGraph(n),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(n){if(n instanceof a.onnx.GraphProto)this.buildGraphFromOnnxFormat(n);else{if(!(n instanceof c.Graph))throw TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(n)}}buildGraphFromOnnxFormat(n){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map;if(!n.input)throw Error("missing information in graph: input");let a=[];for(let i of n.input){if(r.has(i.name))throw Error(`duplicated input name: ${i.name}`);let n=this._allData.push(new h(i))-1;r.set(i.name,n),a.push(i.name)}if(!n.initializer)throw Error("missing information in graph: initializer");for(let i of n.initializer){let n=r.get(i.name);if(void 0===n){let a=new h;a.type={shape:{dims:u.ProtoUtil.tensorDimsFromProto(i.dims)},tensorType:u.ProtoUtil.tensorDataTypeFromProto(i.dataType)},n=this._allData.push(a)-1,r.set(i.name,n)}this._allData[n]._from=-1,this._allData[n].tensor=l.Tensor.fromProto(i)}for(let n=0;n<this._allData.length;n++)this._allData[n].tensor||(this._allInputIndices.push(n),this._allInputNames.push(a[n]));if(!n.output)throw Error("missing information in graph: output");for(let i of n.output){if(r.has(i.name))throw Error(`duplicated output name: ${i.name}`);let n=this._allData.push(new h(i))-1;r.set(i.name,n),this._allOutputIndices.push(n),this._allOutputNames.push(i.name)}if(!n.node)throw Error("missing information in graph: node");for(let r of n.node){if(!r.name)for(let n=0;;n++){let a=`unnamed_${r.opType}_${n}`;if(!i.has(a)){r.name=a;break}}if(i.has(r.name))throw Error(`duplicated node name: ${r.name}`);let n=this._nodes.push(new d(r))-1;i.set(r.name,n)}for(let i=0;i<this._nodes.length;i++){let a=this._nodes[i],s=n.node[i];if(!s.output)throw Error(`missing output for node: ${s.name}`);for(let n of s.output){let o=r.get(n);if(void 0===o&&(o=this._allData.push(new h)-1,r.set(n,o)),a.outputs.push(o),void 0!==this._allData[o]._from)throw Error(`multiple nodes output to one data value: ${o}`);if(this._allData[o]._from=i,"Constant"===s.opType){if(!s.attribute||1!==s.attribute.length||!s.attribute[0].t)throw Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!s.output||1!==s.output.length)throw Error("missing output or incorrect number of outputs for this Constant operator");a.outputs.pop(),a.executeNode=!1,this._allData[o]._from=-1,this._allData[o].tensor=l.Tensor.fromProto(s.attribute[0].t)}}}for(let i=0;i<this._nodes.length;i++){let a=this._nodes[i],s=n.node[i];if(!s.input)throw Error(`missing input for node: ${s.name}`);for(let n of s.input){let o=r.get(n);if(void 0===o){if(""===n&&3===s.input.length&&"Resize"===s.opType)continue;throw Error(`unrecognized input '${n}' for node: ${s.name}`)}a.inputs.push(o),this._allData[o]._to.push(i)}}return!0}buildGraphFromOrtFormat(n){var r,i,a;let s=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let o=new Map,p=[];for(let o=0;o<n.inputsLength();o++){let l=n.inputs(o);if(s.has(l))throw Error(`duplicated input name: ${l}`);for(let o=0;o<n.nodeArgsLength();o++)if((null===(r=n.nodeArgs(o))||void 0===r?void 0:r.name())===l){let r=new h;if((null===(a=null===(i=n.nodeArgs(o))||void 0===i?void 0:i.type())||void 0===a?void 0:a.valueType())!==c.TypeInfoValue.tensor_type)throw Error("Unexpected value type for the nodeArg.");let d=n.nodeArgs(o).type().value(new c.TensorTypeAndShape),f=u.ProtoUtil.tensorDataTypeFromProto(d.elemType()),m=d.shape(),g=[];for(let n=0;n<m.dimLength();n++)g.push(u.LongUtil.longToNumber(m.dim(n).value().dimValue()));r.type={shape:{dims:g},tensorType:f};let _=this._allData.push(r)-1;s.set(l,_),p.push(l)}}for(let r=0;r<n.initializersLength();r++){let i=n.initializers(r),a=s.get(i.name());if(void 0===a){let n=new h,r=u.ProtoUtil.tensorDimsFromORTFormat(i),o=u.ProtoUtil.tensorDataTypeFromProto(i.dataType());n.type={shape:{dims:r},tensorType:o},a=this._allData.push(n)-1,s.set(i.name(),a)}this._allData[a]._from=-1,this._allData[a].tensor=l.Tensor.fromOrtTensor(i)}for(let n=0;n<this._allData.length;n++)this._allData[n].tensor||(this._allInputIndices.push(n),this._allInputNames.push(p[n]));for(let r=0;r<n.outputsLength();r++){let i=n.outputs(r);if(s.has(i))throw Error(`duplicated output name: ${i}`);let a=this._allData.push(new h)-1;s.set(i,a),this._allOutputIndices.push(a),this._allOutputNames.push(i)}if(!n.nodes)throw Error("missing information in graph: node");for(let r=0;r<n.nodesLength();r++){let i=n.nodes(r),a=i.name();if(!a)for(let n=0;a=`unnamed_${i.opType()}_${n}`,o.has(a);n++);if(o.has(a))throw Error(`duplicated node name: ${a}`);let s=this._nodes.push(new d(i,a))-1;o.set(a,s)}for(let r=0;r<this._nodes.length;r++){let i=this._nodes[r],a=n.nodes(r);if(null==a)throw Error(`No node exists at index ${r}`);if(0===(null==a?void 0:a.outputsLength()))throw Error(`missing output for node: ${a.name}`);for(let n=0;n<(null==a?void 0:a.outputsLength());n++){let o=null==a?void 0:a.outputs(n),u=s.get(o);if(void 0===u&&(u=this._allData.push(new h)-1,s.set(o,u)),i.outputs.push(u),void 0!==this._allData[u]._from)throw Error(`multiple nodes output to one data value: ${u}`);if(this._allData[u]._from=r,"Constant"===a.opType()){if(1!==a.attributesLength()||!a.attributes(0).t())throw Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==a.outputsLength())throw Error("missing output or incorrect number of outputs for this Constant operator");i.outputs.pop(),i.executeNode=!1,this._allData[u]._from=-1,this._allData[u].tensor=l.Tensor.fromOrtTensor(a.attributes(0).t())}}}for(let r=0;r<this._nodes.length;r++){let i=this._nodes[r],a=n.nodes(r);if(0===a.inputsLength())throw Error(`missing input for node: ${a.name}`);for(let n=0;n<a.inputsLength();n++){let o=a.inputs(n),l=s.get(o);if(void 0===l)throw Error(`unrecognized input '${o}' for node: ${a.name()}`);i.inputs.push(l),this._allData[l]._to.push(r)}}}checkIsAcyclic(){let n=new Set;this._allInputIndices.forEach(r=>{this._allData[r]._to.forEach(r=>{n.add(r)})});let r=Array.from(n),i=Array(this._nodes.length).fill("white");for(;r.length>0;){let n=r.pop();"gray"===i[n]?i[n]="black":(r.push(n),i[n]="gray",this._nodes[n].outputs.forEach(a=>{let s=this._allData[a];if(void 0!==s.tensor)throw Error("node outputs should not be initialized");if(s._from!==n)throw Error("from property of the Value object doesn't match index of Node being processed");s._to.forEach(n=>{if("gray"===i[n])throw Error("model graph is cyclic");"white"===i[n]&&r.push(n)})}))}}transformGraph(n){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),n&&n.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let n=0;for(let r=0;r<this._nodes.length;r++)this._nodes[r].executeNode?n>0&&(this._nodes[r].inputs.forEach(i=>{let a=this._allData[i]._to.indexOf(r+n);-1!==a&&(this._allData[i]._to[a]=r)}),this._nodes[r].outputs.forEach(i=>{this._allData[i]._from&&this._allData[i]._from===r+n&&(this._allData[i]._from=r)})):(n++,this._nodes[r].outputs.forEach(n=>{this._allData[n]._from=-2}),this._nodes.splice(r,1),r--);n=0;for(let r=0;r<this._allData.length;r++)if(-2!==this._allData[r].from||-1!==this._allOutputIndices.indexOf(r+n)){if(n>0){let i=-1;void 0!==this._allData[r].from&&-1!==this._allData[r].from?-1!==(i=this._nodes[this._allData[r].from].outputs.indexOf(r+n))&&(this._nodes[this._allData[r].from].outputs[i]=r):-1!==(i=this._allInputIndices.indexOf(r+n))&&(this._allInputIndices[i]=r),this._allData[r].to.forEach(a=>{-1!==(i=this._nodes[a].inputs.indexOf(r+n))&&(this._nodes[a].inputs[i]=r)}),0===this._allData[r].to.length&&-1!==(i=this._allOutputIndices.indexOf(r+n))&&(this._allOutputIndices[i]=r)}}else n++,this._allData.splice(r,1),r--}deleteNode(n){let r=this._nodes[n];if(r.outputs.length>1){for(let n=1;n<r.outputs.length;n++)if(this._allData[r.outputs[n]].to.length>0)throw Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;let i=r.inputs[0],a=r.outputs[0],s=this._allData[a].to,o=this._allData[i].to.indexOf(n);if(-1===o)throw Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[i].to.splice(o,1),this._allData[a]._to=[];let l=this._allOutputIndices.indexOf(a);if(-1!==l&&(this._allOutputIndices[l]=i),s&&s.length>0)for(let n of s){let r=this._nodes[n].inputs.indexOf(a);if(-1===r)throw Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[n].inputs[r]=i,this._allData[i].to.push(n)}}removeAllDropoutNodes(){let n=0;for(let r of this._nodes){if("Dropout"===r.opType){if(1!==r.inputs.length)throw Error("Dropout nodes should only contain one input. ");if(1!==r.outputs.length&&2!==r.outputs.length)throw Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===r.outputs.length&&0!==this._allData[r.outputs[1]]._to.length)throw Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(n)}n++}}removeAllIdentityNodes(){let n=0;for(let r of this._nodes)"Identity"===r.opType&&this.deleteNode(n),n++}isActivation(n){switch(n.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let n of this._nodes)if("Conv"===n.opType){let r=this._allData[n.outputs[0]]._to;if(1===r.length&&this.isActivation(this._nodes[r[0]])){let i=this._nodes[r[0]];if("Clip"===i.opType){if(1===i.inputs.length)try{n.attributes.set("activation_params","floats",[i.attributes.getFloat("min"),i.attributes.getFloat("max")])}catch(r){n.attributes.set("activation_params","floats",[u.MIN_CLIP,u.MAX_CLIP])}else{if(!(i.inputs.length>=3&&void 0!==this._allData[i.inputs[1]].tensor&&void 0!==this._allData[i.inputs[2]].tensor))continue;n.attributes.set("activation_params","floats",[this._allData[i.inputs[1]].tensor.floatData[0],this._allData[i.inputs[2]].tensor.floatData[0]])}}n.attributes.set("activation","string",i.opType),this.deleteNode(r[0])}}}}},6231:(n,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.now=r.Profiler=r.Logger=void 0;let i={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},a={none:new class{log(n,r,i){}},console:new class{log(n,r,i){console.log(`${this.color(n)} ${i?"\x1b[35m"+i+"\x1b[0m ":""}${r}`)}color(n){switch(n){case"verbose":return"\x1b[34;40mv\x1b[0m";case"info":return"\x1b[32mi\x1b[0m";case"warning":return"\x1b[30;43mw\x1b[0m";case"error":return"\x1b[31;40me\x1b[0m";case"fatal":return"\x1b[101mf\x1b[0m";default:throw Error(`unsupported severity: ${n}`)}}}},s={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},o={"":s};function l(n,r,i,a){var s;if(void 0===r)return s=n,{verbose:l.verbose.bind(null,s),info:l.info.bind(null,s),warning:l.warning.bind(null,s),error:l.error.bind(null,s),fatal:l.fatal.bind(null,s)};if(void 0===i)u(n,r);else if("number"==typeof i&&void 0===a)u(n,r);else if("string"==typeof i&&void 0===a)u(n,i,0,r);else{if("string"!=typeof i||"number"!=typeof a)throw TypeError("input is valid");u(n,i,0,r)}}function u(n,r,s,l){let u=o[l||""]||o[""];i[n]<i[u.minimalSeverity]||(u.logDateTime&&(r=`${(new Date).toISOString()}|${r}`),u.logSourceLocation,a[u.provider].log(n,r,l))}(function(n){function r(n){o={},i("",n||{})}function i(n,i){if("*"===n)r(i);else{let r=o[n]||s;o[n]={provider:i.provider||r.provider,minimalSeverity:i.minimalSeverity||r.minimalSeverity,logDateTime:void 0===i.logDateTime?r.logDateTime:i.logDateTime,logSourceLocation:void 0===i.logSourceLocation?r.logSourceLocation:i.logSourceLocation}}}n.verbose=function(r,i){n("verbose",r,i)},n.info=function(r,i){n("info",r,i)},n.warning=function(r,i){n("warning",r,i)},n.error=function(r,i){n("error",r,i)},n.fatal=function(r,i){n("fatal",r,i)},n.reset=r,n.set=i,n.setWithEnv=function(n){let r={};n.logLevel&&(r.minimalSeverity=n.logLevel),i("",r)}})(l||(l={})),r.Logger=l;class c{constructor(n,r,i,a,s,o){this.category=n,this.name=r,this.startTime=i,this.endCallback=a,this.timer=s,this.ctx=o}end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class h{constructor(n,r,i,a){this.category=n,this.name=r,this.startTime=i,this.endTime=a}}r.Profiler=class{static create(n){return void 0===n?new this:new this(n.maxNumberEvents,n.flushBatchSize,n.flushIntervalInMilliseconds)}constructor(n,r,i){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===n?1e4:n,this._flushBatchSize=void 0===r?10:r,this._flushIntervalInMilliseconds=void 0===i?5e3:i}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,r.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(n,r,i,a){let s=this._started?this.begin(n,r,a):void 0,o=!1,l=i();if(l&&"function"==typeof l.then)return o=!0,new Promise((n,r)=>{l.then(async r=>{s&&await s.end(),n(r)},async n=>{s&&await s.end(),r(n)})});if(!o&&s){let n=s.end();if(n&&"function"==typeof n.then)return new Promise((r,i)=>{n.then(()=>{r(l)},n=>{i(n)})})}return l}begin(n,i,a){if(!this._started)throw Error("profiler is not started yet");if(void 0===a){let a=(0,r.now)();return this.flush(a),new c(n,i,a,n=>this.endSync(n))}{let r=a.beginTimer();return new c(n,i,0,async n=>this.end(n),r,a)}}async end(n){let r=await n.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new h(n.category,n.name,n.startTime,r)),this.flush(r))}endSync(n){let i=(0,r.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new h(n.category,n.name,n.startTime,i)),this.flush(i))}logOneEvent(n){r.Logger.verbose(`Profiler.${n.category}`,`${(n.endTime-n.startTime).toFixed(2)}ms on event '${n.name}' at ${n.endTime.toFixed(2)}`)}flush(n){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||n-this._flushTime>=this._flushIntervalInMilliseconds){for(let n=this._flushPointer;this._flushPointer<n+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,r.now)()}}get started(){return this._started}},r.now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now},2644:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Model=void 0;let a=i(5686),s=i(1446),o=i(7070),l=i(9395),u=i(2517);var c=l.onnxruntime.experimental.fbs;r.Model=class{constructor(){}load(n,r,i){if(!i)try{return void this.loadFromOnnxFormat(n,r)}catch(n){if(void 0!==i)throw n}this.loadFromOrtFormat(n,r)}loadFromOnnxFormat(n,r){let i=s.onnx.ModelProto.decode(n);if(3>u.LongUtil.longToNumber(i.irVersion))throw Error("only support ONNX model with IR_VERSION>=3");this._opsets=i.opsetImport.map(n=>({domain:n.domain,version:u.LongUtil.longToNumber(n.version)})),this._graph=o.Graph.from(i.graph,r)}loadFromOrtFormat(n,r){let i=new a.flatbuffers.ByteBuffer(n),s=c.InferenceSession.getRootAsInferenceSession(i).model();if(3>u.LongUtil.longToNumber(s.irVersion()))throw Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let n=0;n<s.opsetImportLength();n++){let r=s.opsetImport(n);this._opsets.push({domain:null==r?void 0:r.domain(),version:u.LongUtil.longToNumber(r.version())})}this._graph=o.Graph.from(s.graph(),r)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(n,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.FLOAT_TYPES=r.INT_TYPES=r.NUMBER_TYPES=void 0,r.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],r.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],r.FLOAT_TYPES=["float32","float64"]},1047:(n,r)=>{function i(n,r){if(r.endsWith("+")){let i=Number.parseInt(r.substring(0,r.length-1),10);return!isNaN(i)&&i<=n}if(2===r.split("-").length){let i=r.split("-"),a=Number.parseInt(i[0],10),s=Number.parseInt(i[1],10);return!isNaN(a)&&!isNaN(s)&&a<=n&&n<=s}return Number.parseInt(r,10)===n}Object.defineProperty(r,"__esModule",{value:!0}),r.resolveOperator=void 0,r.resolveOperator=function(n,r,a){for(let s of a){let a=s[0],o=s[1],l=s[2],u=s[3],c=s[4];if(n.opType===a){for(let n of r)if((n.domain===o||"ai.onnx"===n.domain&&""===o)&&i(n.version,l))return{opImpl:u,opInit:c}}}throw TypeError(`cannot resolve operator '${n.opType}' with opsets: ${r.map(n=>`${n.domain||"ai.onnx"} v${n.version}`).join(", ")}`)}},9395:(n,r,i)=>{var a,s;Object.defineProperty(r,"__esModule",{value:!0}),r.onnxruntime=void 0;let o=i(5686);(function(n){let r;!function(n){n[n.UNDEFINED=0]="UNDEFINED",n[n.FLOAT=1]="FLOAT",n[n.INT=2]="INT",n[n.STRING=3]="STRING",n[n.TENSOR=4]="TENSOR",n[n.GRAPH=5]="GRAPH",n[n.FLOATS=6]="FLOATS",n[n.INTS=7]="INTS",n[n.STRINGS=8]="STRINGS",n[n.TENSORS=9]="TENSORS",n[n.GRAPHS=10]="GRAPHS",n[n.SPARSE_TENSOR=11]="SPARSE_TENSOR",n[n.SPARSE_TENSORS=12]="SPARSE_TENSORS"}(r=n.AttributeType||(n.AttributeType={}))})((s=(a=r.onnxruntime||(r.onnxruntime={})).experimental||(a.experimental={})).fbs||(s.fbs={})),function(n){!function(n){!function(n){let r;!function(n){n[n.UNKNOWN=0]="UNKNOWN",n[n.VALUE=1]="VALUE",n[n.PARAM=2]="PARAM"}(r=n.DimensionValueType||(n.DimensionValueType={}))}(n.fbs||(n.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(n){!function(n){let r;!function(n){n[n.UNDEFINED=0]="UNDEFINED",n[n.FLOAT=1]="FLOAT",n[n.UINT8=2]="UINT8",n[n.INT8=3]="INT8",n[n.UINT16=4]="UINT16",n[n.INT16=5]="INT16",n[n.INT32=6]="INT32",n[n.INT64=7]="INT64",n[n.STRING=8]="STRING",n[n.BOOL=9]="BOOL",n[n.FLOAT16=10]="FLOAT16",n[n.DOUBLE=11]="DOUBLE",n[n.UINT32=12]="UINT32",n[n.UINT64=13]="UINT64",n[n.COMPLEX64=14]="COMPLEX64",n[n.COMPLEX128=15]="COMPLEX128",n[n.BFLOAT16=16]="BFLOAT16"}(r=n.TensorDataType||(n.TensorDataType={}))}(n.fbs||(n.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(n){!function(n){let r;!function(n){n[n.Primitive=0]="Primitive",n[n.Fused=1]="Fused"}(r=n.NodeType||(n.NodeType={}))}(n.fbs||(n.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(n){!function(n){let r;!function(n){n[n.NONE=0]="NONE",n[n.tensor_type=1]="tensor_type",n[n.sequence_type=2]="sequence_type",n[n.map_type=3]="map_type"}(r=n.TypeInfoValue||(n.TypeInfoValue={}))}(n.fbs||(n.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsShape(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsShape(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}dim(r,i){let a=this.bb.__offset(this.bb_pos,4);return a?(i||new n.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}dimLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}static startShape(n){n.startObject(1)}static addDim(n,r){n.addFieldOffset(0,r,0)}static createDimVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startDimVector(n,r){n.startVector(4,r,4)}static endShape(n){return n.endObject()}static createShape(n,r){return i.startShape(n),i.addDim(n,r),i.endShape(n)}}r.Shape=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsDimension(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimension(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}value(r){let i=this.bb.__offset(this.bb_pos,4);return i?(r||new n.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}denotation(n){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,n):null}static startDimension(n){n.startObject(2)}static addValue(n,r){n.addFieldOffset(0,r,0)}static addDenotation(n,r){n.addFieldOffset(1,r,0)}static endDimension(n){return n.endObject()}static createDimension(n,r,a){return i.startDimension(n),i.addValue(n,r),i.addDenotation(n,a),i.endDimension(n)}}r.Dimension=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsDimensionValue(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimensionValue(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}dimType(){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.readInt8(this.bb_pos+r):n.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}dimParam(n){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__string(this.bb_pos+r,n):null}static startDimensionValue(n){n.startObject(3)}static addDimType(r,i){r.addFieldInt8(0,i,n.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(n,r){n.addFieldInt64(1,r,n.createLong(0,0))}static addDimParam(n,r){n.addFieldOffset(2,r,0)}static endDimensionValue(n){return n.endObject()}static createDimensionValue(n,r,a,s){return i.startDimensionValue(n),i.addDimType(n,r),i.addDimValue(n,a),i.addDimParam(n,s),i.endDimensionValue(n)}}r.DimensionValue=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsTensorTypeAndShape(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensorTypeAndShape(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}elemType(){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.readInt32(this.bb_pos+r):n.experimental.fbs.TensorDataType.UNDEFINED}shape(r){let i=this.bb.__offset(this.bb_pos,6);return i?(r||new n.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}static startTensorTypeAndShape(n){n.startObject(2)}static addElemType(r,i){r.addFieldInt32(0,i,n.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(n,r){n.addFieldOffset(1,r,0)}static endTensorTypeAndShape(n){return n.endObject()}static createTensorTypeAndShape(n,r,a){return i.startTensorTypeAndShape(n),i.addElemType(n,r),i.addShape(n,a),i.endTensorTypeAndShape(n)}}r.TensorTypeAndShape=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsMapType(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsMapType(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}keyType(){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.readInt32(this.bb_pos+r):n.experimental.fbs.TensorDataType.UNDEFINED}valueType(r){let i=this.bb.__offset(this.bb_pos,6);return i?(r||new n.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}static startMapType(n){n.startObject(2)}static addKeyType(r,i){r.addFieldInt32(0,i,n.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(n,r){n.addFieldOffset(1,r,0)}static endMapType(n){return n.endObject()}static createMapType(n,r,a){return i.startMapType(n),i.addKeyType(n,r),i.addValueType(n,a),i.endMapType(n)}}r.MapType=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsSequenceType(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSequenceType(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}elemType(r){let i=this.bb.__offset(this.bb_pos,4);return i?(r||new n.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}static startSequenceType(n){n.startObject(1)}static addElemType(n,r){n.addFieldOffset(0,r,0)}static endSequenceType(n){return n.endObject()}static createSequenceType(n,r){return i.startSequenceType(n),i.addElemType(n,r),i.endSequenceType(n)}}r.SequenceType=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(n){(n.fbs||(n.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(n,r,i,a){return n.prep(4,12),n.writeInt32(a),n.writeInt32(i),n.writeInt32(r),n.offset()}}}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsNodeEdge(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNodeEdge(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}nodeIndex(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readUint32(this.bb_pos+n):0}inputEdges(r,i){let a=this.bb.__offset(this.bb_pos,6);return a?(i||new n.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+a)+12*r,this.bb):null}inputEdgesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}outputEdges(r,i){let a=this.bb.__offset(this.bb_pos,8);return a?(i||new n.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+a)+12*r,this.bb):null}outputEdgesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNodeEdge(n){n.startObject(3)}static addNodeIndex(n,r){n.addFieldInt32(0,r,0)}static addInputEdges(n,r){n.addFieldOffset(1,r,0)}static startInputEdgesVector(n,r){n.startVector(12,r,4)}static addOutputEdges(n,r){n.addFieldOffset(2,r,0)}static startOutputEdgesVector(n,r){n.startVector(12,r,4)}static endNodeEdge(n){return n.endObject()}static createNodeEdge(n,r,a,s){return i.startNodeEdge(n),i.addNodeIndex(n,r),i.addInputEdges(n,a),i.addOutputEdges(n,s),i.endNodeEdge(n)}}r.NodeEdge=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsNode(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNode(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}name(n){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,n):null}docString(n){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,n):null}domain(n){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__string(this.bb_pos+r,n):null}sinceVersion(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}index(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readUint32(this.bb_pos+n):0}opType(n){let r=this.bb.__offset(this.bb_pos,14);return r?this.bb.__string(this.bb_pos+r,n):null}type(){let r=this.bb.__offset(this.bb_pos,16);return r?this.bb.readInt32(this.bb_pos+r):n.experimental.fbs.NodeType.Primitive}executionProviderType(n){let r=this.bb.__offset(this.bb_pos,18);return r?this.bb.__string(this.bb_pos+r,n):null}inputs(n,r){let i=this.bb.__offset(this.bb_pos,20);return i?this.bb.__string(this.bb.__vector(this.bb_pos+i)+4*n,r):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,r){let i=this.bb.__offset(this.bb_pos,22);return i?this.bb.__string(this.bb.__vector(this.bb_pos+i)+4*n,r):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}attributes(r,i){let a=this.bb.__offset(this.bb_pos,24);return a?(i||new n.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}attributesLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCounts(n){let r=this.bb.__offset(this.bb_pos,26);return r?this.bb.readInt32(this.bb.__vector(this.bb_pos+r)+4*n):0}inputArgCountsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCountsArray(){let n=this.bb.__offset(this.bb_pos,26);return n?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}implicitInputs(n,r){let i=this.bb.__offset(this.bb_pos,28);return i?this.bb.__string(this.bb.__vector(this.bb_pos+i)+4*n,r):null}implicitInputsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNode(n){n.startObject(13)}static addName(n,r){n.addFieldOffset(0,r,0)}static addDocString(n,r){n.addFieldOffset(1,r,0)}static addDomain(n,r){n.addFieldOffset(2,r,0)}static addSinceVersion(n,r){n.addFieldInt32(3,r,0)}static addIndex(n,r){n.addFieldInt32(4,r,0)}static addOpType(n,r){n.addFieldOffset(5,r,0)}static addType(r,i){r.addFieldInt32(6,i,n.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(n,r){n.addFieldOffset(7,r,0)}static addInputs(n,r){n.addFieldOffset(8,r,0)}static createInputsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startInputsVector(n,r){n.startVector(4,r,4)}static addOutputs(n,r){n.addFieldOffset(9,r,0)}static createOutputsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startOutputsVector(n,r){n.startVector(4,r,4)}static addAttributes(n,r){n.addFieldOffset(10,r,0)}static createAttributesVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startAttributesVector(n,r){n.startVector(4,r,4)}static addInputArgCounts(n,r){n.addFieldOffset(11,r,0)}static createInputArgCountsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addInt32(r[i]);return n.endVector()}static startInputArgCountsVector(n,r){n.startVector(4,r,4)}static addImplicitInputs(n,r){n.addFieldOffset(12,r,0)}static createImplicitInputsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startImplicitInputsVector(n,r){n.startVector(4,r,4)}static endNode(n){return n.endObject()}static createNode(n,r,a,s,o,l,u,c,h,d,p,f,m,g){return i.startNode(n),i.addName(n,r),i.addDocString(n,a),i.addDomain(n,s),i.addSinceVersion(n,o),i.addIndex(n,l),i.addOpType(n,u),i.addType(n,c),i.addExecutionProviderType(n,h),i.addInputs(n,d),i.addOutputs(n,p),i.addAttributes(n,f),i.addInputArgCounts(n,m),i.addImplicitInputs(n,g),i.endNode(n)}}r.Node=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsValueInfo(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsValueInfo(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}name(n){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,n):null}docString(n){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,n):null}type(r){let i=this.bb.__offset(this.bb_pos,8);return i?(r||new n.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}static startValueInfo(n){n.startObject(3)}static addName(n,r){n.addFieldOffset(0,r,0)}static addDocString(n,r){n.addFieldOffset(1,r,0)}static addType(n,r){n.addFieldOffset(2,r,0)}static endValueInfo(n){return n.endObject()}static createValueInfo(n,r,a,s){return i.startValueInfo(n),i.addName(n,r),i.addDocString(n,a),i.addType(n,s),i.endValueInfo(n)}}r.ValueInfo=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsTypeInfo(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTypeInfo(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}denotation(n){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,n):null}valueType(){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.readUint8(this.bb_pos+r):n.experimental.fbs.TypeInfoValue.NONE}value(n){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__union(n,this.bb_pos+r):null}static startTypeInfo(n){n.startObject(3)}static addDenotation(n,r){n.addFieldOffset(0,r,0)}static addValueType(r,i){r.addFieldInt8(1,i,n.experimental.fbs.TypeInfoValue.NONE)}static addValue(n,r){n.addFieldOffset(2,r,0)}static endTypeInfo(n){return n.endObject()}static createTypeInfo(n,r,a,s){return i.startTypeInfo(n),i.addDenotation(n,r),i.addValueType(n,a),i.addValue(n,s),i.endTypeInfo(n)}}r.TypeInfo=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(n){!function(n){class r{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsOperatorSetId(n,i){return(i||new r).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsOperatorSetId(n,i){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(i||new r).__init(n.readInt32(n.position())+n.position(),n)}domain(n){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,n):null}version(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}static startOperatorSetId(n){n.startObject(2)}static addDomain(n,r){n.addFieldOffset(0,r,0)}static addVersion(n,r){n.addFieldInt64(1,r,n.createLong(0,0))}static endOperatorSetId(n){return n.endObject()}static createOperatorSetId(n,i,a){return r.startOperatorSetId(n),r.addDomain(n,i),r.addVersion(n,a),r.endOperatorSetId(n)}}n.OperatorSetId=r}(n.fbs||(n.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsTensor(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensor(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}name(n){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,n):null}docString(n){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,n):null}dims(n){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.readInt64(this.bb.__vector(this.bb_pos+r)+8*n):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}dataType(){let r=this.bb.__offset(this.bb_pos,10);return r?this.bb.readInt32(this.bb_pos+r):n.experimental.fbs.TensorDataType.UNDEFINED}rawData(n){let r=this.bb.__offset(this.bb_pos,12);return r?this.bb.readUint8(this.bb.__vector(this.bb_pos+r)+n):0}rawDataLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}rawDataArray(){let n=this.bb.__offset(this.bb_pos,12);return n?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}stringData(n,r){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.__string(this.bb.__vector(this.bb_pos+i)+4*n,r):null}stringDataLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}static startTensor(n){n.startObject(6)}static addName(n,r){n.addFieldOffset(0,r,0)}static addDocString(n,r){n.addFieldOffset(1,r,0)}static addDims(n,r){n.addFieldOffset(2,r,0)}static createDimsVector(n,r){n.startVector(8,r.length,8);for(let i=r.length-1;i>=0;i--)n.addInt64(r[i]);return n.endVector()}static startDimsVector(n,r){n.startVector(8,r,8)}static addDataType(r,i){r.addFieldInt32(3,i,n.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(n,r){n.addFieldOffset(4,r,0)}static createRawDataVector(n,r){n.startVector(1,r.length,1);for(let i=r.length-1;i>=0;i--)n.addInt8(r[i]);return n.endVector()}static startRawDataVector(n,r){n.startVector(1,r,1)}static addStringData(n,r){n.addFieldOffset(5,r,0)}static createStringDataVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startStringDataVector(n,r){n.startVector(4,r,4)}static endTensor(n){return n.endObject()}static createTensor(n,r,a,s,o,l,u){return i.startTensor(n),i.addName(n,r),i.addDocString(n,a),i.addDims(n,s),i.addDataType(n,o),i.addRawData(n,l),i.addStringData(n,u),i.endTensor(n)}}r.Tensor=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsSparseTensor(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSparseTensor(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}values(r){let i=this.bb.__offset(this.bb_pos,4);return i?(r||new n.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}indices(r){let i=this.bb.__offset(this.bb_pos,6);return i?(r||new n.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}dims(n){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.readInt64(this.bb.__vector(this.bb_pos+r)+8*n):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSparseTensor(n){n.startObject(3)}static addValues(n,r){n.addFieldOffset(0,r,0)}static addIndices(n,r){n.addFieldOffset(1,r,0)}static addDims(n,r){n.addFieldOffset(2,r,0)}static createDimsVector(n,r){n.startVector(8,r.length,8);for(let i=r.length-1;i>=0;i--)n.addInt64(r[i]);return n.endVector()}static startDimsVector(n,r){n.startVector(8,r,8)}static endSparseTensor(n){return n.endObject()}static createSparseTensor(n,r,a,s){return i.startSparseTensor(n),i.addValues(n,r),i.addIndices(n,a),i.addDims(n,s),i.endSparseTensor(n)}}r.SparseTensor=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsAttribute(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsAttribute(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}name(n){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,n):null}docString(n){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.__string(this.bb_pos+r,n):null}type(){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.readInt32(this.bb_pos+r):n.experimental.fbs.AttributeType.UNDEFINED}f(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readFloat32(this.bb_pos+n):0}i(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}s(n){let r=this.bb.__offset(this.bb_pos,14);return r?this.bb.__string(this.bb_pos+r,n):null}t(r){let i=this.bb.__offset(this.bb_pos,16);return i?(r||new n.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}g(r){let i=this.bb.__offset(this.bb_pos,18);return i?(r||new n.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}floats(n){let r=this.bb.__offset(this.bb_pos,20);return r?this.bb.readFloat32(this.bb.__vector(this.bb_pos+r)+4*n):0}floatsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}floatsArray(){let n=this.bb.__offset(this.bb_pos,20);return n?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}ints(n){let r=this.bb.__offset(this.bb_pos,22);return r?this.bb.readInt64(this.bb.__vector(this.bb_pos+r)+8*n):this.bb.createLong(0,0)}intsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}strings(n,r){let i=this.bb.__offset(this.bb_pos,24);return i?this.bb.__string(this.bb.__vector(this.bb_pos+i)+4*n,r):null}stringsLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}tensors(r,i){let a=this.bb.__offset(this.bb_pos,26);return a?(i||new n.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}tensorsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}graphs(r,i){let a=this.bb.__offset(this.bb_pos,28);return a?(i||new n.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}graphsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startAttribute(n){n.startObject(13)}static addName(n,r){n.addFieldOffset(0,r,0)}static addDocString(n,r){n.addFieldOffset(1,r,0)}static addType(r,i){r.addFieldInt32(2,i,n.experimental.fbs.AttributeType.UNDEFINED)}static addF(n,r){n.addFieldFloat32(3,r,0)}static addI(n,r){n.addFieldInt64(4,r,n.createLong(0,0))}static addS(n,r){n.addFieldOffset(5,r,0)}static addT(n,r){n.addFieldOffset(6,r,0)}static addG(n,r){n.addFieldOffset(7,r,0)}static addFloats(n,r){n.addFieldOffset(8,r,0)}static createFloatsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addFloat32(r[i]);return n.endVector()}static startFloatsVector(n,r){n.startVector(4,r,4)}static addInts(n,r){n.addFieldOffset(9,r,0)}static createIntsVector(n,r){n.startVector(8,r.length,8);for(let i=r.length-1;i>=0;i--)n.addInt64(r[i]);return n.endVector()}static startIntsVector(n,r){n.startVector(8,r,8)}static addStrings(n,r){n.addFieldOffset(10,r,0)}static createStringsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startStringsVector(n,r){n.startVector(4,r,4)}static addTensors(n,r){n.addFieldOffset(11,r,0)}static createTensorsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startTensorsVector(n,r){n.startVector(4,r,4)}static addGraphs(n,r){n.addFieldOffset(12,r,0)}static createGraphsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startGraphsVector(n,r){n.startVector(4,r,4)}static endAttribute(n){return n.endObject()}static createAttribute(n,r,a,s,o,l,u,c,h,d,p,f,m,g){return i.startAttribute(n),i.addName(n,r),i.addDocString(n,a),i.addType(n,s),i.addF(n,o),i.addI(n,l),i.addS(n,u),i.addT(n,c),i.addG(n,h),i.addFloats(n,d),i.addInts(n,p),i.addStrings(n,f),i.addTensors(n,m),i.addGraphs(n,g),i.endAttribute(n)}}r.Attribute=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsGraph(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsGraph(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}initializers(r,i){let a=this.bb.__offset(this.bb_pos,4);return a?(i||new n.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}initializersLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeArgs(r,i){let a=this.bb.__offset(this.bb_pos,6);return a?(i||new n.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}nodeArgsLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}nodes(r,i){let a=this.bb.__offset(this.bb_pos,8);return a?(i||new n.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}nodesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}maxNodeIndex(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readUint32(this.bb_pos+n):0}nodeEdges(r,i){let a=this.bb.__offset(this.bb_pos,12);return a?(i||new n.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}nodeEdgesLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}inputs(n,r){let i=this.bb.__offset(this.bb_pos,14);return i?this.bb.__string(this.bb.__vector(this.bb_pos+i)+4*n,r):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,r){let i=this.bb.__offset(this.bb_pos,16);return i?this.bb.__string(this.bb.__vector(this.bb_pos+i)+4*n,r):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__vector_len(this.bb_pos+n):0}sparseInitializers(r,i){let a=this.bb.__offset(this.bb_pos,18);return a?(i||new n.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}sparseInitializersLength(){let n=this.bb.__offset(this.bb_pos,18);return n?this.bb.__vector_len(this.bb_pos+n):0}static startGraph(n){n.startObject(8)}static addInitializers(n,r){n.addFieldOffset(0,r,0)}static createInitializersVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startInitializersVector(n,r){n.startVector(4,r,4)}static addNodeArgs(n,r){n.addFieldOffset(1,r,0)}static createNodeArgsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startNodeArgsVector(n,r){n.startVector(4,r,4)}static addNodes(n,r){n.addFieldOffset(2,r,0)}static createNodesVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startNodesVector(n,r){n.startVector(4,r,4)}static addMaxNodeIndex(n,r){n.addFieldInt32(3,r,0)}static addNodeEdges(n,r){n.addFieldOffset(4,r,0)}static createNodeEdgesVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startNodeEdgesVector(n,r){n.startVector(4,r,4)}static addInputs(n,r){n.addFieldOffset(5,r,0)}static createInputsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startInputsVector(n,r){n.startVector(4,r,4)}static addOutputs(n,r){n.addFieldOffset(6,r,0)}static createOutputsVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startOutputsVector(n,r){n.startVector(4,r,4)}static addSparseInitializers(n,r){n.addFieldOffset(7,r,0)}static createSparseInitializersVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startSparseInitializersVector(n,r){n.startVector(4,r,4)}static endGraph(n){return n.endObject()}static createGraph(n,r,a,s,o,l,u,c,h){return i.startGraph(n),i.addInitializers(n,r),i.addNodeArgs(n,a),i.addNodes(n,s),i.addMaxNodeIndex(n,o),i.addNodeEdges(n,l),i.addInputs(n,u),i.addOutputs(n,c),i.addSparseInitializers(n,h),i.endGraph(n)}}r.Graph=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsModel(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsModel(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}irVersion(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}opsetImport(r,i){let a=this.bb.__offset(this.bb_pos,6);return a?(i||new n.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}opsetImportLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}producerName(n){let r=this.bb.__offset(this.bb_pos,8);return r?this.bb.__string(this.bb_pos+r,n):null}producerVersion(n){let r=this.bb.__offset(this.bb_pos,10);return r?this.bb.__string(this.bb_pos+r,n):null}domain(n){let r=this.bb.__offset(this.bb_pos,12);return r?this.bb.__string(this.bb_pos+r,n):null}modelVersion(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}docString(n){let r=this.bb.__offset(this.bb_pos,16);return r?this.bb.__string(this.bb_pos+r,n):null}graph(r){let i=this.bb.__offset(this.bb_pos,18);return i?(r||new n.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}graphDocString(n){let r=this.bb.__offset(this.bb_pos,20);return r?this.bb.__string(this.bb_pos+r,n):null}static startModel(n){n.startObject(9)}static addIrVersion(n,r){n.addFieldInt64(0,r,n.createLong(0,0))}static addOpsetImport(n,r){n.addFieldOffset(1,r,0)}static createOpsetImportVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startOpsetImportVector(n,r){n.startVector(4,r,4)}static addProducerName(n,r){n.addFieldOffset(2,r,0)}static addProducerVersion(n,r){n.addFieldOffset(3,r,0)}static addDomain(n,r){n.addFieldOffset(4,r,0)}static addModelVersion(n,r){n.addFieldInt64(5,r,n.createLong(0,0))}static addDocString(n,r){n.addFieldOffset(6,r,0)}static addGraph(n,r){n.addFieldOffset(7,r,0)}static addGraphDocString(n,r){n.addFieldOffset(8,r,0)}static endModel(n){return n.endObject()}static createModel(n,r,a,s,o,l,u,c,h,d){return i.startModel(n),i.addIrVersion(n,r),i.addOpsetImport(n,a),i.addProducerName(n,s),i.addProducerVersion(n,o),i.addDomain(n,l),i.addModelVersion(n,u),i.addDocString(n,c),i.addGraph(n,h),i.addGraphDocString(n,d),i.endModel(n)}}r.Model=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(n){!function(n){class r{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsKernelCreateInfos(n,i){return(i||new r).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsKernelCreateInfos(n,i){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(i||new r).__init(n.readInt32(n.position())+n.position(),n)}nodeIndices(n){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.readUint32(this.bb.__vector(this.bb_pos+r)+4*n):0}nodeIndicesLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeIndicesArray(){let n=this.bb.__offset(this.bb_pos,4);return n?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}kernelDefHashes(n){let r=this.bb.__offset(this.bb_pos,6);return r?this.bb.readUint64(this.bb.__vector(this.bb_pos+r)+8*n):this.bb.createLong(0,0)}kernelDefHashesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startKernelCreateInfos(n){n.startObject(2)}static addNodeIndices(n,r){n.addFieldOffset(0,r,0)}static createNodeIndicesVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addInt32(r[i]);return n.endVector()}static startNodeIndicesVector(n,r){n.startVector(4,r,4)}static addKernelDefHashes(n,r){n.addFieldOffset(1,r,0)}static createKernelDefHashesVector(n,r){n.startVector(8,r.length,8);for(let i=r.length-1;i>=0;i--)n.addInt64(r[i]);return n.endVector()}static startKernelDefHashesVector(n,r){n.startVector(8,r,8)}static endKernelCreateInfos(n){return n.endObject()}static createKernelCreateInfos(n,i,a){return r.startKernelCreateInfos(n),r.addNodeIndices(n,i),r.addKernelDefHashes(n,a),r.endKernelCreateInfos(n)}}n.KernelCreateInfos=r}(n.fbs||(n.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsSubGraphSessionState(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSubGraphSessionState(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}graphId(n){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,n):null}sessionState(r){let i=this.bb.__offset(this.bb_pos,6);return i?(r||new n.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}static startSubGraphSessionState(n){n.startObject(2)}static addGraphId(n,r){n.addFieldOffset(0,r,0)}static addSessionState(n,r){n.addFieldOffset(1,r,0)}static endSubGraphSessionState(n){let r=n.endObject();return n.requiredField(r,4),r}static createSubGraphSessionState(n,r,a){return i.startSubGraphSessionState(n),i.addGraphId(n,r),i.addSessionState(n,a),i.endSubGraphSessionState(n)}}r.SubGraphSessionState=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsSessionState(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSessionState(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}kernels(r){let i=this.bb.__offset(this.bb_pos,4);return i?(r||new n.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}subGraphSessionStates(r,i){let a=this.bb.__offset(this.bb_pos,6);return a?(i||new n.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+a)+4*r),this.bb):null}subGraphSessionStatesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSessionState(n){n.startObject(2)}static addKernels(n,r){n.addFieldOffset(0,r,0)}static addSubGraphSessionStates(n,r){n.addFieldOffset(1,r,0)}static createSubGraphSessionStatesVector(n,r){n.startVector(4,r.length,4);for(let i=r.length-1;i>=0;i--)n.addOffset(r[i]);return n.endVector()}static startSubGraphSessionStatesVector(n,r){n.startVector(4,r,4)}static endSessionState(n){return n.endObject()}static createSessionState(n,r,a){return i.startSessionState(n),i.addKernels(n,r),i.addSubGraphSessionStates(n,a),i.endSessionState(n)}}r.SessionState=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={})),function(n){!function(r){!function(r){class i{constructor(){this.bb=null,this.bb_pos=0}__init(n,r){return this.bb_pos=n,this.bb=r,this}static getRootAsInferenceSession(n,r){return(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsInferenceSession(n,r){return n.setPosition(n.position()+o.flatbuffers.SIZE_PREFIX_LENGTH),(r||new i).__init(n.readInt32(n.position())+n.position(),n)}static bufferHasIdentifier(n){return n.__has_identifier("ORTM")}ortVersion(n){let r=this.bb.__offset(this.bb_pos,4);return r?this.bb.__string(this.bb_pos+r,n):null}model(r){let i=this.bb.__offset(this.bb_pos,6);return i?(r||new n.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}sessionState(r){let i=this.bb.__offset(this.bb_pos,8);return i?(r||new n.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+i),this.bb):null}static startInferenceSession(n){n.startObject(3)}static addOrtVersion(n,r){n.addFieldOffset(0,r,0)}static addModel(n,r){n.addFieldOffset(1,r,0)}static addSessionState(n,r){n.addFieldOffset(2,r,0)}static endInferenceSession(n){return n.endObject()}static finishInferenceSessionBuffer(n,r){n.finish(r,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(n,r){n.finish(r,"ORTM",!0)}static createInferenceSession(n,r,a,s){return i.startInferenceSession(n),i.addOrtVersion(n,r),i.addModel(n,a),i.addSessionState(n,s),i.endInferenceSession(n)}}r.InferenceSession=i}(r.fbs||(r.fbs={}))}(n.experimental||(n.experimental={}))}(r.onnxruntime||(r.onnxruntime={}))},7448:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.OnnxjsSessionHandler=void 0;let a=i(1670),s=i(9162);r.OnnxjsSessionHandler=class{constructor(n){this.session=n,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(n,r,i){let o=new Map;for(let r in n)if(Object.hasOwnProperty.call(n,r)){let i=n[r];o.set(r,new s.Tensor(i.dims,i.type,void 0,void 0,i.data))}let l=await this.session.run(o),u={};return l.forEach((n,r)=>{u[r]=new a.Tensor(n.type,n.data,n.dims)}),u}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Session=void 0;let a=i(7067),s=i(1296),o=i(7091),l=i(1036),u=i(6231),c=i(2644);r.Session=class{constructor(n={}){this._initialized=!1,this.backendHint=n.backendHint,this.profiler=u.Profiler.create(n.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(n,r,i){await this.profiler.event("session","Session.loadModel",async()=>{let l=await (0,o.resolveBackend)(this.backendHint);if(this.sessionHandler=l.createSessionHandler(this.context),this._model=new c.Model,"string"==typeof n){let r=n.endsWith(".ort");if("undefined"==typeof fetch){let i=await (0,s.promisify)(a.readFile)(n);this.initialize(i,r)}else{let i=await fetch(n),a=await i.arrayBuffer();this.initialize(new Uint8Array(a),r)}}else if(ArrayBuffer.isView(n))this.initialize(n);else{let a=new Uint8Array(n,r||0,i||n.byteLength);this.initialize(a)}})}initialize(n,r){if(this._initialized)throw Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let i=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(n,i,r),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new l.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(n){if(!this._initialized)throw Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let r=this.normalizeAndValidateInputs(n),i=await this._executionPlan.execute(this.sessionHandler,r);return this.createOutput(i)})}normalizeAndValidateInputs(n){let r=this._model.graph.getInputNames();if(Array.isArray(n)){if(n.length!==r.length)throw Error(`incorrect input array length: expected ${r.length} but got ${n.length}`)}else{if(n.size!==r.length)throw Error(`incorrect input map size: expected ${r.length} but got ${n.size}`);let i=Array(n.size),a=0;for(let s=0;s<r.length;++s){let o=n.get(r[s]);if(!o)throw Error(`missing input tensor for: '${name}'`);i[a++]=o}n=i}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,n,!1);else{let r=this._model.graph.getInputIndices(),i=this._model.graph.getValues(),a=Array(r.length);for(let s=0;s<r.length;++s){let o=i[r[s]];a[s]=o.type.shape.dims,this.context.graphInputTypes.push(o.type.tensorType),this.context.graphInputDims.push(n[s].dims)}this.validateInputTensorDims(a,n,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,n),n}validateInputTensorTypes(n,r){for(let i=0;i<r.length;i++){let a=n[i],s=r[i].type;if(a!==s)throw Error(`input tensor[${i}] check failed: expected type '${a}' but got ${s}`)}}validateInputTensorDims(n,r,i){for(let a=0;a<r.length;a++){let s=n[a],o=r[a].dims;if(!this.compareTensorDims(s,o,i))throw Error(`input tensor[${a}] check failed: expected shape '[${s.join(",")}]' but got [${o.join(",")}]`)}}compareTensorDims(n,r,i){if(n.length!==r.length)return!1;for(let a=0;a<n.length;++a)if(n[a]!==r[a]&&(!i||0!==n[a]))return!1;return!0}createOutput(n){let r=this._model.graph.getOutputNames();if(n.length!==r.length)throw Error("expected number of outputs do not match number of generated outputs");let i=new Map;for(let a=0;a<r.length;++a)i.set(r[a],n[a]);return i}initializeOps(n){let r=n.getNodes();this._ops=Array(r.length);for(let i=0;i<r.length;i++)this._ops[i]=this.sessionHandler.resolve(r[i],this._model.opsets,n)}}},9162:function(n,r,i){var a=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(r,"__esModule",{value:!0}),r.Tensor=void 0;let s=i(3442),o=a(i(3720)),l=i(1446),u=i(9395),c=i(2517);var h=u.onnxruntime.experimental.fbs;class d{get data(){if(void 0===this.cache){let n=this.dataProvider(this.dataId);if(n.length!==this.size)throw Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=n}return this.cache}get stringData(){if("string"!==this.type)throw TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw TypeError("type cannot be non-number (string)")}get(n){return this.data[c.ShapeUtil.indicesToOffset(n,this.strides)]}set(n,r){this.data[c.ShapeUtil.indicesToOffset(n,this.strides)]=r}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=c.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(n,r,i,a,o,l=s.Guid.create()){this.dims=n,this.type=r,this.dataProvider=i,this.asyncDataProvider=a,this.cache=o,this.dataId=l,this.size=c.ShapeUtil.validateDimsAndCalcSize(n);let u=this.size,h=void 0===i&&void 0===a&&void 0===o;if(void 0!==o&&o.length!==u)throw RangeError("Input dims doesn't match data length.");if("string"===r){if(!(void 0===o||Array.isArray(o)&&o.every(n=>"string"==typeof n)))throw TypeError("cache should be a string array");h&&(this.cache=Array(u))}else{if(void 0!==o){let n=f(r);if(!(o instanceof n))throw TypeError(`cache should be type ${n.name}`)}if(h){let n=new ArrayBuffer(u*function(n){switch(n){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw Error(`cannot calculate sizeof() on type ${n}`)}}(r));this.cache=function(n,r){return new(f(r))(n)}(n,r)}}}static fromProto(n){if(!n)throw Error("cannot construct Value from an empty tensor");let r=c.ProtoUtil.tensorDataTypeFromProto(n.dataType),i=c.ProtoUtil.tensorDimsFromProto(n.dims),a=new d(i,r);if("string"===r)n.stringData.forEach((n,r)=>{a.data[r]=(0,c.decodeUtf8String)(n)});else if(n.rawData&&"number"==typeof n.rawData.byteLength&&n.rawData.byteLength>0){let r=a.data,i=new DataView(n.rawData.buffer,n.rawData.byteOffset,n.rawData.byteLength),s=p(n.dataType),o=n.rawData.byteLength/s;if(n.rawData.byteLength%s!=0)throw Error("invalid buffer length");if(r.length!==o)throw Error("buffer length mismatch");for(let a=0;a<o;a++){let o=g(i,n.dataType,a*s);r[a]=o}}else{let r;switch(n.dataType){case l.onnx.TensorProto.DataType.FLOAT:r=n.floatData;break;case l.onnx.TensorProto.DataType.INT32:case l.onnx.TensorProto.DataType.INT16:case l.onnx.TensorProto.DataType.UINT16:case l.onnx.TensorProto.DataType.INT8:case l.onnx.TensorProto.DataType.UINT8:case l.onnx.TensorProto.DataType.BOOL:r=n.int32Data;break;case l.onnx.TensorProto.DataType.INT64:r=n.int64Data;break;case l.onnx.TensorProto.DataType.DOUBLE:r=n.doubleData;break;case l.onnx.TensorProto.DataType.UINT32:case l.onnx.TensorProto.DataType.UINT64:r=n.uint64Data;break;default:throw Error("unspecific error")}if(null==r)throw Error("failed to populate data from a tensorproto value");let i=a.data;if(i.length!==r.length)throw Error("array length mismatch");for(let a=0;a<r.length;a++){let s=r[a];o.default.isLong(s)?i[a]=m(s,n.dataType):i[a]=s}}return a}static fromData(n,r,i){return new d(r,i,void 0,void 0,n)}static fromOrtTensor(n){if(!n)throw Error("cannot construct Value from an empty tensor");let r=c.ProtoUtil.tensorDimsFromORTFormat(n),i=c.ProtoUtil.tensorDataTypeFromProto(n.dataType()),a=new d(r,i);if("string"===i)for(let r=0;r<n.stringDataLength();r++)a.data[r]=n.stringData(r);else if(n.rawDataArray()&&"number"==typeof n.rawDataLength()&&n.rawDataLength()>0){let r=a.data,i=new DataView(n.rawDataArray().buffer,n.rawDataArray().byteOffset,n.rawDataLength()),s=p(n.dataType()),o=n.rawDataLength()/s;if(n.rawDataLength()%s!=0)throw Error("invalid buffer length");if(r.length!==o)throw Error("buffer length mismatch");for(let a=0;a<o;a++){let o=g(i,n.dataType(),a*s);r[a]=o}}return a}}function p(n){switch(n){case l.onnx.TensorProto.DataType.UINT8:case l.onnx.TensorProto.DataType.INT8:case l.onnx.TensorProto.DataType.BOOL:return 1;case l.onnx.TensorProto.DataType.UINT16:case l.onnx.TensorProto.DataType.INT16:return 2;case l.onnx.TensorProto.DataType.FLOAT:case l.onnx.TensorProto.DataType.INT32:case l.onnx.TensorProto.DataType.UINT32:return 4;case l.onnx.TensorProto.DataType.INT64:case l.onnx.TensorProto.DataType.DOUBLE:case l.onnx.TensorProto.DataType.UINT64:return 8;default:throw Error(`cannot calculate sizeof() on type ${l.onnx.TensorProto.DataType[n]}`)}}function f(n){switch(n){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw Error("unspecified error")}}function m(n,r){if(r===l.onnx.TensorProto.DataType.INT64||r===h.TensorDataType.INT64){if(n.greaterThanOrEqual(2147483648)||n.lessThan(-2147483648))throw TypeError("int64 is not supported")}else{if(r!==l.onnx.TensorProto.DataType.UINT32&&r!==h.TensorDataType.UINT32&&r!==l.onnx.TensorProto.DataType.UINT64&&r!==h.TensorDataType.UINT64)throw TypeError(`not a LONG type: ${l.onnx.TensorProto.DataType[r]}`);if(n.greaterThanOrEqual(4294967296)||n.lessThan(0))throw TypeError("uint64 is not supported")}return n.toNumber()}function g(n,r,i){switch(r){case l.onnx.TensorProto.DataType.BOOL:case l.onnx.TensorProto.DataType.UINT8:return n.getUint8(i);case l.onnx.TensorProto.DataType.INT8:return n.getInt8(i);case l.onnx.TensorProto.DataType.UINT16:return n.getUint16(i,!0);case l.onnx.TensorProto.DataType.INT16:return n.getInt16(i,!0);case l.onnx.TensorProto.DataType.FLOAT:return n.getFloat32(i,!0);case l.onnx.TensorProto.DataType.INT32:return n.getInt32(i,!0);case l.onnx.TensorProto.DataType.UINT32:return n.getUint32(i,!0);case l.onnx.TensorProto.DataType.INT64:return m(o.default.fromBits(n.getUint32(i,!0),n.getUint32(i+4,!0),!1),r);case l.onnx.TensorProto.DataType.DOUBLE:return n.getFloat64(i,!0);case l.onnx.TensorProto.DataType.UINT64:return m(o.default.fromBits(n.getUint32(i,!0),n.getUint32(i+4,!0),!0),r);default:throw Error(`cannot read from DataView for type ${l.onnx.TensorProto.DataType[r]}`)}}r.Tensor=d},2517:function(n,r,i){var a=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(r,"__esModule",{value:!0}),r.decodeUtf8String=r.MAX_CLIP=r.MIN_CLIP=r.PoolConvUtil=r.ReduceUtil=r.SplitUtil=r.MathUtil=r.ShapeUtil=r.LongUtil=r.ProtoUtil=r.GemmUtil=r.arrayCopyHelper=r.BroadcastUtil=r.MatMulUtil=r.ArrayUtil=r.assert=r.checkInputsShape=void 0;let s=i(5686),o=a(i(3720)),l=i(1446),u=i(9162);r.checkInputsShape=function(n,...r){if(!n||n.length!==r.length)return!1;for(let i=0;i<n.length;i++)if(!n[i].dims||n[i].dims.length!==r[i])return!1;return!0},r.assert=function(n,r){if(!n)throw Error("string"==typeof r?r:r())},r.ArrayUtil=class{static arraysEqual(n,r){if(n.length!==r.length)return!1;for(let i=0;i<n.length;i++)if(n[i]!==r[i])return!1;return!0}};class c{static preprocessInputShapes(n,r){return[1===n.length?[1,n[0]]:n,1===r.length?[r[0],1]:r]}static postprocessOutputShape(n,r,i){1===r&&n.splice(n.length-2,1),1===i&&n.pop()}static calcMatMulShape(n,r){return n[1]!==r[0]?void 0:[n[0],r[1]]}}r.MatMulUtil=c;class h{static calcShape(n,r,i=!1){let a=n.length,s=r.length;if(0===a)return r;if(0===s)return n;let o=Math.max(n.length,r.length),l=Array(o);if(i){if(a<2||s<2)return;let i=c.calcMatMulShape([n[a-2],n[a-1]],[r[s-2],r[s-1]]);if(void 0===i)return;[l[o-2],l[o-1]]=i}for(let u=i?3:1;u<=o;u++){let i=a-u<0?1:n[a-u],c=s-u<0?1:r[s-u];if(i!==c&&i>1&&c>1)return;l[o-u]=Math.max(i,c)}return l}static index(n,r){let i=Array(r.length);return h.fillIndex(n,r,i),i}static fillIndex(n,r,i){let a=n.length-r.length;for(let s=0;s<r.length;s++)i[s]=n[a+s]%r[s]}static calc(n,r,i,a,s){let o=h.calcShape(n.dims,r.dims);if(o){if(a&&!f.areEqual(o,n.dims))return;let l=f.size(o),c=a?n:new u.Tensor(o,s||n.type);if(0===o.length)c.set([],i(n.get([]),r.get([])));else{let a=Array(o.length),s=Array(n.dims.length),u=Array(r.dims.length),d,p=0,f=0,m=!1,g=!1;0===n.dims.length&&(p=n.get([]),m=!0),0===r.dims.length&&(f=r.get([]),g=!0);for(let _=0;_<l;_++){d=_;for(let n=o.length-1;n>=0;n--)a[n]=d%o[n],d=Math.floor(d/o[n]);m||(h.fillIndex(a,n.dims,s),p=n.get(s)),g||(h.fillIndex(a,r.dims,u),f=r.get(u)),c.set(a,i(p,f))}}return c}}static isValidBroadcast(n,r){let i=n.length,a=r.length;if(i>a)return!1;for(let s=1;s<=i;s++)if(1!==n[i-s]&&n[i-s]!==r[a-s])return!1;return!0}static getBroadcastDims(n,r){let i=n.length,a=[];for(let s=0;s<i;s++){let o=i-1-s,l=n[o]||1;(r[r.length-1-s]||1)>1&&1===l&&a.unshift(o)}return a}}r.BroadcastUtil=h,r.arrayCopyHelper=function(n,r,i,a,s){if(a<0||a>=r.length)throw Error("sourceIndex out of bounds");if(i<0||i>=n.length)throw Error("targetIndex out of bounds");if(a+s>r.length)throw Error("source indices to be copied are outside bounds");if(i+s>n.length)throw Error("target array is too small to hold result");for(let o=0;o<s;o++)n[i+o]=r[a+o]},r.GemmUtil=class{static getShapeOfGemmResult(n,r,i,a,s){let o,l,u;if(2!==n.length||2!==i.length)throw Error("shape need to be of size 2");r?(o=n[1],l=n[0]):(o=n[0],l=n[1]);let c=-1;if(a?(u=i[0],c=1):(u=i[1],c=0),i[c]!==l)throw Error("dimension mismatch");if(o<=0||u<=0||l<=0)throw Error("invalid shape specified");if(s&&!h.isValidBroadcast(s,[o,u]))throw Error("gemm: invalid bias shape for broadcast");return[o,u,l]}};class d{static tensorDataTypeFromProto(n){switch(n){case l.onnx.TensorProto.DataType.INT8:return"int8";case l.onnx.TensorProto.DataType.UINT8:return"uint8";case l.onnx.TensorProto.DataType.BOOL:return"bool";case l.onnx.TensorProto.DataType.INT16:return"int16";case l.onnx.TensorProto.DataType.UINT16:return"uint16";case l.onnx.TensorProto.DataType.INT32:return"int32";case l.onnx.TensorProto.DataType.UINT32:return"uint32";case l.onnx.TensorProto.DataType.FLOAT:return"float32";case l.onnx.TensorProto.DataType.DOUBLE:return"float64";case l.onnx.TensorProto.DataType.STRING:return"string";case l.onnx.TensorProto.DataType.INT64:return"int32";case l.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw Error(`unsupported data type: ${l.onnx.TensorProto.DataType[n]}`)}}static tensorDataTypeStringToEnum(n){switch(n){case"int8":return l.onnx.TensorProto.DataType.INT8;case"uint8":return l.onnx.TensorProto.DataType.UINT8;case"bool":return l.onnx.TensorProto.DataType.BOOL;case"int16":return l.onnx.TensorProto.DataType.INT16;case"uint16":return l.onnx.TensorProto.DataType.UINT16;case"int32":return l.onnx.TensorProto.DataType.INT32;case"uint32":return l.onnx.TensorProto.DataType.UINT32;case"float32":return l.onnx.TensorProto.DataType.FLOAT;case"float64":return l.onnx.TensorProto.DataType.DOUBLE;case"string":return l.onnx.TensorProto.DataType.STRING;case"int64":return l.onnx.TensorProto.DataType.INT64;case"uint64":return l.onnx.TensorProto.DataType.UINT64;default:throw Error(`unsupported data type: ${n}`)}}static tensorDimsFromProto(n){return n.map(n=>o.default.isLong(n)?n.toNumber():n)}static tensorValueTypeFromProto(n){return{tensorType:d.tensorDataTypeFromProto(n.elemType),shape:{dims:d.tensorDimsFromProto(n.shape.dim.map(n=>n.dimValue))}}}static tensorDimsFromORTFormat(n){let r=[];for(let i=0;i<n.dimsLength();i++)r.push(p.longToNumber(n.dims(i)));return r}static tensorAttributesFromORTFormat(n){let r=[];for(let i=0;i<n.attributesLength();i++)r.push(n.attributes(i));return r}}r.ProtoUtil=d;class p{static longToNumber(n,r){return o.default.isLong(n)?n.toNumber():n instanceof s.flatbuffers.Long?o.default.fromValue({low:n.low,high:n.high,unsigned:null!=r&&r}).toNumber():n}static isLong(n){return o.default.isLong(n)||n instanceof s.flatbuffers.Long}}r.LongUtil=p;class f{static size(n){return f.getSizeFromDimensionRange(n,0,n.length)}static sizeFromDimension(n,r){if(r<0||r>n.length)throw Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${n.length} dimensions.`);return f.getSizeFromDimensionRange(n,r,n.length)}static sizeToDimension(n,r){if(r<0||r>n.length)throw Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${n.length} dimensions.`);return f.getSizeFromDimensionRange(n,0,r)}static getSizeFromDimensionRange(n,r,i){let a=1;for(let s=r;s<i;s++){if(n[s]<=0)throw Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");a*=n[s]}return a}static computeStrides(n){let r=n.length;if(0===r)return[];if(1===r)return[1];let i=Array(r);i[r-1]=1,i[r-2]=n[r-1];for(let a=r-3;a>=0;--a)i[a]=i[a+1]*n[a+1];return i}static transpose(n){return n.slice().reverse()}static indicesToOffset(n,r,i){void 0===i&&(i=n.length);let a=0;for(let s=0;s<i;++s)a+=r[s]*n[s];return a}static offsetToIndices(n,r){let i=r.length;if(0===i)return[];if(1===i)return[n*r[0]];let a=Array(r.length);for(let i=0;i<a.length-1;++i)a[i]=Math.floor(n/r[i]),n-=a[i]*r[i];return a[a.length-1]=n,a}static normalizeAxis(n,r){if(n<-r&&n>=r)throw Error("unsupported axis for this operation.");return n<0?n+r:n}static normalizeAxes(n,r){return n.map(n=>this.normalizeAxis(n,r))}static incrementIndex(n,r,i){if(0===r.length||0===n.length)throw Error("Index incrementing unsupported for scalar Tensor");if(void 0===i)i=r.length;else if(i<=0||i>r.length)throw Error("Incorrect axis to increment on");for(let a=i-1;a>=0&&(n[a]++,!(n[a]<r[a]));--a)n[a]=0}static calculateReshapedDims(n,r){if(0===r.length){if(0===n.length||1===f.size(n))return[];throw Error("cannot reshape to a scalar Tensor")}let i=r.length,a=Array(i),s=-1,o=1;for(let l=0;l<i;l++){if(r[l]<-1)throw Error("a dimension in shape hints cannot be less than -1");if(-1===r[l]){if(-1!==s)throw Error("at most one dimension in shape hints can be -1");s=l}else{if(0===r[l]){if(l>=n.length)throw Error("the dimension with value zero exceeds the dimension size of the input tensor");a[l]=n[l]}else a[l]=r[l];o*=a[l]}}let l=f.size(n);if(-1!==s){if(l%o!=0)throw Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${n}] Output shape: [${r}]`);a[s]=l/o}else if(o!==l)throw Error("reshapedDims and originalDims don't have matching sizes");return a}static sortBasedOnPerm(n,r){return r?r.map(r=>n[r]):n.slice().reverse()}static padShape(n,r){let i=n.length;return n.map((n,a)=>n+r[a]+r[a+i])}static areEqual(n,r){return n.length===r.length&&n.every((n,i)=>n===r[i])}static validateDimsAndCalcSize(n){if(n.length>6)throw TypeError("Only rank 0 to 6 is supported for tensor shape.");let r=1;for(let i of n){if(!Number.isInteger(i))throw TypeError(`Invalid shape: ${i} is not an integer`);if(i<0||i>2147483647)throw TypeError(`Invalid shape: length ${i} is not allowed`);r*=i}return r}static flattenShape(n,r){r<0&&(r+=n.length);let i=n.reduce((n,r)=>n*r,1),a=n.slice(r).reduce((n,r)=>n*r,1);return[i/a,a]}static squeezeShape(n,r){let i=[];r=f.normalizeAxes(r,n.length);for(let a=0;a<n.length;a++){let s=r.indexOf(a)>=0;if(s&&1!==n[a])throw Error("squeeze an axis of size different than 1");(0===r.length&&n[a]>1||r.length>0&&!s)&&i.push(n[a])}return i}static unsqueezeShape(n,r){let i=Array(n.length+r.length);i.fill(0);for(let n=0;n<r.length;n++){let a=f.normalizeAxis(r[n],i.length);if(a>=i.length)throw Error("'axes' has an out of range axis");if(0!==i[a])throw Error("'axes' has a duplicate axis");i[a]=1}let a=0;for(let r=0;r<i.length;r++)0===i[r]&&(i[r]=n[a++]);if(a!==n.length)throw Error("the unsqueezed dimension could not be established");return i}}r.ShapeUtil=f,r.MathUtil=class{static sqr(n,r,i,a,s){if(a<0||a>=r.length)throw Error("sourceIndex out of bounds");if(i<0||i>=n.length)throw Error("targetIndex out of bounds");if(a+s>r.length)throw Error("source indices to be copied are outside bounds");if(i+s>n.length)throw Error("target array is too small to hold result");for(let o=0;o<s;o++)n[i+o]+=Math.pow(r[a+o],2)}static axpy(n,r,i,a,s,o){if(a<0||a>=r.length)throw Error("sourceIndex out of bounds");if(i<0||i>=n.length)throw Error("targetIndex out of bounds");if(a+s>r.length)throw Error("source indices to be copied are outside bounds");if(i+s>n.length)throw Error("target array is too small to hold result");for(let l=0;l<s;l++)n[i+l]+=o*r[a+l]}static powx(n,r,i,a,s,o){if(a<0||a>=r.length)throw Error("sourceIndex out of bounds");if(i<0||i>=n.length)throw Error("targetIndex out of bounds");if(a+s>r.length)throw Error("source indices to be copied are outside bounds");if(i+s>n.length)throw Error("target array is too small to hold result");for(let l=0;l<s;l++)n[i+l]=Math.pow(r[a+l],o)}static mul(n,r,i,a,s){if(a<0||a>=r.length)throw Error("sourceIndex out of bounds");if(i<0||i>=n.length)throw Error("targetIndex out of bounds");if(a+s>r.length)throw Error("source indices to be copied are outside bounds");if(i+s>n.length)throw Error("target array is too small to hold result");for(let o=0;o<s;o++)n[i+o]=r[a+o]*n[i+o]}};class m{static splitShape(n,r,i,a){if(0===i.length){if(!a)throw Error("need to know number of outputs when the 'split' attribute is not specified");m.determineSplit(n[r],a,i)}let s=[],o=[0];for(let a=0;a<i.length;++a){0!==a&&o.push(o[a-1]+i[a-1]);let l=n.slice();l[r]=i[a],s.push(l)}return[s,o]}static determineSplit(n,r,i){if(n%r!=0)throw Error("cannot split tensor to equal sized parts");for(let a=0;a<r;++a)i.push(n/r)}}r.SplitUtil=m;class g{static calcReduce(n,r,i,a,s){let o=n.dims.slice(0);0===r.length&&o.forEach((n,i)=>r.push(i));let l=g.calcReduceShape(o,r,!0),c=f.size(l),d=new u.Tensor(l,n.type),p=f.computeStrides(l),m=f.computeStrides(o),_=Array(o.length);for(let i=0;i<c;i++){let l=f.offsetToIndices(i,p);h.fillIndex(l,o,_),d.set(l,g.calcReduceByAxis(n.numberData,r,o,0,f.indicesToOffset(_,m),a,s))}return i?d:new u.Tensor(g.calcReduceShape(o,r,i),d.type,void 0,void 0,d.data,d.dataId)}static calcReduceByAxis(n,r,i,a,s,o,l){let u=0;if(a>=r.length)return o(n[s]);let c=r[a],h=c>=i.length?1:f.size(i.slice(c+1));for(let d=0;d<i[c];d++)u=0===d?g.calcReduceByAxis(n,r,i,a+1,s,o,l):l(u,g.calcReduceByAxis(n,r,i,a+1,s,o,l)),s+=h;return u}static calcReduceShape(n,r,i){let a=n.slice();for(let n=0;n<r.length;n++)a[r[n]]=i?1:0;return a.filter(n=>0!==n)}}r.ReduceUtil=g;class _{static adjustPoolAttributes(n,r,i,a,s,o){if(!n&&i.length!==r.length-2)throw Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(n)for(let n=0;n<r.length-2;n++)n>=i.length?i.push(r[n+2]):i[n]=r[n+2];for(let n=0;n<i.length;n++)if(n<a.length){if(a[n]<0)throw Error("strides should be greater than or equal to 1")}else a.push(1);for(let n=0;n<i.length;n++)if(n<s.length){if(s[n]<0)throw Error("dilations should be greater than or equal to 1")}else s.push(1);for(let n=0;n<2*i.length;n++)if(n<o.length){if(o[n]<0)throw Error("pad should be greater than or equal to 1")}else o.push(0);for(let n=0;n<i.length;n++){if(i[n]<=0)throw Error("kernel shapes need to be greater than 0");if(o[n]>=i[n]||o[n+i.length]>=i[n])throw Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(n,r,i,a,s,o){if(o){if(s.length!==2*(n.length-2))throw Error("length of pads should be twice the length of data dimensions");if(r.length!==n.length-2)throw Error("length of strides should be the length of data dimensions");if(a.length!==n.length-2)throw Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<n.length-2;l++)_.adjustPadAndReturnShape(n[l+2],r[l],i[l],a[l],s,l,l+n.length-2,o)}}static computePoolOutputShape(n,r,i,a,s,o,l){if(r.length<=0)throw Error("input shape must be of size greater than 0");let u=[r[0],r[1]];return _.computeShapeHelper(n,r,u,i,a,s,o,l),u}static computeConvOutputShape(n,r,i,a,s,o,l){if(n.length<=0||r.length<=0)throw Error("invalid input tensor dims or invalid filter tensor dims");let u=[n[0],r[0]];return _.computeShapeHelper(!1,n,u,i,a,s,o,l),u}static computeShapeHelper(n,r,i,a,s,o,l,u){if(n)for(let n=0;n<r.length-2;n++)i.push(1);else for(let n=0;n<r.length-2;n++)i.push(_.adjustPadAndReturnShape(r[n+2],a[n],s[n],o[n],l,n,n+r.length-2,u))}static adjustPadAndReturnShape(n,r,i,a,s,o,l,u){let c=i*(a-1)+1;if(!u||"NOTSET"===u)return Math.floor((n+s[o]+s[l]-c)/r+1);switch(u){case"VALID":return s[o]=0,s[l]=0,Math.floor((n-c)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==i)throw Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let i=((n+r-1)/r-1)*r+a-n;return s[o]="SAME_LOWER"===u?Math.floor((i+1)/2):Math.floor(i/2),s[l]=i-s[o],Math.floor((n+i-a)/r+1)}default:throw Error("Unsupported AutoPad type")}}}r.PoolConvUtil=_,r.MIN_CLIP=-34028234663852886e22,r.MAX_CLIP=34028234663852886e22,r.decodeUtf8String=function(n){return(new TextDecoder).decode(n)}},7967:(n,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.iterateExtraOptions=void 0,r.iterateExtraOptions=(n,i,a,s)=>{if("object"==typeof n&&null!==n){if(a.has(n))throw Error("Circular reference in options");a.add(n)}Object.entries(n).forEach(([n,o])=>{let l=i?i+n:n;if("object"==typeof o)(0,r.iterateExtraOptions)(o,l+".",a,s);else if("string"==typeof o||"number"==typeof o)s(l,o.toString());else{if("boolean"!=typeof o)throw Error("Can't handle extra config type: "+typeof o);s(l,o?"1":"0")}})}},2157:function(n,r,i){var a,s=this&&this.__createBinding||(Object.create?function(n,r,i,a){void 0===a&&(a=i);var s=Object.getOwnPropertyDescriptor(r,i);s&&!("get"in s?!r.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return r[i]}}),Object.defineProperty(n,a,s)}:function(n,r,i,a){void 0===a&&(a=i),n[a]=r[i]}),o=this&&this.__setModuleDefault||(Object.create?function(n,r){Object.defineProperty(n,"default",{enumerable:!0,value:r})}:function(n,r){n.default=r}),l=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var r={};if(null!=n)for(var i in n)"default"!==i&&Object.prototype.hasOwnProperty.call(n,i)&&s(r,n,i);return o(r,n),r};Object.defineProperty(r,"__esModule",{value:!0}),r.endProfiling=r.run=r.releaseSession=r.createSession=r.createSessionFinalize=r.createSessionAllocate=r.initOrt=r.initWasm=void 0;let u=i(1670),c=l(i(349)),h=i(6361),d=()=>!!u.env.wasm.proxy&&"undefined"!=typeof document,p,f,m,g=!1,_=!1,y=!1,b=[],v=[],x=[],w=[],T=[],S=[],E=()=>{if(g||!_||y||!p)throw Error("worker not ready")},A=n=>{switch(n.data.type){case"init-wasm":g=!1,n.data.err?(y=!0,f[1](n.data.err)):(_=!0,f[0]());break;case"init-ort":n.data.err?m[1](n.data.err):m[0]();break;case"create_allocate":n.data.err?b.shift()[1](n.data.err):b.shift()[0](n.data.out);break;case"create_finalize":n.data.err?v.shift()[1](n.data.err):v.shift()[0](n.data.out);break;case"create":n.data.err?x.shift()[1](n.data.err):x.shift()[0](n.data.out);break;case"release":n.data.err?w.shift()[1](n.data.err):w.shift()[0]();break;case"run":n.data.err?T.shift()[1](n.data.err):T.shift()[0](n.data.out);break;case"end-profiling":n.data.err?S.shift()[1](n.data.err):S.shift()[0]()}},M="undefined"!=typeof document?null===(a=null==document?void 0:document.currentScript)||void 0===a?void 0:a.src:void 0;r.initWasm=async()=>{if(d()){if(_)return;if(g)throw Error("multiple calls to 'initWasm()' detected.");if(y)throw Error("previous call to 'initWasm()' failed.");return g=!0,void 0===u.env.wasm.wasmPaths&&M&&0!==M.indexOf("blob:")&&(u.env.wasm.wasmPaths=M.substr(0,+M.lastIndexOf("/")+1)),new Promise((n,r)=>{null==p||p.terminate(),(p=i(9710).Z()).onmessage=A,f=[n,r];let a={type:"init-wasm",in:u.env.wasm};p.postMessage(a)})}return(0,h.initializeWebAssembly)(u.env.wasm)},r.initOrt=async(n,r)=>{if(d())return E(),new Promise((i,a)=>{m=[i,a];let s={type:"init-ort",in:{numThreads:n,loggingLevel:r}};p.postMessage(s)});c.initOrt(n,r)},r.createSessionAllocate=async n=>d()?(E(),new Promise((r,i)=>{b.push([r,i]);let a={type:"create_allocate",in:{model:n}};p.postMessage(a,[n.buffer])})):c.createSessionAllocate(n),r.createSessionFinalize=async(n,r)=>d()?(E(),new Promise((i,a)=>{v.push([i,a]);let s={type:"create_finalize",in:{modeldata:n,options:r}};p.postMessage(s)})):c.createSessionFinalize(n,r),r.createSession=async(n,r)=>d()?(E(),new Promise((i,a)=>{x.push([i,a]);let s={type:"create",in:{model:n,options:r}};p.postMessage(s,[n.buffer])})):c.createSession(n,r),r.releaseSession=async n=>{if(d())return E(),new Promise((r,i)=>{w.push([r,i]);let a={type:"release",in:n};p.postMessage(a)});c.releaseSession(n)},r.run=async(n,r,i,a,s)=>d()?(E(),new Promise((o,l)=>{T.push([o,l]);let u={type:"run",in:{sessionId:n,inputIndices:r,inputs:i,outputIndices:a,options:s}};p.postMessage(u,c.extractTransferableBuffers(i))})):c.run(n,r,i,a,s),r.endProfiling=async n=>{if(d())return E(),new Promise((r,i)=>{S.push([r,i]);let a={type:"end-profiling",in:n};p.postMessage(a)});c.endProfiling(n)}},586:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.setRunOptions=void 0;let a=i(7967),s=i(4983),o=i(6361);r.setRunOptions=n=>{let r=(0,o.getInstance)(),i=0,l=[],u=n||{};try{if(void 0===(null==n?void 0:n.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof n.logSeverityLevel||!Number.isInteger(n.logSeverityLevel)||n.logSeverityLevel<0||n.logSeverityLevel>4)throw Error(`log serverity level is not valid: ${n.logSeverityLevel}`);if(void 0===(null==n?void 0:n.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof n.logVerbosityLevel||!Number.isInteger(n.logVerbosityLevel))throw Error(`log verbosity level is not valid: ${n.logVerbosityLevel}`);void 0===(null==n?void 0:n.terminate)&&(u.terminate=!1);let o=0;if(void 0!==(null==n?void 0:n.tag)&&(o=(0,s.allocWasmString)(n.tag,l)),i=r._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,o),0===i)throw Error("Can't create run options");return void 0!==(null==n?void 0:n.extra)&&(0,a.iterateExtraOptions)(n.extra,"",new WeakSet,(n,a)=>{let o=(0,s.allocWasmString)(n,l),u=(0,s.allocWasmString)(a,l);if(0!==r._OrtAddRunConfigEntry(i,o,u))throw Error(`Can't set a run config entry: ${n} - ${a}`)}),[i,l]}catch(n){throw 0!==i&&r._OrtReleaseRunOptions(i),l.forEach(r._free),n}}},2306:(n,r,i)=>{let a;Object.defineProperty(r,"__esModule",{value:!0}),r.OnnxruntimeWebAssemblySessionHandler=void 0;let s=i(2806),o=i(1670),l=i(2850),u=i(2157);r.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(n){let r=await fetch(n),i=await r.arrayBuffer();return(0,u.createSessionAllocate)(new Uint8Array(i))}async loadModel(n,r){if(a||(await (0,u.initOrt)(o.env.wasm.numThreads,(n=>{switch(n){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw Error(`unsupported logging level: ${n}`)}})(o.env.logLevel)),a=!0),"string"==typeof n){if("undefined"==typeof fetch){let i=await (0,l.promisify)(s.readFile)(n);[this.sessionId,this.inputNames,this.outputNames]=await (0,u.createSession)(i,r)}else{let i=await this.createSessionAllocate(n);[this.sessionId,this.inputNames,this.outputNames]=await (0,u.createSessionFinalize)(i,r)}}else[this.sessionId,this.inputNames,this.outputNames]=await (0,u.createSession)(n,r)}async dispose(){return(0,u.releaseSession)(this.sessionId)}async run(n,r,i){let a=[],s=[];Object.entries(n).forEach(n=>{let r=n[0],i=n[1],o=this.inputNames.indexOf(r);if(-1===o)throw Error(`invalid input '${r}'`);a.push(i),s.push(o)});let l=[];Object.entries(r).forEach(n=>{let r=n[0],i=this.outputNames.indexOf(r);if(-1===i)throw Error(`invalid output '${r}'`);l.push(i)});let c=await (0,u.run)(this.sessionId,s,a.map(n=>[n.type,n.dims,n.data]),l,i),h={};for(let n=0;n<c.length;n++)h[this.outputNames[l[n]]]=new o.Tensor(c[n][0],c[n][2],c[n][1]);return h}startProfiling(){}endProfiling(){(0,u.endProfiling)(this.sessionId)}}},4919:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.setSessionOptions=void 0;let a=i(7967),s=i(4983),o=i(6361);r.setSessionOptions=n=>{let r=(0,o.getInstance)(),i=0,l=[],u=n||{};(n=>{n.extra||(n.extra={}),n.extra.session||(n.extra.session={});let r=n.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==n?void 0:n.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");let c=(n=>{switch(n){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw Error(`unsupported graph optimization level: ${n}`)}})(u.graphOptimizationLevel);void 0===(null==n?void 0:n.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==n?void 0:n.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==n?void 0:n.executionMode)&&(u.executionMode="sequential");let h=(n=>{switch(n){case"sequential":return 0;case"parallel":return 1;default:throw Error(`unsupported execution mode: ${n}`)}})(u.executionMode),d=0;if(void 0!==(null==n?void 0:n.logId)&&(d=(0,s.allocWasmString)(n.logId,l)),void 0===(null==n?void 0:n.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof n.logSeverityLevel||!Number.isInteger(n.logSeverityLevel)||n.logSeverityLevel<0||n.logSeverityLevel>4)throw Error(`log serverity level is not valid: ${n.logSeverityLevel}`);if(void 0===(null==n?void 0:n.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof n.logVerbosityLevel||!Number.isInteger(n.logVerbosityLevel))throw Error(`log verbosity level is not valid: ${n.logVerbosityLevel}`);if(void 0===(null==n?void 0:n.enableProfiling)&&(u.enableProfiling=!1),i=r._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,h,!!u.enableProfiling,0,d,u.logSeverityLevel,u.logVerbosityLevel),0===i)throw Error("Can't create session options");return(null==n?void 0:n.executionProviders)&&((n,r,i)=>{for(let a of r){let r="string"==typeof a?a:a.name;switch(r){case"xnnpack":r="XNNPACK";break;case"wasm":case"cpu":continue;default:throw Error(`not supported EP: ${r}`)}let l=(0,s.allocWasmString)(r,i);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(n,l))throw Error(`Can't append execution provider: ${r}`)}})(i,n.executionProviders,l),void 0!==(null==n?void 0:n.extra)&&(0,a.iterateExtraOptions)(n.extra,"",new WeakSet,(n,a)=>{let o=(0,s.allocWasmString)(n,l),u=(0,s.allocWasmString)(a,l);if(0!==r._OrtAddSessionConfigEntry(i,o,u))throw Error(`Can't set a session config entry: ${n} - ${a}`)}),[i,l]}catch(n){throw 0!==i&&r._OrtReleaseSessionOptions(i),l.forEach(r._free),n}}},4983:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.allocWasmString=void 0;let a=i(6361);r.allocWasmString=(n,r)=>{let i=(0,a.getInstance)(),s=i.lengthBytesUTF8(n)+1,o=i._malloc(s);return i.stringToUTF8(n,o,s),r.push(o),o}},349:(n,r,i)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.extractTransferableBuffers=r.endProfiling=r.run=r.releaseSession=r.createSession=r.createSessionFinalize=r.createSessionAllocate=r.initOrt=void 0;let a=i(586),s=i(4919),o=i(4983),l=i(6361);r.initOrt=(n,r)=>{let i=(0,l.getInstance)()._OrtInit(n,r);if(0!==i)throw Error(`Can't initialize onnxruntime. error code = ${i}`)};let u=new Map;r.createSessionAllocate=n=>{let r=(0,l.getInstance)(),i=r._malloc(n.byteLength);return r.HEAPU8.set(n,i),[i,n.byteLength]},r.createSessionFinalize=(n,r)=>{let i=(0,l.getInstance)(),a=0,o=0,c=[];try{if([o,c]=(0,s.setSessionOptions)(r),a=i._OrtCreateSession(n[0],n[1],o),0===a)throw Error("Can't create a session")}finally{i._free(n[0]),i._OrtReleaseSessionOptions(o),c.forEach(i._free)}let h=i._OrtGetInputCount(a),d=i._OrtGetOutputCount(a),p=[],f=[],m=[],g=[];for(let n=0;n<h;n++){let r=i._OrtGetInputName(a,n);if(0===r)throw Error("Can't get an input name");f.push(r),p.push(i.UTF8ToString(r))}for(let n=0;n<d;n++){let r=i._OrtGetOutputName(a,n);if(0===r)throw Error("Can't get an output name");g.push(r),m.push(i.UTF8ToString(r))}return u.set(a,[a,f,g]),[a,p,m]},r.createSession=(n,i)=>{let a=(0,r.createSessionAllocate)(n);return(0,r.createSessionFinalize)(a,i)},r.releaseSession=n=>{let r=(0,l.getInstance)(),i=u.get(n);if(!i)throw Error("invalid session id");let a=i[0],s=i[1],o=i[2];s.forEach(r._OrtFree),o.forEach(r._OrtFree),r._OrtReleaseSession(a),u.delete(n)};let c=n=>{switch(n){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw Error(`unsupported data type: ${n}`)}},h=n=>{switch(n){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw Error(`unsupported data type: ${n}`)}},d=n=>{switch(n){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw Error(`unsupported type: ${n}`)}};r.run=(n,r,i,s,p)=>{let f=(0,l.getInstance)(),m=u.get(n);if(!m)throw Error("invalid session id");let g=m[0],_=m[1],y=m[2],b=r.length,v=s.length,x=0,w=[],T=[],S=[];try{[x,w]=(0,a.setRunOptions)(p);for(let n=0;n<b;n++){let r,a;let s=i[n][0],l=i[n][1],u=i[n][2];if(Array.isArray(u)){a=4*u.length,r=f._malloc(a),S.push(r);let n=r/4;for(let r=0;r<u.length;r++){if("string"!=typeof u[r])throw TypeError(`tensor data at index ${r} is not a string`);f.HEAPU32[n++]=(0,o.allocWasmString)(u[r],S)}}else a=u.byteLength,r=f._malloc(a),S.push(r),f.HEAPU8.set(new Uint8Array(u.buffer,u.byteOffset,a),r);let h=f.stackSave(),d=f.stackAlloc(4*l.length);try{let n=d/4;l.forEach(r=>f.HEAP32[n++]=r);let i=f._OrtCreateTensor(c(s),r,a,d,l.length);if(0===i)throw Error("Can't create a tensor");T.push(i)}finally{f.stackRestore(h)}}let n=f.stackSave(),l=f.stackAlloc(4*b),u=f.stackAlloc(4*b),m=f.stackAlloc(4*v),E=f.stackAlloc(4*v);try{let n=l/4,i=u/4,a=m/4,o=E/4;for(let a=0;a<b;a++)f.HEAPU32[n++]=T[a],f.HEAPU32[i++]=_[r[a]];for(let n=0;n<v;n++)f.HEAPU32[a++]=0,f.HEAPU32[o++]=y[s[n]];let c=f._OrtRun(g,u,l,b,E,v,m,x),p=[];if(0===c)for(let n=0;n<v;n++){let r=f.HEAPU32[m/4+n],i=f.stackSave(),a=f.stackAlloc(16),s,o=0;try{if(c=f._OrtGetTensorData(r,a,a+4,a+8,a+12),0!==c)throw Error(`Can't access output tensor data. error code = ${c}`);let n=a/4,i=f.HEAPU32[n++];o=f.HEAPU32[n++];let l=f.HEAPU32[n++],u=f.HEAPU32[n++],m=[];for(let n=0;n<u;n++)m.push(f.HEAPU32[l/4+n]);f._OrtFree(l);let g=0===m.length?1:m.reduce((n,r)=>n*r);if(s=h(i),"string"===s){let n=[],r=o/4;for(let i=0;i<g;i++){let a=f.HEAPU32[r++],s=i===g-1?void 0:f.HEAPU32[r]-a;n.push(f.UTF8ToString(a,s))}p.push([s,m,n])}else{let n=new(d(s))(g);new Uint8Array(n.buffer,n.byteOffset,n.byteLength).set(f.HEAPU8.subarray(o,o+n.byteLength)),p.push([s,m,n])}}finally{f.stackRestore(i),"string"===s&&o&&f._free(o),f._OrtReleaseTensor(r)}}if(0===c)return p;throw Error(`failed to call OrtRun(). error code = ${c}.`)}finally{f.stackRestore(n)}}finally{T.forEach(f._OrtReleaseTensor),S.forEach(f._free),f._OrtReleaseRunOptions(x),w.forEach(f._free)}},r.endProfiling=n=>{let r=(0,l.getInstance)(),i=u.get(n);if(!i)throw Error("invalid session id");let a=i[0],s=r._OrtEndProfiling(a);if(0===s)throw Error("Can't get an profile file name");r._OrtFree(s)},r.extractTransferableBuffers=n=>{let r=[];for(let i of n){let n=i[2];!Array.isArray(n)&&n.buffer&&r.push(n.buffer)}return r}},6361:function(n,r,i){var a=this&&this.__createBinding||(Object.create?function(n,r,i,a){void 0===a&&(a=i);var s=Object.getOwnPropertyDescriptor(r,i);s&&!("get"in s?!r.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return r[i]}}),Object.defineProperty(n,a,s)}:function(n,r,i,a){void 0===a&&(a=i),n[a]=r[i]}),s=this&&this.__setModuleDefault||(Object.create?function(n,r){Object.defineProperty(n,"default",{enumerable:!0,value:r})}:function(n,r){n.default=r}),o=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var r={};if(null!=n)for(var i in n)"default"!==i&&Object.prototype.hasOwnProperty.call(n,i)&&a(r,n,i);return s(r,n),r},l=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(r,"__esModule",{value:!0}),r.dispose=r.getInstance=r.initializeWebAssembly=void 0;let u=o(i(6449)),c=l(i(932)),h=i(3474),d,p=!1,f=!1,m=!1,g=(n,r)=>r?n?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":n?"ort-wasm-simd.wasm":"ort-wasm.wasm";r.initializeWebAssembly=async n=>{if(p)return Promise.resolve();if(f)throw Error("multiple calls to 'initializeWebAssembly()' detected.");if(m)throw Error("previous call to 'initializeWebAssembly()' failed.");f=!0;let r=n.initTimeout,a=n.numThreads,s=n.simd,o=a>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(n){return!1}})(),l=s&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(n){return!1}})(),_="string"==typeof n.wasmPaths?n.wasmPaths:void 0,y=g(!1,o),b=g(l,o),v="object"==typeof n.wasmPaths?n.wasmPaths[b]:void 0,x=!1,w=[];if(r>0&&w.push(new Promise(n=>{setTimeout(()=>{x=!0,n()},r)})),w.push(new Promise((n,r)=>{let a=o?h:c.default,s={locateFile:(n,r)=>o&&n.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([i(4154)],{type:"text/javascript"})):n===y?null!=v?v:(null!=_?_:r)+b:r+n};if(o){if("undefined"==typeof Blob)s.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{let n=`var ortWasmThreaded=(function(){var _scriptDir;return ${a.toString()}})();`;s.mainScriptUrlOrBlob=new Blob([n],{type:"text/javascript"})}}a(s).then(r=>{f=!1,p=!0,d=r,n()},n=>{f=!1,m=!0,r(n)})})),await Promise.race(w),x)throw Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},r.getInstance=()=>{if(p&&d)return d;throw Error("WebAssembly is not initialized yet.")},r.dispose=()=>{var n;!p||f||m||(f=!0,null===(n=d.PThread)||void 0===n||n.terminateAllThreads(),d=void 0,f=!1,p=!1,m=!0)}},9710:(n,r,i)=>{i.d(r,{Z:()=>o});var a=i(477),s=i.n(a);function o(){return s()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:n=>{n.exports=function(n,r,i,a){var s=self||window;try{try{try{o=new s.Blob([n])}catch(r){(o=new(s.BlobBuilder||s.WebKitBlobBuilder||s.MozBlobBuilder||s.MSBlobBuilder)).append(n),o=o.getBlob()}var o,l=s.URL||s.webkitURL,u=l.createObjectURL(o),c=new s[r](u,i);return l.revokeObjectURL(u),c}catch(a){return new s[r]("data:application/javascript,".concat(encodeURIComponent(n)),i)}}catch(n){if(!a)throw Error("Inline worker is not supported");return new s[r](a,i)}}},4154:n=>{n.exports='"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n'},1670:n=>{n.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(n,r,i)=>{i.r(r),i.d(r,{flatbuffers:()=>a});var a={};a.Offset,a.Table,a.SIZEOF_SHORT=2,a.SIZEOF_INT=4,a.FILE_IDENTIFIER_LENGTH=4,a.SIZE_PREFIX_LENGTH=4,a.Encoding={UTF8_BYTES:1,UTF16_STRING:2},a.int32=new Int32Array(2),a.float32=new Float32Array(a.int32.buffer),a.float64=new Float64Array(a.int32.buffer),a.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],a.Long=function(n,r){this.low=0|n,this.high=0|r},a.Long.create=function(n,r){return 0==n&&0==r?a.Long.ZERO:new a.Long(n,r)},a.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},a.Long.prototype.equals=function(n){return this.low==n.low&&this.high==n.high},a.Long.ZERO=new a.Long(0,0),a.Builder=function(n){if(n)r=n;else var r=1024;this.bb=a.ByteBuffer.allocate(r),this.space=r,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},a.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},a.Builder.prototype.forceDefaults=function(n){this.force_defaults=n},a.Builder.prototype.dataBuffer=function(){return this.bb},a.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},a.Builder.prototype.prep=function(n,r){n>this.minalign&&(this.minalign=n);for(var i=1+~(this.bb.capacity()-this.space+r)&n-1;this.space<i+n+r;){var s=this.bb.capacity();this.bb=a.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-s}this.pad(i)},a.Builder.prototype.pad=function(n){for(var r=0;r<n;r++)this.bb.writeInt8(--this.space,0)},a.Builder.prototype.writeInt8=function(n){this.bb.writeInt8(this.space-=1,n)},a.Builder.prototype.writeInt16=function(n){this.bb.writeInt16(this.space-=2,n)},a.Builder.prototype.writeInt32=function(n){this.bb.writeInt32(this.space-=4,n)},a.Builder.prototype.writeInt64=function(n){this.bb.writeInt64(this.space-=8,n)},a.Builder.prototype.writeFloat32=function(n){this.bb.writeFloat32(this.space-=4,n)},a.Builder.prototype.writeFloat64=function(n){this.bb.writeFloat64(this.space-=8,n)},a.Builder.prototype.addInt8=function(n){this.prep(1,0),this.writeInt8(n)},a.Builder.prototype.addInt16=function(n){this.prep(2,0),this.writeInt16(n)},a.Builder.prototype.addInt32=function(n){this.prep(4,0),this.writeInt32(n)},a.Builder.prototype.addInt64=function(n){this.prep(8,0),this.writeInt64(n)},a.Builder.prototype.addFloat32=function(n){this.prep(4,0),this.writeFloat32(n)},a.Builder.prototype.addFloat64=function(n){this.prep(8,0),this.writeFloat64(n)},a.Builder.prototype.addFieldInt8=function(n,r,i){(this.force_defaults||r!=i)&&(this.addInt8(r),this.slot(n))},a.Builder.prototype.addFieldInt16=function(n,r,i){(this.force_defaults||r!=i)&&(this.addInt16(r),this.slot(n))},a.Builder.prototype.addFieldInt32=function(n,r,i){(this.force_defaults||r!=i)&&(this.addInt32(r),this.slot(n))},a.Builder.prototype.addFieldInt64=function(n,r,i){!this.force_defaults&&r.equals(i)||(this.addInt64(r),this.slot(n))},a.Builder.prototype.addFieldFloat32=function(n,r,i){(this.force_defaults||r!=i)&&(this.addFloat32(r),this.slot(n))},a.Builder.prototype.addFieldFloat64=function(n,r,i){(this.force_defaults||r!=i)&&(this.addFloat64(r),this.slot(n))},a.Builder.prototype.addFieldOffset=function(n,r,i){(this.force_defaults||r!=i)&&(this.addOffset(r),this.slot(n))},a.Builder.prototype.addFieldStruct=function(n,r,i){r!=i&&(this.nested(r),this.slot(n))},a.Builder.prototype.nested=function(n){if(n!=this.offset())throw Error("FlatBuffers: struct must be serialized inline.")},a.Builder.prototype.notNested=function(){if(this.isNested)throw Error("FlatBuffers: object serialization must not be nested.")},a.Builder.prototype.slot=function(n){this.vtable[n]=this.offset()},a.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},a.Builder.growByteBuffer=function(n){var r=n.capacity();if(3221225472&r)throw Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var i=r<<1,s=a.ByteBuffer.allocate(i);return s.setPosition(i-r),s.bytes().set(n.bytes(),i-r),s},a.Builder.prototype.addOffset=function(n){this.prep(a.SIZEOF_INT,0),this.writeInt32(this.offset()-n+a.SIZEOF_INT)},a.Builder.prototype.startObject=function(n){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=n;for(var r=0;r<n;r++)this.vtable[r]=0;this.isNested=!0,this.object_start=this.offset()},a.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var n=this.offset(),r=this.vtable_in_use-1;r>=0&&0==this.vtable[r];r--);for(var i=r+1;r>=0;r--)this.addInt16(0!=this.vtable[r]?n-this.vtable[r]:0);this.addInt16(n-this.object_start);var s=(i+2)*a.SIZEOF_SHORT;this.addInt16(s);var o=0,l=this.space;e:for(r=0;r<this.vtables.length;r++){var u=this.bb.capacity()-this.vtables[r];if(s==this.bb.readInt16(u)){for(var c=a.SIZEOF_SHORT;c<s;c+=a.SIZEOF_SHORT)if(this.bb.readInt16(l+c)!=this.bb.readInt16(u+c))continue e;o=this.vtables[r];break}}return o?(this.space=this.bb.capacity()-n,this.bb.writeInt32(this.space,o-n)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-n,this.offset()-n)),this.isNested=!1,n},a.Builder.prototype.finish=function(n,r,i){var s=i?a.SIZE_PREFIX_LENGTH:0;if(r){var o=r;if(this.prep(this.minalign,a.SIZEOF_INT+a.FILE_IDENTIFIER_LENGTH+s),o.length!=a.FILE_IDENTIFIER_LENGTH)throw Error("FlatBuffers: file identifier must be length "+a.FILE_IDENTIFIER_LENGTH);for(var l=a.FILE_IDENTIFIER_LENGTH-1;l>=0;l--)this.writeInt8(o.charCodeAt(l))}this.prep(this.minalign,a.SIZEOF_INT+s),this.addOffset(n),s&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},a.Builder.prototype.finishSizePrefixed=function(n,r){this.finish(n,r,!0)},a.Builder.prototype.requiredField=function(n,r){var i=this.bb.capacity()-n,a=i-this.bb.readInt32(i);if(0==this.bb.readInt16(a+r))throw Error("FlatBuffers: field "+r+" must be set")},a.Builder.prototype.startVector=function(n,r,i){this.notNested(),this.vector_num_elems=r,this.prep(a.SIZEOF_INT,n*r),this.prep(i,n*r)},a.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},a.Builder.prototype.createString=function(n){if(n instanceof Uint8Array)var r=n;else{r=[];for(var i=0;i<n.length;){var a,s=n.charCodeAt(i++);(a=s<55296||s>=56320?s:(s<<10)+n.charCodeAt(i++)+-56613888)<128?r.push(a):(a<2048?r.push(a>>6&31|192):(a<65536?r.push(a>>12&15|224):r.push(a>>18&7|240,a>>12&63|128),r.push(a>>6&63|128)),r.push(63&a|128))}}this.addInt8(0),this.startVector(1,r.length,1),this.bb.setPosition(this.space-=r.length),i=0;for(var o=this.space,l=this.bb.bytes();i<r.length;i++)l[o++]=r[i];return this.endVector()},a.Builder.prototype.createLong=function(n,r){return a.Long.create(n,r)},a.ByteBuffer=function(n){this.bytes_=n,this.position_=0},a.ByteBuffer.allocate=function(n){return new a.ByteBuffer(new Uint8Array(n))},a.ByteBuffer.prototype.clear=function(){this.position_=0},a.ByteBuffer.prototype.bytes=function(){return this.bytes_},a.ByteBuffer.prototype.position=function(){return this.position_},a.ByteBuffer.prototype.setPosition=function(n){this.position_=n},a.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},a.ByteBuffer.prototype.readInt8=function(n){return this.readUint8(n)<<24>>24},a.ByteBuffer.prototype.readUint8=function(n){return this.bytes_[n]},a.ByteBuffer.prototype.readInt16=function(n){return this.readUint16(n)<<16>>16},a.ByteBuffer.prototype.readUint16=function(n){return this.bytes_[n]|this.bytes_[n+1]<<8},a.ByteBuffer.prototype.readInt32=function(n){return this.bytes_[n]|this.bytes_[n+1]<<8|this.bytes_[n+2]<<16|this.bytes_[n+3]<<24},a.ByteBuffer.prototype.readUint32=function(n){return this.readInt32(n)>>>0},a.ByteBuffer.prototype.readInt64=function(n){return new a.Long(this.readInt32(n),this.readInt32(n+4))},a.ByteBuffer.prototype.readUint64=function(n){return new a.Long(this.readUint32(n),this.readUint32(n+4))},a.ByteBuffer.prototype.readFloat32=function(n){return a.int32[0]=this.readInt32(n),a.float32[0]},a.ByteBuffer.prototype.readFloat64=function(n){return a.int32[a.isLittleEndian?0:1]=this.readInt32(n),a.int32[a.isLittleEndian?1:0]=this.readInt32(n+4),a.float64[0]},a.ByteBuffer.prototype.writeInt8=function(n,r){this.bytes_[n]=r},a.ByteBuffer.prototype.writeUint8=function(n,r){this.bytes_[n]=r},a.ByteBuffer.prototype.writeInt16=function(n,r){this.bytes_[n]=r,this.bytes_[n+1]=r>>8},a.ByteBuffer.prototype.writeUint16=function(n,r){this.bytes_[n]=r,this.bytes_[n+1]=r>>8},a.ByteBuffer.prototype.writeInt32=function(n,r){this.bytes_[n]=r,this.bytes_[n+1]=r>>8,this.bytes_[n+2]=r>>16,this.bytes_[n+3]=r>>24},a.ByteBuffer.prototype.writeUint32=function(n,r){this.bytes_[n]=r,this.bytes_[n+1]=r>>8,this.bytes_[n+2]=r>>16,this.bytes_[n+3]=r>>24},a.ByteBuffer.prototype.writeInt64=function(n,r){this.writeInt32(n,r.low),this.writeInt32(n+4,r.high)},a.ByteBuffer.prototype.writeUint64=function(n,r){this.writeUint32(n,r.low),this.writeUint32(n+4,r.high)},a.ByteBuffer.prototype.writeFloat32=function(n,r){a.float32[0]=r,this.writeInt32(n,a.int32[0])},a.ByteBuffer.prototype.writeFloat64=function(n,r){a.float64[0]=r,this.writeInt32(n,a.int32[a.isLittleEndian?0:1]),this.writeInt32(n+4,a.int32[a.isLittleEndian?1:0])},a.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+a.SIZEOF_INT+a.FILE_IDENTIFIER_LENGTH)throw Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var n="",r=0;r<a.FILE_IDENTIFIER_LENGTH;r++)n+=String.fromCharCode(this.readInt8(this.position_+a.SIZEOF_INT+r));return n},a.ByteBuffer.prototype.__offset=function(n,r){var i=n-this.readInt32(n);return r<this.readInt16(i)?this.readInt16(i+r):0},a.ByteBuffer.prototype.__union=function(n,r){return n.bb_pos=r+this.readInt32(r),n.bb=this,n},a.ByteBuffer.prototype.__string=function(n,r){n+=this.readInt32(n);var i=this.readInt32(n),s="",o=0;if(n+=a.SIZEOF_INT,r===a.Encoding.UTF8_BYTES)return this.bytes_.subarray(n,n+i);for(;o<i;){var l,u=this.readUint8(n+o++);if(u<192)l=u;else{var c=this.readUint8(n+o++);if(u<224)l=(31&u)<<6|63&c;else{var h=this.readUint8(n+o++);l=u<240?(15&u)<<12|(63&c)<<6|63&h:(7&u)<<18|(63&c)<<12|(63&h)<<6|63&this.readUint8(n+o++)}}l<65536?s+=String.fromCharCode(l):(l-=65536,s+=String.fromCharCode(55296+(l>>10),56320+(1023&l)))}return s},a.ByteBuffer.prototype.__indirect=function(n){return n+this.readInt32(n)},a.ByteBuffer.prototype.__vector=function(n){return n+this.readInt32(n)+a.SIZEOF_INT},a.ByteBuffer.prototype.__vector_len=function(n){return this.readInt32(n+this.readInt32(n))},a.ByteBuffer.prototype.__has_identifier=function(n){if(n.length!=a.FILE_IDENTIFIER_LENGTH)throw Error("FlatBuffers: file identifier must be length "+a.FILE_IDENTIFIER_LENGTH);for(var r=0;r<a.FILE_IDENTIFIER_LENGTH;r++)if(n.charCodeAt(r)!=this.readInt8(this.position_+a.SIZEOF_INT+r))return!1;return!0},a.ByteBuffer.prototype.createLong=function(n,r){return a.Long.create(n,r)}}},__webpack_module_cache__={};function __webpack_require__(n){var r=__webpack_module_cache__[n];if(void 0!==r)return r.exports;var i=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n].call(i.exports,i,i.exports,__webpack_require__),i.exports}__webpack_require__.n=n=>{var r=n&&n.__esModule?()=>n.default:()=>n;return __webpack_require__.d(r,{a:r}),r},__webpack_require__.d=(n,r)=>{for(var i in r)__webpack_require__.o(r,i)&&!__webpack_require__.o(n,i)&&Object.defineProperty(n,i,{enumerable:!0,get:r[i]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||Function("return this")()}catch(n){if("object"==typeof window)return window}}(),__webpack_require__.o=(n,r)=>Object.prototype.hasOwnProperty.call(n,r),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(6018);return __webpack_exports__})())}),parcelRequire.register("hPtJY",function(n,r){// shim for using process in browser
var i,a,s,o=n.exports={};function l(){throw Error("setTimeout has not been defined")}function u(){throw Error("clearTimeout has not been defined")}function c(n){if(i===setTimeout)return setTimeout(n,0);// if setTimeout wasn't available but was latter defined
if((i===l||!i)&&setTimeout)return i=setTimeout,setTimeout(n,0);try{// when when somebody has screwed with setTimeout but no I.E. maddness
return i(n,0)}catch(r){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
return i.call(null,n,0)}catch(r){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
return i.call(this,n,0)}}}function h(n){if(a===clearTimeout)return clearTimeout(n);// if clearTimeout wasn't available but was latter defined
if((a===u||!a)&&clearTimeout)return a=clearTimeout,clearTimeout(n);try{// when when somebody has screwed with setTimeout but no I.E. maddness
return a(n)}catch(r){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
return a.call(null,n)}catch(r){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
// Some versions of I.E. have different rules for clearTimeout vs setTimeout
return a.call(this,n)}}}!function(){try{i="function"==typeof setTimeout?setTimeout:l}catch(n){i=l}try{a="function"==typeof clearTimeout?clearTimeout:u}catch(n){a=u}}();var d=[],p=!1,f=-1;function m(){p&&s&&(p=!1,s.length?d=s.concat(d):f=-1,d.length&&g())}function g(){if(!p){var n=c(m);p=!0;for(var r=d.length;r;){for(s=d,d=[];++f<r;)s&&s[f].run();f=-1,r=d.length}s=null,p=!1,h(n)}}// v8 likes predictible objects
function _(n,r){this.fun=n,this.array=r}function y(){}o.nextTick=function(n){var r=Array(arguments.length-1);if(arguments.length>1)for(var i=1;i<arguments.length;i++)r[i-1]=arguments[i];d.push(new _(n,r)),1!==d.length||p||c(g)},_.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=y,o.addListener=y,o.once=y,o.off=y,o.removeListener=y,o.removeAllListeners=y,o.emit=y,o.prependListener=y,o.prependOnceListener=y,o.listeners=function(n){return[]},o.binding=function(n){throw Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(n){throw Error("process.chdir is not supported")},o.umask=function(){return 0}}),parcelRequire.register("7YRm1",function(n,r){// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * # ONNX Runtime JavaScript API
 *
 * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:
 *
 * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)
 * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)
 * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)
 *
 * See also:
 * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript.html)
 * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)
 *
 * @packageDocumentation
 */var i=parcelRequire("8v3s5"),a=parcelRequire("iJ3Jr"),s=parcelRequire("MRHFj"),o=parcelRequire("hvPrG"),l=parcelRequire("723zv");$parcel$exportWildcard(n.exports,i),$parcel$exportWildcard(n.exports,a),$parcel$exportWildcard(n.exports,s),$parcel$exportWildcard(n.exports,o),$parcel$exportWildcard(n.exports,l)}),parcelRequire.register("8v3s5",function(n,r){$parcel$export(n.exports,"registerBackend",()=>parcelRequire("2jNON").registerBackend),parcelRequire("2jNON")}),parcelRequire.register("2jNON",function(n,r){$parcel$export(n.exports,"registerBackend",()=>s),$parcel$export(n.exports,"resolveBackend",()=>o);// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
let i={},a=[],s=(n,r,s)=>{if(r&&"function"==typeof r.init&&"function"==typeof r.createSessionHandler){let o=i[n];if(void 0===o)i[n]={backend:r,priority:s};else if(o.priority>s)return;else if(o.priority===s&&o.backend!==r)throw Error(`cannot register backend "${n}" using priority ${s}`);if(s>=0){let r=a.indexOf(n);-1!==r&&a.splice(r,1);for(let r=0;r<a.length;r++)if(i[a[r]].priority<=s){a.splice(r,0,n);return}a.push(n)}return}throw TypeError("not a valid backend")},o=async n=>{let r=0===n.length?a:n,s=[];for(let n of r){let r=i[n];if(r){if(r.initialized)return r.backend;// current backend is unavailable; try next
if(r.aborted)continue;let i=!!r.initPromise;try{return i||(r.initPromise=r.backend.init()),await r.initPromise,r.initialized=!0,r.backend}catch(a){i||s.push({name:n,err:a}),r.aborted=!0}finally{delete r.initPromise}}}throw Error(`no available backend found. ERR: ${s.map(n=>`[${n.name}] ${n.err}`).join(", ")}`)}}),parcelRequire.register("iJ3Jr",function(n,r){$parcel$export(n.exports,"env",()=>a);// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var i=parcelRequire("lQ5oU");let a=new i.EnvImpl}),parcelRequire.register("lQ5oU",function(n,r){$parcel$export(n.exports,"EnvImpl",()=>i);// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
class i{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}// TODO standadize the getter and setter convention in env for other fields.
set logLevel(n){if(void 0!==n){if("string"!=typeof n||-1===["verbose","info","warning","error","fatal"].indexOf(n))throw Error(`Unsupported logging level: ${n}`);this.logLevelInternal=n}}get logLevel(){return this.logLevelInternal}}}),parcelRequire.register("MRHFj",function(n,r){$parcel$export(n.exports,"InferenceSession",()=>a);// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var i=parcelRequire("cmv1B");let a=i.InferenceSession}),parcelRequire.register("cmv1B",function(n,r){$parcel$export(n.exports,"InferenceSession",()=>s);// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var i=parcelRequire("2jNON"),a=parcelRequire("hvPrG");class s{constructor(n){this.handler=n}async run(n,r,i){let s={},o={};// check inputs
if("object"!=typeof n||null===n||n instanceof a.Tensor||Array.isArray(n))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let l=!0;// determine which override is being used
if("object"==typeof r){if(null===r)throw TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof a.Tensor)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(0===r.length)throw TypeError("'fetches' cannot be an empty array.");// output names
for(let n of(l=!1,r)){if("string"!=typeof n)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(n))throw RangeError(`'fetches' contains invalid output name: ${n}.`);s[n]=null}if("object"==typeof i&&null!==i)o=i;else if(void 0!==i)throw TypeError("'options' must be an object.")}else{// decide whether arg1 is fetches or options
// if any output name is present and its value is valid OnnxValue, we consider it fetches
let n=!1,u=Object.getOwnPropertyNames(r);for(let i of this.outputNames)if(-1!==u.indexOf(i)){let o=r[i];(null===o||o instanceof a.Tensor)&&(n=!0,l=!1,s[i]=o)}if(n){if("object"==typeof i&&null!==i)o=i;else if(void 0!==i)throw TypeError("'options' must be an object.")}else o=r}}else if(void 0!==r)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");// check if all inputs are in feed
for(let r of this.inputNames)if(void 0===n[r])throw Error(`input '${r}' is missing in 'feeds'.`);// if no fetches is specified, we use the full output names list
if(l)for(let n of this.outputNames)s[n]=null;// feeds, fetches and options are prepared
let u=await this.handler.run(n,s,o),c={};for(let n in u)Object.hasOwnProperty.call(u,n)&&(c[n]=new a.Tensor(u[n].type,u[n].data,u[n].dims));return c}static async create(n,r,a,o){let l;let u={};if("string"==typeof n){if(l=n,"object"==typeof r&&null!==r)u=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else if(n instanceof Uint8Array){if(l=n,"object"==typeof r&&null!==r)u=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else if(n instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&n instanceof SharedArrayBuffer){let i=n,s=0,c=n.byteLength;if("object"==typeof r&&null!==r)u=r;else if("number"==typeof r){if(!Number.isSafeInteger(s=r))throw RangeError("'byteOffset' must be an integer.");if(s<0||s>=i.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${i.byteLength}).`);if(c=n.byteLength-s,"number"==typeof a){if(!Number.isSafeInteger(c=a))throw RangeError("'byteLength' must be an integer.");if(c<=0||s+c>i.byteLength)throw RangeError(`'byteLength' is out of range (0, ${i.byteLength-s}].`);if("object"==typeof o&&null!==o)u=o;else if(void 0!==o)throw TypeError("'options' must be an object.")}else if(void 0!==a)throw TypeError("'byteLength' must be a number.")}else if(void 0!==r)throw TypeError("'options' must be an object.");l=new Uint8Array(i,s,c)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");// get backend hints
let c=u.executionProviders||[],h=c.map(n=>"string"==typeof n?n:n.name),d=await (0,i.resolveBackend)(h),p=await d.createSessionHandler(l,u);return new s(p)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),parcelRequire.register("hvPrG",function(n,r){$parcel$export(n.exports,"Tensor",()=>a);// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var i=parcelRequire("lai8e");let a=i.Tensor}),parcelRequire.register("lai8e",function(n,r){$parcel$export(n.exports,"Tensor",()=>u);// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
let i="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,a="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from,s=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),o=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);i&&(s.set("int64",BigInt64Array),o.set(BigInt64Array,"int64")),a&&(s.set("uint64",BigUint64Array),o.set(BigUint64Array,"uint64"));/**
 * calculate size from dims.
 *
 * @param dims the dims array. May be an illegal input.
 */let l=n=>{let r=1;for(let i=0;i<n.length;i++){let a=n[i];if("number"!=typeof a||!Number.isSafeInteger(a))throw TypeError(`dims[${i}] must be an integer, got: ${a}`);if(a<0)throw RangeError(`dims[${i}] must be a non-negative integer, got: ${a}`);r*=a}return r};class u{constructor(n,r,i){let a,u,c;// check whether arg0 is type or data
if("string"==typeof n){if(//
// Override: constructor(type, data, ...)
//
a=n,c=i,"string"===n){// string tensor
if(!Array.isArray(r))throw TypeError("A string tensor's data must be a string array.");// we don't check whether every element in the array is string; this is too slow. we assume it's correct and
// error will be populated at inference
u=r}else{// numeric tensor
let i=s.get(n);if(void 0===i)throw TypeError(`Unsupported tensor type: ${n}.`);if(Array.isArray(r))// incorrect results.
// 'typedArrayConstructor' should be one of the typed array prototype objects.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
u=i.from(r);else if(r instanceof i)u=r;else throw TypeError(`A ${a} tensor's data must be type of ${i}`)}}else if(//
// Override: constructor(data, ...)
//
c=r,Array.isArray(n)){// only boolean[] and string[] is supported
if(0===n.length)throw TypeError("Tensor type cannot be inferred from an empty array.");let r=typeof n[0];if("string"===r)a="string",u=n;else if("boolean"===r)a="bool",// 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is
// wrong type. We use 'as any' to make it happy.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
u=Uint8Array.from(n);else throw TypeError(`Invalid element type of data array: ${r}.`)}else{// get tensor type from TypedArray
let r=o.get(n.constructor);if(void 0===r)throw TypeError(`Unsupported type for tensor data: ${n.constructor}.`);a=r,u=n}// type and data is processed, now processing dims
if(void 0===c)c=[u.length];else if(!Array.isArray(c))throw TypeError("A tensor's dims must be a number array");// perform check
let h=l(c);if(h!==u.length)throw Error(`Tensor's size(${h}) does not match data length(${u.length}).`);this.dims=c,this.type=a,this.data=u,this.size=h}// #endregion
/**
     * Create a new tensor object from image object
     *
     * @param buffer - Extracted image buffer data - assuming RGBA format
     * @param imageFormat - input image configuration - required configurations height, width, format
     * @param tensorFormat - output tensor configuration - Default is RGB format
     */static bufferToTensor(n,r){let i,a;if(void 0===n)throw Error("Image buffer must be defined");if(void 0===r.height||void 0===r.width)throw Error("Image height and width must be defined");let{height:s,width:o}=r,l=r.norm;i=void 0===l||void 0===l.mean?255:l.mean,a=void 0===l||void 0===l.bias?0:l.bias;let c=void 0!==r.bitmapFormat?r.bitmapFormat:"RGBA",h=void 0!==r.tensorFormat&&void 0!==r.tensorFormat?r.tensorFormat:"RGB",d=s*o,p=new Float32Array("RGBA"===h?4*d:3*d),f=4,m=0,g=1,_=2,y=3,b=0,v=d,x=2*d,w=-1;"RGB"===c&&(f=3,m=0,g=1,_=2,y=-1),"RGBA"===h?w=3*d:"RBG"===h?(b=0,x=d,v=2*d):"BGR"===h&&(x=0,v=d,b=2*d);for(let r=0;r<d;r++,m+=f,_+=f,g+=f,y+=f)p[b++]=(n[m]+a)/i,p[v++]=(n[g]+a)/i,p[x++]=(n[_]+a)/i,-1!==w&&-1!==y&&(p[w++]=(n[y]+a)/i);// Float32Array -> ort.Tensor
let T="RGBA"===h?new u("float32",p,[1,4,s,o]):new u("float32",p,[1,3,s,o]);return T}static async fromImage(n,r){let i;// checking the type of image object
let a="undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement,s="undefined"!=typeof ImageData&&n instanceof ImageData,o="undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap,l="undefined"!=typeof String&&(n instanceof String||"string"==typeof n),c={};// filling and checking image configuration options
if(a){// HTMLImageElement - image object - format is RGBA by default
let a=document.createElement("canvas"),s=a.getContext("2d");if(null!=s){let o=n.naturalHeight,l=n.naturalWidth;if(void 0!==r&&void 0!==r.resizedHeight&&void 0!==r.resizedWidth&&(o=r.resizedHeight,l=r.resizedWidth),void 0!==r){if(c=r,void 0!==r.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");if(c.tensorFormat="RGBA",void 0!==r.height&&r.height!==o)throw Error("Image input config height doesn't match HTMLImageElement height");if(c.height=o,void 0!==r.width&&r.width!==l)throw Error("Image input config width doesn't match HTMLImageElement width");c.width=l}else c.tensorFormat="RGBA",c.height=o,c.width=l;a.width=l,a.height=o,s.drawImage(n,0,0,l,o),i=s.getImageData(0,0,l,o).data}else throw Error("Can not access image data")}else if(s){let a,s;// ImageData - image object - format is RGBA by default
let o="RGBA";if(void 0!==r&&void 0!==r.resizedWidth&&void 0!==r.resizedHeight?(a=r.resizedHeight,s=r.resizedWidth):(a=n.height,s=n.width),void 0!==r){if(c=r,void 0!==r.bitmapFormat&&r.bitmapFormat!==o)throw Error("Image input config format must be RGBA for ImageData");c.bitmapFormat="RGBA"}else c.bitmapFormat="RGBA";if(c.height=a,c.width=s,void 0!==r){let r=document.createElement("canvas");r.width=s,r.height=a;let o=r.getContext("2d");if(null!=o)o.putImageData(n,0,0),i=o.getImageData(0,0,s,a).data;else throw Error("Can not access image data")}else i=n.data}else if(o){// ImageBitmap - image object - format must be provided by user
if(void 0===r)throw Error("Please provide image config with format for Imagebitmap");if(void 0!==r.bitmapFormat)throw Error("Image input config format must be defined for ImageBitmap");let a=document.createElement("canvas").getContext("2d");if(null!=a){let s=n.height,o=n.width;if(a.drawImage(n,0,0,o,s),i=a.getImageData(0,0,o,s).data,void 0!==r){// using square brackets to avoid TS error - type 'never'
if(void 0!==r.height&&r.height!==s)throw Error("Image input config height doesn't match ImageBitmap height");// using square brackets to avoid TS error - type 'never'
if(c.height=s,void 0!==r.width&&r.width!==o)throw Error("Image input config width doesn't match ImageBitmap width");c.width=o}else c.height=s,c.width=o;return u.bufferToTensor(i,c)}throw Error("Can not access image data")}else if(l)return new Promise((i,a)=>{let s=document.createElement("canvas"),o=s.getContext("2d");if(!n||!o)return a();let l=new Image;l.crossOrigin="Anonymous",l.src=n,l.onload=()=>{s.width=l.width,s.height=l.height,o.drawImage(l,0,0,s.width,s.height);let n=o.getImageData(0,0,s.width,s.height);if(void 0!==r){// using square brackets to avoid TS error - type 'never'
if(void 0!==r.height&&r.height!==s.height)throw Error("Image input config height doesn't match ImageBitmap height");// using square brackets to avoid TS error - type 'never'
if(c.height=s.height,void 0!==r.width&&r.width!==s.width)throw Error("Image input config width doesn't match ImageBitmap width");c.width=s.width}else c.height=s.height,c.width=s.width;i(u.bufferToTensor(n.data,c))}});else throw Error("Input data provided is not supported - aborted tensor creation");if(void 0!==i)return u.bufferToTensor(i,c);throw Error("Input data provided is not supported - aborted tensor creation")}toImageData(n){var r,i;let a;let s=document.createElement("canvas").getContext("2d");if(null!=s){// Default values for height and width & format
let o=this.dims[3],l=this.dims[2],u=this.dims[1],c=void 0!==n&&void 0!==n.format?n.format:"RGB",h=void 0!==n&&(null===(r=n.norm)||void 0===r?void 0:r.mean)!==void 0?n.norm.mean:255,d=void 0!==n&&(null===(i=n.norm)||void 0===i?void 0:i.bias)!==void 0?n.norm.bias:0,p=l*o;if(void 0!==n){if(void 0!==n.height&&n.height!==l)throw Error("Image output config height doesn't match tensor height");if(void 0!==n.width&&n.width!==o)throw Error("Image output config width doesn't match tensor width");if(void 0!==n.format&&4===u&&"RGBA"!==n.format||3===u&&"RGB"!==n.format&&"BGR"!==n.format)throw Error("Tensor format doesn't match input tensor dims")}// Default pointer assignments
let f=4,m=0,g=1,_=2,y=3,b=0,v=p,x=2*p,w=-1;"RGBA"===c?(b=0,v=p,x=2*p,w=3*p):"RGB"===c?(b=0,v=p,x=2*p):"RBG"===c&&(b=0,x=p,v=2*p),a=s.createImageData(o,l);for(let n=0;n<l*o;m+=f,g+=f,_+=f,y+=f,n++)a.data[m]=(this.data[b++]-d)*h,a.data[g]=(this.data[v++]-d)*h,a.data[_]=(this.data[x++]-d)*h,a.data[y]=-1===w?255:(this.data[w++]-d)*h}else throw Error("Can not access image data");return a}// #endregion
// #region tensor utilities
reshape(n){return new u(this.type,this.data,n)}}}),parcelRequire.register("723zv",function(n,r){// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
});var $d5b33d7c30034067$exports={};$parcel$export($d5b33d7c30034067$exports,"REVISION",()=>$d5b33d7c30034067$export$3545e07a80636437),$parcel$export($d5b33d7c30034067$exports,"MOUSE",()=>$d5b33d7c30034067$export$7177b3e430c2d7ca),$parcel$export($d5b33d7c30034067$exports,"TOUCH",()=>$d5b33d7c30034067$export$d46bd3ead7cc759b),$parcel$export($d5b33d7c30034067$exports,"CullFaceNone",()=>$d5b33d7c30034067$export$3237e1f2c1ea1f44),$parcel$export($d5b33d7c30034067$exports,"CullFaceBack",()=>$d5b33d7c30034067$export$b9a7b4fc5cb15f9b),$parcel$export($d5b33d7c30034067$exports,"CullFaceFront",()=>$d5b33d7c30034067$export$b8058bcc7037d3f3),$parcel$export($d5b33d7c30034067$exports,"CullFaceFrontBack",()=>$d5b33d7c30034067$export$f24be24dcddeac0d),$parcel$export($d5b33d7c30034067$exports,"BasicShadowMap",()=>$d5b33d7c30034067$export$346307dbae2b7447),$parcel$export($d5b33d7c30034067$exports,"PCFShadowMap",()=>$d5b33d7c30034067$export$5813f879eee7cd88),$parcel$export($d5b33d7c30034067$exports,"PCFSoftShadowMap",()=>$d5b33d7c30034067$export$a47c4b43a1be34f0),$parcel$export($d5b33d7c30034067$exports,"VSMShadowMap",()=>$d5b33d7c30034067$export$896ae1ade6c829c4),$parcel$export($d5b33d7c30034067$exports,"FrontSide",()=>$d5b33d7c30034067$export$2ede184fc2998901),$parcel$export($d5b33d7c30034067$exports,"BackSide",()=>$d5b33d7c30034067$export$d9f0486e75b5ace),$parcel$export($d5b33d7c30034067$exports,"DoubleSide",()=>$d5b33d7c30034067$export$3b296b6f144d5b03),$parcel$export($d5b33d7c30034067$exports,"TwoPassDoubleSide",()=>$d5b33d7c30034067$export$211211c00f97204d),$parcel$export($d5b33d7c30034067$exports,"NoBlending",()=>$d5b33d7c30034067$export$63b8d6b580fc65ba),$parcel$export($d5b33d7c30034067$exports,"NormalBlending",()=>$d5b33d7c30034067$export$5b29a26d96ee6af0),$parcel$export($d5b33d7c30034067$exports,"AdditiveBlending",()=>$d5b33d7c30034067$export$777d8f9551c2216b),$parcel$export($d5b33d7c30034067$exports,"SubtractiveBlending",()=>$d5b33d7c30034067$export$cdfa06f868e2e467),$parcel$export($d5b33d7c30034067$exports,"MultiplyBlending",()=>$d5b33d7c30034067$export$4138e1c684b46a20),$parcel$export($d5b33d7c30034067$exports,"CustomBlending",()=>$d5b33d7c30034067$export$eda4864c68df1fa2),$parcel$export($d5b33d7c30034067$exports,"AddEquation",()=>$d5b33d7c30034067$export$20183a0484ce21a0),$parcel$export($d5b33d7c30034067$exports,"SubtractEquation",()=>$d5b33d7c30034067$export$73e0df5177988548),$parcel$export($d5b33d7c30034067$exports,"ReverseSubtractEquation",()=>$d5b33d7c30034067$export$28e582859cbec660),$parcel$export($d5b33d7c30034067$exports,"MinEquation",()=>$d5b33d7c30034067$export$c8c1508da8d0600c),$parcel$export($d5b33d7c30034067$exports,"MaxEquation",()=>$d5b33d7c30034067$export$99948c02fb51055f),$parcel$export($d5b33d7c30034067$exports,"ZeroFactor",()=>$d5b33d7c30034067$export$2110f05edf778d3d),$parcel$export($d5b33d7c30034067$exports,"OneFactor",()=>$d5b33d7c30034067$export$8805bad65e24940e),$parcel$export($d5b33d7c30034067$exports,"SrcColorFactor",()=>$d5b33d7c30034067$export$7fbe15b28d28cf52),$parcel$export($d5b33d7c30034067$exports,"OneMinusSrcColorFactor",()=>$d5b33d7c30034067$export$947829af9f2c17f6),$parcel$export($d5b33d7c30034067$exports,"SrcAlphaFactor",()=>$d5b33d7c30034067$export$d5773124e86cf28c),$parcel$export($d5b33d7c30034067$exports,"OneMinusSrcAlphaFactor",()=>$d5b33d7c30034067$export$11d468cc7f19e971),$parcel$export($d5b33d7c30034067$exports,"DstAlphaFactor",()=>$d5b33d7c30034067$export$a78aed1ca2a87192),$parcel$export($d5b33d7c30034067$exports,"OneMinusDstAlphaFactor",()=>$d5b33d7c30034067$export$5d0fe17fd8773bac),$parcel$export($d5b33d7c30034067$exports,"DstColorFactor",()=>$d5b33d7c30034067$export$ef5f2dd8ffac5574),$parcel$export($d5b33d7c30034067$exports,"OneMinusDstColorFactor",()=>$d5b33d7c30034067$export$56b85b2686ab16),$parcel$export($d5b33d7c30034067$exports,"SrcAlphaSaturateFactor",()=>$d5b33d7c30034067$export$c05e2a1fc8609506),$parcel$export($d5b33d7c30034067$exports,"NeverDepth",()=>$d5b33d7c30034067$export$69025ce147cee220),$parcel$export($d5b33d7c30034067$exports,"AlwaysDepth",()=>$d5b33d7c30034067$export$7182eb52ea3b3f04),$parcel$export($d5b33d7c30034067$exports,"LessDepth",()=>$d5b33d7c30034067$export$eedccec66ab7ebe),$parcel$export($d5b33d7c30034067$exports,"LessEqualDepth",()=>$d5b33d7c30034067$export$296f78a0b892f81a),$parcel$export($d5b33d7c30034067$exports,"EqualDepth",()=>$d5b33d7c30034067$export$a60d398fc7b7590e),$parcel$export($d5b33d7c30034067$exports,"GreaterEqualDepth",()=>$d5b33d7c30034067$export$7d7234c1240a1fc4),$parcel$export($d5b33d7c30034067$exports,"GreaterDepth",()=>$d5b33d7c30034067$export$c5e2c52991f30937),$parcel$export($d5b33d7c30034067$exports,"NotEqualDepth",()=>$d5b33d7c30034067$export$2f843afa843d8916),$parcel$export($d5b33d7c30034067$exports,"MultiplyOperation",()=>$d5b33d7c30034067$export$e50ac29801f1774d),$parcel$export($d5b33d7c30034067$exports,"MixOperation",()=>$d5b33d7c30034067$export$9f9d94f963c85479),$parcel$export($d5b33d7c30034067$exports,"AddOperation",()=>$d5b33d7c30034067$export$e641dc52bc3494aa),$parcel$export($d5b33d7c30034067$exports,"NoToneMapping",()=>$d5b33d7c30034067$export$9fcb6b4294603b2),$parcel$export($d5b33d7c30034067$exports,"LinearToneMapping",()=>$d5b33d7c30034067$export$98f52c2a46c598ca),$parcel$export($d5b33d7c30034067$exports,"ReinhardToneMapping",()=>$d5b33d7c30034067$export$74b25e54b3bcd548),$parcel$export($d5b33d7c30034067$exports,"CineonToneMapping",()=>$d5b33d7c30034067$export$932b3dd283d4a366),$parcel$export($d5b33d7c30034067$exports,"ACESFilmicToneMapping",()=>$d5b33d7c30034067$export$a0d98fe6d7e4af64),$parcel$export($d5b33d7c30034067$exports,"CustomToneMapping",()=>$d5b33d7c30034067$export$2c7b09c1e9abfb5e),$parcel$export($d5b33d7c30034067$exports,"UVMapping",()=>$d5b33d7c30034067$export$1beec6768cbb3d2d),$parcel$export($d5b33d7c30034067$exports,"CubeReflectionMapping",()=>$d5b33d7c30034067$export$8759762a6477f2c4),$parcel$export($d5b33d7c30034067$exports,"CubeRefractionMapping",()=>$d5b33d7c30034067$export$dc59f8aed047f61d),$parcel$export($d5b33d7c30034067$exports,"EquirectangularReflectionMapping",()=>$d5b33d7c30034067$export$d64030b316d3b087),$parcel$export($d5b33d7c30034067$exports,"EquirectangularRefractionMapping",()=>$d5b33d7c30034067$export$ee99d97d46898098),$parcel$export($d5b33d7c30034067$exports,"CubeUVReflectionMapping",()=>$d5b33d7c30034067$export$dbf3e70ff37af79),$parcel$export($d5b33d7c30034067$exports,"RepeatWrapping",()=>$d5b33d7c30034067$export$533346c8e8dac0f5),$parcel$export($d5b33d7c30034067$exports,"ClampToEdgeWrapping",()=>$d5b33d7c30034067$export$9d9334239a5a5e06),$parcel$export($d5b33d7c30034067$exports,"MirroredRepeatWrapping",()=>$d5b33d7c30034067$export$c7e7c00b14f51a4f),$parcel$export($d5b33d7c30034067$exports,"NearestFilter",()=>$d5b33d7c30034067$export$727aa5ec3fe39bf0),$parcel$export($d5b33d7c30034067$exports,"NearestMipmapNearestFilter",()=>$d5b33d7c30034067$export$d129e38cf6feaa8c),$parcel$export($d5b33d7c30034067$exports,"NearestMipMapNearestFilter",()=>$d5b33d7c30034067$export$14a4936464a36496),$parcel$export($d5b33d7c30034067$exports,"NearestMipmapLinearFilter",()=>$d5b33d7c30034067$export$d2327c1afe5bfdf2),$parcel$export($d5b33d7c30034067$exports,"NearestMipMapLinearFilter",()=>$d5b33d7c30034067$export$cbc5b7f5647595d8),$parcel$export($d5b33d7c30034067$exports,"LinearFilter",()=>$d5b33d7c30034067$export$8a72f490b25c56c8),$parcel$export($d5b33d7c30034067$exports,"LinearMipmapNearestFilter",()=>$d5b33d7c30034067$export$19a719f377145a13),$parcel$export($d5b33d7c30034067$exports,"LinearMipMapNearestFilter",()=>$d5b33d7c30034067$export$dbe96bee3fe9dbf0),$parcel$export($d5b33d7c30034067$exports,"LinearMipmapLinearFilter",()=>$d5b33d7c30034067$export$5d8599b6a933fb1b),$parcel$export($d5b33d7c30034067$exports,"LinearMipMapLinearFilter",()=>$d5b33d7c30034067$export$90d80f1e3506775f),$parcel$export($d5b33d7c30034067$exports,"UnsignedByteType",()=>$d5b33d7c30034067$export$2e8ce08d3f6f5e10),$parcel$export($d5b33d7c30034067$exports,"ByteType",()=>$d5b33d7c30034067$export$545fce0311a9796a),$parcel$export($d5b33d7c30034067$exports,"ShortType",()=>$d5b33d7c30034067$export$88572337f312435f),$parcel$export($d5b33d7c30034067$exports,"UnsignedShortType",()=>$d5b33d7c30034067$export$c63dc51868b06a9d),$parcel$export($d5b33d7c30034067$exports,"IntType",()=>$d5b33d7c30034067$export$5c612977753abe2),$parcel$export($d5b33d7c30034067$exports,"UnsignedIntType",()=>$d5b33d7c30034067$export$c3c7fc4518ebba96),$parcel$export($d5b33d7c30034067$exports,"FloatType",()=>$d5b33d7c30034067$export$f6d331659b644596),$parcel$export($d5b33d7c30034067$exports,"HalfFloatType",()=>$d5b33d7c30034067$export$2697304443f382bc),$parcel$export($d5b33d7c30034067$exports,"UnsignedShort4444Type",()=>$d5b33d7c30034067$export$b3969b01faf587f2),$parcel$export($d5b33d7c30034067$exports,"UnsignedShort5551Type",()=>$d5b33d7c30034067$export$18886f8ae33e90de),$parcel$export($d5b33d7c30034067$exports,"UnsignedInt248Type",()=>$d5b33d7c30034067$export$6c8ea339bfab1301),$parcel$export($d5b33d7c30034067$exports,"AlphaFormat",()=>$d5b33d7c30034067$export$988473390501ed4b),$parcel$export($d5b33d7c30034067$exports,"RGBAFormat",()=>$d5b33d7c30034067$export$3f8bb04b555a363c),$parcel$export($d5b33d7c30034067$exports,"LuminanceFormat",()=>$d5b33d7c30034067$export$cc09ccbf6d1ed449),$parcel$export($d5b33d7c30034067$exports,"LuminanceAlphaFormat",()=>$d5b33d7c30034067$export$9053a81c4a69c289),$parcel$export($d5b33d7c30034067$exports,"DepthFormat",()=>$d5b33d7c30034067$export$c1b6b5136be58045),$parcel$export($d5b33d7c30034067$exports,"DepthStencilFormat",()=>$d5b33d7c30034067$export$1e113ac2d0905829),$parcel$export($d5b33d7c30034067$exports,"RedFormat",()=>$d5b33d7c30034067$export$4e041a7967d15c4b),$parcel$export($d5b33d7c30034067$exports,"RedIntegerFormat",()=>$d5b33d7c30034067$export$aa92e870a709d190),$parcel$export($d5b33d7c30034067$exports,"RGFormat",()=>$d5b33d7c30034067$export$6cdf0b461c7ce8a0),$parcel$export($d5b33d7c30034067$exports,"RGIntegerFormat",()=>$d5b33d7c30034067$export$1ba1c45f9f77d4d7),$parcel$export($d5b33d7c30034067$exports,"RGBAIntegerFormat",()=>$d5b33d7c30034067$export$c200e7d26f592f21),$parcel$export($d5b33d7c30034067$exports,"RGB_S3TC_DXT1_Format",()=>$d5b33d7c30034067$export$21d1799c6d552fc0),$parcel$export($d5b33d7c30034067$exports,"RGBA_S3TC_DXT1_Format",()=>$d5b33d7c30034067$export$afa304c3e981b668),$parcel$export($d5b33d7c30034067$exports,"RGBA_S3TC_DXT3_Format",()=>$d5b33d7c30034067$export$d2a1a68024a3e56c),$parcel$export($d5b33d7c30034067$exports,"RGBA_S3TC_DXT5_Format",()=>$d5b33d7c30034067$export$9a79c424327dacf9),$parcel$export($d5b33d7c30034067$exports,"RGB_PVRTC_4BPPV1_Format",()=>$d5b33d7c30034067$export$19ada9bbb1af3573),$parcel$export($d5b33d7c30034067$exports,"RGB_PVRTC_2BPPV1_Format",()=>$d5b33d7c30034067$export$d0f0355bb3d948e4),$parcel$export($d5b33d7c30034067$exports,"RGBA_PVRTC_4BPPV1_Format",()=>$d5b33d7c30034067$export$b82296714358084c),$parcel$export($d5b33d7c30034067$exports,"RGBA_PVRTC_2BPPV1_Format",()=>$d5b33d7c30034067$export$b71692456c47b6c3),$parcel$export($d5b33d7c30034067$exports,"RGB_ETC1_Format",()=>$d5b33d7c30034067$export$6ab91af2d757aee7),$parcel$export($d5b33d7c30034067$exports,"RGB_ETC2_Format",()=>$d5b33d7c30034067$export$7800993ef8106a6a),$parcel$export($d5b33d7c30034067$exports,"RGBA_ETC2_EAC_Format",()=>$d5b33d7c30034067$export$23ed8300a860e7d8),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_4x4_Format",()=>$d5b33d7c30034067$export$dc5570b4a2b92d48),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_5x4_Format",()=>$d5b33d7c30034067$export$68880cd325f8b2fb),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_5x5_Format",()=>$d5b33d7c30034067$export$7d2c0be323373d95),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_6x5_Format",()=>$d5b33d7c30034067$export$22b52da301fc3a3e),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_6x6_Format",()=>$d5b33d7c30034067$export$c009e2cb4a66485e),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_8x5_Format",()=>$d5b33d7c30034067$export$118fff5afa255b63),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_8x6_Format",()=>$d5b33d7c30034067$export$120713c829ae0667),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_8x8_Format",()=>$d5b33d7c30034067$export$c79eeabbf53313e9),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_10x5_Format",()=>$d5b33d7c30034067$export$443cf6567cdd6424),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_10x6_Format",()=>$d5b33d7c30034067$export$6573984fc9840780),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_10x8_Format",()=>$d5b33d7c30034067$export$e7aee563f30091de),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_10x10_Format",()=>$d5b33d7c30034067$export$2eb8634622ddeab7),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_12x10_Format",()=>$d5b33d7c30034067$export$202b1ce7b5d25742),$parcel$export($d5b33d7c30034067$exports,"RGBA_ASTC_12x12_Format",()=>$d5b33d7c30034067$export$18ab77abd087e467),$parcel$export($d5b33d7c30034067$exports,"RGBA_BPTC_Format",()=>$d5b33d7c30034067$export$ce40b115e188bc81),$parcel$export($d5b33d7c30034067$exports,"RGB_BPTC_SIGNED_Format",()=>$d5b33d7c30034067$export$d279c5c4bac5121e),$parcel$export($d5b33d7c30034067$exports,"RGB_BPTC_UNSIGNED_Format",()=>$d5b33d7c30034067$export$cde52d17225fdbd3),$parcel$export($d5b33d7c30034067$exports,"RED_RGTC1_Format",()=>$d5b33d7c30034067$export$b1688df4c4c21670),$parcel$export($d5b33d7c30034067$exports,"SIGNED_RED_RGTC1_Format",()=>$d5b33d7c30034067$export$fc15e5d8261eed58),$parcel$export($d5b33d7c30034067$exports,"RED_GREEN_RGTC2_Format",()=>$d5b33d7c30034067$export$d220f6ade8463a0f),$parcel$export($d5b33d7c30034067$exports,"SIGNED_RED_GREEN_RGTC2_Format",()=>$d5b33d7c30034067$export$768646d09dc1b6ef),$parcel$export($d5b33d7c30034067$exports,"LoopOnce",()=>$d5b33d7c30034067$export$d62fdc9d1b1cccad),$parcel$export($d5b33d7c30034067$exports,"LoopRepeat",()=>$d5b33d7c30034067$export$dfaf4422ce096e29),$parcel$export($d5b33d7c30034067$exports,"LoopPingPong",()=>$d5b33d7c30034067$export$f8f6f2041b78e210),$parcel$export($d5b33d7c30034067$exports,"InterpolateDiscrete",()=>$d5b33d7c30034067$export$995b32462a65e855),$parcel$export($d5b33d7c30034067$exports,"InterpolateLinear",()=>$d5b33d7c30034067$export$30fac1aace31cf4d),$parcel$export($d5b33d7c30034067$exports,"InterpolateSmooth",()=>$d5b33d7c30034067$export$198b11ff4c72bb30),$parcel$export($d5b33d7c30034067$exports,"ZeroCurvatureEnding",()=>$d5b33d7c30034067$export$7f795934b84ab523),$parcel$export($d5b33d7c30034067$exports,"ZeroSlopeEnding",()=>$d5b33d7c30034067$export$24a4ccb5099273b5),$parcel$export($d5b33d7c30034067$exports,"WrapAroundEnding",()=>$d5b33d7c30034067$export$8e8c3ecdcd8e1fee),$parcel$export($d5b33d7c30034067$exports,"NormalAnimationBlendMode",()=>$d5b33d7c30034067$export$bcfbbdcf8de7f8cd),$parcel$export($d5b33d7c30034067$exports,"AdditiveAnimationBlendMode",()=>$d5b33d7c30034067$export$d875e029ef558d3),$parcel$export($d5b33d7c30034067$exports,"TrianglesDrawMode",()=>$d5b33d7c30034067$export$4c28c87c2dc84758),$parcel$export($d5b33d7c30034067$exports,"TriangleStripDrawMode",()=>$d5b33d7c30034067$export$b23a071aa286eb29),$parcel$export($d5b33d7c30034067$exports,"TriangleFanDrawMode",()=>$d5b33d7c30034067$export$f0d8293634f88842),$parcel$export($d5b33d7c30034067$exports,"LinearEncoding",()=>$d5b33d7c30034067$export$7207336e4151a112),$parcel$export($d5b33d7c30034067$exports,"sRGBEncoding",()=>$d5b33d7c30034067$export$f32388edbb32674),$parcel$export($d5b33d7c30034067$exports,"BasicDepthPacking",()=>$d5b33d7c30034067$export$deeb383078690b50),$parcel$export($d5b33d7c30034067$exports,"RGBADepthPacking",()=>$d5b33d7c30034067$export$8f910f4c4f73df11),$parcel$export($d5b33d7c30034067$exports,"TangentSpaceNormalMap",()=>$d5b33d7c30034067$export$2852a58ebdac27b8),$parcel$export($d5b33d7c30034067$exports,"ObjectSpaceNormalMap",()=>$d5b33d7c30034067$export$9990ad26f9db5b2c),$parcel$export($d5b33d7c30034067$exports,"NoColorSpace",()=>$d5b33d7c30034067$export$bfcb490c2dd3db51),$parcel$export($d5b33d7c30034067$exports,"SRGBColorSpace",()=>$d5b33d7c30034067$export$561f394b24edfcaa),$parcel$export($d5b33d7c30034067$exports,"LinearSRGBColorSpace",()=>$d5b33d7c30034067$export$42429b3acfb233a4),$parcel$export($d5b33d7c30034067$exports,"DisplayP3ColorSpace",()=>$d5b33d7c30034067$export$626af19ae879bdf6),$parcel$export($d5b33d7c30034067$exports,"LinearDisplayP3ColorSpace",()=>$d5b33d7c30034067$export$c0dc1bc7e964761),$parcel$export($d5b33d7c30034067$exports,"ZeroStencilOp",()=>$d5b33d7c30034067$export$69433f11f42d5527),$parcel$export($d5b33d7c30034067$exports,"KeepStencilOp",()=>$d5b33d7c30034067$export$9f542ae4b5baca34),$parcel$export($d5b33d7c30034067$exports,"ReplaceStencilOp",()=>$d5b33d7c30034067$export$8a4f28336ef203d3),$parcel$export($d5b33d7c30034067$exports,"IncrementStencilOp",()=>$d5b33d7c30034067$export$2928c0231297c036),$parcel$export($d5b33d7c30034067$exports,"DecrementStencilOp",()=>$d5b33d7c30034067$export$c0e9611c8a15f9a8),$parcel$export($d5b33d7c30034067$exports,"IncrementWrapStencilOp",()=>$d5b33d7c30034067$export$9c2c08927385dcc4),$parcel$export($d5b33d7c30034067$exports,"DecrementWrapStencilOp",()=>$d5b33d7c30034067$export$7c74ea00fa1315e6),$parcel$export($d5b33d7c30034067$exports,"InvertStencilOp",()=>$d5b33d7c30034067$export$22e2e5726612443),$parcel$export($d5b33d7c30034067$exports,"NeverStencilFunc",()=>$d5b33d7c30034067$export$1343870698229224),$parcel$export($d5b33d7c30034067$exports,"LessStencilFunc",()=>$d5b33d7c30034067$export$8e1d8ed281997fa6),$parcel$export($d5b33d7c30034067$exports,"EqualStencilFunc",()=>$d5b33d7c30034067$export$55648a1cde8329a7),$parcel$export($d5b33d7c30034067$exports,"LessEqualStencilFunc",()=>$d5b33d7c30034067$export$2dff107857e6aca2),$parcel$export($d5b33d7c30034067$exports,"GreaterStencilFunc",()=>$d5b33d7c30034067$export$6f93765ab2f451a2),$parcel$export($d5b33d7c30034067$exports,"NotEqualStencilFunc",()=>$d5b33d7c30034067$export$6f3fb2d2440f2b76),$parcel$export($d5b33d7c30034067$exports,"GreaterEqualStencilFunc",()=>$d5b33d7c30034067$export$4119cf7b4c98fd5a),$parcel$export($d5b33d7c30034067$exports,"AlwaysStencilFunc",()=>$d5b33d7c30034067$export$14cf96713ddd97a8),$parcel$export($d5b33d7c30034067$exports,"NeverCompare",()=>$d5b33d7c30034067$export$d9e2d19a747baaab),$parcel$export($d5b33d7c30034067$exports,"LessCompare",()=>$d5b33d7c30034067$export$36bcf49c713b3eb7),$parcel$export($d5b33d7c30034067$exports,"EqualCompare",()=>$d5b33d7c30034067$export$66f28d946fc6a0d5),$parcel$export($d5b33d7c30034067$exports,"LessEqualCompare",()=>$d5b33d7c30034067$export$64eea11eb407ddf1),$parcel$export($d5b33d7c30034067$exports,"GreaterCompare",()=>$d5b33d7c30034067$export$155af022118f3a38),$parcel$export($d5b33d7c30034067$exports,"NotEqualCompare",()=>$d5b33d7c30034067$export$67ab95dde6bed156),$parcel$export($d5b33d7c30034067$exports,"GreaterEqualCompare",()=>$d5b33d7c30034067$export$1cdcb70d53d65f61),$parcel$export($d5b33d7c30034067$exports,"AlwaysCompare",()=>$d5b33d7c30034067$export$187b73a3e352c145),$parcel$export($d5b33d7c30034067$exports,"StaticDrawUsage",()=>$d5b33d7c30034067$export$763e8360f4d7f77d),$parcel$export($d5b33d7c30034067$exports,"DynamicDrawUsage",()=>$d5b33d7c30034067$export$8505d14ac8546ca),$parcel$export($d5b33d7c30034067$exports,"StreamDrawUsage",()=>$d5b33d7c30034067$export$721e63549e51d81e),$parcel$export($d5b33d7c30034067$exports,"StaticReadUsage",()=>$d5b33d7c30034067$export$415731dc4f48e299),$parcel$export($d5b33d7c30034067$exports,"DynamicReadUsage",()=>$d5b33d7c30034067$export$9e809946455f13bc),$parcel$export($d5b33d7c30034067$exports,"StreamReadUsage",()=>$d5b33d7c30034067$export$2ed9499a35b5f832),$parcel$export($d5b33d7c30034067$exports,"StaticCopyUsage",()=>$d5b33d7c30034067$export$32ab2503ea19469a),$parcel$export($d5b33d7c30034067$exports,"DynamicCopyUsage",()=>$d5b33d7c30034067$export$ab4022c2c3f86315),$parcel$export($d5b33d7c30034067$exports,"StreamCopyUsage",()=>$d5b33d7c30034067$export$ba7f1db36a76a970),$parcel$export($d5b33d7c30034067$exports,"GLSL1",()=>$d5b33d7c30034067$export$43600cc67fabd9f),$parcel$export($d5b33d7c30034067$exports,"GLSL3",()=>$d5b33d7c30034067$export$f63012db5506e7dd),$parcel$export($d5b33d7c30034067$exports,"_SRGBAFormat",()=>$d5b33d7c30034067$export$ca1dce8b5e1de74d),$parcel$export($d5b33d7c30034067$exports,"WebGLCoordinateSystem",()=>$d5b33d7c30034067$export$5a0e9190d10875d3),$parcel$export($d5b33d7c30034067$exports,"WebGPUCoordinateSystem",()=>$d5b33d7c30034067$export$cc83beedcb9be9ac),$parcel$export($d5b33d7c30034067$exports,"EventDispatcher",()=>$d5b33d7c30034067$export$ec8b666c5fe2c75a),$parcel$export($d5b33d7c30034067$exports,"MathUtils",()=>$d5b33d7c30034067$export$6a7ef315a0d1ef07),$parcel$export($d5b33d7c30034067$exports,"Vector2",()=>$d5b33d7c30034067$export$c977b3e384af9ae1),$parcel$export($d5b33d7c30034067$exports,"Matrix3",()=>$d5b33d7c30034067$export$8ff26dafa08918),$parcel$export($d5b33d7c30034067$exports,"createCanvasElement",()=>$d5b33d7c30034067$export$1033a2df66368859),$parcel$export($d5b33d7c30034067$exports,"ColorManagement",()=>$d5b33d7c30034067$export$5e6fd513f44698c),$parcel$export($d5b33d7c30034067$exports,"ImageUtils",()=>$d5b33d7c30034067$export$698882cf06df44aa),$parcel$export($d5b33d7c30034067$exports,"Source",()=>$d5b33d7c30034067$export$1d2df86270c81ecb),$parcel$export($d5b33d7c30034067$exports,"Texture",()=>$d5b33d7c30034067$export$5431306cf43de24a),$parcel$export($d5b33d7c30034067$exports,"Vector4",()=>$d5b33d7c30034067$export$fa7daccca11cdbe3),$parcel$export($d5b33d7c30034067$exports,"RenderTarget",()=>$d5b33d7c30034067$export$efcb1f8bf367cbfb),$parcel$export($d5b33d7c30034067$exports,"WebGLRenderTarget",()=>$d5b33d7c30034067$export$3c052beb2e51e23f),$parcel$export($d5b33d7c30034067$exports,"DataArrayTexture",()=>$d5b33d7c30034067$export$dfac6c8e811406a3),$parcel$export($d5b33d7c30034067$exports,"WebGLArrayRenderTarget",()=>$d5b33d7c30034067$export$c77a02c11ed180c7),$parcel$export($d5b33d7c30034067$exports,"Data3DTexture",()=>$d5b33d7c30034067$export$d7a3086320f856db),$parcel$export($d5b33d7c30034067$exports,"WebGL3DRenderTarget",()=>$d5b33d7c30034067$export$7ee06591009639df),$parcel$export($d5b33d7c30034067$exports,"WebGLMultipleRenderTargets",()=>$d5b33d7c30034067$export$bd934554fb721730),$parcel$export($d5b33d7c30034067$exports,"Quaternion",()=>$d5b33d7c30034067$export$23d6a54f0bbc85a3),$parcel$export($d5b33d7c30034067$exports,"Vector3",()=>$d5b33d7c30034067$export$64b5c384219d3699),$parcel$export($d5b33d7c30034067$exports,"Box3",()=>$d5b33d7c30034067$export$6f7d5a9418ab2aa3),$parcel$export($d5b33d7c30034067$exports,"Sphere",()=>$d5b33d7c30034067$export$805e8b72413ccaba),$parcel$export($d5b33d7c30034067$exports,"Ray",()=>$d5b33d7c30034067$export$a186db52eed6d40e),$parcel$export($d5b33d7c30034067$exports,"Matrix4",()=>$d5b33d7c30034067$export$2ae72fc923e5eb5),$parcel$export($d5b33d7c30034067$exports,"Euler",()=>$d5b33d7c30034067$export$d93cc409a0768c5f),$parcel$export($d5b33d7c30034067$exports,"Layers",()=>$d5b33d7c30034067$export$89312ce47c0ca777),$parcel$export($d5b33d7c30034067$exports,"Object3D",()=>$d5b33d7c30034067$export$e4dd07dff30cc924),$parcel$export($d5b33d7c30034067$exports,"Triangle",()=>$d5b33d7c30034067$export$5a465592bfe74b48),$parcel$export($d5b33d7c30034067$exports,"Material",()=>$d5b33d7c30034067$export$a2d8b23205c25948),$parcel$export($d5b33d7c30034067$exports,"Color",()=>$d5b33d7c30034067$export$892596cec99bc70e),$parcel$export($d5b33d7c30034067$exports,"MeshBasicMaterial",()=>$d5b33d7c30034067$export$55cbcc9b622fe1f5),$parcel$export($d5b33d7c30034067$exports,"DataUtils",()=>$d5b33d7c30034067$export$11ce8b759162cc80),$parcel$export($d5b33d7c30034067$exports,"BufferAttribute",()=>$d5b33d7c30034067$export$8dea267bd6bde117),$parcel$export($d5b33d7c30034067$exports,"Int8BufferAttribute",()=>$d5b33d7c30034067$export$f9ff2d6a20248cbf),$parcel$export($d5b33d7c30034067$exports,"Uint8BufferAttribute",()=>$d5b33d7c30034067$export$cacc90cf35d11cdd),$parcel$export($d5b33d7c30034067$exports,"Uint8ClampedBufferAttribute",()=>$d5b33d7c30034067$export$baaa85a1a812c157),$parcel$export($d5b33d7c30034067$exports,"Int16BufferAttribute",()=>$d5b33d7c30034067$export$2b755a102ccdcefe),$parcel$export($d5b33d7c30034067$exports,"Uint16BufferAttribute",()=>$d5b33d7c30034067$export$640a853f68025f2e),$parcel$export($d5b33d7c30034067$exports,"Int32BufferAttribute",()=>$d5b33d7c30034067$export$46b369aed2968a0a),$parcel$export($d5b33d7c30034067$exports,"Uint32BufferAttribute",()=>$d5b33d7c30034067$export$7eb8c9fa25cd5bd6),$parcel$export($d5b33d7c30034067$exports,"Float16BufferAttribute",()=>$d5b33d7c30034067$export$dbd3698c64958d69),$parcel$export($d5b33d7c30034067$exports,"Float32BufferAttribute",()=>$d5b33d7c30034067$export$cbe7a62641830ebd),$parcel$export($d5b33d7c30034067$exports,"Float64BufferAttribute",()=>$d5b33d7c30034067$export$9e0ade74842adbb8),$parcel$export($d5b33d7c30034067$exports,"BufferGeometry",()=>$d5b33d7c30034067$export$b7be63a67df8959),$parcel$export($d5b33d7c30034067$exports,"Mesh",()=>$d5b33d7c30034067$export$e176487c05830cc5),$parcel$export($d5b33d7c30034067$exports,"BoxGeometry",()=>$d5b33d7c30034067$export$33e43285f7406bd5),$parcel$export($d5b33d7c30034067$exports,"UniformsUtils",()=>$d5b33d7c30034067$export$d8ecdf8615bfea69),$parcel$export($d5b33d7c30034067$exports,"ShaderMaterial",()=>$d5b33d7c30034067$export$83c7d75d550a8b0d),$parcel$export($d5b33d7c30034067$exports,"Camera",()=>$d5b33d7c30034067$export$79f141de891a5fed),$parcel$export($d5b33d7c30034067$exports,"PerspectiveCamera",()=>$d5b33d7c30034067$export$74e4ae24825f68d7),$parcel$export($d5b33d7c30034067$exports,"CubeCamera",()=>$d5b33d7c30034067$export$d0cdd0bd804995de),$parcel$export($d5b33d7c30034067$exports,"CubeTexture",()=>$d5b33d7c30034067$export$ee2e5a18258a4049),$parcel$export($d5b33d7c30034067$exports,"WebGLCubeRenderTarget",()=>$d5b33d7c30034067$export$ac386671d651941e),$parcel$export($d5b33d7c30034067$exports,"Plane",()=>$d5b33d7c30034067$export$7ff5ac152ef991b0),$parcel$export($d5b33d7c30034067$exports,"Frustum",()=>$d5b33d7c30034067$export$35efe6f4c85463d2),$parcel$export($d5b33d7c30034067$exports,"PlaneGeometry",()=>$d5b33d7c30034067$export$967d831af31f69ce),$parcel$export($d5b33d7c30034067$exports,"ShaderChunk",()=>$d5b33d7c30034067$export$955f9f2e84c43c8b),$parcel$export($d5b33d7c30034067$exports,"UniformsLib",()=>$d5b33d7c30034067$export$6643083551874bf5),$parcel$export($d5b33d7c30034067$exports,"ShaderLib",()=>$d5b33d7c30034067$export$bee4a7d47f8f5014),$parcel$export($d5b33d7c30034067$exports,"OrthographicCamera",()=>$d5b33d7c30034067$export$9ebf355ee4ed261b),$parcel$export($d5b33d7c30034067$exports,"PMREMGenerator",()=>$d5b33d7c30034067$export$6add42717753e221),$parcel$export($d5b33d7c30034067$exports,"MeshDepthMaterial",()=>$d5b33d7c30034067$export$2698c22ec13825db),$parcel$export($d5b33d7c30034067$exports,"MeshDistanceMaterial",()=>$d5b33d7c30034067$export$33e187ed002f2a19),$parcel$export($d5b33d7c30034067$exports,"WebGLUtils",()=>$d5b33d7c30034067$export$ddaebcad857649a8),$parcel$export($d5b33d7c30034067$exports,"ArrayCamera",()=>$d5b33d7c30034067$export$56b937d9e5581166),$parcel$export($d5b33d7c30034067$exports,"Group",()=>$d5b33d7c30034067$export$eb2fcfdbd7ba97d4),$parcel$export($d5b33d7c30034067$exports,"DepthTexture",()=>$d5b33d7c30034067$export$fc830aa069cc8c2f),$parcel$export($d5b33d7c30034067$exports,"WebGLRenderer",()=>$d5b33d7c30034067$export$f6cc00ef28d7cf97),$parcel$export($d5b33d7c30034067$exports,"WebGL1Renderer",()=>$d5b33d7c30034067$export$a2f65229194348f9),$parcel$export($d5b33d7c30034067$exports,"FogExp2",()=>$d5b33d7c30034067$export$6f1519f023b8d0f6),$parcel$export($d5b33d7c30034067$exports,"Fog",()=>$d5b33d7c30034067$export$3c890837b09508d4),$parcel$export($d5b33d7c30034067$exports,"Scene",()=>$d5b33d7c30034067$export$38af1803e3442a7f),$parcel$export($d5b33d7c30034067$exports,"InterleavedBuffer",()=>$d5b33d7c30034067$export$3d5cd879f108f53f),$parcel$export($d5b33d7c30034067$exports,"InterleavedBufferAttribute",()=>$d5b33d7c30034067$export$920b6d07334599c7),$parcel$export($d5b33d7c30034067$exports,"SpriteMaterial",()=>$d5b33d7c30034067$export$5ec7dd1c6994bf8e),$parcel$export($d5b33d7c30034067$exports,"Sprite",()=>$d5b33d7c30034067$export$3075603db8e6204c),$parcel$export($d5b33d7c30034067$exports,"LOD",()=>$d5b33d7c30034067$export$112e7237be0c5f30),$parcel$export($d5b33d7c30034067$exports,"SkinnedMesh",()=>$d5b33d7c30034067$export$b303577035157ecf),$parcel$export($d5b33d7c30034067$exports,"Bone",()=>$d5b33d7c30034067$export$b127726e56765aa4),$parcel$export($d5b33d7c30034067$exports,"DataTexture",()=>$d5b33d7c30034067$export$b691f601014eabe1),$parcel$export($d5b33d7c30034067$exports,"Skeleton",()=>$d5b33d7c30034067$export$8f31e4c4a37b8e9c),$parcel$export($d5b33d7c30034067$exports,"InstancedBufferAttribute",()=>$d5b33d7c30034067$export$32ea87a8b54d744a),$parcel$export($d5b33d7c30034067$exports,"InstancedMesh",()=>$d5b33d7c30034067$export$f3c979c331175ad7),$parcel$export($d5b33d7c30034067$exports,"LineBasicMaterial",()=>$d5b33d7c30034067$export$fbaaa33907730a0c),$parcel$export($d5b33d7c30034067$exports,"Line",()=>$d5b33d7c30034067$export$17d680238e50603e),$parcel$export($d5b33d7c30034067$exports,"LineSegments",()=>$d5b33d7c30034067$export$ff1ed10fedfdd604),$parcel$export($d5b33d7c30034067$exports,"LineLoop",()=>$d5b33d7c30034067$export$f85a24d745e4f17d),$parcel$export($d5b33d7c30034067$exports,"PointsMaterial",()=>$d5b33d7c30034067$export$a178c45366ce5d6b),$parcel$export($d5b33d7c30034067$exports,"Points",()=>$d5b33d7c30034067$export$1c787534cb11aa3e),$parcel$export($d5b33d7c30034067$exports,"VideoTexture",()=>$d5b33d7c30034067$export$6e09d1edf8d5a25c),$parcel$export($d5b33d7c30034067$exports,"FramebufferTexture",()=>$d5b33d7c30034067$export$9270d786f73ce6fe),$parcel$export($d5b33d7c30034067$exports,"CompressedTexture",()=>$d5b33d7c30034067$export$3466bac9141a5cc4),$parcel$export($d5b33d7c30034067$exports,"CompressedArrayTexture",()=>$d5b33d7c30034067$export$5fe6b8e34b274fcb),$parcel$export($d5b33d7c30034067$exports,"CompressedCubeTexture",()=>$d5b33d7c30034067$export$d80173634de65bff),$parcel$export($d5b33d7c30034067$exports,"CanvasTexture",()=>$d5b33d7c30034067$export$f7189e49152d1c13),$parcel$export($d5b33d7c30034067$exports,"Curve",()=>$d5b33d7c30034067$export$b0e83c3ef8d2db1),$parcel$export($d5b33d7c30034067$exports,"EllipseCurve",()=>$d5b33d7c30034067$export$3f87a931616cde04),$parcel$export($d5b33d7c30034067$exports,"ArcCurve",()=>$d5b33d7c30034067$export$b1eedc9aab6300e8),$parcel$export($d5b33d7c30034067$exports,"CatmullRomCurve3",()=>$d5b33d7c30034067$export$b9146b27c24b744c),$parcel$export($d5b33d7c30034067$exports,"CubicBezierCurve",()=>$d5b33d7c30034067$export$e36650d36468bb39),$parcel$export($d5b33d7c30034067$exports,"CubicBezierCurve3",()=>$d5b33d7c30034067$export$13d5f1c9525f246c),$parcel$export($d5b33d7c30034067$exports,"LineCurve",()=>$d5b33d7c30034067$export$ab2e07e76531a47e),$parcel$export($d5b33d7c30034067$exports,"LineCurve3",()=>$d5b33d7c30034067$export$1fdfd9d9cf487600),$parcel$export($d5b33d7c30034067$exports,"QuadraticBezierCurve",()=>$d5b33d7c30034067$export$5938c4ee491a43ad),$parcel$export($d5b33d7c30034067$exports,"QuadraticBezierCurve3",()=>$d5b33d7c30034067$export$bf3f4c7e459f90fc),$parcel$export($d5b33d7c30034067$exports,"SplineCurve",()=>$d5b33d7c30034067$export$d3bdd77da77afc1b),$parcel$export($d5b33d7c30034067$exports,"CurvePath",()=>$d5b33d7c30034067$export$4aaf9b66af1bbf2c),$parcel$export($d5b33d7c30034067$exports,"Path",()=>$d5b33d7c30034067$export$4b2950bdac9b6ee9),$parcel$export($d5b33d7c30034067$exports,"LatheGeometry",()=>$d5b33d7c30034067$export$6d839803fcd1882c),$parcel$export($d5b33d7c30034067$exports,"CapsuleGeometry",()=>$d5b33d7c30034067$export$41680e8551036033),$parcel$export($d5b33d7c30034067$exports,"CircleGeometry",()=>$d5b33d7c30034067$export$d5c0e8d607467193),$parcel$export($d5b33d7c30034067$exports,"CylinderGeometry",()=>$d5b33d7c30034067$export$68f745719dbe5198),$parcel$export($d5b33d7c30034067$exports,"ConeGeometry",()=>$d5b33d7c30034067$export$a7a48974f285c9b3),$parcel$export($d5b33d7c30034067$exports,"PolyhedronGeometry",()=>$d5b33d7c30034067$export$60e57a7d3f20ff65),$parcel$export($d5b33d7c30034067$exports,"DodecahedronGeometry",()=>$d5b33d7c30034067$export$c0babfeb8708fc9c),$parcel$export($d5b33d7c30034067$exports,"EdgesGeometry",()=>$d5b33d7c30034067$export$4730b1542707547f),$parcel$export($d5b33d7c30034067$exports,"Shape",()=>$d5b33d7c30034067$export$6428a7f2611ef1fa),$parcel$export($d5b33d7c30034067$exports,"ShapeUtils",()=>$d5b33d7c30034067$export$96bdf6d9c66d7ba8),$parcel$export($d5b33d7c30034067$exports,"ExtrudeGeometry",()=>$d5b33d7c30034067$export$598697a1efa63ca7),$parcel$export($d5b33d7c30034067$exports,"IcosahedronGeometry",()=>$d5b33d7c30034067$export$9567cc828c9535da),$parcel$export($d5b33d7c30034067$exports,"OctahedronGeometry",()=>$d5b33d7c30034067$export$1954e2b809fe361e),$parcel$export($d5b33d7c30034067$exports,"RingGeometry",()=>$d5b33d7c30034067$export$68cb731f50f614af),$parcel$export($d5b33d7c30034067$exports,"ShapeGeometry",()=>$d5b33d7c30034067$export$57a29a1c803e9065),$parcel$export($d5b33d7c30034067$exports,"SphereGeometry",()=>$d5b33d7c30034067$export$1b417fc3b307a251),$parcel$export($d5b33d7c30034067$exports,"TetrahedronGeometry",()=>$d5b33d7c30034067$export$fb3f7adc68bd6e02),$parcel$export($d5b33d7c30034067$exports,"TorusGeometry",()=>$d5b33d7c30034067$export$a2312a2a1fa56495),$parcel$export($d5b33d7c30034067$exports,"TorusKnotGeometry",()=>$d5b33d7c30034067$export$77e9bfadfb9ab8c8),$parcel$export($d5b33d7c30034067$exports,"TubeGeometry",()=>$d5b33d7c30034067$export$7897d9d48904490c),$parcel$export($d5b33d7c30034067$exports,"WireframeGeometry",()=>$d5b33d7c30034067$export$4b739da06d24892b),$parcel$export($d5b33d7c30034067$exports,"ShadowMaterial",()=>$d5b33d7c30034067$export$e8564da406055a3),$parcel$export($d5b33d7c30034067$exports,"RawShaderMaterial",()=>$d5b33d7c30034067$export$21c421a2e1df9d22),$parcel$export($d5b33d7c30034067$exports,"MeshStandardMaterial",()=>$d5b33d7c30034067$export$f2980790215acccd),$parcel$export($d5b33d7c30034067$exports,"MeshPhysicalMaterial",()=>$d5b33d7c30034067$export$28d04986c4269c9f),$parcel$export($d5b33d7c30034067$exports,"MeshPhongMaterial",()=>$d5b33d7c30034067$export$24c72f71cbaf0678),$parcel$export($d5b33d7c30034067$exports,"MeshToonMaterial",()=>$d5b33d7c30034067$export$df893cf97e765622),$parcel$export($d5b33d7c30034067$exports,"MeshNormalMaterial",()=>$d5b33d7c30034067$export$bfe8c0a091f41ae7),$parcel$export($d5b33d7c30034067$exports,"MeshLambertMaterial",()=>$d5b33d7c30034067$export$5023a9a8114806b8),$parcel$export($d5b33d7c30034067$exports,"MeshMatcapMaterial",()=>$d5b33d7c30034067$export$6f5fef6235ec12ee),$parcel$export($d5b33d7c30034067$exports,"LineDashedMaterial",()=>$d5b33d7c30034067$export$327886a3efaeaebe),$parcel$export($d5b33d7c30034067$exports,"AnimationUtils",()=>$d5b33d7c30034067$export$7ee8caa573e71ad1),$parcel$export($d5b33d7c30034067$exports,"Interpolant",()=>$d5b33d7c30034067$export$b558baee9c0f72d3),$parcel$export($d5b33d7c30034067$exports,"CubicInterpolant",()=>$d5b33d7c30034067$export$3646682e7a3959),$parcel$export($d5b33d7c30034067$exports,"LinearInterpolant",()=>$d5b33d7c30034067$export$a8e6009059f51e1a),$parcel$export($d5b33d7c30034067$exports,"DiscreteInterpolant",()=>$d5b33d7c30034067$export$fb9758ef7ef8d5cc),$parcel$export($d5b33d7c30034067$exports,"KeyframeTrack",()=>$d5b33d7c30034067$export$b0e479f45b7006d6),$parcel$export($d5b33d7c30034067$exports,"BooleanKeyframeTrack",()=>$d5b33d7c30034067$export$d3a344b98cf0b775),$parcel$export($d5b33d7c30034067$exports,"ColorKeyframeTrack",()=>$d5b33d7c30034067$export$83444c5d885347d8),$parcel$export($d5b33d7c30034067$exports,"NumberKeyframeTrack",()=>$d5b33d7c30034067$export$d45f0d1a4d9a9314),$parcel$export($d5b33d7c30034067$exports,"QuaternionLinearInterpolant",()=>$d5b33d7c30034067$export$2db1cfb7923d931e),$parcel$export($d5b33d7c30034067$exports,"QuaternionKeyframeTrack",()=>$d5b33d7c30034067$export$b8043f12b5aafbd7),$parcel$export($d5b33d7c30034067$exports,"StringKeyframeTrack",()=>$d5b33d7c30034067$export$6ce41d4f3a8df9cd),$parcel$export($d5b33d7c30034067$exports,"VectorKeyframeTrack",()=>$d5b33d7c30034067$export$5ce2dcb4cc9f2bff),$parcel$export($d5b33d7c30034067$exports,"AnimationClip",()=>$d5b33d7c30034067$export$d942c706bf23829c),$parcel$export($d5b33d7c30034067$exports,"Cache",()=>$d5b33d7c30034067$export$94affb487e701bf2),$parcel$export($d5b33d7c30034067$exports,"LoadingManager",()=>$d5b33d7c30034067$export$99cc795e99919eed),$parcel$export($d5b33d7c30034067$exports,"DefaultLoadingManager",()=>$d5b33d7c30034067$export$b033c3f9a95c6a16),$parcel$export($d5b33d7c30034067$exports,"Loader",()=>$d5b33d7c30034067$export$3b0d6d7590275603),$parcel$export($d5b33d7c30034067$exports,"FileLoader",()=>$d5b33d7c30034067$export$98435a25b5cf7b2b),$parcel$export($d5b33d7c30034067$exports,"AnimationLoader",()=>$d5b33d7c30034067$export$29711c7e14f61db),$parcel$export($d5b33d7c30034067$exports,"CompressedTextureLoader",()=>$d5b33d7c30034067$export$bd73ce947a280350),$parcel$export($d5b33d7c30034067$exports,"ImageLoader",()=>$d5b33d7c30034067$export$8905ce1c7a2464a1),$parcel$export($d5b33d7c30034067$exports,"CubeTextureLoader",()=>$d5b33d7c30034067$export$2ec114afc2cf6308),$parcel$export($d5b33d7c30034067$exports,"DataTextureLoader",()=>$d5b33d7c30034067$export$792d8a18f2c55855),$parcel$export($d5b33d7c30034067$exports,"TextureLoader",()=>$d5b33d7c30034067$export$fd1bfc71f64c538c),$parcel$export($d5b33d7c30034067$exports,"Light",()=>$d5b33d7c30034067$export$6ecadb6ed240d696),$parcel$export($d5b33d7c30034067$exports,"HemisphereLight",()=>$d5b33d7c30034067$export$8d474f55edbb9624),$parcel$export($d5b33d7c30034067$exports,"SpotLight",()=>$d5b33d7c30034067$export$81495cbb73897362),$parcel$export($d5b33d7c30034067$exports,"PointLight",()=>$d5b33d7c30034067$export$4c9c1cb3f0b6f455),$parcel$export($d5b33d7c30034067$exports,"DirectionalLight",()=>$d5b33d7c30034067$export$3fea33cc9972c868),$parcel$export($d5b33d7c30034067$exports,"AmbientLight",()=>$d5b33d7c30034067$export$af279bfef9ec2c96),$parcel$export($d5b33d7c30034067$exports,"RectAreaLight",()=>$d5b33d7c30034067$export$61db2d908bbd2429),$parcel$export($d5b33d7c30034067$exports,"SphericalHarmonics3",()=>$d5b33d7c30034067$export$ba61ce607e1f405a),$parcel$export($d5b33d7c30034067$exports,"LightProbe",()=>$d5b33d7c30034067$export$e7ef036e309b38d2),$parcel$export($d5b33d7c30034067$exports,"MaterialLoader",()=>$d5b33d7c30034067$export$3bd6d323353dcf96),$parcel$export($d5b33d7c30034067$exports,"LoaderUtils",()=>$d5b33d7c30034067$export$b5d2dc08d867e41a),$parcel$export($d5b33d7c30034067$exports,"InstancedBufferGeometry",()=>$d5b33d7c30034067$export$231f009cbe414146),$parcel$export($d5b33d7c30034067$exports,"BufferGeometryLoader",()=>$d5b33d7c30034067$export$dc275bb96327833a),$parcel$export($d5b33d7c30034067$exports,"ObjectLoader",()=>$d5b33d7c30034067$export$40110c8505c5ad19),$parcel$export($d5b33d7c30034067$exports,"ImageBitmapLoader",()=>$d5b33d7c30034067$export$52286b55c4a9b51f),$parcel$export($d5b33d7c30034067$exports,"AudioContext",()=>$d5b33d7c30034067$export$fcbc63750ec2a81f),$parcel$export($d5b33d7c30034067$exports,"AudioLoader",()=>$d5b33d7c30034067$export$d8d5fccfbf47714e),$parcel$export($d5b33d7c30034067$exports,"HemisphereLightProbe",()=>$d5b33d7c30034067$export$2f22dadc8bc42820),$parcel$export($d5b33d7c30034067$exports,"AmbientLightProbe",()=>$d5b33d7c30034067$export$afe310a21c86023d),$parcel$export($d5b33d7c30034067$exports,"StereoCamera",()=>$d5b33d7c30034067$export$bc7f73a1065bee0c),$parcel$export($d5b33d7c30034067$exports,"Clock",()=>$d5b33d7c30034067$export$9735c82c4bae3302),$parcel$export($d5b33d7c30034067$exports,"AudioListener",()=>$d5b33d7c30034067$export$8a1b810c6fde8951),$parcel$export($d5b33d7c30034067$exports,"Audio",()=>$d5b33d7c30034067$export$153755f98d9861de),$parcel$export($d5b33d7c30034067$exports,"PositionalAudio",()=>$d5b33d7c30034067$export$4b3e397ef1832507),$parcel$export($d5b33d7c30034067$exports,"AudioAnalyser",()=>$d5b33d7c30034067$export$d47da1ef3d382827),$parcel$export($d5b33d7c30034067$exports,"PropertyMixer",()=>$d5b33d7c30034067$export$dfe0af1ca1acb78a),$parcel$export($d5b33d7c30034067$exports,"PropertyBinding",()=>$d5b33d7c30034067$export$7bf70fcf9f891893),$parcel$export($d5b33d7c30034067$exports,"AnimationObjectGroup",()=>$d5b33d7c30034067$export$30619c2afd3f34db),$parcel$export($d5b33d7c30034067$exports,"AnimationAction",()=>$d5b33d7c30034067$export$6946940a69e799e),$parcel$export($d5b33d7c30034067$exports,"AnimationMixer",()=>$d5b33d7c30034067$export$fbd77e5aefaa0102),$parcel$export($d5b33d7c30034067$exports,"Uniform",()=>$d5b33d7c30034067$export$2947cebfe91c02f8),$parcel$export($d5b33d7c30034067$exports,"UniformsGroup",()=>$d5b33d7c30034067$export$c412d5ffe1f79209),$parcel$export($d5b33d7c30034067$exports,"InstancedInterleavedBuffer",()=>$d5b33d7c30034067$export$25ec0e1af1389358),$parcel$export($d5b33d7c30034067$exports,"GLBufferAttribute",()=>$d5b33d7c30034067$export$6b7339ae8dbddf73),$parcel$export($d5b33d7c30034067$exports,"Raycaster",()=>$d5b33d7c30034067$export$8b7aaceff00bd2f),$parcel$export($d5b33d7c30034067$exports,"Spherical",()=>$d5b33d7c30034067$export$d712cd887b4a00f7),$parcel$export($d5b33d7c30034067$exports,"Cylindrical",()=>$d5b33d7c30034067$export$287165bb2177f4fd),$parcel$export($d5b33d7c30034067$exports,"Box2",()=>$d5b33d7c30034067$export$60f553fa130f08b0),$parcel$export($d5b33d7c30034067$exports,"Line3",()=>$d5b33d7c30034067$export$e0ba6359f1954fd3),$parcel$export($d5b33d7c30034067$exports,"SpotLightHelper",()=>$d5b33d7c30034067$export$4b14638ffdd81e68),$parcel$export($d5b33d7c30034067$exports,"SkeletonHelper",()=>$d5b33d7c30034067$export$5277df3c9e732259),$parcel$export($d5b33d7c30034067$exports,"PointLightHelper",()=>$d5b33d7c30034067$export$9a9291685b9e4023),$parcel$export($d5b33d7c30034067$exports,"HemisphereLightHelper",()=>$d5b33d7c30034067$export$8dca15f13f4f8172),$parcel$export($d5b33d7c30034067$exports,"GridHelper",()=>$d5b33d7c30034067$export$3875d39926561055),$parcel$export($d5b33d7c30034067$exports,"PolarGridHelper",()=>$d5b33d7c30034067$export$361430a10f533cd3),$parcel$export($d5b33d7c30034067$exports,"DirectionalLightHelper",()=>$d5b33d7c30034067$export$f8e434dc14203e7d),$parcel$export($d5b33d7c30034067$exports,"CameraHelper",()=>$d5b33d7c30034067$export$ed8e93f853cd795),$parcel$export($d5b33d7c30034067$exports,"BoxHelper",()=>$d5b33d7c30034067$export$38a664cc862a6a9d),$parcel$export($d5b33d7c30034067$exports,"Box3Helper",()=>$d5b33d7c30034067$export$ce39f4bb96c9a290),$parcel$export($d5b33d7c30034067$exports,"PlaneHelper",()=>$d5b33d7c30034067$export$a34fe8156c66e5d7),$parcel$export($d5b33d7c30034067$exports,"ArrowHelper",()=>$d5b33d7c30034067$export$a3008e7bd8d2cbe7),$parcel$export($d5b33d7c30034067$exports,"AxesHelper",()=>$d5b33d7c30034067$export$6c8303f35b8578fd),$parcel$export($d5b33d7c30034067$exports,"ShapePath",()=>$d5b33d7c30034067$export$148534a3c727230b);/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const $d5b33d7c30034067$export$3545e07a80636437="156",$d5b33d7c30034067$export$7177b3e430c2d7ca={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},$d5b33d7c30034067$export$d46bd3ead7cc759b={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},$d5b33d7c30034067$export$3237e1f2c1ea1f44=0,$d5b33d7c30034067$export$b9a7b4fc5cb15f9b=1,$d5b33d7c30034067$export$b8058bcc7037d3f3=2,$d5b33d7c30034067$export$f24be24dcddeac0d=3,$d5b33d7c30034067$export$346307dbae2b7447=0,$d5b33d7c30034067$export$5813f879eee7cd88=1,$d5b33d7c30034067$export$a47c4b43a1be34f0=2,$d5b33d7c30034067$export$896ae1ade6c829c4=3,$d5b33d7c30034067$export$2ede184fc2998901=0,$d5b33d7c30034067$export$d9f0486e75b5ace=1,$d5b33d7c30034067$export$3b296b6f144d5b03=2,$d5b33d7c30034067$export$211211c00f97204d=2,$d5b33d7c30034067$export$63b8d6b580fc65ba=0,$d5b33d7c30034067$export$5b29a26d96ee6af0=1,$d5b33d7c30034067$export$777d8f9551c2216b=2,$d5b33d7c30034067$export$cdfa06f868e2e467=3,$d5b33d7c30034067$export$4138e1c684b46a20=4,$d5b33d7c30034067$export$eda4864c68df1fa2=5,$d5b33d7c30034067$export$20183a0484ce21a0=100,$d5b33d7c30034067$export$73e0df5177988548=101,$d5b33d7c30034067$export$28e582859cbec660=102,$d5b33d7c30034067$export$c8c1508da8d0600c=103,$d5b33d7c30034067$export$99948c02fb51055f=104,$d5b33d7c30034067$export$2110f05edf778d3d=200,$d5b33d7c30034067$export$8805bad65e24940e=201,$d5b33d7c30034067$export$7fbe15b28d28cf52=202,$d5b33d7c30034067$export$947829af9f2c17f6=203,$d5b33d7c30034067$export$d5773124e86cf28c=204,$d5b33d7c30034067$export$11d468cc7f19e971=205,$d5b33d7c30034067$export$a78aed1ca2a87192=206,$d5b33d7c30034067$export$5d0fe17fd8773bac=207,$d5b33d7c30034067$export$ef5f2dd8ffac5574=208,$d5b33d7c30034067$export$56b85b2686ab16=209,$d5b33d7c30034067$export$c05e2a1fc8609506=210,$d5b33d7c30034067$export$69025ce147cee220=0,$d5b33d7c30034067$export$7182eb52ea3b3f04=1,$d5b33d7c30034067$export$eedccec66ab7ebe=2,$d5b33d7c30034067$export$296f78a0b892f81a=3,$d5b33d7c30034067$export$a60d398fc7b7590e=4,$d5b33d7c30034067$export$7d7234c1240a1fc4=5,$d5b33d7c30034067$export$c5e2c52991f30937=6,$d5b33d7c30034067$export$2f843afa843d8916=7,$d5b33d7c30034067$export$e50ac29801f1774d=0,$d5b33d7c30034067$export$9f9d94f963c85479=1,$d5b33d7c30034067$export$e641dc52bc3494aa=2,$d5b33d7c30034067$export$9fcb6b4294603b2=0,$d5b33d7c30034067$export$98f52c2a46c598ca=1,$d5b33d7c30034067$export$74b25e54b3bcd548=2,$d5b33d7c30034067$export$932b3dd283d4a366=3,$d5b33d7c30034067$export$a0d98fe6d7e4af64=4,$d5b33d7c30034067$export$2c7b09c1e9abfb5e=5,$d5b33d7c30034067$export$1beec6768cbb3d2d=300,$d5b33d7c30034067$export$8759762a6477f2c4=301,$d5b33d7c30034067$export$dc59f8aed047f61d=302,$d5b33d7c30034067$export$d64030b316d3b087=303,$d5b33d7c30034067$export$ee99d97d46898098=304,$d5b33d7c30034067$export$dbf3e70ff37af79=306,$d5b33d7c30034067$export$533346c8e8dac0f5=1e3,$d5b33d7c30034067$export$9d9334239a5a5e06=1001,$d5b33d7c30034067$export$c7e7c00b14f51a4f=1002,$d5b33d7c30034067$export$727aa5ec3fe39bf0=1003,$d5b33d7c30034067$export$d129e38cf6feaa8c=1004,$d5b33d7c30034067$export$14a4936464a36496=1004,$d5b33d7c30034067$export$d2327c1afe5bfdf2=1005,$d5b33d7c30034067$export$cbc5b7f5647595d8=1005,$d5b33d7c30034067$export$8a72f490b25c56c8=1006,$d5b33d7c30034067$export$19a719f377145a13=1007,$d5b33d7c30034067$export$dbe96bee3fe9dbf0=1007,$d5b33d7c30034067$export$5d8599b6a933fb1b=1008,$d5b33d7c30034067$export$90d80f1e3506775f=1008,$d5b33d7c30034067$export$2e8ce08d3f6f5e10=1009,$d5b33d7c30034067$export$545fce0311a9796a=1010,$d5b33d7c30034067$export$88572337f312435f=1011,$d5b33d7c30034067$export$c63dc51868b06a9d=1012,$d5b33d7c30034067$export$5c612977753abe2=1013,$d5b33d7c30034067$export$c3c7fc4518ebba96=1014,$d5b33d7c30034067$export$f6d331659b644596=1015,$d5b33d7c30034067$export$2697304443f382bc=1016,$d5b33d7c30034067$export$b3969b01faf587f2=1017,$d5b33d7c30034067$export$18886f8ae33e90de=1018,$d5b33d7c30034067$export$6c8ea339bfab1301=1020,$d5b33d7c30034067$export$988473390501ed4b=1021,$d5b33d7c30034067$export$3f8bb04b555a363c=1023,$d5b33d7c30034067$export$cc09ccbf6d1ed449=1024,$d5b33d7c30034067$export$9053a81c4a69c289=1025,$d5b33d7c30034067$export$c1b6b5136be58045=1026,$d5b33d7c30034067$export$1e113ac2d0905829=1027,$d5b33d7c30034067$export$4e041a7967d15c4b=1028,$d5b33d7c30034067$export$aa92e870a709d190=1029,$d5b33d7c30034067$export$6cdf0b461c7ce8a0=1030,$d5b33d7c30034067$export$1ba1c45f9f77d4d7=1031,$d5b33d7c30034067$export$c200e7d26f592f21=1033,$d5b33d7c30034067$export$21d1799c6d552fc0=33776,$d5b33d7c30034067$export$afa304c3e981b668=33777,$d5b33d7c30034067$export$d2a1a68024a3e56c=33778,$d5b33d7c30034067$export$9a79c424327dacf9=33779,$d5b33d7c30034067$export$19ada9bbb1af3573=35840,$d5b33d7c30034067$export$d0f0355bb3d948e4=35841,$d5b33d7c30034067$export$b82296714358084c=35842,$d5b33d7c30034067$export$b71692456c47b6c3=35843,$d5b33d7c30034067$export$6ab91af2d757aee7=36196,$d5b33d7c30034067$export$7800993ef8106a6a=37492,$d5b33d7c30034067$export$23ed8300a860e7d8=37496,$d5b33d7c30034067$export$dc5570b4a2b92d48=37808,$d5b33d7c30034067$export$68880cd325f8b2fb=37809,$d5b33d7c30034067$export$7d2c0be323373d95=37810,$d5b33d7c30034067$export$22b52da301fc3a3e=37811,$d5b33d7c30034067$export$c009e2cb4a66485e=37812,$d5b33d7c30034067$export$118fff5afa255b63=37813,$d5b33d7c30034067$export$120713c829ae0667=37814,$d5b33d7c30034067$export$c79eeabbf53313e9=37815,$d5b33d7c30034067$export$443cf6567cdd6424=37816,$d5b33d7c30034067$export$6573984fc9840780=37817,$d5b33d7c30034067$export$e7aee563f30091de=37818,$d5b33d7c30034067$export$2eb8634622ddeab7=37819,$d5b33d7c30034067$export$202b1ce7b5d25742=37820,$d5b33d7c30034067$export$18ab77abd087e467=37821,$d5b33d7c30034067$export$ce40b115e188bc81=36492,$d5b33d7c30034067$export$d279c5c4bac5121e=36494,$d5b33d7c30034067$export$cde52d17225fdbd3=36495,$d5b33d7c30034067$export$b1688df4c4c21670=36283,$d5b33d7c30034067$export$fc15e5d8261eed58=36284,$d5b33d7c30034067$export$d220f6ade8463a0f=36285,$d5b33d7c30034067$export$768646d09dc1b6ef=36286,$d5b33d7c30034067$export$d62fdc9d1b1cccad=2200,$d5b33d7c30034067$export$dfaf4422ce096e29=2201,$d5b33d7c30034067$export$f8f6f2041b78e210=2202,$d5b33d7c30034067$export$995b32462a65e855=2300,$d5b33d7c30034067$export$30fac1aace31cf4d=2301,$d5b33d7c30034067$export$198b11ff4c72bb30=2302,$d5b33d7c30034067$export$7f795934b84ab523=2400,$d5b33d7c30034067$export$24a4ccb5099273b5=2401,$d5b33d7c30034067$export$8e8c3ecdcd8e1fee=2402,$d5b33d7c30034067$export$bcfbbdcf8de7f8cd=2500,$d5b33d7c30034067$export$d875e029ef558d3=2501,$d5b33d7c30034067$export$4c28c87c2dc84758=0,$d5b33d7c30034067$export$b23a071aa286eb29=1,$d5b33d7c30034067$export$f0d8293634f88842=2,$d5b33d7c30034067$export$7207336e4151a112=3e3,$d5b33d7c30034067$export$f32388edbb32674=3001,$d5b33d7c30034067$export$deeb383078690b50=3200,$d5b33d7c30034067$export$8f910f4c4f73df11=3201,$d5b33d7c30034067$export$2852a58ebdac27b8=0,$d5b33d7c30034067$export$9990ad26f9db5b2c=1,$d5b33d7c30034067$export$bfcb490c2dd3db51="",$d5b33d7c30034067$export$561f394b24edfcaa="srgb",$d5b33d7c30034067$export$42429b3acfb233a4="srgb-linear",$d5b33d7c30034067$export$626af19ae879bdf6="display-p3",$d5b33d7c30034067$export$c0dc1bc7e964761="display-p3-linear",$d5b33d7c30034067$export$69433f11f42d5527=0,$d5b33d7c30034067$export$9f542ae4b5baca34=7680,$d5b33d7c30034067$export$8a4f28336ef203d3=7681,$d5b33d7c30034067$export$2928c0231297c036=7682,$d5b33d7c30034067$export$c0e9611c8a15f9a8=7683,$d5b33d7c30034067$export$9c2c08927385dcc4=34055,$d5b33d7c30034067$export$7c74ea00fa1315e6=34056,$d5b33d7c30034067$export$22e2e5726612443=5386,$d5b33d7c30034067$export$1343870698229224=512,$d5b33d7c30034067$export$8e1d8ed281997fa6=513,$d5b33d7c30034067$export$55648a1cde8329a7=514,$d5b33d7c30034067$export$2dff107857e6aca2=515,$d5b33d7c30034067$export$6f93765ab2f451a2=516,$d5b33d7c30034067$export$6f3fb2d2440f2b76=517,$d5b33d7c30034067$export$4119cf7b4c98fd5a=518,$d5b33d7c30034067$export$14cf96713ddd97a8=519,$d5b33d7c30034067$export$d9e2d19a747baaab=512,$d5b33d7c30034067$export$36bcf49c713b3eb7=513,$d5b33d7c30034067$export$66f28d946fc6a0d5=514,$d5b33d7c30034067$export$64eea11eb407ddf1=515,$d5b33d7c30034067$export$155af022118f3a38=516,$d5b33d7c30034067$export$67ab95dde6bed156=517,$d5b33d7c30034067$export$1cdcb70d53d65f61=518,$d5b33d7c30034067$export$187b73a3e352c145=519,$d5b33d7c30034067$export$763e8360f4d7f77d=35044,$d5b33d7c30034067$export$8505d14ac8546ca=35048,$d5b33d7c30034067$export$721e63549e51d81e=35040,$d5b33d7c30034067$export$415731dc4f48e299=35045,$d5b33d7c30034067$export$9e809946455f13bc=35049,$d5b33d7c30034067$export$2ed9499a35b5f832=35041,$d5b33d7c30034067$export$32ab2503ea19469a=35046,$d5b33d7c30034067$export$ab4022c2c3f86315=35050,$d5b33d7c30034067$export$ba7f1db36a76a970=35042,$d5b33d7c30034067$export$43600cc67fabd9f="100",$d5b33d7c30034067$export$f63012db5506e7dd="300 es",$d5b33d7c30034067$export$ca1dce8b5e1de74d=1035,$d5b33d7c30034067$export$5a0e9190d10875d3=2e3,$d5b33d7c30034067$export$cc83beedcb9be9ac=2001;/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */class $d5b33d7c30034067$export$ec8b666c5fe2c75a{addEventListener(n,r){void 0===this._listeners&&(this._listeners={});let i=this._listeners;void 0===i[n]&&(i[n]=[]),-1===i[n].indexOf(r)&&i[n].push(r)}hasEventListener(n,r){if(void 0===this._listeners)return!1;let i=this._listeners;return void 0!==i[n]&&-1!==i[n].indexOf(r)}removeEventListener(n,r){if(void 0===this._listeners)return;let i=this._listeners,a=i[n];if(void 0!==a){let n=a.indexOf(r);-1!==n&&a.splice(n,1)}}dispatchEvent(n){if(void 0===this._listeners)return;let r=this._listeners,i=r[n.type];if(void 0!==i){n.target=this;// Make a copy, in case listeners are removed while iterating.
let r=i.slice(0);for(let i=0,a=r.length;i<a;i++)r[i].call(this,n);n.target=null}}}const $d5b33d7c30034067$var$_lut=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let $d5b33d7c30034067$var$_seed=1234567;const $d5b33d7c30034067$var$DEG2RAD=Math.PI/180,$d5b33d7c30034067$var$RAD2DEG=180/Math.PI;// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function $d5b33d7c30034067$var$generateUUID(){let n=4294967295*Math.random()|0,r=4294967295*Math.random()|0,i=4294967295*Math.random()|0,a=4294967295*Math.random()|0,s=$d5b33d7c30034067$var$_lut[255&n]+$d5b33d7c30034067$var$_lut[n>>8&255]+$d5b33d7c30034067$var$_lut[n>>16&255]+$d5b33d7c30034067$var$_lut[n>>24&255]+"-"+$d5b33d7c30034067$var$_lut[255&r]+$d5b33d7c30034067$var$_lut[r>>8&255]+"-"+$d5b33d7c30034067$var$_lut[r>>16&15|64]+$d5b33d7c30034067$var$_lut[r>>24&255]+"-"+$d5b33d7c30034067$var$_lut[63&i|128]+$d5b33d7c30034067$var$_lut[i>>8&255]+"-"+$d5b33d7c30034067$var$_lut[i>>16&255]+$d5b33d7c30034067$var$_lut[i>>24&255]+$d5b33d7c30034067$var$_lut[255&a]+$d5b33d7c30034067$var$_lut[a>>8&255]+$d5b33d7c30034067$var$_lut[a>>16&255]+$d5b33d7c30034067$var$_lut[a>>24&255];// .toLowerCase() here flattens concatenated strings to save heap memory space.
return s.toLowerCase()}function $d5b33d7c30034067$var$clamp(n,r,i){return Math.max(r,Math.min(i,n))}// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function $d5b33d7c30034067$var$euclideanModulo(n,r){return(n%r+r)%r}// Linear mapping from range <a1, a2> to range <b1, b2>
function $d5b33d7c30034067$var$mapLinear(n,r,i,a,s){return a+(n-r)*(s-a)/(i-r)}// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function $d5b33d7c30034067$var$inverseLerp(n,r,i){return n!==r?(i-n)/(r-n):0}// https://en.wikipedia.org/wiki/Linear_interpolation
function $d5b33d7c30034067$var$lerp(n,r,i){return(1-i)*n+i*r}// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function $d5b33d7c30034067$var$damp(n,r,i,a){return $d5b33d7c30034067$var$lerp(n,r,1-Math.exp(-i*a))}// https://www.desmos.com/calculator/vcsjnyz7x4
function $d5b33d7c30034067$var$pingpong(n,r=1){return r-Math.abs($d5b33d7c30034067$var$euclideanModulo(n,2*r)-r)}// http://en.wikipedia.org/wiki/Smoothstep
function $d5b33d7c30034067$var$smoothstep(n,r,i){return n<=r?0:n>=i?1:(n=(n-r)/(i-r))*n*(3-2*n)}function $d5b33d7c30034067$var$smootherstep(n,r,i){return n<=r?0:n>=i?1:(n=(n-r)/(i-r))*n*n*(n*(6*n-15)+10)}// Random integer from <low, high> interval
function $d5b33d7c30034067$var$randInt(n,r){return n+Math.floor(Math.random()*(r-n+1))}// Random float from <low, high> interval
function $d5b33d7c30034067$var$randFloat(n,r){return n+Math.random()*(r-n)}// Random float from <-range/2, range/2> interval
function $d5b33d7c30034067$var$randFloatSpread(n){return n*(.5-Math.random())}// Deterministic pseudo-random float in the interval [ 0, 1 ]
function $d5b33d7c30034067$var$seededRandom(n){void 0!==n&&($d5b33d7c30034067$var$_seed=n);// Mulberry32 generator
let r=$d5b33d7c30034067$var$_seed+=1831565813;return r=Math.imul(r^r>>>15,1|r),(((r^=r+Math.imul(r^r>>>7,61|r))^r>>>14)>>>0)/4294967296}function $d5b33d7c30034067$var$degToRad(n){return n*$d5b33d7c30034067$var$DEG2RAD}function $d5b33d7c30034067$var$radToDeg(n){return n*$d5b33d7c30034067$var$RAD2DEG}function $d5b33d7c30034067$var$isPowerOfTwo(n){return(n&n-1)==0&&0!==n}function $d5b33d7c30034067$var$ceilPowerOfTwo(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function $d5b33d7c30034067$var$floorPowerOfTwo(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function $d5b33d7c30034067$var$setQuaternionFromProperEuler(n,r,i,a,s){// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
// rotations are applied to the axes in the order specified by 'order'
// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
// angles are in radians
let o=Math.cos,l=Math.sin,u=o(i/2),c=l(i/2),h=o((r+a)/2),d=l((r+a)/2),p=o((r-a)/2),f=l((r-a)/2),m=o((a-r)/2),g=l((a-r)/2);switch(s){case"XYX":n.set(u*d,c*p,c*f,u*h);break;case"YZY":n.set(c*f,u*d,c*p,u*h);break;case"ZXZ":n.set(c*p,c*f,u*d,u*h);break;case"XZX":n.set(u*d,c*g,c*m,u*h);break;case"YXY":n.set(c*m,u*d,c*g,u*h);break;case"ZYZ":n.set(c*g,c*m,u*d,u*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}function $d5b33d7c30034067$var$denormalize(n,r){switch(r.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw Error("Invalid component type.")}}function $d5b33d7c30034067$var$normalize(n,r){switch(r.constructor){case Float32Array:return n;case Uint32Array:return Math.round(4294967295*n);case Uint16Array:return Math.round(65535*n);case Uint8Array:return Math.round(255*n);case Int32Array:return Math.round(2147483647*n);case Int16Array:return Math.round(32767*n);case Int8Array:return Math.round(127*n);default:throw Error("Invalid component type.")}}const $d5b33d7c30034067$export$6a7ef315a0d1ef07={DEG2RAD:$d5b33d7c30034067$var$DEG2RAD,RAD2DEG:$d5b33d7c30034067$var$RAD2DEG,generateUUID:$d5b33d7c30034067$var$generateUUID,clamp:$d5b33d7c30034067$var$clamp,euclideanModulo:$d5b33d7c30034067$var$euclideanModulo,mapLinear:$d5b33d7c30034067$var$mapLinear,inverseLerp:$d5b33d7c30034067$var$inverseLerp,lerp:$d5b33d7c30034067$var$lerp,damp:$d5b33d7c30034067$var$damp,pingpong:$d5b33d7c30034067$var$pingpong,smoothstep:$d5b33d7c30034067$var$smoothstep,smootherstep:$d5b33d7c30034067$var$smootherstep,randInt:$d5b33d7c30034067$var$randInt,randFloat:$d5b33d7c30034067$var$randFloat,randFloatSpread:$d5b33d7c30034067$var$randFloatSpread,seededRandom:$d5b33d7c30034067$var$seededRandom,degToRad:$d5b33d7c30034067$var$degToRad,radToDeg:$d5b33d7c30034067$var$radToDeg,isPowerOfTwo:$d5b33d7c30034067$var$isPowerOfTwo,ceilPowerOfTwo:$d5b33d7c30034067$var$ceilPowerOfTwo,floorPowerOfTwo:$d5b33d7c30034067$var$floorPowerOfTwo,setQuaternionFromProperEuler:$d5b33d7c30034067$var$setQuaternionFromProperEuler,normalize:$d5b33d7c30034067$var$normalize,denormalize:$d5b33d7c30034067$var$denormalize};class $d5b33d7c30034067$export$c977b3e384af9ae1{constructor(n=0,r=0){$d5b33d7c30034067$export$c977b3e384af9ae1.prototype.isVector2=!0,this.x=n,this.y=r}get width(){return this.x}set width(n){this.x=n}get height(){return this.y}set height(n){this.y=n}set(n,r){return this.x=n,this.y=r,this}setScalar(n){return this.x=n,this.y=n,this}setX(n){return this.x=n,this}setY(n){return this.y=n,this}setComponent(n,r){switch(n){case 0:this.x=r;break;case 1:this.y=r;break;default:throw Error("index is out of range: "+n)}return this}getComponent(n){switch(n){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+n)}}clone(){return new this.constructor(this.x,this.y)}copy(n){return this.x=n.x,this.y=n.y,this}add(n){return this.x+=n.x,this.y+=n.y,this}addScalar(n){return this.x+=n,this.y+=n,this}addVectors(n,r){return this.x=n.x+r.x,this.y=n.y+r.y,this}addScaledVector(n,r){return this.x+=n.x*r,this.y+=n.y*r,this}sub(n){return this.x-=n.x,this.y-=n.y,this}subScalar(n){return this.x-=n,this.y-=n,this}subVectors(n,r){return this.x=n.x-r.x,this.y=n.y-r.y,this}multiply(n){return this.x*=n.x,this.y*=n.y,this}multiplyScalar(n){return this.x*=n,this.y*=n,this}divide(n){return this.x/=n.x,this.y/=n.y,this}divideScalar(n){return this.multiplyScalar(1/n)}applyMatrix3(n){let r=this.x,i=this.y,a=n.elements;return this.x=a[0]*r+a[3]*i+a[6],this.y=a[1]*r+a[4]*i+a[7],this}min(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this}max(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this}clamp(n,r){return(// assumes min < max, componentwise
this.x=Math.max(n.x,Math.min(r.x,this.x)),this.y=Math.max(n.y,Math.min(r.y,this.y)),this)}clampScalar(n,r){return this.x=Math.max(n,Math.min(r,this.x)),this.y=Math.max(n,Math.min(r,this.y)),this}clampLength(n,r){let i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(n,Math.min(r,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(n){return this.x*n.x+this.y*n.y}cross(n){return this.x*n.y-this.y*n.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){// computes the angle in radians with respect to the positive x-axis
let n=Math.atan2(-this.y,-this.x)+Math.PI;return n}angleTo(n){let r=Math.sqrt(this.lengthSq()*n.lengthSq());if(0===r)return Math.PI/2;let i=this.dot(n)/r;// clamp, to handle numerical problems
return Math.acos($d5b33d7c30034067$var$clamp(i,-1,1))}distanceTo(n){return Math.sqrt(this.distanceToSquared(n))}distanceToSquared(n){let r=this.x-n.x,i=this.y-n.y;return r*r+i*i}manhattanDistanceTo(n){return Math.abs(this.x-n.x)+Math.abs(this.y-n.y)}setLength(n){return this.normalize().multiplyScalar(n)}lerp(n,r){return this.x+=(n.x-this.x)*r,this.y+=(n.y-this.y)*r,this}lerpVectors(n,r,i){return this.x=n.x+(r.x-n.x)*i,this.y=n.y+(r.y-n.y)*i,this}equals(n){return n.x===this.x&&n.y===this.y}fromArray(n,r=0){return this.x=n[r],this.y=n[r+1],this}toArray(n=[],r=0){return n[r]=this.x,n[r+1]=this.y,n}fromBufferAttribute(n,r){return this.x=n.getX(r),this.y=n.getY(r),this}rotateAround(n,r){let i=Math.cos(r),a=Math.sin(r),s=this.x-n.x,o=this.y-n.y;return this.x=s*i-o*a+n.x,this.y=s*a+o*i+n.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class $d5b33d7c30034067$export$8ff26dafa08918{constructor(n,r,i,a,s,o,l,u,c){$d5b33d7c30034067$export$8ff26dafa08918.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==n&&this.set(n,r,i,a,s,o,l,u,c)}set(n,r,i,a,s,o,l,u,c){let h=this.elements;return h[0]=n,h[1]=a,h[2]=l,h[3]=r,h[4]=s,h[5]=u,h[6]=i,h[7]=o,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(n){let r=this.elements,i=n.elements;return r[0]=i[0],r[1]=i[1],r[2]=i[2],r[3]=i[3],r[4]=i[4],r[5]=i[5],r[6]=i[6],r[7]=i[7],r[8]=i[8],this}extractBasis(n,r,i){return n.setFromMatrix3Column(this,0),r.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(n){let r=n.elements;return this.set(r[0],r[4],r[8],r[1],r[5],r[9],r[2],r[6],r[10]),this}multiply(n){return this.multiplyMatrices(this,n)}premultiply(n){return this.multiplyMatrices(n,this)}multiplyMatrices(n,r){let i=n.elements,a=r.elements,s=this.elements,o=i[0],l=i[3],u=i[6],c=i[1],h=i[4],d=i[7],p=i[2],f=i[5],m=i[8],g=a[0],_=a[3],y=a[6],b=a[1],v=a[4],x=a[7],w=a[2],T=a[5],S=a[8];return s[0]=o*g+l*b+u*w,s[3]=o*_+l*v+u*T,s[6]=o*y+l*x+u*S,s[1]=c*g+h*b+d*w,s[4]=c*_+h*v+d*T,s[7]=c*y+h*x+d*S,s[2]=p*g+f*b+m*w,s[5]=p*_+f*v+m*T,s[8]=p*y+f*x+m*S,this}multiplyScalar(n){let r=this.elements;return r[0]*=n,r[3]*=n,r[6]*=n,r[1]*=n,r[4]*=n,r[7]*=n,r[2]*=n,r[5]*=n,r[8]*=n,this}determinant(){let n=this.elements,r=n[0],i=n[1],a=n[2],s=n[3],o=n[4],l=n[5],u=n[6],c=n[7],h=n[8];return r*o*h-r*l*c-i*s*h+i*l*u+a*s*c-a*o*u}invert(){let n=this.elements,r=n[0],i=n[1],a=n[2],s=n[3],o=n[4],l=n[5],u=n[6],c=n[7],h=n[8],d=h*o-l*c,p=l*u-h*s,f=c*s-o*u,m=r*d+i*p+a*f;if(0===m)return this.set(0,0,0,0,0,0,0,0,0);let g=1/m;return n[0]=d*g,n[1]=(a*c-h*i)*g,n[2]=(l*i-a*o)*g,n[3]=p*g,n[4]=(h*r-a*u)*g,n[5]=(a*s-l*r)*g,n[6]=f*g,n[7]=(i*u-c*r)*g,n[8]=(o*r-i*s)*g,this}transpose(){let n;let r=this.elements;return n=r[1],r[1]=r[3],r[3]=n,n=r[2],r[2]=r[6],r[6]=n,n=r[5],r[5]=r[7],r[7]=n,this}getNormalMatrix(n){return this.setFromMatrix4(n).invert().transpose()}transposeIntoArray(n){let r=this.elements;return n[0]=r[0],n[1]=r[3],n[2]=r[6],n[3]=r[1],n[4]=r[4],n[5]=r[7],n[6]=r[2],n[7]=r[5],n[8]=r[8],this}setUvTransform(n,r,i,a,s,o,l){let u=Math.cos(s),c=Math.sin(s);return this.set(i*u,i*c,-i*(u*o+c*l)+o+n,-a*c,a*u,-a*(-c*o+u*l)+l+r,0,0,1),this}//
scale(n,r){return this.premultiply($d5b33d7c30034067$var$_m3.makeScale(n,r)),this}rotate(n){return this.premultiply($d5b33d7c30034067$var$_m3.makeRotation(-n)),this}translate(n,r){return this.premultiply($d5b33d7c30034067$var$_m3.makeTranslation(n,r)),this}// for 2D Transforms
makeTranslation(n,r){return n.isVector2?this.set(1,0,n.x,0,1,n.y,0,0,1):this.set(1,0,n,0,1,r,0,0,1),this}makeRotation(n){// counterclockwise
let r=Math.cos(n),i=Math.sin(n);return this.set(r,-i,0,i,r,0,0,0,1),this}makeScale(n,r){return this.set(n,0,0,0,r,0,0,0,1),this}//
equals(n){let r=this.elements,i=n.elements;for(let n=0;n<9;n++)if(r[n]!==i[n])return!1;return!0}fromArray(n,r=0){for(let i=0;i<9;i++)this.elements[i]=n[i+r];return this}toArray(n=[],r=0){let i=this.elements;return n[r]=i[0],n[r+1]=i[1],n[r+2]=i[2],n[r+3]=i[3],n[r+4]=i[4],n[r+5]=i[5],n[r+6]=i[6],n[r+7]=i[7],n[r+8]=i[8],n}clone(){return new this.constructor().fromArray(this.elements)}}const $d5b33d7c30034067$var$_m3=/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918;function $d5b33d7c30034067$var$arrayNeedsUint32(n){// assumes larger values usually on last
for(let r=n.length-1;r>=0;--r)if(n[r]>=65535)return!0;// account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
return!1}const $d5b33d7c30034067$var$TYPED_ARRAYS={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function $d5b33d7c30034067$var$getTypedArray(n,r){return new $d5b33d7c30034067$var$TYPED_ARRAYS[n](r)}function $d5b33d7c30034067$var$createElementNS(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function $d5b33d7c30034067$export$1033a2df66368859(){let n=$d5b33d7c30034067$var$createElementNS("canvas");return n.style.display="block",n}const $d5b33d7c30034067$var$_cache={};function $d5b33d7c30034067$var$warnOnce(n){n in $d5b33d7c30034067$var$_cache||($d5b33d7c30034067$var$_cache[n]=!0,console.warn(n))}function $d5b33d7c30034067$var$SRGBToLinear(n){return n<.04045?.0773993808*n:Math.pow(.9478672986*n+.0521327014,2.4)}function $d5b33d7c30034067$var$LinearToSRGB(n){return n<.0031308?12.92*n:1.055*Math.pow(n,.41666)-.055}/**
 * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping
 * or clipping. Based on W3C specifications for sRGB and Display P3,
 * and ICC specifications for the D50 connection space. Values in/out
 * are _linear_ sRGB and _linear_ Display P3.
 *
 * Note that both sRGB and Display P3 use the sRGB transfer functions.
 *
 * Reference:
 * - http://www.russellcottrell.com/photo/matrixCalculator.htm
 */const $d5b33d7c30034067$var$LINEAR_SRGB_TO_LINEAR_DISPLAY_P3=/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918().fromArray([.8224621,.0331941,.0170827,.177538,.9668058,.0723974,-.0000001,1e-7,.9105199]),$d5b33d7c30034067$var$LINEAR_DISPLAY_P3_TO_LINEAR_SRGB=/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918().fromArray([1.2249401,-.0420569,-.0196376,-.2249404,1.0420571,-.0786361,1e-7,0,1.0982735]);function $d5b33d7c30034067$var$DisplayP3ToLinearSRGB(n){// Display P3 uses the sRGB transfer functions
return n.convertSRGBToLinear().applyMatrix3($d5b33d7c30034067$var$LINEAR_DISPLAY_P3_TO_LINEAR_SRGB)}function $d5b33d7c30034067$var$LinearSRGBToDisplayP3(n){// Display P3 uses the sRGB transfer functions
return n.applyMatrix3($d5b33d7c30034067$var$LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()}// Conversions from <source> to Linear-sRGB reference space.
const $d5b33d7c30034067$var$TO_LINEAR={[$d5b33d7c30034067$export$42429b3acfb233a4]:n=>n,[$d5b33d7c30034067$export$561f394b24edfcaa]:n=>n.convertSRGBToLinear(),[$d5b33d7c30034067$export$626af19ae879bdf6]:$d5b33d7c30034067$var$DisplayP3ToLinearSRGB},$d5b33d7c30034067$var$FROM_LINEAR={[$d5b33d7c30034067$export$42429b3acfb233a4]:n=>n,[$d5b33d7c30034067$export$561f394b24edfcaa]:n=>n.convertLinearToSRGB(),[$d5b33d7c30034067$export$626af19ae879bdf6]:$d5b33d7c30034067$var$LinearSRGBToDisplayP3},$d5b33d7c30034067$export$5e6fd513f44698c={enabled:!0,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(legacyMode){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!legacyMode},get workingColorSpace(){return $d5b33d7c30034067$export$42429b3acfb233a4},set workingColorSpace(colorSpace){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(n,r,i){if(!1===this.enabled||r===i||!r||!i)return n;let a=$d5b33d7c30034067$var$TO_LINEAR[r],s=$d5b33d7c30034067$var$FROM_LINEAR[i];if(void 0===a||void 0===s)throw Error(`Unsupported color space conversion, "${r}" to "${i}".`);return s(a(n))},fromWorkingColorSpace:function(n,r){return this.convert(n,this.workingColorSpace,r)},toWorkingColorSpace:function(n,r){return this.convert(n,r,this.workingColorSpace)}};class $d5b33d7c30034067$export$698882cf06df44aa{static getDataURL(n){let r;if(/^data:/i.test(n.src)||"undefined"==typeof HTMLCanvasElement)return n.src;if(n instanceof HTMLCanvasElement)r=n;else{void 0===$d5b33d7c30034067$var$_canvas&&($d5b33d7c30034067$var$_canvas=$d5b33d7c30034067$var$createElementNS("canvas")),$d5b33d7c30034067$var$_canvas.width=n.width,$d5b33d7c30034067$var$_canvas.height=n.height;let i=$d5b33d7c30034067$var$_canvas.getContext("2d");n instanceof ImageData?i.putImageData(n,0,0):i.drawImage(n,0,0,n.width,n.height),r=$d5b33d7c30034067$var$_canvas}return r.width>2048||r.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",n),r.toDataURL("image/jpeg",.6)):r.toDataURL("image/png")}static sRGBToLinear(n){if("undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap){let r=$d5b33d7c30034067$var$createElementNS("canvas");r.width=n.width,r.height=n.height;let i=r.getContext("2d");i.drawImage(n,0,0,n.width,n.height);let a=i.getImageData(0,0,n.width,n.height),s=a.data;for(let n=0;n<s.length;n++)s[n]=255*$d5b33d7c30034067$var$SRGBToLinear(s[n]/255);return i.putImageData(a,0,0),r}if(!n.data)return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),n;{let r=n.data.slice(0);for(let n=0;n<r.length;n++)r instanceof Uint8Array||r instanceof Uint8ClampedArray?r[n]=Math.floor(255*$d5b33d7c30034067$var$SRGBToLinear(r[n]/255)):r[n]=$d5b33d7c30034067$var$SRGBToLinear(r[n]);return{data:r,width:n.width,height:n.height}}}}let $d5b33d7c30034067$var$sourceId=0;class $d5b33d7c30034067$export$1d2df86270c81ecb{constructor(n=null){this.isSource=!0,Object.defineProperty(this,"id",{value:$d5b33d7c30034067$var$sourceId++}),this.uuid=$d5b33d7c30034067$var$generateUUID(),this.data=n,this.version=0}set needsUpdate(n){!0===n&&this.version++}toJSON(n){let r=void 0===n||"string"==typeof n;if(!r&&void 0!==n.images[this.uuid])return n.images[this.uuid];let i={uuid:this.uuid,url:""},a=this.data;if(null!==a){let n;if(Array.isArray(a)){// cube texture
n=[];for(let r=0,i=a.length;r<i;r++)a[r].isDataTexture?n.push($d5b33d7c30034067$var$serializeImage(a[r].image)):n.push($d5b33d7c30034067$var$serializeImage(a[r]))}else n=$d5b33d7c30034067$var$serializeImage(a);i.url=n}return r||(n.images[this.uuid]=i),i}}function $d5b33d7c30034067$var$serializeImage(n){return"undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap?$d5b33d7c30034067$export$698882cf06df44aa.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let $d5b33d7c30034067$var$_textureId=0;class $d5b33d7c30034067$export$5431306cf43de24a extends $d5b33d7c30034067$export$ec8b666c5fe2c75a{constructor(n=$d5b33d7c30034067$export$5431306cf43de24a.DEFAULT_IMAGE,r=$d5b33d7c30034067$export$5431306cf43de24a.DEFAULT_MAPPING,i=$d5b33d7c30034067$export$9d9334239a5a5e06,a=$d5b33d7c30034067$export$9d9334239a5a5e06,s=$d5b33d7c30034067$export$8a72f490b25c56c8,o=$d5b33d7c30034067$export$5d8599b6a933fb1b,l=$d5b33d7c30034067$export$3f8bb04b555a363c,u=$d5b33d7c30034067$export$2e8ce08d3f6f5e10,c=$d5b33d7c30034067$export$5431306cf43de24a.DEFAULT_ANISOTROPY,h=$d5b33d7c30034067$export$bfcb490c2dd3db51){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:$d5b33d7c30034067$var$_textureId++}),this.uuid=$d5b33d7c30034067$var$generateUUID(),this.name="",this.source=new $d5b33d7c30034067$export$1d2df86270c81ecb(n),this.mipmaps=[],this.mapping=r,this.channel=0,this.wrapS=i,this.wrapT=a,this.magFilter=s,this.minFilter=o,this.anisotropy=c,this.format=l,this.internalFormat=null,this.type=u,this.offset=new $d5b33d7c30034067$export$c977b3e384af9ae1(0,0),this.repeat=new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1),this.center=new $d5b33d7c30034067$export$c977b3e384af9ae1(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new $d5b33d7c30034067$export$8ff26dafa08918,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,"string"==typeof h?this.colorSpace=h:($d5b33d7c30034067$var$warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=h===$d5b33d7c30034067$export$f32388edbb32674?$d5b33d7c30034067$export$561f394b24edfcaa:$d5b33d7c30034067$export$bfcb490c2dd3db51),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(n=null){this.source.data=n}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(n){return this.name=n.name,this.source=n.source,this.mipmaps=n.mipmaps.slice(0),this.mapping=n.mapping,this.channel=n.channel,this.wrapS=n.wrapS,this.wrapT=n.wrapT,this.magFilter=n.magFilter,this.minFilter=n.minFilter,this.anisotropy=n.anisotropy,this.format=n.format,this.internalFormat=n.internalFormat,this.type=n.type,this.offset.copy(n.offset),this.repeat.copy(n.repeat),this.center.copy(n.center),this.rotation=n.rotation,this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrix.copy(n.matrix),this.generateMipmaps=n.generateMipmaps,this.premultiplyAlpha=n.premultiplyAlpha,this.flipY=n.flipY,this.unpackAlignment=n.unpackAlignment,this.colorSpace=n.colorSpace,this.userData=JSON.parse(JSON.stringify(n.userData)),this.needsUpdate=!0,this}toJSON(n){let r=void 0===n||"string"==typeof n;if(!r&&void 0!==n.textures[this.uuid])return n.textures[this.uuid];let i={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(n).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),r||(n.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(n){if(this.mapping!==$d5b33d7c30034067$export$1beec6768cbb3d2d)return n;if(n.applyMatrix3(this.matrix),n.x<0||n.x>1)switch(this.wrapS){case $d5b33d7c30034067$export$533346c8e8dac0f5:n.x=n.x-Math.floor(n.x);break;case $d5b33d7c30034067$export$9d9334239a5a5e06:n.x=n.x<0?0:1;break;case $d5b33d7c30034067$export$c7e7c00b14f51a4f:1===Math.abs(Math.floor(n.x)%2)?n.x=Math.ceil(n.x)-n.x:n.x=n.x-Math.floor(n.x)}if(n.y<0||n.y>1)switch(this.wrapT){case $d5b33d7c30034067$export$533346c8e8dac0f5:n.y=n.y-Math.floor(n.y);break;case $d5b33d7c30034067$export$9d9334239a5a5e06:n.y=n.y<0?0:1;break;case $d5b33d7c30034067$export$c7e7c00b14f51a4f:1===Math.abs(Math.floor(n.y)%2)?n.y=Math.ceil(n.y)-n.y:n.y=n.y-Math.floor(n.y)}return this.flipY&&(n.y=1-n.y),n}set needsUpdate(n){!0===n&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return $d5b33d7c30034067$var$warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===$d5b33d7c30034067$export$561f394b24edfcaa?$d5b33d7c30034067$export$f32388edbb32674:$d5b33d7c30034067$export$7207336e4151a112}set encoding(n){$d5b33d7c30034067$var$warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=n===$d5b33d7c30034067$export$f32388edbb32674?$d5b33d7c30034067$export$561f394b24edfcaa:$d5b33d7c30034067$export$bfcb490c2dd3db51}}$d5b33d7c30034067$export$5431306cf43de24a.DEFAULT_IMAGE=null,$d5b33d7c30034067$export$5431306cf43de24a.DEFAULT_MAPPING=$d5b33d7c30034067$export$1beec6768cbb3d2d,$d5b33d7c30034067$export$5431306cf43de24a.DEFAULT_ANISOTROPY=1;class $d5b33d7c30034067$export$fa7daccca11cdbe3{constructor(n=0,r=0,i=0,a=1){$d5b33d7c30034067$export$fa7daccca11cdbe3.prototype.isVector4=!0,this.x=n,this.y=r,this.z=i,this.w=a}get width(){return this.z}set width(n){this.z=n}get height(){return this.w}set height(n){this.w=n}set(n,r,i,a){return this.x=n,this.y=r,this.z=i,this.w=a,this}setScalar(n){return this.x=n,this.y=n,this.z=n,this.w=n,this}setX(n){return this.x=n,this}setY(n){return this.y=n,this}setZ(n){return this.z=n,this}setW(n){return this.w=n,this}setComponent(n,r){switch(n){case 0:this.x=r;break;case 1:this.y=r;break;case 2:this.z=r;break;case 3:this.w=r;break;default:throw Error("index is out of range: "+n)}return this}getComponent(n){switch(n){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+n)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(n){return this.x=n.x,this.y=n.y,this.z=n.z,this.w=void 0!==n.w?n.w:1,this}add(n){return this.x+=n.x,this.y+=n.y,this.z+=n.z,this.w+=n.w,this}addScalar(n){return this.x+=n,this.y+=n,this.z+=n,this.w+=n,this}addVectors(n,r){return this.x=n.x+r.x,this.y=n.y+r.y,this.z=n.z+r.z,this.w=n.w+r.w,this}addScaledVector(n,r){return this.x+=n.x*r,this.y+=n.y*r,this.z+=n.z*r,this.w+=n.w*r,this}sub(n){return this.x-=n.x,this.y-=n.y,this.z-=n.z,this.w-=n.w,this}subScalar(n){return this.x-=n,this.y-=n,this.z-=n,this.w-=n,this}subVectors(n,r){return this.x=n.x-r.x,this.y=n.y-r.y,this.z=n.z-r.z,this.w=n.w-r.w,this}multiply(n){return this.x*=n.x,this.y*=n.y,this.z*=n.z,this.w*=n.w,this}multiplyScalar(n){return this.x*=n,this.y*=n,this.z*=n,this.w*=n,this}applyMatrix4(n){let r=this.x,i=this.y,a=this.z,s=this.w,o=n.elements;return this.x=o[0]*r+o[4]*i+o[8]*a+o[12]*s,this.y=o[1]*r+o[5]*i+o[9]*a+o[13]*s,this.z=o[2]*r+o[6]*i+o[10]*a+o[14]*s,this.w=o[3]*r+o[7]*i+o[11]*a+o[15]*s,this}divideScalar(n){return this.multiplyScalar(1/n)}setAxisAngleFromQuaternion(n){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
// q is assumed to be normalized
this.w=2*Math.acos(n.w);let r=Math.sqrt(1-n.w*n.w);return r<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=n.x/r,this.y=n.y/r,this.z=n.z/r),this}setAxisAngleFromRotationMatrix(n){let r,i,a,s;let o=.01,l=.1,u=n.elements,c=u[0],h=u[4],d=u[8],p=u[1],f=u[5],m=u[9],g=u[2],_=u[6],y=u[10];if(Math.abs(h-p)<o&&Math.abs(d-g)<o&&Math.abs(m-_)<o){// singularity found
// first check for identity matrix which must have +1 for all terms
// in leading diagonal and zero in other terms
if(Math.abs(h+p)<l&&Math.abs(d+g)<l&&Math.abs(m+_)<l&&Math.abs(c+f+y-3)<l)return(// this singularity is identity matrix so angle = 0
this.set(1,0,0,0),this);// zero angle, arbitrary axis
// otherwise this singularity is angle = 180
r=Math.PI;let n=(c+1)/2,u=(f+1)/2,b=(y+1)/2,v=(h+p)/4,x=(d+g)/4,w=(m+_)/4;return n>u&&n>b?n<o?(i=0,a=.707106781,s=.707106781):(a=v/(i=Math.sqrt(n)),s=x/i):u>b?u<o?(i=.707106781,a=0,s=.707106781):(i=v/(a=Math.sqrt(u)),s=w/a):b<o?(i=.707106781,a=.707106781,s=0):(i=x/(s=Math.sqrt(b)),a=w/s),this.set(i,a,s,r),this;// return 180 deg rotation
}// as we have reached here there are no singularities so we can handle normally
let b=Math.sqrt((_-m)*(_-m)+(d-g)*(d-g)+(p-h)*(p-h));// used to normalize
return .001>Math.abs(b)&&(b=1),// prevent divide by zero, should not happen if matrix is orthogonal and should be
// caught by singularity test above, but I've left it in just in case
this.x=(_-m)/b,this.y=(d-g)/b,this.z=(p-h)/b,this.w=Math.acos((c+f+y-1)/2),this}min(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this.z=Math.min(this.z,n.z),this.w=Math.min(this.w,n.w),this}max(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this.z=Math.max(this.z,n.z),this.w=Math.max(this.w,n.w),this}clamp(n,r){return(// assumes min < max, componentwise
this.x=Math.max(n.x,Math.min(r.x,this.x)),this.y=Math.max(n.y,Math.min(r.y,this.y)),this.z=Math.max(n.z,Math.min(r.z,this.z)),this.w=Math.max(n.w,Math.min(r.w,this.w)),this)}clampScalar(n,r){return this.x=Math.max(n,Math.min(r,this.x)),this.y=Math.max(n,Math.min(r,this.y)),this.z=Math.max(n,Math.min(r,this.z)),this.w=Math.max(n,Math.min(r,this.w)),this}clampLength(n,r){let i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(n,Math.min(r,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(n){return this.x*n.x+this.y*n.y+this.z*n.z+this.w*n.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(n){return this.normalize().multiplyScalar(n)}lerp(n,r){return this.x+=(n.x-this.x)*r,this.y+=(n.y-this.y)*r,this.z+=(n.z-this.z)*r,this.w+=(n.w-this.w)*r,this}lerpVectors(n,r,i){return this.x=n.x+(r.x-n.x)*i,this.y=n.y+(r.y-n.y)*i,this.z=n.z+(r.z-n.z)*i,this.w=n.w+(r.w-n.w)*i,this}equals(n){return n.x===this.x&&n.y===this.y&&n.z===this.z&&n.w===this.w}fromArray(n,r=0){return this.x=n[r],this.y=n[r+1],this.z=n[r+2],this.w=n[r+3],this}toArray(n=[],r=0){return n[r]=this.x,n[r+1]=this.y,n[r+2]=this.z,n[r+3]=this.w,n}fromBufferAttribute(n,r){return this.x=n.getX(r),this.y=n.getY(r),this.z=n.getZ(r),this.w=n.getW(r),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/class $d5b33d7c30034067$export$efcb1f8bf367cbfb extends $d5b33d7c30034067$export$ec8b666c5fe2c75a{constructor(n=1,r=1,i={}){super(),this.isRenderTarget=!0,this.width=n,this.height=r,this.depth=1,this.scissor=new $d5b33d7c30034067$export$fa7daccca11cdbe3(0,0,n,r),this.scissorTest=!1,this.viewport=new $d5b33d7c30034067$export$fa7daccca11cdbe3(0,0,n,r);let a={width:n,height:r,depth:1};void 0!==i.encoding&&(// @deprecated, r152
$d5b33d7c30034067$var$warnOnce("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),i.colorSpace=i.encoding===$d5b33d7c30034067$export$f32388edbb32674?$d5b33d7c30034067$export$561f394b24edfcaa:$d5b33d7c30034067$export$bfcb490c2dd3db51),this.texture=new $d5b33d7c30034067$export$5431306cf43de24a(a,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==i.generateMipmaps&&i.generateMipmaps,this.texture.internalFormat=void 0!==i.internalFormat?i.internalFormat:null,this.texture.minFilter=void 0!==i.minFilter?i.minFilter:$d5b33d7c30034067$export$8a72f490b25c56c8,this.depthBuffer=void 0===i.depthBuffer||i.depthBuffer,this.stencilBuffer=void 0!==i.stencilBuffer&&i.stencilBuffer,this.depthTexture=void 0!==i.depthTexture?i.depthTexture:null,this.samples=void 0!==i.samples?i.samples:0}setSize(n,r,i=1){(this.width!==n||this.height!==r||this.depth!==i)&&(this.width=n,this.height=r,this.depth=i,this.texture.image.width=n,this.texture.image.height=r,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,n,r),this.scissor.set(0,0,n,r)}clone(){return new this.constructor().copy(this)}copy(n){this.width=n.width,this.height=n.height,this.depth=n.depth,this.scissor.copy(n.scissor),this.scissorTest=n.scissorTest,this.viewport.copy(n.viewport),this.texture=n.texture.clone(),this.texture.isRenderTargetTexture=!0;// ensure image object is not shared, see #20328
let r=Object.assign({},n.texture.image);return this.texture.source=new $d5b33d7c30034067$export$1d2df86270c81ecb(r),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,null!==n.depthTexture&&(this.depthTexture=n.depthTexture.clone()),this.samples=n.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class $d5b33d7c30034067$export$3c052beb2e51e23f extends $d5b33d7c30034067$export$efcb1f8bf367cbfb{constructor(n=1,r=1,i={}){super(n,r,i),this.isWebGLRenderTarget=!0}}class $d5b33d7c30034067$export$dfac6c8e811406a3 extends $d5b33d7c30034067$export$5431306cf43de24a{constructor(n=null,r=1,i=1,a=1){super(null),this.isDataArrayTexture=!0,this.image={data:n,width:r,height:i,depth:a},this.magFilter=$d5b33d7c30034067$export$727aa5ec3fe39bf0,this.minFilter=$d5b33d7c30034067$export$727aa5ec3fe39bf0,this.wrapR=$d5b33d7c30034067$export$9d9334239a5a5e06,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class $d5b33d7c30034067$export$c77a02c11ed180c7 extends $d5b33d7c30034067$export$3c052beb2e51e23f{constructor(n=1,r=1,i=1){super(n,r),this.isWebGLArrayRenderTarget=!0,this.depth=i,this.texture=new $d5b33d7c30034067$export$dfac6c8e811406a3(null,n,r,i),this.texture.isRenderTargetTexture=!0}}class $d5b33d7c30034067$export$d7a3086320f856db extends $d5b33d7c30034067$export$5431306cf43de24a{constructor(n=null,r=1,i=1,a=1){// We're going to add .setXXX() methods for setting properties later.
// Users can still set in DataTexture3D directly.
//
//	const texture = new THREE.DataTexture3D( data, width, height, depth );
// 	texture.anisotropy = 16;
//
// See #14839
super(null),this.isData3DTexture=!0,this.image={data:n,width:r,height:i,depth:a},this.magFilter=$d5b33d7c30034067$export$727aa5ec3fe39bf0,this.minFilter=$d5b33d7c30034067$export$727aa5ec3fe39bf0,this.wrapR=$d5b33d7c30034067$export$9d9334239a5a5e06,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class $d5b33d7c30034067$export$7ee06591009639df extends $d5b33d7c30034067$export$3c052beb2e51e23f{constructor(n=1,r=1,i=1){super(n,r),this.isWebGL3DRenderTarget=!0,this.depth=i,this.texture=new $d5b33d7c30034067$export$d7a3086320f856db(null,n,r,i),this.texture.isRenderTargetTexture=!0}}class $d5b33d7c30034067$export$bd934554fb721730 extends $d5b33d7c30034067$export$3c052beb2e51e23f{constructor(n=1,r=1,i=1,a={}){super(n,r,a),this.isWebGLMultipleRenderTargets=!0;let s=this.texture;this.texture=[];for(let n=0;n<i;n++)this.texture[n]=s.clone(),this.texture[n].isRenderTargetTexture=!0}setSize(n,r,i=1){if(this.width!==n||this.height!==r||this.depth!==i){this.width=n,this.height=r,this.depth=i;for(let a=0,s=this.texture.length;a<s;a++)this.texture[a].image.width=n,this.texture[a].image.height=r,this.texture[a].image.depth=i;this.dispose()}this.viewport.set(0,0,n,r),this.scissor.set(0,0,n,r)}copy(n){this.dispose(),this.width=n.width,this.height=n.height,this.depth=n.depth,this.scissor.copy(n.scissor),this.scissorTest=n.scissorTest,this.viewport.copy(n.viewport),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,null!==n.depthTexture&&(this.depthTexture=n.depthTexture.clone()),this.texture.length=0;for(let r=0,i=n.texture.length;r<i;r++)this.texture[r]=n.texture[r].clone(),this.texture[r].isRenderTargetTexture=!0;return this}}class $d5b33d7c30034067$export$23d6a54f0bbc85a3{constructor(n=0,r=0,i=0,a=1){this.isQuaternion=!0,this._x=n,this._y=r,this._z=i,this._w=a}static slerpFlat(n,r,i,a,s,o,l){// fuzz-free, array-based Quaternion SLERP operation
let u=i[a+0],c=i[a+1],h=i[a+2],d=i[a+3],p=s[o+0],f=s[o+1],m=s[o+2],g=s[o+3];if(0===l){n[r+0]=u,n[r+1]=c,n[r+2]=h,n[r+3]=d;return}if(1===l){n[r+0]=p,n[r+1]=f,n[r+2]=m,n[r+3]=g;return}if(d!==g||u!==p||c!==f||h!==m){let n=1-l,r=u*p+c*f+h*m+d*g,i=r>=0?1:-1,a=1-r*r;// Skip the Slerp for tiny steps to avoid numeric problems:
if(a>Number.EPSILON){let s=Math.sqrt(a),o=Math.atan2(s,r*i);n=Math.sin(n*o)/s,l=Math.sin(l*o)/s}let s=l*i;// Normalize in case we just did a lerp:
if(u=u*n+p*s,c=c*n+f*s,h=h*n+m*s,d=d*n+g*s,n===1-l){let n=1/Math.sqrt(u*u+c*c+h*h+d*d);u*=n,c*=n,h*=n,d*=n}}n[r]=u,n[r+1]=c,n[r+2]=h,n[r+3]=d}static multiplyQuaternionsFlat(n,r,i,a,s,o){let l=i[a],u=i[a+1],c=i[a+2],h=i[a+3],d=s[o],p=s[o+1],f=s[o+2],m=s[o+3];return n[r]=l*m+h*d+u*f-c*p,n[r+1]=u*m+h*p+c*d-l*f,n[r+2]=c*m+h*f+l*p-u*d,n[r+3]=h*m-l*d-u*p-c*f,n}get x(){return this._x}set x(n){this._x=n,this._onChangeCallback()}get y(){return this._y}set y(n){this._y=n,this._onChangeCallback()}get z(){return this._z}set z(n){this._z=n,this._onChangeCallback()}get w(){return this._w}set w(n){this._w=n,this._onChangeCallback()}set(n,r,i,a){return this._x=n,this._y=r,this._z=i,this._w=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(n){return this._x=n.x,this._y=n.y,this._z=n.z,this._w=n.w,this._onChangeCallback(),this}setFromEuler(n,r){let i=n._x,a=n._y,s=n._z,o=n._order,l=Math.cos,u=Math.sin,c=l(i/2),h=l(a/2),d=l(s/2),p=u(i/2),f=u(a/2),m=u(s/2);switch(o){case"XYZ":this._x=p*h*d+c*f*m,this._y=c*f*d-p*h*m,this._z=c*h*m+p*f*d,this._w=c*h*d-p*f*m;break;case"YXZ":this._x=p*h*d+c*f*m,this._y=c*f*d-p*h*m,this._z=c*h*m-p*f*d,this._w=c*h*d+p*f*m;break;case"ZXY":this._x=p*h*d-c*f*m,this._y=c*f*d+p*h*m,this._z=c*h*m+p*f*d,this._w=c*h*d-p*f*m;break;case"ZYX":this._x=p*h*d-c*f*m,this._y=c*f*d+p*h*m,this._z=c*h*m-p*f*d,this._w=c*h*d+p*f*m;break;case"YZX":this._x=p*h*d+c*f*m,this._y=c*f*d+p*h*m,this._z=c*h*m-p*f*d,this._w=c*h*d-p*f*m;break;case"XZY":this._x=p*h*d-c*f*m,this._y=c*f*d-p*h*m,this._z=c*h*m+p*f*d,this._w=c*h*d+p*f*m;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return!1!==r&&this._onChangeCallback(),this}setFromAxisAngle(n,r){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
// assumes axis is normalized
let i=r/2,a=Math.sin(i);return this._x=n.x*a,this._y=n.y*a,this._z=n.z*a,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(n){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
let r=n.elements,i=r[0],a=r[4],s=r[8],o=r[1],l=r[5],u=r[9],c=r[2],h=r[6],d=r[10],p=i+l+d;if(p>0){let n=.5/Math.sqrt(p+1);this._w=.25/n,this._x=(h-u)*n,this._y=(s-c)*n,this._z=(o-a)*n}else if(i>l&&i>d){let n=2*Math.sqrt(1+i-l-d);this._w=(h-u)/n,this._x=.25*n,this._y=(a+o)/n,this._z=(s+c)/n}else if(l>d){let n=2*Math.sqrt(1+l-i-d);this._w=(s-c)/n,this._x=(a+o)/n,this._y=.25*n,this._z=(u+h)/n}else{let n=2*Math.sqrt(1+d-i-l);this._w=(o-a)/n,this._x=(s+c)/n,this._y=(u+h)/n,this._z=.25*n}return this._onChangeCallback(),this}setFromUnitVectors(n,r){// assumes direction vectors vFrom and vTo are normalized
let i=n.dot(r)+1;return i<Number.EPSILON?(// vFrom and vTo point in opposite directions
i=0,Math.abs(n.x)>Math.abs(n.z)?(this._x=-n.y,this._y=n.x,this._z=0):(this._x=0,this._y=-n.z,this._z=n.y)):(// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
this._x=n.y*r.z-n.z*r.y,this._y=n.z*r.x-n.x*r.z,this._z=n.x*r.y-n.y*r.x),this._w=i,this.normalize()}angleTo(n){return 2*Math.acos(Math.abs($d5b33d7c30034067$var$clamp(this.dot(n),-1,1)))}rotateTowards(n,r){let i=this.angleTo(n);if(0===i)return this;let a=Math.min(1,r/i);return this.slerp(n,a),this}identity(){return this.set(0,0,0,1)}invert(){// quaternion is assumed to have unit length
return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(n){return this._x*n._x+this._y*n._y+this._z*n._z+this._w*n._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let n=this.length();return 0===n?(this._x=0,this._y=0,this._z=0,this._w=1):(n=1/n,this._x=this._x*n,this._y=this._y*n,this._z=this._z*n,this._w=this._w*n),this._onChangeCallback(),this}multiply(n){return this.multiplyQuaternions(this,n)}premultiply(n){return this.multiplyQuaternions(n,this)}multiplyQuaternions(n,r){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
let i=n._x,a=n._y,s=n._z,o=n._w,l=r._x,u=r._y,c=r._z,h=r._w;return this._x=i*h+o*l+a*c-s*u,this._y=a*h+o*u+s*l-i*c,this._z=s*h+o*c+i*u-a*l,this._w=o*h-i*l-a*u-s*c,this._onChangeCallback(),this}slerp(n,r){if(0===r)return this;if(1===r)return this.copy(n);let i=this._x,a=this._y,s=this._z,o=this._w,l=o*n._w+i*n._x+a*n._y+s*n._z;if(l<0?(this._w=-n._w,this._x=-n._x,this._y=-n._y,this._z=-n._z,l=-l):this.copy(n),l>=1)return this._w=o,this._x=i,this._y=a,this._z=s,this;let u=1-l*l;if(u<=Number.EPSILON){let n=1-r;return this._w=n*o+r*this._w,this._x=n*i+r*this._x,this._y=n*a+r*this._y,this._z=n*s+r*this._z,this.normalize(),this._onChangeCallback(),this}let c=Math.sqrt(u),h=Math.atan2(c,l),d=Math.sin((1-r)*h)/c,p=Math.sin(r*h)/c;return this._w=o*d+this._w*p,this._x=i*d+this._x*p,this._y=a*d+this._y*p,this._z=s*d+this._z*p,this._onChangeCallback(),this}slerpQuaternions(n,r,i){return this.copy(n).slerp(r,i)}random(){// Derived from http://planning.cs.uiuc.edu/node198.html
// Note, this source uses w, x, y, z ordering,
// so we swap the order below.
let n=Math.random(),r=Math.sqrt(1-n),i=Math.sqrt(n),a=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(r*Math.cos(a),i*Math.sin(s),i*Math.cos(s),r*Math.sin(a))}equals(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._w===this._w}fromArray(n,r=0){return this._x=n[r],this._y=n[r+1],this._z=n[r+2],this._w=n[r+3],this._onChangeCallback(),this}toArray(n=[],r=0){return n[r]=this._x,n[r+1]=this._y,n[r+2]=this._z,n[r+3]=this._w,n}fromBufferAttribute(n,r){return this._x=n.getX(r),this._y=n.getY(r),this._z=n.getZ(r),this._w=n.getW(r),this}toJSON(){return this.toArray()}_onChange(n){return this._onChangeCallback=n,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class $d5b33d7c30034067$export$64b5c384219d3699{constructor(n=0,r=0,i=0){$d5b33d7c30034067$export$64b5c384219d3699.prototype.isVector3=!0,this.x=n,this.y=r,this.z=i}set(n,r,i){return void 0===i&&(i=this.z),this.x=n,this.y=r,this.z=i,this}setScalar(n){return this.x=n,this.y=n,this.z=n,this}setX(n){return this.x=n,this}setY(n){return this.y=n,this}setZ(n){return this.z=n,this}setComponent(n,r){switch(n){case 0:this.x=r;break;case 1:this.y=r;break;case 2:this.z=r;break;default:throw Error("index is out of range: "+n)}return this}getComponent(n){switch(n){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+n)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(n){return this.x=n.x,this.y=n.y,this.z=n.z,this}add(n){return this.x+=n.x,this.y+=n.y,this.z+=n.z,this}addScalar(n){return this.x+=n,this.y+=n,this.z+=n,this}addVectors(n,r){return this.x=n.x+r.x,this.y=n.y+r.y,this.z=n.z+r.z,this}addScaledVector(n,r){return this.x+=n.x*r,this.y+=n.y*r,this.z+=n.z*r,this}sub(n){return this.x-=n.x,this.y-=n.y,this.z-=n.z,this}subScalar(n){return this.x-=n,this.y-=n,this.z-=n,this}subVectors(n,r){return this.x=n.x-r.x,this.y=n.y-r.y,this.z=n.z-r.z,this}multiply(n){return this.x*=n.x,this.y*=n.y,this.z*=n.z,this}multiplyScalar(n){return this.x*=n,this.y*=n,this.z*=n,this}multiplyVectors(n,r){return this.x=n.x*r.x,this.y=n.y*r.y,this.z=n.z*r.z,this}applyEuler(n){return this.applyQuaternion($d5b33d7c30034067$var$_quaternion$4.setFromEuler(n))}applyAxisAngle(n,r){return this.applyQuaternion($d5b33d7c30034067$var$_quaternion$4.setFromAxisAngle(n,r))}applyMatrix3(n){let r=this.x,i=this.y,a=this.z,s=n.elements;return this.x=s[0]*r+s[3]*i+s[6]*a,this.y=s[1]*r+s[4]*i+s[7]*a,this.z=s[2]*r+s[5]*i+s[8]*a,this}applyNormalMatrix(n){return this.applyMatrix3(n).normalize()}applyMatrix4(n){let r=this.x,i=this.y,a=this.z,s=n.elements,o=1/(s[3]*r+s[7]*i+s[11]*a+s[15]);return this.x=(s[0]*r+s[4]*i+s[8]*a+s[12])*o,this.y=(s[1]*r+s[5]*i+s[9]*a+s[13])*o,this.z=(s[2]*r+s[6]*i+s[10]*a+s[14])*o,this}applyQuaternion(n){let r=this.x,i=this.y,a=this.z,s=n.x,o=n.y,l=n.z,u=n.w,c=u*r+o*a-l*i,h=u*i+l*r-s*a,d=u*a+s*i-o*r,p=-s*r-o*i-l*a;return(// calculate result * inverse quat
this.x=c*u+-(p*s)+-(h*l)- -(d*o),this.y=h*u+-(p*o)+-(d*s)- -(c*l),this.z=d*u+-(p*l)+-(c*o)- -(h*s),this)}project(n){return this.applyMatrix4(n.matrixWorldInverse).applyMatrix4(n.projectionMatrix)}unproject(n){return this.applyMatrix4(n.projectionMatrixInverse).applyMatrix4(n.matrixWorld)}transformDirection(n){// input: THREE.Matrix4 affine matrix
// vector interpreted as a direction
let r=this.x,i=this.y,a=this.z,s=n.elements;return this.x=s[0]*r+s[4]*i+s[8]*a,this.y=s[1]*r+s[5]*i+s[9]*a,this.z=s[2]*r+s[6]*i+s[10]*a,this.normalize()}divide(n){return this.x/=n.x,this.y/=n.y,this.z/=n.z,this}divideScalar(n){return this.multiplyScalar(1/n)}min(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this.z=Math.min(this.z,n.z),this}max(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this.z=Math.max(this.z,n.z),this}clamp(n,r){return(// assumes min < max, componentwise
this.x=Math.max(n.x,Math.min(r.x,this.x)),this.y=Math.max(n.y,Math.min(r.y,this.y)),this.z=Math.max(n.z,Math.min(r.z,this.z)),this)}clampScalar(n,r){return this.x=Math.max(n,Math.min(r,this.x)),this.y=Math.max(n,Math.min(r,this.y)),this.z=Math.max(n,Math.min(r,this.z)),this}clampLength(n,r){let i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(n,Math.min(r,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(n){return this.x*n.x+this.y*n.y+this.z*n.z}// TODO lengthSquared?
lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(n){return this.normalize().multiplyScalar(n)}lerp(n,r){return this.x+=(n.x-this.x)*r,this.y+=(n.y-this.y)*r,this.z+=(n.z-this.z)*r,this}lerpVectors(n,r,i){return this.x=n.x+(r.x-n.x)*i,this.y=n.y+(r.y-n.y)*i,this.z=n.z+(r.z-n.z)*i,this}cross(n){return this.crossVectors(this,n)}crossVectors(n,r){let i=n.x,a=n.y,s=n.z,o=r.x,l=r.y,u=r.z;return this.x=a*u-s*l,this.y=s*o-i*u,this.z=i*l-a*o,this}projectOnVector(n){let r=n.lengthSq();if(0===r)return this.set(0,0,0);let i=n.dot(this)/r;return this.copy(n).multiplyScalar(i)}projectOnPlane(n){return $d5b33d7c30034067$var$_vector$b.copy(this).projectOnVector(n),this.sub($d5b33d7c30034067$var$_vector$b)}reflect(n){// reflect incident vector off plane orthogonal to normal
// normal is assumed to have unit length
return this.sub($d5b33d7c30034067$var$_vector$b.copy(n).multiplyScalar(2*this.dot(n)))}angleTo(n){let r=Math.sqrt(this.lengthSq()*n.lengthSq());if(0===r)return Math.PI/2;let i=this.dot(n)/r;// clamp, to handle numerical problems
return Math.acos($d5b33d7c30034067$var$clamp(i,-1,1))}distanceTo(n){return Math.sqrt(this.distanceToSquared(n))}distanceToSquared(n){let r=this.x-n.x,i=this.y-n.y,a=this.z-n.z;return r*r+i*i+a*a}manhattanDistanceTo(n){return Math.abs(this.x-n.x)+Math.abs(this.y-n.y)+Math.abs(this.z-n.z)}setFromSpherical(n){return this.setFromSphericalCoords(n.radius,n.phi,n.theta)}setFromSphericalCoords(n,r,i){let a=Math.sin(r)*n;return this.x=a*Math.sin(i),this.y=Math.cos(r)*n,this.z=a*Math.cos(i),this}setFromCylindrical(n){return this.setFromCylindricalCoords(n.radius,n.theta,n.y)}setFromCylindricalCoords(n,r,i){return this.x=n*Math.sin(r),this.y=i,this.z=n*Math.cos(r),this}setFromMatrixPosition(n){let r=n.elements;return this.x=r[12],this.y=r[13],this.z=r[14],this}setFromMatrixScale(n){let r=this.setFromMatrixColumn(n,0).length(),i=this.setFromMatrixColumn(n,1).length(),a=this.setFromMatrixColumn(n,2).length();return this.x=r,this.y=i,this.z=a,this}setFromMatrixColumn(n,r){return this.fromArray(n.elements,4*r)}setFromMatrix3Column(n,r){return this.fromArray(n.elements,3*r)}setFromEuler(n){return this.x=n._x,this.y=n._y,this.z=n._z,this}setFromColor(n){return this.x=n.r,this.y=n.g,this.z=n.b,this}equals(n){return n.x===this.x&&n.y===this.y&&n.z===this.z}fromArray(n,r=0){return this.x=n[r],this.y=n[r+1],this.z=n[r+2],this}toArray(n=[],r=0){return n[r]=this.x,n[r+1]=this.y,n[r+2]=this.z,n}fromBufferAttribute(n,r){return this.x=n.getX(r),this.y=n.getY(r),this.z=n.getZ(r),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){// Derived from https://mathworld.wolfram.com/SpherePointPicking.html
let n=(Math.random()-.5)*2,r=Math.random()*Math.PI*2,i=Math.sqrt(1-n**2);return this.x=i*Math.cos(r),this.y=i*Math.sin(r),this.z=n,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const $d5b33d7c30034067$var$_vector$b=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_quaternion$4=/*@__PURE__*/new $d5b33d7c30034067$export$23d6a54f0bbc85a3;class $d5b33d7c30034067$export$6f7d5a9418ab2aa3{constructor(n=new $d5b33d7c30034067$export$64b5c384219d3699(1/0,1/0,1/0),r=new $d5b33d7c30034067$export$64b5c384219d3699(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=n,this.max=r}set(n,r){return this.min.copy(n),this.max.copy(r),this}setFromArray(n){this.makeEmpty();for(let r=0,i=n.length;r<i;r+=3)this.expandByPoint($d5b33d7c30034067$var$_vector$a.fromArray(n,r));return this}setFromBufferAttribute(n){this.makeEmpty();for(let r=0,i=n.count;r<i;r++)this.expandByPoint($d5b33d7c30034067$var$_vector$a.fromBufferAttribute(n,r));return this}setFromPoints(n){this.makeEmpty();for(let r=0,i=n.length;r<i;r++)this.expandByPoint(n[r]);return this}setFromCenterAndSize(n,r){let i=$d5b33d7c30034067$var$_vector$a.copy(r).multiplyScalar(.5);return this.min.copy(n).sub(i),this.max.copy(n).add(i),this}setFromObject(n,r=!1){return this.makeEmpty(),this.expandByObject(n,r)}clone(){return new this.constructor().copy(this)}copy(n){return this.min.copy(n.min),this.max.copy(n.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(n){return this.isEmpty()?n.set(0,0,0):n.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(n){return this.isEmpty()?n.set(0,0,0):n.subVectors(this.max,this.min)}expandByPoint(n){return this.min.min(n),this.max.max(n),this}expandByVector(n){return this.min.sub(n),this.max.add(n),this}expandByScalar(n){return this.min.addScalar(-n),this.max.addScalar(n),this}expandByObject(n,r=!1){if(// Computes the world-axis-aligned bounding box of an object (including its children),
// accounting for both the object's, and children's, world transforms
n.updateWorldMatrix(!1,!1),void 0!==n.boundingBox)null===n.boundingBox&&n.computeBoundingBox(),$d5b33d7c30034067$var$_box$3.copy(n.boundingBox),$d5b33d7c30034067$var$_box$3.applyMatrix4(n.matrixWorld),this.union($d5b33d7c30034067$var$_box$3);else{let i=n.geometry;if(void 0!==i){if(r&&void 0!==i.attributes&&void 0!==i.attributes.position){let r=i.attributes.position;for(let i=0,a=r.count;i<a;i++)$d5b33d7c30034067$var$_vector$a.fromBufferAttribute(r,i).applyMatrix4(n.matrixWorld),this.expandByPoint($d5b33d7c30034067$var$_vector$a)}else null===i.boundingBox&&i.computeBoundingBox(),$d5b33d7c30034067$var$_box$3.copy(i.boundingBox),$d5b33d7c30034067$var$_box$3.applyMatrix4(n.matrixWorld),this.union($d5b33d7c30034067$var$_box$3)}}let i=n.children;for(let n=0,a=i.length;n<a;n++)this.expandByObject(i[n],r);return this}containsPoint(n){return!(n.x<this.min.x)&&!(n.x>this.max.x)&&!(n.y<this.min.y)&&!(n.y>this.max.y)&&!(n.z<this.min.z)&&!(n.z>this.max.z)}containsBox(n){return this.min.x<=n.min.x&&n.max.x<=this.max.x&&this.min.y<=n.min.y&&n.max.y<=this.max.y&&this.min.z<=n.min.z&&n.max.z<=this.max.z}getParameter(n,r){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
return r.set((n.x-this.min.x)/(this.max.x-this.min.x),(n.y-this.min.y)/(this.max.y-this.min.y),(n.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(n){// using 6 splitting planes to rule out intersections.
return!(n.max.x<this.min.x)&&!(n.min.x>this.max.x)&&!(n.max.y<this.min.y)&&!(n.min.y>this.max.y)&&!(n.max.z<this.min.z)&&!(n.min.z>this.max.z)}intersectsSphere(n){// If that point is inside the sphere, the AABB and sphere intersect.
return(// Find the point on the AABB closest to the sphere center.
this.clampPoint(n.center,$d5b33d7c30034067$var$_vector$a),$d5b33d7c30034067$var$_vector$a.distanceToSquared(n.center)<=n.radius*n.radius)}intersectsPlane(n){// We compute the minimum and maximum dot product values. If those values
// are on the same side (back or front) of the plane, then there is no intersection.
let r,i;return n.normal.x>0?(r=n.normal.x*this.min.x,i=n.normal.x*this.max.x):(r=n.normal.x*this.max.x,i=n.normal.x*this.min.x),n.normal.y>0?(r+=n.normal.y*this.min.y,i+=n.normal.y*this.max.y):(r+=n.normal.y*this.max.y,i+=n.normal.y*this.min.y),n.normal.z>0?(r+=n.normal.z*this.min.z,i+=n.normal.z*this.max.z):(r+=n.normal.z*this.max.z,i+=n.normal.z*this.min.z),r<=-n.constant&&i>=-n.constant}intersectsTriangle(n){if(this.isEmpty())return!1;// compute box center and extents
this.getCenter($d5b33d7c30034067$var$_center),$d5b33d7c30034067$var$_extents.subVectors(this.max,$d5b33d7c30034067$var$_center),// translate triangle to aabb origin
$d5b33d7c30034067$var$_v0$2.subVectors(n.a,$d5b33d7c30034067$var$_center),$d5b33d7c30034067$var$_v1$7.subVectors(n.b,$d5b33d7c30034067$var$_center),$d5b33d7c30034067$var$_v2$4.subVectors(n.c,$d5b33d7c30034067$var$_center),// compute edge vectors for triangle
$d5b33d7c30034067$var$_f0.subVectors($d5b33d7c30034067$var$_v1$7,$d5b33d7c30034067$var$_v0$2),$d5b33d7c30034067$var$_f1.subVectors($d5b33d7c30034067$var$_v2$4,$d5b33d7c30034067$var$_v1$7),$d5b33d7c30034067$var$_f2.subVectors($d5b33d7c30034067$var$_v0$2,$d5b33d7c30034067$var$_v2$4);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
let r=[0,-$d5b33d7c30034067$var$_f0.z,$d5b33d7c30034067$var$_f0.y,0,-$d5b33d7c30034067$var$_f1.z,$d5b33d7c30034067$var$_f1.y,0,-$d5b33d7c30034067$var$_f2.z,$d5b33d7c30034067$var$_f2.y,$d5b33d7c30034067$var$_f0.z,0,-$d5b33d7c30034067$var$_f0.x,$d5b33d7c30034067$var$_f1.z,0,-$d5b33d7c30034067$var$_f1.x,$d5b33d7c30034067$var$_f2.z,0,-$d5b33d7c30034067$var$_f2.x,-$d5b33d7c30034067$var$_f0.y,$d5b33d7c30034067$var$_f0.x,0,-$d5b33d7c30034067$var$_f1.y,$d5b33d7c30034067$var$_f1.x,0,-$d5b33d7c30034067$var$_f2.y,$d5b33d7c30034067$var$_f2.x,0];return!!($d5b33d7c30034067$var$satForAxes(r,$d5b33d7c30034067$var$_v0$2,$d5b33d7c30034067$var$_v1$7,$d5b33d7c30034067$var$_v2$4,$d5b33d7c30034067$var$_extents)&&$d5b33d7c30034067$var$satForAxes(// test 3 face normals from the aabb
r=[1,0,0,0,1,0,0,0,1],$d5b33d7c30034067$var$_v0$2,$d5b33d7c30034067$var$_v1$7,$d5b33d7c30034067$var$_v2$4,$d5b33d7c30034067$var$_extents))&&(// finally testing the face normal of the triangle
// use already existing triangle edge vectors here
$d5b33d7c30034067$var$_triangleNormal.crossVectors($d5b33d7c30034067$var$_f0,$d5b33d7c30034067$var$_f1),$d5b33d7c30034067$var$satForAxes(r=[$d5b33d7c30034067$var$_triangleNormal.x,$d5b33d7c30034067$var$_triangleNormal.y,$d5b33d7c30034067$var$_triangleNormal.z],$d5b33d7c30034067$var$_v0$2,$d5b33d7c30034067$var$_v1$7,$d5b33d7c30034067$var$_v2$4,$d5b33d7c30034067$var$_extents))}clampPoint(n,r){return r.copy(n).clamp(this.min,this.max)}distanceToPoint(n){return this.clampPoint(n,$d5b33d7c30034067$var$_vector$a).distanceTo(n)}getBoundingSphere(n){return this.isEmpty()?n.makeEmpty():(this.getCenter(n.center),n.radius=.5*this.getSize($d5b33d7c30034067$var$_vector$a).length()),n}intersect(n){return this.min.max(n.min),this.max.min(n.max),this.isEmpty()&&this.makeEmpty(),this}union(n){return this.min.min(n.min),this.max.max(n.max),this}applyMatrix4(n){return this.isEmpty()||(// NOTE: I am using a binary pattern to specify all 2^3 combinations below
$d5b33d7c30034067$var$_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(n),$d5b33d7c30034067$var$_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(n),$d5b33d7c30034067$var$_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(n),$d5b33d7c30034067$var$_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(n),$d5b33d7c30034067$var$_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(n),$d5b33d7c30034067$var$_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(n),$d5b33d7c30034067$var$_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(n),$d5b33d7c30034067$var$_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(n),this.setFromPoints($d5b33d7c30034067$var$_points)),this}translate(n){return this.min.add(n),this.max.add(n),this}equals(n){return n.min.equals(this.min)&&n.max.equals(this.max)}}const $d5b33d7c30034067$var$_points=[/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699],$d5b33d7c30034067$var$_vector$a=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_box$3=/*@__PURE__*/new $d5b33d7c30034067$export$6f7d5a9418ab2aa3,$d5b33d7c30034067$var$_v0$2=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_v1$7=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_v2$4=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_f0=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_f1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_f2=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_center=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_extents=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_triangleNormal=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_testAxis=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;function $d5b33d7c30034067$var$satForAxes(n,r,i,a,s){for(let o=0,l=n.length-3;o<=l;o+=3){$d5b33d7c30034067$var$_testAxis.fromArray(n,o);// project the aabb onto the separating axis
let l=s.x*Math.abs($d5b33d7c30034067$var$_testAxis.x)+s.y*Math.abs($d5b33d7c30034067$var$_testAxis.y)+s.z*Math.abs($d5b33d7c30034067$var$_testAxis.z),u=r.dot($d5b33d7c30034067$var$_testAxis),c=i.dot($d5b33d7c30034067$var$_testAxis),h=a.dot($d5b33d7c30034067$var$_testAxis);// actual test, basically see if either of the most extreme of the triangle points intersects r
if(Math.max(-Math.max(u,c,h),Math.min(u,c,h))>l)// the axis is separating and we can exit
return!1}return!0}const $d5b33d7c30034067$var$_box$2=/*@__PURE__*/new $d5b33d7c30034067$export$6f7d5a9418ab2aa3,$d5b33d7c30034067$var$_v1$6=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_v2$3=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$805e8b72413ccaba{constructor(n=new $d5b33d7c30034067$export$64b5c384219d3699,r=-1){this.center=n,this.radius=r}set(n,r){return this.center.copy(n),this.radius=r,this}setFromPoints(n,r){let i=this.center;void 0!==r?i.copy(r):$d5b33d7c30034067$var$_box$2.setFromPoints(n).getCenter(i);let a=0;for(let r=0,s=n.length;r<s;r++)a=Math.max(a,i.distanceToSquared(n[r]));return this.radius=Math.sqrt(a),this}copy(n){return this.center.copy(n.center),this.radius=n.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(n){return n.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(n){return n.distanceTo(this.center)-this.radius}intersectsSphere(n){let r=this.radius+n.radius;return n.center.distanceToSquared(this.center)<=r*r}intersectsBox(n){return n.intersectsSphere(this)}intersectsPlane(n){return Math.abs(n.distanceToPoint(this.center))<=this.radius}clampPoint(n,r){let i=this.center.distanceToSquared(n);return r.copy(n),i>this.radius*this.radius&&(r.sub(this.center).normalize(),r.multiplyScalar(this.radius).add(this.center)),r}getBoundingBox(n){return this.isEmpty()?// Empty sphere produces empty bounding box
n.makeEmpty():(n.set(this.center,this.center),n.expandByScalar(this.radius)),n}applyMatrix4(n){return this.center.applyMatrix4(n),this.radius=this.radius*n.getMaxScaleOnAxis(),this}translate(n){return this.center.add(n),this}expandByPoint(n){if(this.isEmpty())return this.center.copy(n),this.radius=0,this;$d5b33d7c30034067$var$_v1$6.subVectors(n,this.center);let r=$d5b33d7c30034067$var$_v1$6.lengthSq();if(r>this.radius*this.radius){// calculate the minimal sphere
let n=Math.sqrt(r),i=(n-this.radius)*.5;this.center.addScaledVector($d5b33d7c30034067$var$_v1$6,i/n),this.radius+=i}return this}union(n){return n.isEmpty()||(this.isEmpty()?this.copy(n):!0===this.center.equals(n.center)?this.radius=Math.max(this.radius,n.radius):($d5b33d7c30034067$var$_v2$3.subVectors(n.center,this.center).setLength(n.radius),this.expandByPoint($d5b33d7c30034067$var$_v1$6.copy(n.center).add($d5b33d7c30034067$var$_v2$3)),this.expandByPoint($d5b33d7c30034067$var$_v1$6.copy(n.center).sub($d5b33d7c30034067$var$_v2$3)))),this}equals(n){return n.center.equals(this.center)&&n.radius===this.radius}clone(){return new this.constructor().copy(this)}}const $d5b33d7c30034067$var$_vector$9=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_segCenter=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_segDir=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_diff=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_edge1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_edge2=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_normal$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$a186db52eed6d40e{constructor(n=new $d5b33d7c30034067$export$64b5c384219d3699,r=new $d5b33d7c30034067$export$64b5c384219d3699(0,0,-1)){this.origin=n,this.direction=r}set(n,r){return this.origin.copy(n),this.direction.copy(r),this}copy(n){return this.origin.copy(n.origin),this.direction.copy(n.direction),this}at(n,r){return r.copy(this.origin).addScaledVector(this.direction,n)}lookAt(n){return this.direction.copy(n).sub(this.origin).normalize(),this}recast(n){return this.origin.copy(this.at(n,$d5b33d7c30034067$var$_vector$9)),this}closestPointToPoint(n,r){r.subVectors(n,this.origin);let i=r.dot(this.direction);return i<0?r.copy(this.origin):r.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(n){return Math.sqrt(this.distanceSqToPoint(n))}distanceSqToPoint(n){let r=$d5b33d7c30034067$var$_vector$9.subVectors(n,this.origin).dot(this.direction);return(// point behind the ray
r<0?this.origin.distanceToSquared(n):($d5b33d7c30034067$var$_vector$9.copy(this.origin).addScaledVector(this.direction,r),$d5b33d7c30034067$var$_vector$9.distanceToSquared(n)))}distanceSqToSegment(n,r,i,a){let s,o,l,u;// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
// It returns the min distance between the ray and the segment
// defined by v0 and v1
// It can also set two optional targets :
// - The closest point on the ray
// - The closest point on the segment
$d5b33d7c30034067$var$_segCenter.copy(n).add(r).multiplyScalar(.5),$d5b33d7c30034067$var$_segDir.copy(r).sub(n).normalize(),$d5b33d7c30034067$var$_diff.copy(this.origin).sub($d5b33d7c30034067$var$_segCenter);let c=.5*n.distanceTo(r),h=-this.direction.dot($d5b33d7c30034067$var$_segDir),d=$d5b33d7c30034067$var$_diff.dot(this.direction),p=-$d5b33d7c30034067$var$_diff.dot($d5b33d7c30034067$var$_segDir),f=$d5b33d7c30034067$var$_diff.lengthSq(),m=Math.abs(1-h*h);if(m>0){if(// The ray and segment are not parallel.
s=h*p-d,o=h*d-p,u=c*m,s>=0){if(o>=-u){if(o<=u){// region 0
// Minimum at interior points of ray and segment.
let n=1/m;s*=n,o*=n,l=s*(s+h*o+2*d)+o*(h*s+o+2*p)+f}else l=-(s=Math.max(0,-(h*// region 1
(o=c)+d)))*s+o*(o+2*p)+f}else l=-(s=Math.max(0,-(h*// region 5
(o=-c)+d)))*s+o*(o+2*p)+f}else o<=-u?(o=// region 4
(s=Math.max(0,-(-h*c+d)))>0?-c:Math.min(Math.max(-c,-p),c),l=-s*s+o*(o+2*p)+f):o<=u?(// region 3
s=0,l=(o=Math.min(Math.max(-c,-p),c))*(o+2*p)+f):(o=// region 2
(s=Math.max(0,-(h*c+d)))>0?c:Math.min(Math.max(-c,-p),c),l=-s*s+o*(o+2*p)+f)}else // Ray and segment are parallel.
o=h>0?-c:c,l=-(s=Math.max(0,-(h*o+d)))*s+o*(o+2*p)+f;return i&&i.copy(this.origin).addScaledVector(this.direction,s),a&&a.copy($d5b33d7c30034067$var$_segCenter).addScaledVector($d5b33d7c30034067$var$_segDir,o),l}intersectSphere(n,r){$d5b33d7c30034067$var$_vector$9.subVectors(n.center,this.origin);let i=$d5b33d7c30034067$var$_vector$9.dot(this.direction),a=$d5b33d7c30034067$var$_vector$9.dot($d5b33d7c30034067$var$_vector$9)-i*i,s=n.radius*n.radius;if(a>s)return null;let o=Math.sqrt(s-a),l=i-o,u=i+o;return(// test to see if t1 is behind the ray - if so, return null
u<0?null:l<0?this.at(u,r):this.at(l,r))}intersectsSphere(n){return this.distanceSqToPoint(n.center)<=n.radius*n.radius}distanceToPlane(n){let r=n.normal.dot(this.direction);if(0===r)return(// line is coplanar, return origin
0===n.distanceToPoint(this.origin)?0:null);let i=-(this.origin.dot(n.normal)+n.constant)/r;// Return if the ray never intersects the plane
return i>=0?i:null}intersectPlane(n,r){let i=this.distanceToPlane(n);return null===i?null:this.at(i,r)}intersectsPlane(n){// check if the ray lies on the plane first
let r=n.distanceToPoint(this.origin);if(0===r)return!0;let i=n.normal.dot(this.direction);return i*r<0}intersectBox(n,r){let i,a,s,o,l,u;let c=1/this.direction.x,h=1/this.direction.y,d=1/this.direction.z,p=this.origin;return(c>=0?(i=(n.min.x-p.x)*c,a=(n.max.x-p.x)*c):(i=(n.max.x-p.x)*c,a=(n.min.x-p.x)*c),h>=0?(s=(n.min.y-p.y)*h,o=(n.max.y-p.y)*h):(s=(n.max.y-p.y)*h,o=(n.min.y-p.y)*h),i>o||s>a)?null:((s>i||isNaN(i))&&(i=s),(o<a||isNaN(a))&&(a=o),d>=0?(l=(n.min.z-p.z)*d,u=(n.max.z-p.z)*d):(l=(n.max.z-p.z)*d,u=(n.min.z-p.z)*d),i>u||l>a)?null:((l>i||i!=i)&&(i=l),(u<a||a!=a)&&(a=u),a<0)?null:this.at(i>=0?i:a,r)}intersectsBox(n){return null!==this.intersectBox(n,$d5b33d7c30034067$var$_vector$9)}intersectTriangle(n,r,i,a,s){let o;// Compute the offset origin, edges, and normal.
// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
$d5b33d7c30034067$var$_edge1.subVectors(r,n),$d5b33d7c30034067$var$_edge2.subVectors(i,n),$d5b33d7c30034067$var$_normal$1.crossVectors($d5b33d7c30034067$var$_edge1,$d5b33d7c30034067$var$_edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
let l=this.direction.dot($d5b33d7c30034067$var$_normal$1);if(l>0){if(a)return null;o=1}else{if(!(l<0))return null;o=-1,l=-l}$d5b33d7c30034067$var$_diff.subVectors(this.origin,n);let u=o*this.direction.dot($d5b33d7c30034067$var$_edge2.crossVectors($d5b33d7c30034067$var$_diff,$d5b33d7c30034067$var$_edge2));// b1 < 0, no intersection
if(u<0)return null;let c=o*this.direction.dot($d5b33d7c30034067$var$_edge1.cross($d5b33d7c30034067$var$_diff));// b2 < 0, no intersection
if(c<0||u+c>l)return null;// Line intersects triangle, check if ray does.
let h=-o*$d5b33d7c30034067$var$_diff.dot($d5b33d7c30034067$var$_normal$1);return(// t < 0, no intersection
h<0?null:this.at(h/l,s))}applyMatrix4(n){return this.origin.applyMatrix4(n),this.direction.transformDirection(n),this}equals(n){return n.origin.equals(this.origin)&&n.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class $d5b33d7c30034067$export$2ae72fc923e5eb5{constructor(n,r,i,a,s,o,l,u,c,h,d,p,f,m,g,_){$d5b33d7c30034067$export$2ae72fc923e5eb5.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==n&&this.set(n,r,i,a,s,o,l,u,c,h,d,p,f,m,g,_)}set(n,r,i,a,s,o,l,u,c,h,d,p,f,m,g,_){let y=this.elements;return y[0]=n,y[4]=r,y[8]=i,y[12]=a,y[1]=s,y[5]=o,y[9]=l,y[13]=u,y[2]=c,y[6]=h,y[10]=d,y[14]=p,y[3]=f,y[7]=m,y[11]=g,y[15]=_,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new $d5b33d7c30034067$export$2ae72fc923e5eb5().fromArray(this.elements)}copy(n){let r=this.elements,i=n.elements;return r[0]=i[0],r[1]=i[1],r[2]=i[2],r[3]=i[3],r[4]=i[4],r[5]=i[5],r[6]=i[6],r[7]=i[7],r[8]=i[8],r[9]=i[9],r[10]=i[10],r[11]=i[11],r[12]=i[12],r[13]=i[13],r[14]=i[14],r[15]=i[15],this}copyPosition(n){let r=this.elements,i=n.elements;return r[12]=i[12],r[13]=i[13],r[14]=i[14],this}setFromMatrix3(n){let r=n.elements;return this.set(r[0],r[3],r[6],0,r[1],r[4],r[7],0,r[2],r[5],r[8],0,0,0,0,1),this}extractBasis(n,r,i){return n.setFromMatrixColumn(this,0),r.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(n,r,i){return this.set(n.x,r.x,i.x,0,n.y,r.y,i.y,0,n.z,r.z,i.z,0,0,0,0,1),this}extractRotation(n){// this method does not support reflection matrices
let r=this.elements,i=n.elements,a=1/$d5b33d7c30034067$var$_v1$5.setFromMatrixColumn(n,0).length(),s=1/$d5b33d7c30034067$var$_v1$5.setFromMatrixColumn(n,1).length(),o=1/$d5b33d7c30034067$var$_v1$5.setFromMatrixColumn(n,2).length();return r[0]=i[0]*a,r[1]=i[1]*a,r[2]=i[2]*a,r[3]=0,r[4]=i[4]*s,r[5]=i[5]*s,r[6]=i[6]*s,r[7]=0,r[8]=i[8]*o,r[9]=i[9]*o,r[10]=i[10]*o,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,this}makeRotationFromEuler(n){let r=this.elements,i=n.x,a=n.y,s=n.z,o=Math.cos(i),l=Math.sin(i),u=Math.cos(a),c=Math.sin(a),h=Math.cos(s),d=Math.sin(s);if("XYZ"===n.order){let n=o*h,i=o*d,a=l*h,s=l*d;r[0]=u*h,r[4]=-u*d,r[8]=c,r[1]=i+a*c,r[5]=n-s*c,r[9]=-l*u,r[2]=s-n*c,r[6]=a+i*c,r[10]=o*u}else if("YXZ"===n.order){let n=u*h,i=u*d,a=c*h,s=c*d;r[0]=n+s*l,r[4]=a*l-i,r[8]=o*c,r[1]=o*d,r[5]=o*h,r[9]=-l,r[2]=i*l-a,r[6]=s+n*l,r[10]=o*u}else if("ZXY"===n.order){let n=u*h,i=u*d,a=c*h,s=c*d;r[0]=n-s*l,r[4]=-o*d,r[8]=a+i*l,r[1]=i+a*l,r[5]=o*h,r[9]=s-n*l,r[2]=-o*c,r[6]=l,r[10]=o*u}else if("ZYX"===n.order){let n=o*h,i=o*d,a=l*h,s=l*d;r[0]=u*h,r[4]=a*c-i,r[8]=n*c+s,r[1]=u*d,r[5]=s*c+n,r[9]=i*c-a,r[2]=-c,r[6]=l*u,r[10]=o*u}else if("YZX"===n.order){let n=o*u,i=o*c,a=l*u,s=l*c;r[0]=u*h,r[4]=s-n*d,r[8]=a*d+i,r[1]=d,r[5]=o*h,r[9]=-l*h,r[2]=-c*h,r[6]=i*d+a,r[10]=n-s*d}else if("XZY"===n.order){let n=o*u,i=o*c,a=l*u,s=l*c;r[0]=u*h,r[4]=-d,r[8]=c*h,r[1]=n*d+s,r[5]=o*h,r[9]=i*d-a,r[2]=a*d-i,r[6]=l*h,r[10]=s*d+n}return(// bottom row
r[3]=0,r[7]=0,r[11]=0,// last column
r[12]=0,r[13]=0,r[14]=0,r[15]=1,this)}makeRotationFromQuaternion(n){return this.compose($d5b33d7c30034067$var$_zero,n,$d5b33d7c30034067$var$_one)}lookAt(n,r,i){let a=this.elements;return $d5b33d7c30034067$var$_z.subVectors(n,r),0===$d5b33d7c30034067$var$_z.lengthSq()&&($d5b33d7c30034067$var$_z.z=1),$d5b33d7c30034067$var$_z.normalize(),$d5b33d7c30034067$var$_x.crossVectors(i,$d5b33d7c30034067$var$_z),0===$d5b33d7c30034067$var$_x.lengthSq()&&(1===Math.abs(i.z)?$d5b33d7c30034067$var$_z.x+=1e-4:$d5b33d7c30034067$var$_z.z+=1e-4,$d5b33d7c30034067$var$_z.normalize(),$d5b33d7c30034067$var$_x.crossVectors(i,$d5b33d7c30034067$var$_z)),$d5b33d7c30034067$var$_x.normalize(),$d5b33d7c30034067$var$_y.crossVectors($d5b33d7c30034067$var$_z,$d5b33d7c30034067$var$_x),a[0]=$d5b33d7c30034067$var$_x.x,a[4]=$d5b33d7c30034067$var$_y.x,a[8]=$d5b33d7c30034067$var$_z.x,a[1]=$d5b33d7c30034067$var$_x.y,a[5]=$d5b33d7c30034067$var$_y.y,a[9]=$d5b33d7c30034067$var$_z.y,a[2]=$d5b33d7c30034067$var$_x.z,a[6]=$d5b33d7c30034067$var$_y.z,a[10]=$d5b33d7c30034067$var$_z.z,this}multiply(n){return this.multiplyMatrices(this,n)}premultiply(n){return this.multiplyMatrices(n,this)}multiplyMatrices(n,r){let i=n.elements,a=r.elements,s=this.elements,o=i[0],l=i[4],u=i[8],c=i[12],h=i[1],d=i[5],p=i[9],f=i[13],m=i[2],g=i[6],_=i[10],y=i[14],b=i[3],v=i[7],x=i[11],w=i[15],T=a[0],S=a[4],E=a[8],A=a[12],M=a[1],I=a[5],P=a[9],O=a[13],R=a[2],C=a[6],L=a[10],D=a[14],N=a[3],k=a[7],U=a[11],F=a[15];return s[0]=o*T+l*M+u*R+c*N,s[4]=o*S+l*I+u*C+c*k,s[8]=o*E+l*P+u*L+c*U,s[12]=o*A+l*O+u*D+c*F,s[1]=h*T+d*M+p*R+f*N,s[5]=h*S+d*I+p*C+f*k,s[9]=h*E+d*P+p*L+f*U,s[13]=h*A+d*O+p*D+f*F,s[2]=m*T+g*M+_*R+y*N,s[6]=m*S+g*I+_*C+y*k,s[10]=m*E+g*P+_*L+y*U,s[14]=m*A+g*O+_*D+y*F,s[3]=b*T+v*M+x*R+w*N,s[7]=b*S+v*I+x*C+w*k,s[11]=b*E+v*P+x*L+w*U,s[15]=b*A+v*O+x*D+w*F,this}multiplyScalar(n){let r=this.elements;return r[0]*=n,r[4]*=n,r[8]*=n,r[12]*=n,r[1]*=n,r[5]*=n,r[9]*=n,r[13]*=n,r[2]*=n,r[6]*=n,r[10]*=n,r[14]*=n,r[3]*=n,r[7]*=n,r[11]*=n,r[15]*=n,this}determinant(){let n=this.elements,r=n[0],i=n[4],a=n[8],s=n[12],o=n[1],l=n[5],u=n[9],c=n[13],h=n[2],d=n[6],p=n[10],f=n[14],m=n[3],g=n[7],_=n[11],y=n[15];//TODO: make this more efficient
//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
return m*(+s*u*d-a*c*d-s*l*p+i*c*p+a*l*f-i*u*f)+g*(+r*u*f-r*c*p+s*o*p-a*o*f+a*c*h-s*u*h)+_*(+r*c*d-r*l*f-s*o*d+i*o*f+s*l*h-i*c*h)+y*(-a*l*h-r*u*d+r*l*p+a*o*d-i*o*p+i*u*h)}transpose(){let n;let r=this.elements;return n=r[1],r[1]=r[4],r[4]=n,n=r[2],r[2]=r[8],r[8]=n,n=r[6],r[6]=r[9],r[9]=n,n=r[3],r[3]=r[12],r[12]=n,n=r[7],r[7]=r[13],r[13]=n,n=r[11],r[11]=r[14],r[14]=n,this}setPosition(n,r,i){let a=this.elements;return n.isVector3?(a[12]=n.x,a[13]=n.y,a[14]=n.z):(a[12]=n,a[13]=r,a[14]=i),this}invert(){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
let n=this.elements,r=n[0],i=n[1],a=n[2],s=n[3],o=n[4],l=n[5],u=n[6],c=n[7],h=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],_=n[14],y=n[15],b=d*_*c-g*p*c+g*u*f-l*_*f-d*u*y+l*p*y,v=m*p*c-h*_*c-m*u*f+o*_*f+h*u*y-o*p*y,x=h*g*c-m*d*c+m*l*f-o*g*f-h*l*y+o*d*y,w=m*d*u-h*g*u-m*l*p+o*g*p+h*l*_-o*d*_,T=r*b+i*v+a*x+s*w;if(0===T)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);let S=1/T;return n[0]=b*S,n[1]=(g*p*s-d*_*s-g*a*f+i*_*f+d*a*y-i*p*y)*S,n[2]=(l*_*s-g*u*s+g*a*c-i*_*c-l*a*y+i*u*y)*S,n[3]=(d*u*s-l*p*s-d*a*c+i*p*c+l*a*f-i*u*f)*S,n[4]=v*S,n[5]=(h*_*s-m*p*s+m*a*f-r*_*f-h*a*y+r*p*y)*S,n[6]=(m*u*s-o*_*s-m*a*c+r*_*c+o*a*y-r*u*y)*S,n[7]=(o*p*s-h*u*s+h*a*c-r*p*c-o*a*f+r*u*f)*S,n[8]=x*S,n[9]=(m*d*s-h*g*s-m*i*f+r*g*f+h*i*y-r*d*y)*S,n[10]=(o*g*s-m*l*s+m*i*c-r*g*c-o*i*y+r*l*y)*S,n[11]=(h*l*s-o*d*s-h*i*c+r*d*c+o*i*f-r*l*f)*S,n[12]=w*S,n[13]=(h*g*a-m*d*a+m*i*p-r*g*p-h*i*_+r*d*_)*S,n[14]=(m*l*a-o*g*a-m*i*u+r*g*u+o*i*_-r*l*_)*S,n[15]=(o*d*a-h*l*a+h*i*u-r*d*u-o*i*p+r*l*p)*S,this}scale(n){let r=this.elements,i=n.x,a=n.y,s=n.z;return r[0]*=i,r[4]*=a,r[8]*=s,r[1]*=i,r[5]*=a,r[9]*=s,r[2]*=i,r[6]*=a,r[10]*=s,r[3]*=i,r[7]*=a,r[11]*=s,this}getMaxScaleOnAxis(){let n=this.elements,r=n[0]*n[0]+n[1]*n[1]+n[2]*n[2],i=n[4]*n[4]+n[5]*n[5]+n[6]*n[6],a=n[8]*n[8]+n[9]*n[9]+n[10]*n[10];return Math.sqrt(Math.max(r,i,a))}makeTranslation(n,r,i){return n.isVector3?this.set(1,0,0,n.x,0,1,0,n.y,0,0,1,n.z,0,0,0,1):this.set(1,0,0,n,0,1,0,r,0,0,1,i,0,0,0,1),this}makeRotationX(n){let r=Math.cos(n),i=Math.sin(n);return this.set(1,0,0,0,0,r,-i,0,0,i,r,0,0,0,0,1),this}makeRotationY(n){let r=Math.cos(n),i=Math.sin(n);return this.set(r,0,i,0,0,1,0,0,-i,0,r,0,0,0,0,1),this}makeRotationZ(n){let r=Math.cos(n),i=Math.sin(n);return this.set(r,-i,0,0,i,r,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(n,r){// Based on http://www.gamedev.net/reference/articles/article1199.asp
let i=Math.cos(r),a=Math.sin(r),s=1-i,o=n.x,l=n.y,u=n.z,c=s*o,h=s*l;return this.set(c*o+i,c*l-a*u,c*u+a*l,0,c*l+a*u,h*l+i,h*u-a*o,0,c*u-a*l,h*u+a*o,s*u*u+i,0,0,0,0,1),this}makeScale(n,r,i){return this.set(n,0,0,0,0,r,0,0,0,0,i,0,0,0,0,1),this}makeShear(n,r,i,a,s,o){return this.set(1,i,s,0,n,1,o,0,r,a,1,0,0,0,0,1),this}compose(n,r,i){let a=this.elements,s=r._x,o=r._y,l=r._z,u=r._w,c=s+s,h=o+o,d=l+l,p=s*c,f=s*h,m=s*d,g=o*h,_=o*d,y=l*d,b=u*c,v=u*h,x=u*d,w=i.x,T=i.y,S=i.z;return a[0]=(1-(g+y))*w,a[1]=(f+x)*w,a[2]=(m-v)*w,a[3]=0,a[4]=(f-x)*T,a[5]=(1-(p+y))*T,a[6]=(_+b)*T,a[7]=0,a[8]=(m+v)*S,a[9]=(_-b)*S,a[10]=(1-(p+g))*S,a[11]=0,a[12]=n.x,a[13]=n.y,a[14]=n.z,a[15]=1,this}decompose(n,r,i){let a=this.elements,s=$d5b33d7c30034067$var$_v1$5.set(a[0],a[1],a[2]).length(),o=$d5b33d7c30034067$var$_v1$5.set(a[4],a[5],a[6]).length(),l=$d5b33d7c30034067$var$_v1$5.set(a[8],a[9],a[10]).length(),u=this.determinant();u<0&&(s=-s),n.x=a[12],n.y=a[13],n.z=a[14],// scale the rotation part
$d5b33d7c30034067$var$_m1$2.copy(this);let c=1/s,h=1/o,d=1/l;return $d5b33d7c30034067$var$_m1$2.elements[0]*=c,$d5b33d7c30034067$var$_m1$2.elements[1]*=c,$d5b33d7c30034067$var$_m1$2.elements[2]*=c,$d5b33d7c30034067$var$_m1$2.elements[4]*=h,$d5b33d7c30034067$var$_m1$2.elements[5]*=h,$d5b33d7c30034067$var$_m1$2.elements[6]*=h,$d5b33d7c30034067$var$_m1$2.elements[8]*=d,$d5b33d7c30034067$var$_m1$2.elements[9]*=d,$d5b33d7c30034067$var$_m1$2.elements[10]*=d,r.setFromRotationMatrix($d5b33d7c30034067$var$_m1$2),i.x=s,i.y=o,i.z=l,this}makePerspective(n,r,i,a,s,o,l=$d5b33d7c30034067$export$5a0e9190d10875d3){let u,c;let h=this.elements,d=2*s/(r-n),p=2*s/(i-a),f=(r+n)/(r-n),m=(i+a)/(i-a);if(l===$d5b33d7c30034067$export$5a0e9190d10875d3)u=-(o+s)/(o-s),c=-2*o*s/(o-s);else if(l===$d5b33d7c30034067$export$cc83beedcb9be9ac)u=-o/(o-s),c=-o*s/(o-s);else throw Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+l);return h[0]=d,h[4]=0,h[8]=f,h[12]=0,h[1]=0,h[5]=p,h[9]=m,h[13]=0,h[2]=0,h[6]=0,h[10]=u,h[14]=c,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(n,r,i,a,s,o,l=$d5b33d7c30034067$export$5a0e9190d10875d3){let u,c;let h=this.elements,d=1/(r-n),p=1/(i-a),f=1/(o-s),m=(r+n)*d,g=(i+a)*p;if(l===$d5b33d7c30034067$export$5a0e9190d10875d3)u=(o+s)*f,c=-2*f;else if(l===$d5b33d7c30034067$export$cc83beedcb9be9ac)u=s*f,c=-1*f;else throw Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+l);return h[0]=2*d,h[4]=0,h[8]=0,h[12]=-m,h[1]=0,h[5]=2*p,h[9]=0,h[13]=-g,h[2]=0,h[6]=0,h[10]=c,h[14]=-u,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(n){let r=this.elements,i=n.elements;for(let n=0;n<16;n++)if(r[n]!==i[n])return!1;return!0}fromArray(n,r=0){for(let i=0;i<16;i++)this.elements[i]=n[i+r];return this}toArray(n=[],r=0){let i=this.elements;return n[r]=i[0],n[r+1]=i[1],n[r+2]=i[2],n[r+3]=i[3],n[r+4]=i[4],n[r+5]=i[5],n[r+6]=i[6],n[r+7]=i[7],n[r+8]=i[8],n[r+9]=i[9],n[r+10]=i[10],n[r+11]=i[11],n[r+12]=i[12],n[r+13]=i[13],n[r+14]=i[14],n[r+15]=i[15],n}}const $d5b33d7c30034067$var$_v1$5=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_m1$2=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_zero=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(0,0,0),$d5b33d7c30034067$var$_one=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(1,1,1),$d5b33d7c30034067$var$_x=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_y=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_z=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_matrix=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_quaternion$3=/*@__PURE__*/new $d5b33d7c30034067$export$23d6a54f0bbc85a3;class $d5b33d7c30034067$export$d93cc409a0768c5f{constructor(n=0,r=0,i=0,a=$d5b33d7c30034067$export$d93cc409a0768c5f.DEFAULT_ORDER){this.isEuler=!0,this._x=n,this._y=r,this._z=i,this._order=a}get x(){return this._x}set x(n){this._x=n,this._onChangeCallback()}get y(){return this._y}set y(n){this._y=n,this._onChangeCallback()}get z(){return this._z}set z(n){this._z=n,this._onChangeCallback()}get order(){return this._order}set order(n){this._order=n,this._onChangeCallback()}set(n,r,i,a=this._order){return this._x=n,this._y=r,this._z=i,this._order=a,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(n){return this._x=n._x,this._y=n._y,this._z=n._z,this._order=n._order,this._onChangeCallback(),this}setFromRotationMatrix(n,r=this._order,i=!0){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
let a=n.elements,s=a[0],o=a[4],l=a[8],u=a[1],c=a[5],h=a[9],d=a[2],p=a[6],f=a[10];switch(r){case"XYZ":this._y=Math.asin($d5b33d7c30034067$var$clamp(l,-1,1)),.9999999>Math.abs(l)?(this._x=Math.atan2(-h,f),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(p,c),this._z=0);break;case"YXZ":this._x=Math.asin(-$d5b33d7c30034067$var$clamp(h,-1,1)),.9999999>Math.abs(h)?(this._y=Math.atan2(l,f),this._z=Math.atan2(u,c)):(this._y=Math.atan2(-d,s),this._z=0);break;case"ZXY":this._x=Math.asin($d5b33d7c30034067$var$clamp(p,-1,1)),.9999999>Math.abs(p)?(this._y=Math.atan2(-d,f),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(u,s));break;case"ZYX":this._y=Math.asin(-$d5b33d7c30034067$var$clamp(d,-1,1)),.9999999>Math.abs(d)?(this._x=Math.atan2(p,f),this._z=Math.atan2(u,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin($d5b33d7c30034067$var$clamp(u,-1,1)),.9999999>Math.abs(u)?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-d,s)):(this._x=0,this._y=Math.atan2(l,f));break;case"XZY":this._z=Math.asin(-$d5b33d7c30034067$var$clamp(o,-1,1)),.9999999>Math.abs(o)?(this._x=Math.atan2(p,c),this._y=Math.atan2(l,s)):(this._x=Math.atan2(-h,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+r)}return this._order=r,!0===i&&this._onChangeCallback(),this}setFromQuaternion(n,r,i){return $d5b33d7c30034067$var$_matrix.makeRotationFromQuaternion(n),this.setFromRotationMatrix($d5b33d7c30034067$var$_matrix,r,i)}setFromVector3(n,r=this._order){return this.set(n.x,n.y,n.z,r)}reorder(n){return(// WARNING: this discards revolution information -bhouston
$d5b33d7c30034067$var$_quaternion$3.setFromEuler(this),this.setFromQuaternion($d5b33d7c30034067$var$_quaternion$3,n))}equals(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._order===this._order}fromArray(n){return this._x=n[0],this._y=n[1],this._z=n[2],void 0!==n[3]&&(this._order=n[3]),this._onChangeCallback(),this}toArray(n=[],r=0){return n[r]=this._x,n[r+1]=this._y,n[r+2]=this._z,n[r+3]=this._order,n}_onChange(n){return this._onChangeCallback=n,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}$d5b33d7c30034067$export$d93cc409a0768c5f.DEFAULT_ORDER="XYZ";class $d5b33d7c30034067$export$89312ce47c0ca777{constructor(){this.mask=1}set(n){this.mask=(1<<n|0)>>>0}enable(n){this.mask|=1<<n|0}enableAll(){this.mask=-1}toggle(n){this.mask^=1<<n|0}disable(n){this.mask&=~(1<<n|0)}disableAll(){this.mask=0}test(n){return(this.mask&n.mask)!=0}isEnabled(n){return(this.mask&(1<<n|0))!=0}}let $d5b33d7c30034067$var$_object3DId=0;const $d5b33d7c30034067$var$_v1$4=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_q1=/*@__PURE__*/new $d5b33d7c30034067$export$23d6a54f0bbc85a3,$d5b33d7c30034067$var$_m1$1=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_target=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_position$3=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_scale$2=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_quaternion$2=/*@__PURE__*/new $d5b33d7c30034067$export$23d6a54f0bbc85a3,$d5b33d7c30034067$var$_xAxis=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(1,0,0),$d5b33d7c30034067$var$_yAxis=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(0,1,0),$d5b33d7c30034067$var$_zAxis=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(0,0,1),$d5b33d7c30034067$var$_addedEvent={type:"added"},$d5b33d7c30034067$var$_removedEvent={type:"removed"};class $d5b33d7c30034067$export$e4dd07dff30cc924 extends $d5b33d7c30034067$export$ec8b666c5fe2c75a{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:$d5b33d7c30034067$var$_object3DId++}),this.uuid=$d5b33d7c30034067$var$generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=$d5b33d7c30034067$export$e4dd07dff30cc924.DEFAULT_UP.clone();let n=new $d5b33d7c30034067$export$64b5c384219d3699,r=new $d5b33d7c30034067$export$d93cc409a0768c5f,i=new $d5b33d7c30034067$export$23d6a54f0bbc85a3,a=new $d5b33d7c30034067$export$64b5c384219d3699(1,1,1);function s(){i.setFromEuler(r,!1)}function o(){r.setFromQuaternion(i,void 0,!1)}r._onChange(s),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:n},rotation:{configurable:!0,enumerable:!0,value:r},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:a},modelViewMatrix:{value:new $d5b33d7c30034067$export$2ae72fc923e5eb5},normalMatrix:{value:new $d5b33d7c30034067$export$8ff26dafa08918}}),this.matrix=new $d5b33d7c30034067$export$2ae72fc923e5eb5,this.matrixWorld=new $d5b33d7c30034067$export$2ae72fc923e5eb5,this.matrixAutoUpdate=$d5b33d7c30034067$export$e4dd07dff30cc924.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=$d5b33d7c30034067$export$e4dd07dff30cc924.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new $d5b33d7c30034067$export$89312ce47c0ca777,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(n){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(n),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(n){return this.quaternion.premultiply(n),this}setRotationFromAxisAngle(n,r){// assumes axis is normalized
this.quaternion.setFromAxisAngle(n,r)}setRotationFromEuler(n){this.quaternion.setFromEuler(n,!0)}setRotationFromMatrix(n){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
this.quaternion.setFromRotationMatrix(n)}setRotationFromQuaternion(n){// assumes q is normalized
this.quaternion.copy(n)}rotateOnAxis(n,r){return(// rotate object on axis in object space
// axis is assumed to be normalized
$d5b33d7c30034067$var$_q1.setFromAxisAngle(n,r),this.quaternion.multiply($d5b33d7c30034067$var$_q1),this)}rotateOnWorldAxis(n,r){return(// rotate object on axis in world space
// axis is assumed to be normalized
// method assumes no rotated parent
$d5b33d7c30034067$var$_q1.setFromAxisAngle(n,r),this.quaternion.premultiply($d5b33d7c30034067$var$_q1),this)}rotateX(n){return this.rotateOnAxis($d5b33d7c30034067$var$_xAxis,n)}rotateY(n){return this.rotateOnAxis($d5b33d7c30034067$var$_yAxis,n)}rotateZ(n){return this.rotateOnAxis($d5b33d7c30034067$var$_zAxis,n)}translateOnAxis(n,r){return(// translate object by distance along axis in object space
// axis is assumed to be normalized
$d5b33d7c30034067$var$_v1$4.copy(n).applyQuaternion(this.quaternion),this.position.add($d5b33d7c30034067$var$_v1$4.multiplyScalar(r)),this)}translateX(n){return this.translateOnAxis($d5b33d7c30034067$var$_xAxis,n)}translateY(n){return this.translateOnAxis($d5b33d7c30034067$var$_yAxis,n)}translateZ(n){return this.translateOnAxis($d5b33d7c30034067$var$_zAxis,n)}localToWorld(n){return this.updateWorldMatrix(!0,!1),n.applyMatrix4(this.matrixWorld)}worldToLocal(n){return this.updateWorldMatrix(!0,!1),n.applyMatrix4($d5b33d7c30034067$var$_m1$1.copy(this.matrixWorld).invert())}lookAt(n,r,i){n.isVector3?$d5b33d7c30034067$var$_target.copy(n):$d5b33d7c30034067$var$_target.set(n,r,i);let a=this.parent;this.updateWorldMatrix(!0,!1),$d5b33d7c30034067$var$_position$3.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?$d5b33d7c30034067$var$_m1$1.lookAt($d5b33d7c30034067$var$_position$3,$d5b33d7c30034067$var$_target,this.up):$d5b33d7c30034067$var$_m1$1.lookAt($d5b33d7c30034067$var$_target,$d5b33d7c30034067$var$_position$3,this.up),this.quaternion.setFromRotationMatrix($d5b33d7c30034067$var$_m1$1),a&&($d5b33d7c30034067$var$_m1$1.extractRotation(a.matrixWorld),$d5b33d7c30034067$var$_q1.setFromRotationMatrix($d5b33d7c30034067$var$_m1$1),this.quaternion.premultiply($d5b33d7c30034067$var$_q1.invert()))}add(n){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.add(arguments[n]);return this}return n===this?console.error("THREE.Object3D.add: object can't be added as a child of itself.",n):n&&n.isObject3D?(null!==n.parent&&n.parent.remove(n),n.parent=this,this.children.push(n),n.dispatchEvent($d5b33d7c30034067$var$_addedEvent)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",n),this}remove(n){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}let r=this.children.indexOf(n);return -1!==r&&(n.parent=null,this.children.splice(r,1),n.dispatchEvent($d5b33d7c30034067$var$_removedEvent)),this}removeFromParent(){let n=this.parent;return null!==n&&n.remove(this),this}clear(){return this.remove(...this.children)}attach(n){return(// adds object as a child of this, while maintaining the object's world transform
// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
this.updateWorldMatrix(!0,!1),$d5b33d7c30034067$var$_m1$1.copy(this.matrixWorld).invert(),null!==n.parent&&(n.parent.updateWorldMatrix(!0,!1),$d5b33d7c30034067$var$_m1$1.multiply(n.parent.matrixWorld)),n.applyMatrix4($d5b33d7c30034067$var$_m1$1),this.add(n),n.updateWorldMatrix(!1,!0),this)}getObjectById(n){return this.getObjectByProperty("id",n)}getObjectByName(n){return this.getObjectByProperty("name",n)}getObjectByProperty(n,r){if(this[n]===r)return this;for(let i=0,a=this.children.length;i<a;i++){let a=this.children[i],s=a.getObjectByProperty(n,r);if(void 0!==s)return s}}getObjectsByProperty(n,r){let i=[];this[n]===r&&i.push(this);for(let a=0,s=this.children.length;a<s;a++){let s=this.children[a].getObjectsByProperty(n,r);s.length>0&&(i=i.concat(s))}return i}getWorldPosition(n){return this.updateWorldMatrix(!0,!1),n.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(n){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose($d5b33d7c30034067$var$_position$3,n,$d5b33d7c30034067$var$_scale$2),n}getWorldScale(n){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose($d5b33d7c30034067$var$_position$3,$d5b33d7c30034067$var$_quaternion$2,n),n}getWorldDirection(n){this.updateWorldMatrix(!0,!1);let r=this.matrixWorld.elements;return n.set(r[8],r[9],r[10]).normalize()}raycast(){}traverse(n){n(this);let r=this.children;for(let i=0,a=r.length;i<a;i++)r[i].traverse(n)}traverseVisible(n){if(!1===this.visible)return;n(this);let r=this.children;for(let i=0,a=r.length;i<a;i++)r[i].traverseVisible(n)}traverseAncestors(n){let r=this.parent;null!==r&&(n(r),r.traverseAncestors(n))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(n){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||n)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,n=!0);// update children
let r=this.children;for(let i=0,a=r.length;i<a;i++){let a=r[i];(!0===a.matrixWorldAutoUpdate||!0===n)&&a.updateMatrixWorld(n)}}updateWorldMatrix(n,r){let i=this.parent;// update children
if(!0===n&&null!==i&&!0===i.matrixWorldAutoUpdate&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===r){let n=this.children;for(let r=0,i=n.length;r<i;r++){let i=n[r];!0===i.matrixWorldAutoUpdate&&i.updateWorldMatrix(!1,!0)}}}toJSON(n){// meta is a string when called from JSON.stringify
let r=void 0===n||"string"==typeof n,i={};r&&(// initialize meta obj
n={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});// standard Object3D serialization
let a={};//
function s(r,i){return void 0===r[i.uuid]&&(r[i.uuid]=i.toJSON(n)),i.uuid}if(a.uuid=this.uuid,a.type=this.type,""!==this.name&&(a.name=this.name),!0===this.castShadow&&(a.castShadow=!0),!0===this.receiveShadow&&(a.receiveShadow=!0),!1===this.visible&&(a.visible=!1),!1===this.frustumCulled&&(a.frustumCulled=!1),0!==this.renderOrder&&(a.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(a.userData=this.userData),a.layers=this.layers.mask,a.matrix=this.matrix.toArray(),a.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(a.matrixAutoUpdate=!1),this.isInstancedMesh&&(a.type="InstancedMesh",a.count=this.count,a.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(a.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?a.background=this.background.toJSON():this.background.isTexture&&(a.background=this.background.toJSON(n).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(a.environment=this.environment.toJSON(n).uuid);else if(this.isMesh||this.isLine||this.isPoints){a.geometry=s(n.geometries,this.geometry);let r=this.geometry.parameters;if(void 0!==r&&void 0!==r.shapes){let i=r.shapes;if(Array.isArray(i))for(let r=0,a=i.length;r<a;r++){let a=i[r];s(n.shapes,a)}else s(n.shapes,i)}}if(this.isSkinnedMesh&&(a.bindMode=this.bindMode,a.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(s(n.skeletons,this.skeleton),a.skeleton=this.skeleton.uuid)),void 0!==this.material){if(Array.isArray(this.material)){let r=[];for(let i=0,a=this.material.length;i<a;i++)r.push(s(n.materials,this.material[i]));a.material=r}else a.material=s(n.materials,this.material)}//
if(this.children.length>0){a.children=[];for(let r=0;r<this.children.length;r++)a.children.push(this.children[r].toJSON(n).object)}//
if(this.animations.length>0){a.animations=[];for(let r=0;r<this.animations.length;r++){let i=this.animations[r];a.animations.push(s(n.animations,i))}}if(r){let r=o(n.geometries),a=o(n.materials),s=o(n.textures),l=o(n.images),u=o(n.shapes),c=o(n.skeletons),h=o(n.animations),d=o(n.nodes);r.length>0&&(i.geometries=r),a.length>0&&(i.materials=a),s.length>0&&(i.textures=s),l.length>0&&(i.images=l),u.length>0&&(i.shapes=u),c.length>0&&(i.skeletons=c),h.length>0&&(i.animations=h),d.length>0&&(i.nodes=d)}return i.object=a,i;// extract data from the cache hash
// remove metadata on each item
// and return as array
function o(n){let r=[];for(let i in n){let a=n[i];delete a.metadata,r.push(a)}return r}}clone(n){return new this.constructor().copy(this,n)}copy(n,r=!0){if(this.name=n.name,this.up.copy(n.up),this.position.copy(n.position),this.rotation.order=n.rotation.order,this.quaternion.copy(n.quaternion),this.scale.copy(n.scale),this.matrix.copy(n.matrix),this.matrixWorld.copy(n.matrixWorld),this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrixWorldNeedsUpdate=n.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=n.matrixWorldAutoUpdate,this.layers.mask=n.layers.mask,this.visible=n.visible,this.castShadow=n.castShadow,this.receiveShadow=n.receiveShadow,this.frustumCulled=n.frustumCulled,this.renderOrder=n.renderOrder,this.animations=n.animations.slice(),this.userData=JSON.parse(JSON.stringify(n.userData)),!0===r)for(let r=0;r<n.children.length;r++){let i=n.children[r];this.add(i.clone())}return this}}$d5b33d7c30034067$export$e4dd07dff30cc924.DEFAULT_UP=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(0,1,0),$d5b33d7c30034067$export$e4dd07dff30cc924.DEFAULT_MATRIX_AUTO_UPDATE=!0,$d5b33d7c30034067$export$e4dd07dff30cc924.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const $d5b33d7c30034067$var$_v0$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_v1$3=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_v2$2=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_v3$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vab=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vac=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vbc=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vap=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vbp=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vcp=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;let $d5b33d7c30034067$var$warnedGetUV=!1;class $d5b33d7c30034067$export$5a465592bfe74b48{constructor(n=new $d5b33d7c30034067$export$64b5c384219d3699,r=new $d5b33d7c30034067$export$64b5c384219d3699,i=new $d5b33d7c30034067$export$64b5c384219d3699){this.a=n,this.b=r,this.c=i}static getNormal(n,r,i,a){a.subVectors(i,r),$d5b33d7c30034067$var$_v0$1.subVectors(n,r),a.cross($d5b33d7c30034067$var$_v0$1);let s=a.lengthSq();return s>0?a.multiplyScalar(1/Math.sqrt(s)):a.set(0,0,0)}// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
static getBarycoord(n,r,i,a,s){$d5b33d7c30034067$var$_v0$1.subVectors(a,r),$d5b33d7c30034067$var$_v1$3.subVectors(i,r),$d5b33d7c30034067$var$_v2$2.subVectors(n,r);let o=$d5b33d7c30034067$var$_v0$1.dot($d5b33d7c30034067$var$_v0$1),l=$d5b33d7c30034067$var$_v0$1.dot($d5b33d7c30034067$var$_v1$3),u=$d5b33d7c30034067$var$_v0$1.dot($d5b33d7c30034067$var$_v2$2),c=$d5b33d7c30034067$var$_v1$3.dot($d5b33d7c30034067$var$_v1$3),h=$d5b33d7c30034067$var$_v1$3.dot($d5b33d7c30034067$var$_v2$2),d=o*c-l*l;// collinear or singular triangle
if(0===d)// not sure if this is the best idea, maybe should be returning undefined
return s.set(-2,-1,-1);let p=1/d,f=(c*u-l*h)*p,m=(o*h-l*u)*p;// barycentric coordinates must always sum to 1
return s.set(1-f-m,m,f)}static containsPoint(n,r,i,a){return this.getBarycoord(n,r,i,a,$d5b33d7c30034067$var$_v3$1),$d5b33d7c30034067$var$_v3$1.x>=0&&$d5b33d7c30034067$var$_v3$1.y>=0&&$d5b33d7c30034067$var$_v3$1.x+$d5b33d7c30034067$var$_v3$1.y<=1}static getUV(n,r,i,a,s,o,l,u){return!1===$d5b33d7c30034067$var$warnedGetUV&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),$d5b33d7c30034067$var$warnedGetUV=!0),this.getInterpolation(n,r,i,a,s,o,l,u)}static getInterpolation(n,r,i,a,s,o,l,u){return this.getBarycoord(n,r,i,a,$d5b33d7c30034067$var$_v3$1),u.setScalar(0),u.addScaledVector(s,$d5b33d7c30034067$var$_v3$1.x),u.addScaledVector(o,$d5b33d7c30034067$var$_v3$1.y),u.addScaledVector(l,$d5b33d7c30034067$var$_v3$1.z),u}static isFrontFacing(n,r,i,a){// strictly front facing
return $d5b33d7c30034067$var$_v0$1.subVectors(i,r),$d5b33d7c30034067$var$_v1$3.subVectors(n,r),0>$d5b33d7c30034067$var$_v0$1.cross($d5b33d7c30034067$var$_v1$3).dot(a)}set(n,r,i){return this.a.copy(n),this.b.copy(r),this.c.copy(i),this}setFromPointsAndIndices(n,r,i,a){return this.a.copy(n[r]),this.b.copy(n[i]),this.c.copy(n[a]),this}setFromAttributeAndIndices(n,r,i,a){return this.a.fromBufferAttribute(n,r),this.b.fromBufferAttribute(n,i),this.c.fromBufferAttribute(n,a),this}clone(){return new this.constructor().copy(this)}copy(n){return this.a.copy(n.a),this.b.copy(n.b),this.c.copy(n.c),this}getArea(){return $d5b33d7c30034067$var$_v0$1.subVectors(this.c,this.b),$d5b33d7c30034067$var$_v1$3.subVectors(this.a,this.b),.5*$d5b33d7c30034067$var$_v0$1.cross($d5b33d7c30034067$var$_v1$3).length()}getMidpoint(n){return n.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(n){return $d5b33d7c30034067$export$5a465592bfe74b48.getNormal(this.a,this.b,this.c,n)}getPlane(n){return n.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(n,r){return $d5b33d7c30034067$export$5a465592bfe74b48.getBarycoord(n,this.a,this.b,this.c,r)}getUV(n,r,i,a,s){return!1===$d5b33d7c30034067$var$warnedGetUV&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),$d5b33d7c30034067$var$warnedGetUV=!0),$d5b33d7c30034067$export$5a465592bfe74b48.getInterpolation(n,this.a,this.b,this.c,r,i,a,s)}getInterpolation(n,r,i,a,s){return $d5b33d7c30034067$export$5a465592bfe74b48.getInterpolation(n,this.a,this.b,this.c,r,i,a,s)}containsPoint(n){return $d5b33d7c30034067$export$5a465592bfe74b48.containsPoint(n,this.a,this.b,this.c)}isFrontFacing(n){return $d5b33d7c30034067$export$5a465592bfe74b48.isFrontFacing(this.a,this.b,this.c,n)}intersectsBox(n){return n.intersectsTriangle(this)}closestPointToPoint(n,r){let i,a;let s=this.a,o=this.b,l=this.c;// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
// under the accompanying license; see chapter 5.1.5 for detailed explanation.
// basically, we're distinguishing which of the voronoi regions of the triangle
// the point lies in with the minimum amount of redundant computation.
$d5b33d7c30034067$var$_vab.subVectors(o,s),$d5b33d7c30034067$var$_vac.subVectors(l,s),$d5b33d7c30034067$var$_vap.subVectors(n,s);let u=$d5b33d7c30034067$var$_vab.dot($d5b33d7c30034067$var$_vap),c=$d5b33d7c30034067$var$_vac.dot($d5b33d7c30034067$var$_vap);if(u<=0&&c<=0)return r.copy(s);$d5b33d7c30034067$var$_vbp.subVectors(n,o);let h=$d5b33d7c30034067$var$_vab.dot($d5b33d7c30034067$var$_vbp),d=$d5b33d7c30034067$var$_vac.dot($d5b33d7c30034067$var$_vbp);if(h>=0&&d<=h)return r.copy(o);let p=u*d-h*c;if(p<=0&&u>=0&&h<=0)// edge region of AB; barycentric coords (1-v, v, 0)
return i=u/(u-h),r.copy(s).addScaledVector($d5b33d7c30034067$var$_vab,i);$d5b33d7c30034067$var$_vcp.subVectors(n,l);let f=$d5b33d7c30034067$var$_vab.dot($d5b33d7c30034067$var$_vcp),m=$d5b33d7c30034067$var$_vac.dot($d5b33d7c30034067$var$_vcp);if(m>=0&&f<=m)return r.copy(l);let g=f*c-u*m;if(g<=0&&c>=0&&m<=0)// edge region of AC; barycentric coords (1-w, 0, w)
return a=c/(c-m),r.copy(s).addScaledVector($d5b33d7c30034067$var$_vac,a);let _=h*m-f*d;if(_<=0&&d-h>=0&&f-m>=0)// edge region of BC; barycentric coords (0, 1-w, w)
return $d5b33d7c30034067$var$_vbc.subVectors(l,o),a=(d-h)/(d-h+(f-m)),r.copy(o).addScaledVector($d5b33d7c30034067$var$_vbc,a);// edge region of BC
// face region
let y=1/(_+g+p);return(// u = va * denom
i=g*y,a=p*y,r.copy(s).addScaledVector($d5b33d7c30034067$var$_vab,i).addScaledVector($d5b33d7c30034067$var$_vac,a))}equals(n){return n.a.equals(this.a)&&n.b.equals(this.b)&&n.c.equals(this.c)}}let $d5b33d7c30034067$var$_materialId=0;class $d5b33d7c30034067$export$a2d8b23205c25948 extends $d5b33d7c30034067$export$ec8b666c5fe2c75a{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:$d5b33d7c30034067$var$_materialId++}),this.uuid=$d5b33d7c30034067$var$generateUUID(),this.name="",this.type="Material",this.blending=$d5b33d7c30034067$export$5b29a26d96ee6af0,this.side=$d5b33d7c30034067$export$2ede184fc2998901,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=$d5b33d7c30034067$export$d5773124e86cf28c,this.blendDst=$d5b33d7c30034067$export$11d468cc7f19e971,this.blendEquation=$d5b33d7c30034067$export$20183a0484ce21a0,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=$d5b33d7c30034067$export$296f78a0b892f81a,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=$d5b33d7c30034067$export$14cf96713ddd97a8,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=$d5b33d7c30034067$export$9f542ae4b5baca34,this.stencilZFail=$d5b33d7c30034067$export$9f542ae4b5baca34,this.stencilZPass=$d5b33d7c30034067$export$9f542ae4b5baca34,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(n){this._alphaTest>0!=n>0&&this.version++,this._alphaTest=n}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(n){if(void 0!==n)for(let r in n){let i=n[r];if(void 0===i){console.warn(`THREE.Material: parameter '${r}' has value of undefined.`);continue}let a=this[r];if(void 0===a){console.warn(`THREE.Material: '${r}' is not a property of THREE.${this.type}.`);continue}a&&a.isColor?a.set(i):a&&a.isVector3&&i&&i.isVector3?a.copy(i):this[r]=i}}toJSON(n){let r=void 0===n||"string"==typeof n;r&&(n={textures:{},images:{}});let i={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};// TODO: Copied from Object3D.toJSON
function a(n){let r=[];for(let i in n){let a=n[i];delete a.metadata,r.push(a)}return r}if(// standard Material serialization
i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),void 0!==this.roughness&&(i.roughness=this.roughness),void 0!==this.metalness&&(i.metalness=this.metalness),void 0!==this.sheen&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(i.shininess=this.shininess),void 0!==this.clearcoat&&(i.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(n).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(n).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(n).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(i.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(i.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(n).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(n).uuid),void 0!==this.anisotropy&&(i.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(n).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(n).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(n).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(n).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(n).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(n).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(n).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(n).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(n).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(n).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(n).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(n).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(n).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(n).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(n).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(n).uuid,void 0!==this.combine&&(i.combine=this.combine)),void 0!==this.envMapIntensity&&(i.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(i.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(n).uuid),void 0!==this.transmission&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(n).uuid),void 0!==this.thickness&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(n).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(i.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(i.size=this.size),null!==this.shadowSide&&(i.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==$d5b33d7c30034067$export$5b29a26d96ee6af0&&(i.blending=this.blending),this.side!==$d5b33d7c30034067$export$2ede184fc2998901&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),!0===this.transparent&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(i.rotation=this.rotation),!0===this.polygonOffset&&(i.polygonOffset=!0),0!==this.polygonOffsetFactor&&(i.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(i.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(i.linewidth=this.linewidth),void 0!==this.dashSize&&(i.dashSize=this.dashSize),void 0!==this.gapSize&&(i.gapSize=this.gapSize),void 0!==this.scale&&(i.scale=this.scale),!0===this.dithering&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),!0===this.alphaHash&&(i.alphaHash=this.alphaHash),!0===this.alphaToCoverage&&(i.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(i.premultipliedAlpha=this.premultipliedAlpha),!0===this.forceSinglePass&&(i.forceSinglePass=this.forceSinglePass),!0===this.wireframe&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(i.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(i.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(i.flatShading=this.flatShading),!1===this.visible&&(i.visible=!1),!1===this.toneMapped&&(i.toneMapped=!1),!1===this.fog&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData),r){let r=a(n.textures),s=a(n.images);r.length>0&&(i.textures=r),s.length>0&&(i.images=s)}return i}clone(){return new this.constructor().copy(this)}copy(n){this.name=n.name,this.blending=n.blending,this.side=n.side,this.vertexColors=n.vertexColors,this.opacity=n.opacity,this.transparent=n.transparent,this.blendSrc=n.blendSrc,this.blendDst=n.blendDst,this.blendEquation=n.blendEquation,this.blendSrcAlpha=n.blendSrcAlpha,this.blendDstAlpha=n.blendDstAlpha,this.blendEquationAlpha=n.blendEquationAlpha,this.depthFunc=n.depthFunc,this.depthTest=n.depthTest,this.depthWrite=n.depthWrite,this.stencilWriteMask=n.stencilWriteMask,this.stencilFunc=n.stencilFunc,this.stencilRef=n.stencilRef,this.stencilFuncMask=n.stencilFuncMask,this.stencilFail=n.stencilFail,this.stencilZFail=n.stencilZFail,this.stencilZPass=n.stencilZPass,this.stencilWrite=n.stencilWrite;let r=n.clippingPlanes,i=null;if(null!==r){let n=r.length;i=Array(n);for(let a=0;a!==n;++a)i[a]=r[a].clone()}return this.clippingPlanes=i,this.clipIntersection=n.clipIntersection,this.clipShadows=n.clipShadows,this.shadowSide=n.shadowSide,this.colorWrite=n.colorWrite,this.precision=n.precision,this.polygonOffset=n.polygonOffset,this.polygonOffsetFactor=n.polygonOffsetFactor,this.polygonOffsetUnits=n.polygonOffsetUnits,this.dithering=n.dithering,this.alphaTest=n.alphaTest,this.alphaHash=n.alphaHash,this.alphaToCoverage=n.alphaToCoverage,this.premultipliedAlpha=n.premultipliedAlpha,this.forceSinglePass=n.forceSinglePass,this.visible=n.visible,this.toneMapped=n.toneMapped,this.userData=JSON.parse(JSON.stringify(n.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(n){!0===n&&this.version++}}const $d5b33d7c30034067$var$_colorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},$d5b33d7c30034067$var$_hslA={h:0,s:0,l:0},$d5b33d7c30034067$var$_hslB={h:0,s:0,l:0};function $d5b33d7c30034067$var$hue2rgb(n,r,i){return(i<0&&(i+=1),i>1&&(i-=1),i<1/6)?n+(r-n)*6*i:i<.5?r:i<2/3?n+(r-n)*6*(2/3-i):n}class $d5b33d7c30034067$export$892596cec99bc70e{constructor(n,r,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(n,r,i)}set(n,r,i){if(void 0===r&&void 0===i){// r is THREE.Color, hex or string
let r=n;r&&r.isColor?this.copy(r):"number"==typeof r?this.setHex(r):"string"==typeof r&&this.setStyle(r)}else this.setRGB(n,r,i);return this}setScalar(n){return this.r=n,this.g=n,this.b=n,this}setHex(n,r=$d5b33d7c30034067$export$561f394b24edfcaa){return n=Math.floor(n),this.r=(n>>16&255)/255,this.g=(n>>8&255)/255,this.b=(255&n)/255,$d5b33d7c30034067$export$5e6fd513f44698c.toWorkingColorSpace(this,r),this}setRGB(n,r,i,a=$d5b33d7c30034067$export$5e6fd513f44698c.workingColorSpace){return this.r=n,this.g=r,this.b=i,$d5b33d7c30034067$export$5e6fd513f44698c.toWorkingColorSpace(this,a),this}setHSL(n,r,i,a=$d5b33d7c30034067$export$5e6fd513f44698c.workingColorSpace){if(// h,s,l ranges are in 0.0 - 1.0
n=$d5b33d7c30034067$var$euclideanModulo(n,1),r=$d5b33d7c30034067$var$clamp(r,0,1),i=$d5b33d7c30034067$var$clamp(i,0,1),0===r)this.r=this.g=this.b=i;else{let a=i<=.5?i*(1+r):i+r-i*r,s=2*i-a;this.r=$d5b33d7c30034067$var$hue2rgb(s,a,n+1/3),this.g=$d5b33d7c30034067$var$hue2rgb(s,a,n),this.b=$d5b33d7c30034067$var$hue2rgb(s,a,n-1/3)}return $d5b33d7c30034067$export$5e6fd513f44698c.toWorkingColorSpace(this,a),this}setStyle(n,r=$d5b33d7c30034067$export$561f394b24edfcaa){let i;function a(r){void 0!==r&&1>parseFloat(r)&&console.warn("THREE.Color: Alpha component of "+n+" will be ignored.")}if(i=/^(\w+)\(([^\)]*)\)/.exec(n)){let s;let o=i[1],l=i[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return(// rgb(255,0,0) rgba(255,0,0,0.5)
a(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,r));if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return(// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
a(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,r));break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return(// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
a(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,r));break;default:console.warn("THREE.Color: Unknown color model "+n)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(n)){// hex color
let a=i[1],s=a.length;if(3===s)return this.setRGB(parseInt(a.charAt(0),16)/15,parseInt(a.charAt(1),16)/15,parseInt(a.charAt(2),16)/15,r);if(6===s)return this.setHex(parseInt(a,16),r);console.warn("THREE.Color: Invalid hex color "+n)}else if(n&&n.length>0)return this.setColorName(n,r);return this}setColorName(n,r=$d5b33d7c30034067$export$561f394b24edfcaa){// color keywords
let i=$d5b33d7c30034067$var$_colorKeywords[n.toLowerCase()];return void 0!==i?this.setHex(i,r):console.warn("THREE.Color: Unknown color "+n),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(n){return this.r=n.r,this.g=n.g,this.b=n.b,this}copySRGBToLinear(n){return this.r=$d5b33d7c30034067$var$SRGBToLinear(n.r),this.g=$d5b33d7c30034067$var$SRGBToLinear(n.g),this.b=$d5b33d7c30034067$var$SRGBToLinear(n.b),this}copyLinearToSRGB(n){return this.r=$d5b33d7c30034067$var$LinearToSRGB(n.r),this.g=$d5b33d7c30034067$var$LinearToSRGB(n.g),this.b=$d5b33d7c30034067$var$LinearToSRGB(n.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(n=$d5b33d7c30034067$export$561f394b24edfcaa){return $d5b33d7c30034067$export$5e6fd513f44698c.fromWorkingColorSpace($d5b33d7c30034067$var$_color.copy(this),n),65536*Math.round($d5b33d7c30034067$var$clamp(255*$d5b33d7c30034067$var$_color.r,0,255))+256*Math.round($d5b33d7c30034067$var$clamp(255*$d5b33d7c30034067$var$_color.g,0,255))+Math.round($d5b33d7c30034067$var$clamp(255*$d5b33d7c30034067$var$_color.b,0,255))}getHexString(n=$d5b33d7c30034067$export$561f394b24edfcaa){return("000000"+this.getHex(n).toString(16)).slice(-6)}getHSL(n,r=$d5b33d7c30034067$export$5e6fd513f44698c.workingColorSpace){let i,a;// h,s,l ranges are in 0.0 - 1.0
$d5b33d7c30034067$export$5e6fd513f44698c.fromWorkingColorSpace($d5b33d7c30034067$var$_color.copy(this),r);let s=$d5b33d7c30034067$var$_color.r,o=$d5b33d7c30034067$var$_color.g,l=$d5b33d7c30034067$var$_color.b,u=Math.max(s,o,l),c=Math.min(s,o,l),h=(c+u)/2;if(c===u)i=0,a=0;else{let n=u-c;switch(a=h<=.5?n/(u+c):n/(2-u-c),u){case s:i=(o-l)/n+(o<l?6:0);break;case o:i=(l-s)/n+2;break;case l:i=(s-o)/n+4}i/=6}return n.h=i,n.s=a,n.l=h,n}getRGB(n,r=$d5b33d7c30034067$export$5e6fd513f44698c.workingColorSpace){return $d5b33d7c30034067$export$5e6fd513f44698c.fromWorkingColorSpace($d5b33d7c30034067$var$_color.copy(this),r),n.r=$d5b33d7c30034067$var$_color.r,n.g=$d5b33d7c30034067$var$_color.g,n.b=$d5b33d7c30034067$var$_color.b,n}getStyle(n=$d5b33d7c30034067$export$561f394b24edfcaa){$d5b33d7c30034067$export$5e6fd513f44698c.fromWorkingColorSpace($d5b33d7c30034067$var$_color.copy(this),n);let r=$d5b33d7c30034067$var$_color.r,i=$d5b33d7c30034067$var$_color.g,a=$d5b33d7c30034067$var$_color.b;return n!==$d5b33d7c30034067$export$561f394b24edfcaa?`color(${n} ${r.toFixed(3)} ${i.toFixed(3)} ${a.toFixed(3)})`:`rgb(${Math.round(255*r)},${Math.round(255*i)},${Math.round(255*a)})`}offsetHSL(n,r,i){return this.getHSL($d5b33d7c30034067$var$_hslA),$d5b33d7c30034067$var$_hslA.h+=n,$d5b33d7c30034067$var$_hslA.s+=r,$d5b33d7c30034067$var$_hslA.l+=i,this.setHSL($d5b33d7c30034067$var$_hslA.h,$d5b33d7c30034067$var$_hslA.s,$d5b33d7c30034067$var$_hslA.l),this}add(n){return this.r+=n.r,this.g+=n.g,this.b+=n.b,this}addColors(n,r){return this.r=n.r+r.r,this.g=n.g+r.g,this.b=n.b+r.b,this}addScalar(n){return this.r+=n,this.g+=n,this.b+=n,this}sub(n){return this.r=Math.max(0,this.r-n.r),this.g=Math.max(0,this.g-n.g),this.b=Math.max(0,this.b-n.b),this}multiply(n){return this.r*=n.r,this.g*=n.g,this.b*=n.b,this}multiplyScalar(n){return this.r*=n,this.g*=n,this.b*=n,this}lerp(n,r){return this.r+=(n.r-this.r)*r,this.g+=(n.g-this.g)*r,this.b+=(n.b-this.b)*r,this}lerpColors(n,r,i){return this.r=n.r+(r.r-n.r)*i,this.g=n.g+(r.g-n.g)*i,this.b=n.b+(r.b-n.b)*i,this}lerpHSL(n,r){this.getHSL($d5b33d7c30034067$var$_hslA),n.getHSL($d5b33d7c30034067$var$_hslB);let i=$d5b33d7c30034067$var$lerp($d5b33d7c30034067$var$_hslA.h,$d5b33d7c30034067$var$_hslB.h,r),a=$d5b33d7c30034067$var$lerp($d5b33d7c30034067$var$_hslA.s,$d5b33d7c30034067$var$_hslB.s,r),s=$d5b33d7c30034067$var$lerp($d5b33d7c30034067$var$_hslA.l,$d5b33d7c30034067$var$_hslB.l,r);return this.setHSL(i,a,s),this}setFromVector3(n){return this.r=n.x,this.g=n.y,this.b=n.z,this}applyMatrix3(n){let r=this.r,i=this.g,a=this.b,s=n.elements;return this.r=s[0]*r+s[3]*i+s[6]*a,this.g=s[1]*r+s[4]*i+s[7]*a,this.b=s[2]*r+s[5]*i+s[8]*a,this}equals(n){return n.r===this.r&&n.g===this.g&&n.b===this.b}fromArray(n,r=0){return this.r=n[r],this.g=n[r+1],this.b=n[r+2],this}toArray(n=[],r=0){return n[r]=this.r,n[r+1]=this.g,n[r+2]=this.b,n}fromBufferAttribute(n,r){return this.r=n.getX(r),this.g=n.getY(r),this.b=n.getZ(r),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const $d5b33d7c30034067$var$_color=/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e;$d5b33d7c30034067$export$892596cec99bc70e.NAMES=$d5b33d7c30034067$var$_colorKeywords;class $d5b33d7c30034067$export$55cbcc9b622fe1f5 extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=$d5b33d7c30034067$export$e50ac29801f1774d,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(n)}copy(n){return super.copy(n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.fog=n.fog,this}}// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
const $d5b33d7c30034067$var$_tables=/*@__PURE__*/$d5b33d7c30034067$var$_generateTables();function $d5b33d7c30034067$var$_generateTables(){// float32 to float16 helpers
let n=new ArrayBuffer(4),r=new Float32Array(n),i=new Uint32Array(n),a=new Uint32Array(512),s=new Uint32Array(512);for(let n=0;n<256;++n){let r=n-127;// very small number (0, -0)
r<-27?(a[n]=0,a[256|n]=32768,s[n]=24,s[256|n]=24):r<-14?(a[n]=1024>>-r-14,a[256|n]=1024>>-r-14|32768,s[n]=-r-1,s[256|n]=-r-1):r<=15?(a[n]=r+15<<10,a[256|n]=r+15<<10|32768,s[n]=13,s[256|n]=13):r<128?(a[n]=31744,a[256|n]=64512,s[n]=24,s[256|n]=24):(a[n]=31744,a[256|n]=64512,s[n]=13,s[256|n]=13)}// float16 to float32 helpers
let o=new Uint32Array(2048),l=new Uint32Array(64),u=new Uint32Array(64);for(let n=1;n<1024;++n){let r=n<<13,i=0;// zero pad mantissa bits
// normalized
for(;(8388608&r)==0;)r<<=1,i-=8388608;r&=-8388609,i+=947912704,o[n]=r|i}for(let n=1024;n<2048;++n)o[n]=939524096+(n-1024<<13);for(let n=1;n<31;++n)l[n]=n<<23;l[31]=1199570944,l[32]=2147483648;for(let n=33;n<63;++n)l[n]=2147483648+(n-32<<23);l[63]=3347054592;for(let n=1;n<64;++n)32!==n&&(u[n]=1024);return{floatView:r,uint32View:i,baseTable:a,shiftTable:s,mantissaTable:o,exponentTable:l,offsetTable:u}}// float32 to float16
function $d5b33d7c30034067$var$toHalfFloat(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=$d5b33d7c30034067$var$clamp(n,-65504,65504),$d5b33d7c30034067$var$_tables.floatView[0]=n;let r=$d5b33d7c30034067$var$_tables.uint32View[0],i=r>>23&511;return $d5b33d7c30034067$var$_tables.baseTable[i]+((8388607&r)>>$d5b33d7c30034067$var$_tables.shiftTable[i])}// float16 to float32
function $d5b33d7c30034067$var$fromHalfFloat(n){let r=n>>10;return $d5b33d7c30034067$var$_tables.uint32View[0]=$d5b33d7c30034067$var$_tables.mantissaTable[$d5b33d7c30034067$var$_tables.offsetTable[r]+(1023&n)]+$d5b33d7c30034067$var$_tables.exponentTable[r],$d5b33d7c30034067$var$_tables.floatView[0]}const $d5b33d7c30034067$export$11ce8b759162cc80={toHalfFloat:$d5b33d7c30034067$var$toHalfFloat,fromHalfFloat:$d5b33d7c30034067$var$fromHalfFloat},$d5b33d7c30034067$var$_vector$8=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vector2$1=/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1;class $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i=!1){if(Array.isArray(n))throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=n,this.itemSize=r,this.count=void 0!==n?n.length/r:0,this.normalized=i,this.usage=$d5b33d7c30034067$export$763e8360f4d7f77d,this.updateRange={offset:0,count:-1},this.gpuType=$d5b33d7c30034067$export$f6d331659b644596,this.version=0}onUploadCallback(){}set needsUpdate(n){!0===n&&this.version++}setUsage(n){return this.usage=n,this}copy(n){return this.name=n.name,this.array=new n.array.constructor(n.array),this.itemSize=n.itemSize,this.count=n.count,this.normalized=n.normalized,this.usage=n.usage,this.gpuType=n.gpuType,this}copyAt(n,r,i){n*=this.itemSize,i*=r.itemSize;for(let a=0,s=this.itemSize;a<s;a++)this.array[n+a]=r.array[i+a];return this}copyArray(n){return this.array.set(n),this}applyMatrix3(n){if(2===this.itemSize)for(let r=0,i=this.count;r<i;r++)$d5b33d7c30034067$var$_vector2$1.fromBufferAttribute(this,r),$d5b33d7c30034067$var$_vector2$1.applyMatrix3(n),this.setXY(r,$d5b33d7c30034067$var$_vector2$1.x,$d5b33d7c30034067$var$_vector2$1.y);else if(3===this.itemSize)for(let r=0,i=this.count;r<i;r++)$d5b33d7c30034067$var$_vector$8.fromBufferAttribute(this,r),$d5b33d7c30034067$var$_vector$8.applyMatrix3(n),this.setXYZ(r,$d5b33d7c30034067$var$_vector$8.x,$d5b33d7c30034067$var$_vector$8.y,$d5b33d7c30034067$var$_vector$8.z);return this}applyMatrix4(n){for(let r=0,i=this.count;r<i;r++)$d5b33d7c30034067$var$_vector$8.fromBufferAttribute(this,r),$d5b33d7c30034067$var$_vector$8.applyMatrix4(n),this.setXYZ(r,$d5b33d7c30034067$var$_vector$8.x,$d5b33d7c30034067$var$_vector$8.y,$d5b33d7c30034067$var$_vector$8.z);return this}applyNormalMatrix(n){for(let r=0,i=this.count;r<i;r++)$d5b33d7c30034067$var$_vector$8.fromBufferAttribute(this,r),$d5b33d7c30034067$var$_vector$8.applyNormalMatrix(n),this.setXYZ(r,$d5b33d7c30034067$var$_vector$8.x,$d5b33d7c30034067$var$_vector$8.y,$d5b33d7c30034067$var$_vector$8.z);return this}transformDirection(n){for(let r=0,i=this.count;r<i;r++)$d5b33d7c30034067$var$_vector$8.fromBufferAttribute(this,r),$d5b33d7c30034067$var$_vector$8.transformDirection(n),this.setXYZ(r,$d5b33d7c30034067$var$_vector$8.x,$d5b33d7c30034067$var$_vector$8.y,$d5b33d7c30034067$var$_vector$8.z);return this}set(n,r=0){return(// Matching BufferAttribute constructor, do not normalize the array.
this.array.set(n,r),this)}getComponent(n,r){let i=this.array[n*this.itemSize+r];return this.normalized&&(i=$d5b33d7c30034067$var$denormalize(i,this.array)),i}setComponent(n,r,i){return this.normalized&&(i=$d5b33d7c30034067$var$normalize(i,this.array)),this.array[n*this.itemSize+r]=i,this}getX(n){let r=this.array[n*this.itemSize];return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}setX(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.array[n*this.itemSize]=r,this}getY(n){let r=this.array[n*this.itemSize+1];return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}setY(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.array[n*this.itemSize+1]=r,this}getZ(n){let r=this.array[n*this.itemSize+2];return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}setZ(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.array[n*this.itemSize+2]=r,this}getW(n){let r=this.array[n*this.itemSize+3];return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}setW(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.array[n*this.itemSize+3]=r,this}setXY(n,r,i){return n*=this.itemSize,this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array),i=$d5b33d7c30034067$var$normalize(i,this.array)),this.array[n+0]=r,this.array[n+1]=i,this}setXYZ(n,r,i,a){return n*=this.itemSize,this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array),i=$d5b33d7c30034067$var$normalize(i,this.array),a=$d5b33d7c30034067$var$normalize(a,this.array)),this.array[n+0]=r,this.array[n+1]=i,this.array[n+2]=a,this}setXYZW(n,r,i,a,s){return n*=this.itemSize,this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array),i=$d5b33d7c30034067$var$normalize(i,this.array),a=$d5b33d7c30034067$var$normalize(a,this.array),s=$d5b33d7c30034067$var$normalize(s,this.array)),this.array[n+0]=r,this.array[n+1]=i,this.array[n+2]=a,this.array[n+3]=s,this}onUpload(n){return this.onUploadCallback=n,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){let n={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(n.name=this.name),this.usage!==$d5b33d7c30034067$export$763e8360f4d7f77d&&(n.usage=this.usage),(0!==this.updateRange.offset||-1!==this.updateRange.count)&&(n.updateRange=this.updateRange),n}}//
class $d5b33d7c30034067$export$f9ff2d6a20248cbf extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i){super(new Int8Array(n),r,i)}}class $d5b33d7c30034067$export$cacc90cf35d11cdd extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i){super(new Uint8Array(n),r,i)}}class $d5b33d7c30034067$export$baaa85a1a812c157 extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i){super(new Uint8ClampedArray(n),r,i)}}class $d5b33d7c30034067$export$2b755a102ccdcefe extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i){super(new Int16Array(n),r,i)}}class $d5b33d7c30034067$export$640a853f68025f2e extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i){super(new Uint16Array(n),r,i)}}class $d5b33d7c30034067$export$46b369aed2968a0a extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i){super(new Int32Array(n),r,i)}}class $d5b33d7c30034067$export$7eb8c9fa25cd5bd6 extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i){super(new Uint32Array(n),r,i)}}class $d5b33d7c30034067$export$dbd3698c64958d69 extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i){super(new Uint16Array(n),r,i),this.isFloat16BufferAttribute=!0}getX(n){let r=$d5b33d7c30034067$var$fromHalfFloat(this.array[n*this.itemSize]);return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}setX(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.array[n*this.itemSize]=$d5b33d7c30034067$var$toHalfFloat(r),this}getY(n){let r=$d5b33d7c30034067$var$fromHalfFloat(this.array[n*this.itemSize+1]);return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}setY(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.array[n*this.itemSize+1]=$d5b33d7c30034067$var$toHalfFloat(r),this}getZ(n){let r=$d5b33d7c30034067$var$fromHalfFloat(this.array[n*this.itemSize+2]);return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}setZ(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.array[n*this.itemSize+2]=$d5b33d7c30034067$var$toHalfFloat(r),this}getW(n){let r=$d5b33d7c30034067$var$fromHalfFloat(this.array[n*this.itemSize+3]);return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}setW(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.array[n*this.itemSize+3]=$d5b33d7c30034067$var$toHalfFloat(r),this}setXY(n,r,i){return n*=this.itemSize,this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array),i=$d5b33d7c30034067$var$normalize(i,this.array)),this.array[n+0]=$d5b33d7c30034067$var$toHalfFloat(r),this.array[n+1]=$d5b33d7c30034067$var$toHalfFloat(i),this}setXYZ(n,r,i,a){return n*=this.itemSize,this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array),i=$d5b33d7c30034067$var$normalize(i,this.array),a=$d5b33d7c30034067$var$normalize(a,this.array)),this.array[n+0]=$d5b33d7c30034067$var$toHalfFloat(r),this.array[n+1]=$d5b33d7c30034067$var$toHalfFloat(i),this.array[n+2]=$d5b33d7c30034067$var$toHalfFloat(a),this}setXYZW(n,r,i,a,s){return n*=this.itemSize,this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array),i=$d5b33d7c30034067$var$normalize(i,this.array),a=$d5b33d7c30034067$var$normalize(a,this.array),s=$d5b33d7c30034067$var$normalize(s,this.array)),this.array[n+0]=$d5b33d7c30034067$var$toHalfFloat(r),this.array[n+1]=$d5b33d7c30034067$var$toHalfFloat(i),this.array[n+2]=$d5b33d7c30034067$var$toHalfFloat(a),this.array[n+3]=$d5b33d7c30034067$var$toHalfFloat(s),this}}class $d5b33d7c30034067$export$cbe7a62641830ebd extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i){super(new Float32Array(n),r,i)}}class $d5b33d7c30034067$export$9e0ade74842adbb8 extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i){super(new Float64Array(n),r,i)}}let $d5b33d7c30034067$var$_id$2=0;const $d5b33d7c30034067$var$_m1=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_obj=/*@__PURE__*/new $d5b33d7c30034067$export$e4dd07dff30cc924,$d5b33d7c30034067$var$_offset=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_box$1=/*@__PURE__*/new $d5b33d7c30034067$export$6f7d5a9418ab2aa3,$d5b33d7c30034067$var$_boxMorphTargets=/*@__PURE__*/new $d5b33d7c30034067$export$6f7d5a9418ab2aa3,$d5b33d7c30034067$var$_vector$7=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$b7be63a67df8959 extends $d5b33d7c30034067$export$ec8b666c5fe2c75a{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:$d5b33d7c30034067$var$_id$2++}),this.uuid=$d5b33d7c30034067$var$generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(n){return Array.isArray(n)?this.index=new($d5b33d7c30034067$var$arrayNeedsUint32(n)?$d5b33d7c30034067$export$7eb8c9fa25cd5bd6:$d5b33d7c30034067$export$640a853f68025f2e)(n,1):this.index=n,this}getAttribute(n){return this.attributes[n]}setAttribute(n,r){return this.attributes[n]=r,this}deleteAttribute(n){return delete this.attributes[n],this}hasAttribute(n){return void 0!==this.attributes[n]}addGroup(n,r,i=0){this.groups.push({start:n,count:r,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(n,r){this.drawRange.start=n,this.drawRange.count=r}applyMatrix4(n){let r=this.attributes.position;void 0!==r&&(r.applyMatrix4(n),r.needsUpdate=!0);let i=this.attributes.normal;if(void 0!==i){let r=new $d5b33d7c30034067$export$8ff26dafa08918().getNormalMatrix(n);i.applyNormalMatrix(r),i.needsUpdate=!0}let a=this.attributes.tangent;return void 0!==a&&(a.transformDirection(n),a.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(n){return $d5b33d7c30034067$var$_m1.makeRotationFromQuaternion(n),this.applyMatrix4($d5b33d7c30034067$var$_m1),this}rotateX(n){return(// rotate geometry around world x-axis
$d5b33d7c30034067$var$_m1.makeRotationX(n),this.applyMatrix4($d5b33d7c30034067$var$_m1),this)}rotateY(n){return(// rotate geometry around world y-axis
$d5b33d7c30034067$var$_m1.makeRotationY(n),this.applyMatrix4($d5b33d7c30034067$var$_m1),this)}rotateZ(n){return(// rotate geometry around world z-axis
$d5b33d7c30034067$var$_m1.makeRotationZ(n),this.applyMatrix4($d5b33d7c30034067$var$_m1),this)}translate(n,r,i){return(// translate geometry
$d5b33d7c30034067$var$_m1.makeTranslation(n,r,i),this.applyMatrix4($d5b33d7c30034067$var$_m1),this)}scale(n,r,i){return(// scale geometry
$d5b33d7c30034067$var$_m1.makeScale(n,r,i),this.applyMatrix4($d5b33d7c30034067$var$_m1),this)}lookAt(n){return $d5b33d7c30034067$var$_obj.lookAt(n),$d5b33d7c30034067$var$_obj.updateMatrix(),this.applyMatrix4($d5b33d7c30034067$var$_obj.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter($d5b33d7c30034067$var$_offset).negate(),this.translate($d5b33d7c30034067$var$_offset.x,$d5b33d7c30034067$var$_offset.y,$d5b33d7c30034067$var$_offset.z),this}setFromPoints(n){let r=[];for(let i=0,a=n.length;i<a;i++){let a=n[i];r.push(a.x,a.y,a.z||0)}return this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(r,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new $d5b33d7c30034067$export$6f7d5a9418ab2aa3);let n=this.attributes.position,r=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new $d5b33d7c30034067$export$64b5c384219d3699(-1/0,-1/0,-1/0),new $d5b33d7c30034067$export$64b5c384219d3699(1/0,1/0,1/0));return}if(void 0!==n)// process morph attributes if present
{if(this.boundingBox.setFromBufferAttribute(n),r)for(let n=0,i=r.length;n<i;n++){let i=r[n];$d5b33d7c30034067$var$_box$1.setFromBufferAttribute(i),this.morphTargetsRelative?($d5b33d7c30034067$var$_vector$7.addVectors(this.boundingBox.min,$d5b33d7c30034067$var$_box$1.min),this.boundingBox.expandByPoint($d5b33d7c30034067$var$_vector$7),$d5b33d7c30034067$var$_vector$7.addVectors(this.boundingBox.max,$d5b33d7c30034067$var$_box$1.max),this.boundingBox.expandByPoint($d5b33d7c30034067$var$_vector$7)):(this.boundingBox.expandByPoint($d5b33d7c30034067$var$_box$1.min),this.boundingBox.expandByPoint($d5b33d7c30034067$var$_box$1.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new $d5b33d7c30034067$export$805e8b72413ccaba);let n=this.attributes.position,r=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new $d5b33d7c30034067$export$64b5c384219d3699,1/0);return}if(n){// first, find the center of the bounding sphere
let i=this.boundingSphere.center;// process morph attributes if present
if($d5b33d7c30034067$var$_box$1.setFromBufferAttribute(n),r)for(let n=0,i=r.length;n<i;n++){let i=r[n];$d5b33d7c30034067$var$_boxMorphTargets.setFromBufferAttribute(i),this.morphTargetsRelative?($d5b33d7c30034067$var$_vector$7.addVectors($d5b33d7c30034067$var$_box$1.min,$d5b33d7c30034067$var$_boxMorphTargets.min),$d5b33d7c30034067$var$_box$1.expandByPoint($d5b33d7c30034067$var$_vector$7),$d5b33d7c30034067$var$_vector$7.addVectors($d5b33d7c30034067$var$_box$1.max,$d5b33d7c30034067$var$_boxMorphTargets.max),$d5b33d7c30034067$var$_box$1.expandByPoint($d5b33d7c30034067$var$_vector$7)):($d5b33d7c30034067$var$_box$1.expandByPoint($d5b33d7c30034067$var$_boxMorphTargets.min),$d5b33d7c30034067$var$_box$1.expandByPoint($d5b33d7c30034067$var$_boxMorphTargets.max))}$d5b33d7c30034067$var$_box$1.getCenter(i);// second, try to find a boundingSphere with a radius smaller than the
// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
let a=0;for(let r=0,s=n.count;r<s;r++)$d5b33d7c30034067$var$_vector$7.fromBufferAttribute(n,r),a=Math.max(a,i.distanceToSquared($d5b33d7c30034067$var$_vector$7));// process morph attributes if present
if(r)for(let s=0,o=r.length;s<o;s++){let o=r[s],l=this.morphTargetsRelative;for(let r=0,s=o.count;r<s;r++)$d5b33d7c30034067$var$_vector$7.fromBufferAttribute(o,r),l&&($d5b33d7c30034067$var$_offset.fromBufferAttribute(n,r),$d5b33d7c30034067$var$_vector$7.add($d5b33d7c30034067$var$_offset)),a=Math.max(a,i.distanceToSquared($d5b33d7c30034067$var$_vector$7))}this.boundingSphere.radius=Math.sqrt(a),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){let n=this.index,r=this.attributes;// based on http://www.terathon.com/code/tangent.html
// (per vertex tangents)
if(null===n||void 0===r.position||void 0===r.normal||void 0===r.uv){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}let i=n.array,a=r.position.array,s=r.normal.array,o=r.uv.array,l=a.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new $d5b33d7c30034067$export$8dea267bd6bde117(new Float32Array(4*l),4));let u=this.getAttribute("tangent").array,c=[],h=[];for(let n=0;n<l;n++)c[n]=new $d5b33d7c30034067$export$64b5c384219d3699,h[n]=new $d5b33d7c30034067$export$64b5c384219d3699;let d=new $d5b33d7c30034067$export$64b5c384219d3699,p=new $d5b33d7c30034067$export$64b5c384219d3699,f=new $d5b33d7c30034067$export$64b5c384219d3699,m=new $d5b33d7c30034067$export$c977b3e384af9ae1,g=new $d5b33d7c30034067$export$c977b3e384af9ae1,_=new $d5b33d7c30034067$export$c977b3e384af9ae1,y=new $d5b33d7c30034067$export$64b5c384219d3699,b=new $d5b33d7c30034067$export$64b5c384219d3699;function v(n,r,i){d.fromArray(a,3*n),p.fromArray(a,3*r),f.fromArray(a,3*i),m.fromArray(o,2*n),g.fromArray(o,2*r),_.fromArray(o,2*i),p.sub(d),f.sub(d),g.sub(m),_.sub(m);let s=1/(g.x*_.y-_.x*g.y);isFinite(s)&&(y.copy(p).multiplyScalar(_.y).addScaledVector(f,-g.y).multiplyScalar(s),b.copy(f).multiplyScalar(g.x).addScaledVector(p,-_.x).multiplyScalar(s),c[n].add(y),c[r].add(y),c[i].add(y),h[n].add(b),h[r].add(b),h[i].add(b))}let x=this.groups;0===x.length&&(x=[{start:0,count:i.length}]);for(let n=0,r=x.length;n<r;++n){let r=x[n],a=r.start,s=r.count;for(let n=a,r=a+s;n<r;n+=3)v(i[n+0],i[n+1],i[n+2])}let w=new $d5b33d7c30034067$export$64b5c384219d3699,T=new $d5b33d7c30034067$export$64b5c384219d3699,S=new $d5b33d7c30034067$export$64b5c384219d3699,E=new $d5b33d7c30034067$export$64b5c384219d3699;function A(n){S.fromArray(s,3*n),E.copy(S);let r=c[n];// Gram-Schmidt orthogonalize
w.copy(r),w.sub(S.multiplyScalar(S.dot(r))).normalize(),// Calculate handedness
T.crossVectors(E,r);let i=T.dot(h[n]),a=i<0?-1:1;u[4*n]=w.x,u[4*n+1]=w.y,u[4*n+2]=w.z,u[4*n+3]=a}for(let n=0,r=x.length;n<r;++n){let r=x[n],a=r.start,s=r.count;for(let n=a,r=a+s;n<r;n+=3)A(i[n+0]),A(i[n+1]),A(i[n+2])}}computeVertexNormals(){let n=this.index,r=this.getAttribute("position");if(void 0!==r){let i=this.getAttribute("normal");if(void 0===i)i=new $d5b33d7c30034067$export$8dea267bd6bde117(new Float32Array(3*r.count),3),this.setAttribute("normal",i);else for(let n=0,r=i.count;n<r;n++)i.setXYZ(n,0,0,0);let a=new $d5b33d7c30034067$export$64b5c384219d3699,s=new $d5b33d7c30034067$export$64b5c384219d3699,o=new $d5b33d7c30034067$export$64b5c384219d3699,l=new $d5b33d7c30034067$export$64b5c384219d3699,u=new $d5b33d7c30034067$export$64b5c384219d3699,c=new $d5b33d7c30034067$export$64b5c384219d3699,h=new $d5b33d7c30034067$export$64b5c384219d3699,d=new $d5b33d7c30034067$export$64b5c384219d3699;// indexed elements
if(n)for(let p=0,f=n.count;p<f;p+=3){let f=n.getX(p+0),m=n.getX(p+1),g=n.getX(p+2);a.fromBufferAttribute(r,f),s.fromBufferAttribute(r,m),o.fromBufferAttribute(r,g),h.subVectors(o,s),d.subVectors(a,s),h.cross(d),l.fromBufferAttribute(i,f),u.fromBufferAttribute(i,m),c.fromBufferAttribute(i,g),l.add(h),u.add(h),c.add(h),i.setXYZ(f,l.x,l.y,l.z),i.setXYZ(m,u.x,u.y,u.z),i.setXYZ(g,c.x,c.y,c.z)}else for(let n=0,l=r.count;n<l;n+=3)a.fromBufferAttribute(r,n+0),s.fromBufferAttribute(r,n+1),o.fromBufferAttribute(r,n+2),h.subVectors(o,s),d.subVectors(a,s),h.cross(d),i.setXYZ(n+0,h.x,h.y,h.z),i.setXYZ(n+1,h.x,h.y,h.z),i.setXYZ(n+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){let n=this.attributes.normal;for(let r=0,i=n.count;r<i;r++)$d5b33d7c30034067$var$_vector$7.fromBufferAttribute(n,r),$d5b33d7c30034067$var$_vector$7.normalize(),n.setXYZ(r,$d5b33d7c30034067$var$_vector$7.x,$d5b33d7c30034067$var$_vector$7.y,$d5b33d7c30034067$var$_vector$7.z)}toNonIndexed(){function n(n,r){let i=n.array,a=n.itemSize,s=n.normalized,o=new i.constructor(r.length*a),l=0,u=0;for(let s=0,c=r.length;s<c;s++){l=n.isInterleavedBufferAttribute?r[s]*n.data.stride+n.offset:r[s]*a;for(let n=0;n<a;n++)o[u++]=i[l++]}return new $d5b33d7c30034067$export$8dea267bd6bde117(o,a,s)}//
if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;let r=new $d5b33d7c30034067$export$b7be63a67df8959,i=this.index.array,a=this.attributes;// attributes
for(let s in a){let o=a[s],l=n(o,i);r.setAttribute(s,l)}// morph attributes
let s=this.morphAttributes;for(let a in s){let o=[],l=s[a];for(let r=0,a=l.length;r<a;r++){let a=l[r],s=n(a,i);o.push(s)}r.morphAttributes[a]=o}r.morphTargetsRelative=this.morphTargetsRelative;// groups
let o=this.groups;for(let n=0,i=o.length;n<i;n++){let i=o[n];r.addGroup(i.start,i.count,i.materialIndex)}return r}toJSON(){let n={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(// standard BufferGeometry serialization
n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),Object.keys(this.userData).length>0&&(n.userData=this.userData),void 0!==this.parameters){let r=this.parameters;for(let i in r)void 0!==r[i]&&(n[i]=r[i]);return n}// for simplicity the code assumes attributes are not shared across geometries, see #15811
n.data={attributes:{}};let r=this.index;null!==r&&(n.data.index={type:r.array.constructor.name,array:Array.prototype.slice.call(r.array)});let i=this.attributes;for(let r in i){let a=i[r];n.data.attributes[r]=a.toJSON(n.data)}let a={},s=!1;for(let r in this.morphAttributes){let i=this.morphAttributes[r],o=[];for(let r=0,a=i.length;r<a;r++){let a=i[r];o.push(a.toJSON(n.data))}o.length>0&&(a[r]=o,s=!0)}s&&(n.data.morphAttributes=a,n.data.morphTargetsRelative=this.morphTargetsRelative);let o=this.groups;o.length>0&&(n.data.groups=JSON.parse(JSON.stringify(o)));let l=this.boundingSphere;return null!==l&&(n.data.boundingSphere={center:l.center.toArray(),radius:l.radius}),n}clone(){return new this.constructor().copy(this)}copy(n){// reset
this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;// used for storing cloned, shared data
let r={};// name
this.name=n.name;// index
let i=n.index;null!==i&&this.setIndex(i.clone(r));// attributes
let a=n.attributes;for(let n in a){let i=a[n];this.setAttribute(n,i.clone(r))}// morph attributes
let s=n.morphAttributes;for(let n in s){let i=[],a=s[n];for(let n=0,s=a.length;n<s;n++)i.push(a[n].clone(r));this.morphAttributes[n]=i}this.morphTargetsRelative=n.morphTargetsRelative;// groups
let o=n.groups;for(let n=0,r=o.length;n<r;n++){let r=o[n];this.addGroup(r.start,r.count,r.materialIndex)}// bounding box
let l=n.boundingBox;null!==l&&(this.boundingBox=l.clone());// bounding sphere
let u=n.boundingSphere;return null!==u&&(this.boundingSphere=u.clone()),// draw range
this.drawRange.start=n.drawRange.start,this.drawRange.count=n.drawRange.count,// user data
this.userData=n.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const $d5b33d7c30034067$var$_inverseMatrix$3=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_ray$3=/*@__PURE__*/new $d5b33d7c30034067$export$a186db52eed6d40e,$d5b33d7c30034067$var$_sphere$5=/*@__PURE__*/new $d5b33d7c30034067$export$805e8b72413ccaba,$d5b33d7c30034067$var$_sphereHitAt=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vA$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vB$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vC$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_tempA=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_morphA=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_uvA$1=/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1,$d5b33d7c30034067$var$_uvB$1=/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1,$d5b33d7c30034067$var$_uvC$1=/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1,$d5b33d7c30034067$var$_normalA=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_normalB=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_normalC=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_intersectionPoint=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_intersectionPointWorld=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$e176487c05830cc5 extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(n=new $d5b33d7c30034067$export$b7be63a67df8959,r=new $d5b33d7c30034067$export$55cbcc9b622fe1f5){super(),this.isMesh=!0,this.type="Mesh",this.geometry=n,this.material=r,this.updateMorphTargets()}copy(n,r){return super.copy(n,r),void 0!==n.morphTargetInfluences&&(this.morphTargetInfluences=n.morphTargetInfluences.slice()),void 0!==n.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},n.morphTargetDictionary)),this.material=Array.isArray(n.material)?n.material.slice():n.material,this.geometry=n.geometry,this}updateMorphTargets(){let n=this.geometry,r=n.morphAttributes,i=Object.keys(r);if(i.length>0){let n=r[i[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,i=n.length;r<i;r++){let i=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=r}}}}getVertexPosition(n,r){let i=this.geometry,a=i.attributes.position,s=i.morphAttributes.position,o=i.morphTargetsRelative;r.fromBufferAttribute(a,n);let l=this.morphTargetInfluences;if(s&&l){$d5b33d7c30034067$var$_morphA.set(0,0,0);for(let i=0,a=s.length;i<a;i++){let a=l[i],u=s[i];0!==a&&($d5b33d7c30034067$var$_tempA.fromBufferAttribute(u,n),o?$d5b33d7c30034067$var$_morphA.addScaledVector($d5b33d7c30034067$var$_tempA,a):$d5b33d7c30034067$var$_morphA.addScaledVector($d5b33d7c30034067$var$_tempA.sub(r),a))}r.add($d5b33d7c30034067$var$_morphA)}return r}raycast(n,r){let i=this.geometry,a=this.material,s=this.matrixWorld;if(void 0!==a){if(null===i.boundingSphere&&i.computeBoundingSphere(),$d5b33d7c30034067$var$_sphere$5.copy(i.boundingSphere),$d5b33d7c30034067$var$_sphere$5.applyMatrix4(s),// check distance from ray origin to bounding sphere
$d5b33d7c30034067$var$_ray$3.copy(n.ray).recast(n.near),!1===$d5b33d7c30034067$var$_sphere$5.containsPoint($d5b33d7c30034067$var$_ray$3.origin)&&(null===$d5b33d7c30034067$var$_ray$3.intersectSphere($d5b33d7c30034067$var$_sphere$5,$d5b33d7c30034067$var$_sphereHitAt)||$d5b33d7c30034067$var$_ray$3.origin.distanceToSquared($d5b33d7c30034067$var$_sphereHitAt)>(n.far-n.near)**2)||(// convert ray to local space of mesh
$d5b33d7c30034067$var$_inverseMatrix$3.copy(s).invert(),$d5b33d7c30034067$var$_ray$3.copy(n.ray).applyMatrix4($d5b33d7c30034067$var$_inverseMatrix$3),null!==i.boundingBox&&!1===$d5b33d7c30034067$var$_ray$3.intersectsBox(i.boundingBox)))return;// test for intersections with geometry
this._computeIntersections(n,r,$d5b33d7c30034067$var$_ray$3)}}_computeIntersections(n,r,i){let a;let s=this.geometry,o=this.material,l=s.index,u=s.attributes.position,c=s.attributes.uv,h=s.attributes.uv1,d=s.attributes.normal,p=s.groups,f=s.drawRange;if(null!==l){// indexed buffer geometry
if(Array.isArray(o))for(let s=0,u=p.length;s<u;s++){let u=p[s],m=o[u.materialIndex],g=Math.max(u.start,f.start),_=Math.min(l.count,Math.min(u.start+u.count,f.start+f.count));for(let s=g,o=_;s<o;s+=3){let o=l.getX(s),p=l.getX(s+1),f=l.getX(s+2);(a=$d5b33d7c30034067$var$checkGeometryIntersection(this,m,n,i,c,h,d,o,p,f))&&(a.faceIndex=Math.floor(s/3),a.face.materialIndex=u.materialIndex,r.push(a))}}else{let s=Math.max(0,f.start),u=Math.min(l.count,f.start+f.count);for(let p=s,f=u;p<f;p+=3){let s=l.getX(p),u=l.getX(p+1),f=l.getX(p+2);(a=$d5b33d7c30034067$var$checkGeometryIntersection(this,o,n,i,c,h,d,s,u,f))&&(a.faceIndex=Math.floor(p/3),r.push(a))}}}else if(void 0!==u){// non-indexed buffer geometry
if(Array.isArray(o))for(let s=0,l=p.length;s<l;s++){let l=p[s],m=o[l.materialIndex],g=Math.max(l.start,f.start),_=Math.min(u.count,Math.min(l.start+l.count,f.start+f.count));for(let s=g,o=_;s<o;s+=3){let o=s,u=s+1,p=s+2;(a=$d5b33d7c30034067$var$checkGeometryIntersection(this,m,n,i,c,h,d,o,u,p))&&(a.faceIndex=Math.floor(s/3),a.face.materialIndex=l.materialIndex,r.push(a))}}else{let s=Math.max(0,f.start),l=Math.min(u.count,f.start+f.count);for(let u=s,p=l;u<p;u+=3){let s=u,l=u+1,p=u+2;(a=$d5b33d7c30034067$var$checkGeometryIntersection(this,o,n,i,c,h,d,s,l,p))&&(a.faceIndex=Math.floor(u/3),r.push(a))}}}}}function $d5b33d7c30034067$var$checkIntersection(n,r,i,a,s,o,l,u){let c;if(null===(c=r.side===$d5b33d7c30034067$export$d9f0486e75b5ace?a.intersectTriangle(l,o,s,!0,u):a.intersectTriangle(s,o,l,r.side===$d5b33d7c30034067$export$2ede184fc2998901,u)))return null;$d5b33d7c30034067$var$_intersectionPointWorld.copy(u),$d5b33d7c30034067$var$_intersectionPointWorld.applyMatrix4(n.matrixWorld);let h=i.ray.origin.distanceTo($d5b33d7c30034067$var$_intersectionPointWorld);return h<i.near||h>i.far?null:{distance:h,point:$d5b33d7c30034067$var$_intersectionPointWorld.clone(),object:n}}function $d5b33d7c30034067$var$checkGeometryIntersection(n,r,i,a,s,o,l,u,c,h){n.getVertexPosition(u,$d5b33d7c30034067$var$_vA$1),n.getVertexPosition(c,$d5b33d7c30034067$var$_vB$1),n.getVertexPosition(h,$d5b33d7c30034067$var$_vC$1);let d=$d5b33d7c30034067$var$checkIntersection(n,r,i,a,$d5b33d7c30034067$var$_vA$1,$d5b33d7c30034067$var$_vB$1,$d5b33d7c30034067$var$_vC$1,$d5b33d7c30034067$var$_intersectionPoint);if(d){s&&($d5b33d7c30034067$var$_uvA$1.fromBufferAttribute(s,u),$d5b33d7c30034067$var$_uvB$1.fromBufferAttribute(s,c),$d5b33d7c30034067$var$_uvC$1.fromBufferAttribute(s,h),d.uv=$d5b33d7c30034067$export$5a465592bfe74b48.getInterpolation($d5b33d7c30034067$var$_intersectionPoint,$d5b33d7c30034067$var$_vA$1,$d5b33d7c30034067$var$_vB$1,$d5b33d7c30034067$var$_vC$1,$d5b33d7c30034067$var$_uvA$1,$d5b33d7c30034067$var$_uvB$1,$d5b33d7c30034067$var$_uvC$1,new $d5b33d7c30034067$export$c977b3e384af9ae1)),o&&($d5b33d7c30034067$var$_uvA$1.fromBufferAttribute(o,u),$d5b33d7c30034067$var$_uvB$1.fromBufferAttribute(o,c),$d5b33d7c30034067$var$_uvC$1.fromBufferAttribute(o,h),d.uv1=$d5b33d7c30034067$export$5a465592bfe74b48.getInterpolation($d5b33d7c30034067$var$_intersectionPoint,$d5b33d7c30034067$var$_vA$1,$d5b33d7c30034067$var$_vB$1,$d5b33d7c30034067$var$_vC$1,$d5b33d7c30034067$var$_uvA$1,$d5b33d7c30034067$var$_uvB$1,$d5b33d7c30034067$var$_uvC$1,new $d5b33d7c30034067$export$c977b3e384af9ae1),d.uv2=d.uv1),l&&($d5b33d7c30034067$var$_normalA.fromBufferAttribute(l,u),$d5b33d7c30034067$var$_normalB.fromBufferAttribute(l,c),$d5b33d7c30034067$var$_normalC.fromBufferAttribute(l,h),d.normal=$d5b33d7c30034067$export$5a465592bfe74b48.getInterpolation($d5b33d7c30034067$var$_intersectionPoint,$d5b33d7c30034067$var$_vA$1,$d5b33d7c30034067$var$_vB$1,$d5b33d7c30034067$var$_vC$1,$d5b33d7c30034067$var$_normalA,$d5b33d7c30034067$var$_normalB,$d5b33d7c30034067$var$_normalC,new $d5b33d7c30034067$export$64b5c384219d3699),d.normal.dot(a.direction)>0&&d.normal.multiplyScalar(-1));let n={a:u,b:c,c:h,normal:new $d5b33d7c30034067$export$64b5c384219d3699,materialIndex:0};$d5b33d7c30034067$export$5a465592bfe74b48.getNormal($d5b33d7c30034067$var$_vA$1,$d5b33d7c30034067$var$_vB$1,$d5b33d7c30034067$var$_vC$1,n.normal),d.face=n}return d}class $d5b33d7c30034067$export$33e43285f7406bd5 extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=1,r=1,i=1,a=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:n,height:r,depth:i,widthSegments:a,heightSegments:s,depthSegments:o};let l=this;// segments
a=Math.floor(a),s=Math.floor(s),o=Math.floor(o);// buffers
let u=[],c=[],h=[],d=[],p=0,f=0;function m(n,r,i,a,s,o,m,g,_,y,b){let v=o/_,x=m/y,w=o/2,T=m/2,S=g/2,E=_+1,A=y+1,M=0,I=0,P=new $d5b33d7c30034067$export$64b5c384219d3699;// generate vertices, normals and uvs
for(let o=0;o<A;o++){let l=o*x-T;for(let u=0;u<E;u++){let p=u*v-w;// set values to correct vector component
P[n]=p*a,P[r]=l*s,P[i]=S,// now apply vector to vertex buffer
c.push(P.x,P.y,P.z),// set values to correct vector component
P[n]=0,P[r]=0,P[i]=g>0?1:-1,// now apply vector to normal buffer
h.push(P.x,P.y,P.z),// uvs
d.push(u/_),d.push(1-o/y),// counters
M+=1}}// indices
// 1. you need three indices to draw a single face
// 2. a single segment consists of two faces
// 3. so we need to generate six (2*3) indices per segment
for(let n=0;n<y;n++)for(let r=0;r<_;r++){let i=p+r+E*n,a=p+r+E*(n+1),s=p+(r+1)+E*(n+1),o=p+(r+1)+E*n;// faces
u.push(i,a,o),u.push(a,s,o),// increase counter
I+=6}// add a group to the geometry. this will ensure multi material support
l.addGroup(f,I,b),// calculate new start value for groups
f+=I,// update total number of vertices
p+=M}// build each side of the box geometry
m("z","y","x",-1,-1,i,r,n,o,s,0),m("z","y","x",1,-1,i,r,-n,o,s,1),m("x","z","y",1,1,n,i,r,a,o,2),m("x","z","y",1,-1,n,i,-r,a,o,3),m("x","y","z",1,-1,n,r,i,a,s,4),m("x","y","z",-1,-1,n,r,-i,a,s,5),// build geometry
this.setIndex(u),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(c,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(h,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(d,2))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}static fromJSON(n){return new $d5b33d7c30034067$export$33e43285f7406bd5(n.width,n.height,n.depth,n.widthSegments,n.heightSegments,n.depthSegments)}}/**
 * Uniform Utilities
 */function $d5b33d7c30034067$var$cloneUniforms(n){let r={};for(let i in n)for(let a in r[i]={},n[i]){let s=n[i][a];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?s.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),r[i][a]=null):r[i][a]=s.clone():Array.isArray(s)?r[i][a]=s.slice():r[i][a]=s}return r}function $d5b33d7c30034067$var$mergeUniforms(n){let r={};for(let i=0;i<n.length;i++){let a=$d5b33d7c30034067$var$cloneUniforms(n[i]);for(let n in a)r[n]=a[n]}return r}function $d5b33d7c30034067$var$cloneUniformsGroups(n){let r=[];for(let i=0;i<n.length;i++)r.push(n[i].clone());return r}function $d5b33d7c30034067$var$getUnlitUniformColorSpace(n){return null===n.getRenderTarget()?n.outputColorSpace:$d5b33d7c30034067$export$42429b3acfb233a4}// Legacy
const $d5b33d7c30034067$export$d8ecdf8615bfea69={clone:$d5b33d7c30034067$var$cloneUniforms,merge:$d5b33d7c30034067$var$mergeUniforms};var $d5b33d7c30034067$var$default_vertex="void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",$d5b33d7c30034067$var$default_fragment="void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";class $d5b33d7c30034067$export$83c7d75d550a8b0d extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=$d5b33d7c30034067$var$default_vertex,this.fragmentShader=$d5b33d7c30034067$var$default_fragment,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1// set to use shader texture LOD
},// When rendered geometry doesn't include these attributes but the material does,
// use these default values in WebGL. This avoids errors when buffer data is missing.
this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==n&&this.setValues(n)}copy(n){return super.copy(n),this.fragmentShader=n.fragmentShader,this.vertexShader=n.vertexShader,this.uniforms=$d5b33d7c30034067$var$cloneUniforms(n.uniforms),this.uniformsGroups=$d5b33d7c30034067$var$cloneUniformsGroups(n.uniformsGroups),this.defines=Object.assign({},n.defines),this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.fog=n.fog,this.lights=n.lights,this.clipping=n.clipping,this.extensions=Object.assign({},n.extensions),this.glslVersion=n.glslVersion,this}toJSON(n){let r=super.toJSON(n);for(let i in r.glslVersion=this.glslVersion,r.uniforms={},this.uniforms){let a=this.uniforms[i],s=a.value;s&&s.isTexture?r.uniforms[i]={type:"t",value:s.toJSON(n).uuid}:s&&s.isColor?r.uniforms[i]={type:"c",value:s.getHex()}:s&&s.isVector2?r.uniforms[i]={type:"v2",value:s.toArray()}:s&&s.isVector3?r.uniforms[i]={type:"v3",value:s.toArray()}:s&&s.isVector4?r.uniforms[i]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?r.uniforms[i]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?r.uniforms[i]={type:"m4",value:s.toArray()}:r.uniforms[i]={value:s}}Object.keys(this.defines).length>0&&(r.defines=this.defines),r.vertexShader=this.vertexShader,r.fragmentShader=this.fragmentShader,r.lights=this.lights,r.clipping=this.clipping;let i={};for(let n in this.extensions)!0===this.extensions[n]&&(i[n]=!0);return Object.keys(i).length>0&&(r.extensions=i),r}}class $d5b33d7c30034067$export$79f141de891a5fed extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new $d5b33d7c30034067$export$2ae72fc923e5eb5,this.projectionMatrix=new $d5b33d7c30034067$export$2ae72fc923e5eb5,this.projectionMatrixInverse=new $d5b33d7c30034067$export$2ae72fc923e5eb5,this.coordinateSystem=$d5b33d7c30034067$export$5a0e9190d10875d3}copy(n,r){return super.copy(n,r),this.matrixWorldInverse.copy(n.matrixWorldInverse),this.projectionMatrix.copy(n.projectionMatrix),this.projectionMatrixInverse.copy(n.projectionMatrixInverse),this.coordinateSystem=n.coordinateSystem,this}getWorldDirection(n){this.updateWorldMatrix(!0,!1);let r=this.matrixWorld.elements;return n.set(-r[8],-r[9],-r[10]).normalize()}updateMatrixWorld(n){super.updateMatrixWorld(n),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(n,r){super.updateWorldMatrix(n,r),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class $d5b33d7c30034067$export$74e4ae24825f68d7 extends $d5b33d7c30034067$export$79f141de891a5fed{constructor(n=50,r=1,i=.1,a=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=n,this.zoom=1,this.near=i,this.far=a,this.focus=10,this.aspect=r,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(n,r){return super.copy(n,r),this.fov=n.fov,this.zoom=n.zoom,this.near=n.near,this.far=n.far,this.focus=n.focus,this.aspect=n.aspect,this.view=null===n.view?null:Object.assign({},n.view),this.filmGauge=n.filmGauge,this.filmOffset=n.filmOffset,this}/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */setFocalLength(n){/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */let r=.5*this.getFilmHeight()/n;this.fov=2*$d5b33d7c30034067$var$RAD2DEG*Math.atan(r),this.updateProjectionMatrix()}/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */getFocalLength(){let n=Math.tan(.5*$d5b33d7c30034067$var$DEG2RAD*this.fov);return .5*this.getFilmHeight()/n}getEffectiveFOV(){return 2*$d5b33d7c30034067$var$RAD2DEG*Math.atan(Math.tan(.5*$d5b33d7c30034067$var$DEG2RAD*this.fov)/this.zoom)}getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
return this.filmGauge/Math.max(this.aspect,1)}/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */setViewOffset(n,r,i,a,s,o){this.aspect=n/r,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=r,this.view.offsetX=i,this.view.offsetY=a,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){let n=this.near,r=n*Math.tan(.5*$d5b33d7c30034067$var$DEG2RAD*this.fov)/this.zoom,i=2*r,a=this.aspect*i,s=-.5*a,o=this.view;if(null!==this.view&&this.view.enabled){let n=o.fullWidth,l=o.fullHeight;s+=o.offsetX*a/n,r-=o.offsetY*i/l,a*=o.width/n,i*=o.height/l}let l=this.filmOffset;0!==l&&(s+=n*l/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+a,r,r-i,n,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(n){let r=super.toJSON(n);return r.object.fov=this.fov,r.object.zoom=this.zoom,r.object.near=this.near,r.object.far=this.far,r.object.focus=this.focus,r.object.aspect=this.aspect,null!==this.view&&(r.object.view=Object.assign({},this.view)),r.object.filmGauge=this.filmGauge,r.object.filmOffset=this.filmOffset,r}}const $d5b33d7c30034067$var$fov=-90,$d5b33d7c30034067$var$aspect=1;// negative fov is not an error
class $d5b33d7c30034067$export$d0cdd0bd804995de extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(n,r,i){super(),this.type="CubeCamera",this.renderTarget=i,this.coordinateSystem=null;let a=new $d5b33d7c30034067$export$74e4ae24825f68d7($d5b33d7c30034067$var$fov,$d5b33d7c30034067$var$aspect,n,r);a.layers=this.layers,this.add(a);let s=new $d5b33d7c30034067$export$74e4ae24825f68d7($d5b33d7c30034067$var$fov,$d5b33d7c30034067$var$aspect,n,r);s.layers=this.layers,this.add(s);let o=new $d5b33d7c30034067$export$74e4ae24825f68d7($d5b33d7c30034067$var$fov,$d5b33d7c30034067$var$aspect,n,r);o.layers=this.layers,this.add(o);let l=new $d5b33d7c30034067$export$74e4ae24825f68d7($d5b33d7c30034067$var$fov,$d5b33d7c30034067$var$aspect,n,r);l.layers=this.layers,this.add(l);let u=new $d5b33d7c30034067$export$74e4ae24825f68d7($d5b33d7c30034067$var$fov,$d5b33d7c30034067$var$aspect,n,r);u.layers=this.layers,this.add(u);let c=new $d5b33d7c30034067$export$74e4ae24825f68d7($d5b33d7c30034067$var$fov,$d5b33d7c30034067$var$aspect,n,r);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){let n=this.coordinateSystem,r=this.children.concat(),[i,a,s,o,l,u]=r;for(let n of r)this.remove(n);if(n===$d5b33d7c30034067$export$5a0e9190d10875d3)i.up.set(0,1,0),i.lookAt(1,0,0),a.up.set(0,1,0),a.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),l.up.set(0,1,0),l.lookAt(0,0,1),u.up.set(0,1,0),u.lookAt(0,0,-1);else if(n===$d5b33d7c30034067$export$cc83beedcb9be9ac)i.up.set(0,-1,0),i.lookAt(-1,0,0),a.up.set(0,-1,0),a.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),l.up.set(0,-1,0),l.lookAt(0,0,1),u.up.set(0,-1,0),u.lookAt(0,0,-1);else throw Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+n);for(let n of r)this.add(n),n.updateMatrixWorld()}update(n,r){null===this.parent&&this.updateMatrixWorld();let i=this.renderTarget;this.coordinateSystem!==n.coordinateSystem&&(this.coordinateSystem=n.coordinateSystem,this.updateCoordinateSystem());let[a,s,o,l,u,c]=this.children,h=n.getRenderTarget(),d=n.xr.enabled;n.xr.enabled=!1;let p=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,n.setRenderTarget(i,0),n.render(r,a),n.setRenderTarget(i,1),n.render(r,s),n.setRenderTarget(i,2),n.render(r,o),n.setRenderTarget(i,3),n.render(r,l),n.setRenderTarget(i,4),n.render(r,u),i.texture.generateMipmaps=p,n.setRenderTarget(i,5),n.render(r,c),n.setRenderTarget(h),n.xr.enabled=d,i.texture.needsPMREMUpdate=!0}}class $d5b33d7c30034067$export$ee2e5a18258a4049 extends $d5b33d7c30034067$export$5431306cf43de24a{constructor(n,r,i,a,s,o,l,u,c,h){super(n=void 0!==n?n:[],r=void 0!==r?r:$d5b33d7c30034067$export$8759762a6477f2c4,i,a,s,o,l,u,c,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(n){this.image=n}}class $d5b33d7c30034067$export$ac386671d651941e extends $d5b33d7c30034067$export$3c052beb2e51e23f{constructor(n=1,r={}){super(n,n,r),this.isWebGLCubeRenderTarget=!0;let i={width:n,height:n,depth:1},a=[i,i,i,i,i,i];void 0!==r.encoding&&(// @deprecated, r152
$d5b33d7c30034067$var$warnOnce("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),r.colorSpace=r.encoding===$d5b33d7c30034067$export$f32388edbb32674?$d5b33d7c30034067$export$561f394b24edfcaa:$d5b33d7c30034067$export$bfcb490c2dd3db51),this.texture=new $d5b33d7c30034067$export$ee2e5a18258a4049(a,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.colorSpace),// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==r.generateMipmaps&&r.generateMipmaps,this.texture.minFilter=void 0!==r.minFilter?r.minFilter:$d5b33d7c30034067$export$8a72f490b25c56c8}fromEquirectangularTexture(n,r){this.texture.type=r.type,this.texture.colorSpace=r.colorSpace,this.texture.generateMipmaps=r.generateMipmaps,this.texture.minFilter=r.minFilter,this.texture.magFilter=r.magFilter;let i={uniforms:{tEquirect:{value:null}},vertexShader:/* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:/* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},a=new $d5b33d7c30034067$export$33e43285f7406bd5(5,5,5),s=new $d5b33d7c30034067$export$83c7d75d550a8b0d({name:"CubemapFromEquirect",uniforms:$d5b33d7c30034067$var$cloneUniforms(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:$d5b33d7c30034067$export$d9f0486e75b5ace,blending:$d5b33d7c30034067$export$63b8d6b580fc65ba});s.uniforms.tEquirect.value=r;let o=new $d5b33d7c30034067$export$e176487c05830cc5(a,s),l=r.minFilter;r.minFilter===$d5b33d7c30034067$export$5d8599b6a933fb1b&&(r.minFilter=$d5b33d7c30034067$export$8a72f490b25c56c8);let u=new $d5b33d7c30034067$export$d0cdd0bd804995de(1,10,this);return u.update(n,o),r.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(n,r,i,a){let s=n.getRenderTarget();for(let s=0;s<6;s++)n.setRenderTarget(this,s),n.clear(r,i,a);n.setRenderTarget(s)}}const $d5b33d7c30034067$var$_vector1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vector2=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_normalMatrix=/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918;class $d5b33d7c30034067$export$7ff5ac152ef991b0{constructor(n=new $d5b33d7c30034067$export$64b5c384219d3699(1,0,0),r=0){this.isPlane=!0,// normal is assumed to be normalized
this.normal=n,this.constant=r}set(n,r){return this.normal.copy(n),this.constant=r,this}setComponents(n,r,i,a){return this.normal.set(n,r,i),this.constant=a,this}setFromNormalAndCoplanarPoint(n,r){return this.normal.copy(n),this.constant=-r.dot(this.normal),this}setFromCoplanarPoints(n,r,i){let a=$d5b33d7c30034067$var$_vector1.subVectors(i,r).cross($d5b33d7c30034067$var$_vector2.subVectors(n,r)).normalize();return(// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
this.setFromNormalAndCoplanarPoint(a,n),this)}copy(n){return this.normal.copy(n.normal),this.constant=n.constant,this}normalize(){// Note: will lead to a divide by zero if the plane is invalid.
let n=1/this.normal.length();return this.normal.multiplyScalar(n),this.constant*=n,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(n){return this.normal.dot(n)+this.constant}distanceToSphere(n){return this.distanceToPoint(n.center)-n.radius}projectPoint(n,r){return r.copy(n).addScaledVector(this.normal,-this.distanceToPoint(n))}intersectLine(n,r){let i=n.delta($d5b33d7c30034067$var$_vector1),a=this.normal.dot(i);if(0===a)return(// line is coplanar, return origin
0===this.distanceToPoint(n.start)?r.copy(n.start):null);let s=-(n.start.dot(this.normal)+this.constant)/a;return s<0||s>1?null:r.copy(n.start).addScaledVector(i,s)}intersectsLine(n){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
let r=this.distanceToPoint(n.start),i=this.distanceToPoint(n.end);return r<0&&i>0||i<0&&r>0}intersectsBox(n){return n.intersectsPlane(this)}intersectsSphere(n){return n.intersectsPlane(this)}coplanarPoint(n){return n.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(n,r){let i=r||$d5b33d7c30034067$var$_normalMatrix.getNormalMatrix(n),a=this.coplanarPoint($d5b33d7c30034067$var$_vector1).applyMatrix4(n),s=this.normal.applyMatrix3(i).normalize();return this.constant=-a.dot(s),this}translate(n){return this.constant-=n.dot(this.normal),this}equals(n){return n.normal.equals(this.normal)&&n.constant===this.constant}clone(){return new this.constructor().copy(this)}}const $d5b33d7c30034067$var$_sphere$4=/*@__PURE__*/new $d5b33d7c30034067$export$805e8b72413ccaba,$d5b33d7c30034067$var$_vector$6=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$35efe6f4c85463d2{constructor(n=new $d5b33d7c30034067$export$7ff5ac152ef991b0,r=new $d5b33d7c30034067$export$7ff5ac152ef991b0,i=new $d5b33d7c30034067$export$7ff5ac152ef991b0,a=new $d5b33d7c30034067$export$7ff5ac152ef991b0,s=new $d5b33d7c30034067$export$7ff5ac152ef991b0,o=new $d5b33d7c30034067$export$7ff5ac152ef991b0){this.planes=[n,r,i,a,s,o]}set(n,r,i,a,s,o){let l=this.planes;return l[0].copy(n),l[1].copy(r),l[2].copy(i),l[3].copy(a),l[4].copy(s),l[5].copy(o),this}copy(n){let r=this.planes;for(let i=0;i<6;i++)r[i].copy(n.planes[i]);return this}setFromProjectionMatrix(n,r=$d5b33d7c30034067$export$5a0e9190d10875d3){let i=this.planes,a=n.elements,s=a[0],o=a[1],l=a[2],u=a[3],c=a[4],h=a[5],d=a[6],p=a[7],f=a[8],m=a[9],g=a[10],_=a[11],y=a[12],b=a[13],v=a[14],x=a[15];if(i[0].setComponents(u-s,p-c,_-f,x-y).normalize(),i[1].setComponents(u+s,p+c,_+f,x+y).normalize(),i[2].setComponents(u+o,p+h,_+m,x+b).normalize(),i[3].setComponents(u-o,p-h,_-m,x-b).normalize(),i[4].setComponents(u-l,p-d,_-g,x-v).normalize(),r===$d5b33d7c30034067$export$5a0e9190d10875d3)i[5].setComponents(u+l,p+d,_+g,x+v).normalize();else if(r===$d5b33d7c30034067$export$cc83beedcb9be9ac)i[5].setComponents(l,d,g,v).normalize();else throw Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+r);return this}intersectsObject(n){if(void 0!==n.boundingSphere)null===n.boundingSphere&&n.computeBoundingSphere(),$d5b33d7c30034067$var$_sphere$4.copy(n.boundingSphere).applyMatrix4(n.matrixWorld);else{let r=n.geometry;null===r.boundingSphere&&r.computeBoundingSphere(),$d5b33d7c30034067$var$_sphere$4.copy(r.boundingSphere).applyMatrix4(n.matrixWorld)}return this.intersectsSphere($d5b33d7c30034067$var$_sphere$4)}intersectsSprite(n){return $d5b33d7c30034067$var$_sphere$4.center.set(0,0,0),$d5b33d7c30034067$var$_sphere$4.radius=.7071067811865476,$d5b33d7c30034067$var$_sphere$4.applyMatrix4(n.matrixWorld),this.intersectsSphere($d5b33d7c30034067$var$_sphere$4)}intersectsSphere(n){let r=this.planes,i=n.center,a=-n.radius;for(let n=0;n<6;n++){let s=r[n].distanceToPoint(i);if(s<a)return!1}return!0}intersectsBox(n){let r=this.planes;for(let i=0;i<6;i++){let a=r[i];if(// corner at max distance
$d5b33d7c30034067$var$_vector$6.x=a.normal.x>0?n.max.x:n.min.x,$d5b33d7c30034067$var$_vector$6.y=a.normal.y>0?n.max.y:n.min.y,$d5b33d7c30034067$var$_vector$6.z=a.normal.z>0?n.max.z:n.min.z,0>a.distanceToPoint($d5b33d7c30034067$var$_vector$6))return!1}return!0}containsPoint(n){let r=this.planes;for(let i=0;i<6;i++)if(0>r[i].distanceToPoint(n))return!1;return!0}clone(){return new this.constructor().copy(this)}}function $d5b33d7c30034067$var$WebGLAnimation(){let n=null,r=!1,i=null,a=null;function s(r,o){i(r,o),a=n.requestAnimationFrame(s)}return{start:function(){!0!==r&&null!==i&&(a=n.requestAnimationFrame(s),r=!0)},stop:function(){n.cancelAnimationFrame(a),r=!1},setAnimationLoop:function(n){i=n},setContext:function(r){n=r}}}function $d5b33d7c30034067$var$WebGLAttributes(n,r){let i=r.isWebGL2,a=new WeakMap;function s(r,a){let s;let o=r.array,l=r.usage,u=n.createBuffer();if(n.bindBuffer(a,u),n.bufferData(a,o,l),r.onUploadCallback(),o instanceof Float32Array)s=n.FLOAT;else if(o instanceof Uint16Array){if(r.isFloat16BufferAttribute){if(i)s=n.HALF_FLOAT;else throw Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.")}else s=n.UNSIGNED_SHORT}else if(o instanceof Int16Array)s=n.SHORT;else if(o instanceof Uint32Array)s=n.UNSIGNED_INT;else if(o instanceof Int32Array)s=n.INT;else if(o instanceof Int8Array)s=n.BYTE;else if(o instanceof Uint8Array)s=n.UNSIGNED_BYTE;else if(o instanceof Uint8ClampedArray)s=n.UNSIGNED_BYTE;else throw Error("THREE.WebGLAttributes: Unsupported buffer data format: "+o);return{buffer:u,type:s,bytesPerElement:o.BYTES_PER_ELEMENT,version:r.version}}function o(r,a,s){let o=a.array,l=a.updateRange;n.bindBuffer(s,r),-1===l.count?n.bufferSubData(s,0,o):(i?n.bufferSubData(s,l.offset*o.BYTES_PER_ELEMENT,o,l.offset,l.count):n.bufferSubData(s,l.offset*o.BYTES_PER_ELEMENT,o.subarray(l.offset,l.offset+l.count)),l.count=-1),a.onUploadCallback()}return{get://
function(n){return n.isInterleavedBufferAttribute&&(n=n.data),a.get(n)},remove:function(r){r.isInterleavedBufferAttribute&&(r=r.data);let i=a.get(r);i&&(n.deleteBuffer(i.buffer),a.delete(r))},update:function(n,r){if(n.isGLBufferAttribute){let r=a.get(n);(!r||r.version<n.version)&&a.set(n,{buffer:n.buffer,type:n.type,bytesPerElement:n.elementSize,version:n.version});return}n.isInterleavedBufferAttribute&&(n=n.data);let i=a.get(n);void 0===i?a.set(n,s(n,r)):i.version<n.version&&(o(i.buffer,n,r),i.version=n.version)}}}class $d5b33d7c30034067$export$967d831af31f69ce extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=1,r=1,i=1,a=1){super(),this.type="PlaneGeometry",this.parameters={width:n,height:r,widthSegments:i,heightSegments:a};let s=n/2,o=r/2,l=Math.floor(i),u=Math.floor(a),c=l+1,h=u+1,d=n/l,p=r/u,f=[],m=[],g=[],_=[];for(let n=0;n<h;n++){let r=n*p-o;for(let i=0;i<c;i++){let a=i*d-s;m.push(a,-r,0),g.push(0,0,1),_.push(i/l),_.push(1-n/u)}}for(let n=0;n<u;n++)for(let r=0;r<l;r++){let i=r+c*n,a=r+c*(n+1),s=r+1+c*(n+1),o=r+1+c*n;f.push(i,a,o),f.push(a,s,o)}this.setIndex(f),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(m,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(g,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(_,2))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}static fromJSON(n){return new $d5b33d7c30034067$export$967d831af31f69ce(n.width,n.height,n.widthSegments,n.heightSegments)}}var $d5b33d7c30034067$var$alphahash_fragment="#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",$d5b33d7c30034067$var$alphahash_pars_fragment="#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif",$d5b33d7c30034067$var$alphamap_fragment="#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",$d5b33d7c30034067$var$alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",$d5b33d7c30034067$var$alphatest_fragment="#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif",$d5b33d7c30034067$var$alphatest_pars_fragment="#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif",$d5b33d7c30034067$var$aomap_fragment="#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif",$d5b33d7c30034067$var$aomap_pars_fragment="#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",$d5b33d7c30034067$var$begin_vertex="vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif",$d5b33d7c30034067$var$beginnormal_vertex="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",$d5b33d7c30034067$var$bsdfs="float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated",$d5b33d7c30034067$var$iridescence_fragment="#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif",$d5b33d7c30034067$var$bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = dFdx( surf_pos.xyz );\n		vec3 vSigmaY = dFdy( surf_pos.xyz );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",$d5b33d7c30034067$var$clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif",$d5b33d7c30034067$var$clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",$d5b33d7c30034067$var$clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",$d5b33d7c30034067$var$clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",$d5b33d7c30034067$var$color_fragment="#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",$d5b33d7c30034067$var$color_pars_fragment="#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",$d5b33d7c30034067$var$color_pars_vertex="#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif",$d5b33d7c30034067$var$color_vertex="#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif",$d5b33d7c30034067$var$common="#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",$d5b33d7c30034067$var$cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",$d5b33d7c30034067$var$defaultnormal_vertex="vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",$d5b33d7c30034067$var$displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",$d5b33d7c30034067$var$displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",$d5b33d7c30034067$var$emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",$d5b33d7c30034067$var$emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",$d5b33d7c30034067$var$colorspace_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );",$d5b33d7c30034067$var$colorspace_pars_fragment="vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",$d5b33d7c30034067$var$envmap_fragment="#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",$d5b33d7c30034067$var$envmap_common_pars_fragment="#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",$d5b33d7c30034067$var$envmap_pars_fragment="#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",$d5b33d7c30034067$var$envmap_pars_vertex="#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",$d5b33d7c30034067$var$envmap_vertex="#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",$d5b33d7c30034067$var$fog_vertex="#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif",$d5b33d7c30034067$var$fog_pars_vertex="#ifdef USE_FOG\n	varying float vFogDepth;\n#endif",$d5b33d7c30034067$var$fog_fragment="#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",$d5b33d7c30034067$var$fog_pars_fragment="#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",$d5b33d7c30034067$var$gradientmap_pars_fragment="#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}",$d5b33d7c30034067$var$lightmap_fragment="#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",$d5b33d7c30034067$var$lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",$d5b33d7c30034067$var$lights_lambert_fragment="LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",$d5b33d7c30034067$var$lights_lambert_pars_fragment="varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert",$d5b33d7c30034067$var$lights_pars_begin="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif",$d5b33d7c30034067$var$envmap_physical_pars_fragment="#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif",$d5b33d7c30034067$var$lights_toon_fragment="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",$d5b33d7c30034067$var$lights_toon_pars_fragment="varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon",$d5b33d7c30034067$var$lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",$d5b33d7c30034067$var$lights_phong_pars_fragment="varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong",$d5b33d7c30034067$var$lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	anisotropyV /= material.anisotropy;\n	material.anisotropy = saturate( material.anisotropy );\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",$d5b33d7c30034067$var$lights_physical_pars_fragment="struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",$d5b33d7c30034067$var$lights_fragment_begin="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometry.viewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",$d5b33d7c30034067$var$lights_fragment_maps="#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif",$d5b33d7c30034067$var$lights_fragment_end="#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",$d5b33d7c30034067$var$logdepthbuf_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",$d5b33d7c30034067$var$logdepthbuf_pars_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",$d5b33d7c30034067$var$logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",$d5b33d7c30034067$var$logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",$d5b33d7c30034067$var$map_fragment="#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif",$d5b33d7c30034067$var$map_pars_fragment="#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",$d5b33d7c30034067$var$map_particle_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",$d5b33d7c30034067$var$map_particle_pars_fragment="#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",$d5b33d7c30034067$var$metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",$d5b33d7c30034067$var$metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",$d5b33d7c30034067$var$morphcolor_vertex="#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif",$d5b33d7c30034067$var$morphnormal_vertex="#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif",$d5b33d7c30034067$var$morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif",$d5b33d7c30034067$var$morphtarget_vertex="#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif",$d5b33d7c30034067$var$normal_fragment_begin="float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 geometryNormal = normal;",$d5b33d7c30034067$var$normal_fragment_maps="#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",$d5b33d7c30034067$var$normal_pars_fragment="#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",$d5b33d7c30034067$var$normal_pars_vertex="#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",$d5b33d7c30034067$var$normal_vertex="#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif",$d5b33d7c30034067$var$normalmap_pars_fragment="#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif",$d5b33d7c30034067$var$clearcoat_normal_fragment_begin="#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",$d5b33d7c30034067$var$clearcoat_normal_fragment_maps="#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",$d5b33d7c30034067$var$clearcoat_pars_fragment="#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif",$d5b33d7c30034067$var$iridescence_pars_fragment="#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif",$d5b33d7c30034067$var$opaque_fragment="#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",$d5b33d7c30034067$var$packing="vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}",$d5b33d7c30034067$var$premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",$d5b33d7c30034067$var$project_vertex="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",$d5b33d7c30034067$var$dithering_fragment="#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",$d5b33d7c30034067$var$dithering_pars_fragment="#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",$d5b33d7c30034067$var$roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",$d5b33d7c30034067$var$roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",$d5b33d7c30034067$var$shadowmap_pars_fragment="#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",$d5b33d7c30034067$var$shadowmap_pars_vertex="#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",$d5b33d7c30034067$var$shadowmap_vertex="#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif",$d5b33d7c30034067$var$shadowmask_pars_fragment="float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",$d5b33d7c30034067$var$skinbase_vertex="#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",$d5b33d7c30034067$var$skinning_pars_vertex="#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif",$d5b33d7c30034067$var$skinning_vertex="#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",$d5b33d7c30034067$var$skinnormal_vertex="#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",$d5b33d7c30034067$var$specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",$d5b33d7c30034067$var$specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",$d5b33d7c30034067$var$tonemapping_fragment="#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",$d5b33d7c30034067$var$tonemapping_pars_fragment="#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",$d5b33d7c30034067$var$transmission_fragment="#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",$d5b33d7c30034067$var$transmission_pars_fragment="#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif",$d5b33d7c30034067$var$uv_pars_fragment="#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif",$d5b33d7c30034067$var$uv_pars_vertex="#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif",$d5b33d7c30034067$var$uv_vertex="#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",$d5b33d7c30034067$var$worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";const $d5b33d7c30034067$var$vertex$h="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",$d5b33d7c30034067$var$fragment$h="uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",$d5b33d7c30034067$var$vertex$g="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",$d5b33d7c30034067$var$fragment$g="#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",$d5b33d7c30034067$var$vertex$f="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",$d5b33d7c30034067$var$fragment$f="uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",$d5b33d7c30034067$var$vertex$e="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",$d5b33d7c30034067$var$fragment$e="#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}",$d5b33d7c30034067$var$vertex$d="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",$d5b33d7c30034067$var$fragment$d="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",$d5b33d7c30034067$var$vertex$c="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",$d5b33d7c30034067$var$fragment$c="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",$d5b33d7c30034067$var$vertex$b="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",$d5b33d7c30034067$var$fragment$b="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",$d5b33d7c30034067$var$vertex$a="#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",$d5b33d7c30034067$var$fragment$a="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",$d5b33d7c30034067$var$vertex$9="#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",$d5b33d7c30034067$var$fragment$9="#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",$d5b33d7c30034067$var$vertex$8="#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",$d5b33d7c30034067$var$fragment$8="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",$d5b33d7c30034067$var$vertex$7="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",$d5b33d7c30034067$var$fragment$7="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}",$d5b33d7c30034067$var$vertex$6="#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",$d5b33d7c30034067$var$fragment$6="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",$d5b33d7c30034067$var$vertex$5="#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",$d5b33d7c30034067$var$fragment$5="#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",$d5b33d7c30034067$var$vertex$4="#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",$d5b33d7c30034067$var$fragment$4="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",$d5b33d7c30034067$var$vertex$3="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",$d5b33d7c30034067$var$fragment$3="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",$d5b33d7c30034067$var$vertex$2="#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",$d5b33d7c30034067$var$fragment$2="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}",$d5b33d7c30034067$var$vertex$1="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",$d5b33d7c30034067$var$fragment$1="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}",$d5b33d7c30034067$export$955f9f2e84c43c8b={alphahash_fragment:$d5b33d7c30034067$var$alphahash_fragment,alphahash_pars_fragment:$d5b33d7c30034067$var$alphahash_pars_fragment,alphamap_fragment:$d5b33d7c30034067$var$alphamap_fragment,alphamap_pars_fragment:$d5b33d7c30034067$var$alphamap_pars_fragment,alphatest_fragment:$d5b33d7c30034067$var$alphatest_fragment,alphatest_pars_fragment:$d5b33d7c30034067$var$alphatest_pars_fragment,aomap_fragment:$d5b33d7c30034067$var$aomap_fragment,aomap_pars_fragment:$d5b33d7c30034067$var$aomap_pars_fragment,begin_vertex:$d5b33d7c30034067$var$begin_vertex,beginnormal_vertex:$d5b33d7c30034067$var$beginnormal_vertex,bsdfs:$d5b33d7c30034067$var$bsdfs,iridescence_fragment:$d5b33d7c30034067$var$iridescence_fragment,bumpmap_pars_fragment:$d5b33d7c30034067$var$bumpmap_pars_fragment,clipping_planes_fragment:$d5b33d7c30034067$var$clipping_planes_fragment,clipping_planes_pars_fragment:$d5b33d7c30034067$var$clipping_planes_pars_fragment,clipping_planes_pars_vertex:$d5b33d7c30034067$var$clipping_planes_pars_vertex,clipping_planes_vertex:$d5b33d7c30034067$var$clipping_planes_vertex,color_fragment:$d5b33d7c30034067$var$color_fragment,color_pars_fragment:$d5b33d7c30034067$var$color_pars_fragment,color_pars_vertex:$d5b33d7c30034067$var$color_pars_vertex,color_vertex:$d5b33d7c30034067$var$color_vertex,common:$d5b33d7c30034067$var$common,cube_uv_reflection_fragment:$d5b33d7c30034067$var$cube_uv_reflection_fragment,defaultnormal_vertex:$d5b33d7c30034067$var$defaultnormal_vertex,displacementmap_pars_vertex:$d5b33d7c30034067$var$displacementmap_pars_vertex,displacementmap_vertex:$d5b33d7c30034067$var$displacementmap_vertex,emissivemap_fragment:$d5b33d7c30034067$var$emissivemap_fragment,emissivemap_pars_fragment:$d5b33d7c30034067$var$emissivemap_pars_fragment,colorspace_fragment:$d5b33d7c30034067$var$colorspace_fragment,colorspace_pars_fragment:$d5b33d7c30034067$var$colorspace_pars_fragment,envmap_fragment:$d5b33d7c30034067$var$envmap_fragment,envmap_common_pars_fragment:$d5b33d7c30034067$var$envmap_common_pars_fragment,envmap_pars_fragment:$d5b33d7c30034067$var$envmap_pars_fragment,envmap_pars_vertex:$d5b33d7c30034067$var$envmap_pars_vertex,envmap_physical_pars_fragment:$d5b33d7c30034067$var$envmap_physical_pars_fragment,envmap_vertex:$d5b33d7c30034067$var$envmap_vertex,fog_vertex:$d5b33d7c30034067$var$fog_vertex,fog_pars_vertex:$d5b33d7c30034067$var$fog_pars_vertex,fog_fragment:$d5b33d7c30034067$var$fog_fragment,fog_pars_fragment:$d5b33d7c30034067$var$fog_pars_fragment,gradientmap_pars_fragment:$d5b33d7c30034067$var$gradientmap_pars_fragment,lightmap_fragment:$d5b33d7c30034067$var$lightmap_fragment,lightmap_pars_fragment:$d5b33d7c30034067$var$lightmap_pars_fragment,lights_lambert_fragment:$d5b33d7c30034067$var$lights_lambert_fragment,lights_lambert_pars_fragment:$d5b33d7c30034067$var$lights_lambert_pars_fragment,lights_pars_begin:$d5b33d7c30034067$var$lights_pars_begin,lights_toon_fragment:$d5b33d7c30034067$var$lights_toon_fragment,lights_toon_pars_fragment:$d5b33d7c30034067$var$lights_toon_pars_fragment,lights_phong_fragment:$d5b33d7c30034067$var$lights_phong_fragment,lights_phong_pars_fragment:$d5b33d7c30034067$var$lights_phong_pars_fragment,lights_physical_fragment:$d5b33d7c30034067$var$lights_physical_fragment,lights_physical_pars_fragment:$d5b33d7c30034067$var$lights_physical_pars_fragment,lights_fragment_begin:$d5b33d7c30034067$var$lights_fragment_begin,lights_fragment_maps:$d5b33d7c30034067$var$lights_fragment_maps,lights_fragment_end:$d5b33d7c30034067$var$lights_fragment_end,logdepthbuf_fragment:$d5b33d7c30034067$var$logdepthbuf_fragment,logdepthbuf_pars_fragment:$d5b33d7c30034067$var$logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:$d5b33d7c30034067$var$logdepthbuf_pars_vertex,logdepthbuf_vertex:$d5b33d7c30034067$var$logdepthbuf_vertex,map_fragment:$d5b33d7c30034067$var$map_fragment,map_pars_fragment:$d5b33d7c30034067$var$map_pars_fragment,map_particle_fragment:$d5b33d7c30034067$var$map_particle_fragment,map_particle_pars_fragment:$d5b33d7c30034067$var$map_particle_pars_fragment,metalnessmap_fragment:$d5b33d7c30034067$var$metalnessmap_fragment,metalnessmap_pars_fragment:$d5b33d7c30034067$var$metalnessmap_pars_fragment,morphcolor_vertex:$d5b33d7c30034067$var$morphcolor_vertex,morphnormal_vertex:$d5b33d7c30034067$var$morphnormal_vertex,morphtarget_pars_vertex:$d5b33d7c30034067$var$morphtarget_pars_vertex,morphtarget_vertex:$d5b33d7c30034067$var$morphtarget_vertex,normal_fragment_begin:$d5b33d7c30034067$var$normal_fragment_begin,normal_fragment_maps:$d5b33d7c30034067$var$normal_fragment_maps,normal_pars_fragment:$d5b33d7c30034067$var$normal_pars_fragment,normal_pars_vertex:$d5b33d7c30034067$var$normal_pars_vertex,normal_vertex:$d5b33d7c30034067$var$normal_vertex,normalmap_pars_fragment:$d5b33d7c30034067$var$normalmap_pars_fragment,clearcoat_normal_fragment_begin:$d5b33d7c30034067$var$clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps:$d5b33d7c30034067$var$clearcoat_normal_fragment_maps,clearcoat_pars_fragment:$d5b33d7c30034067$var$clearcoat_pars_fragment,iridescence_pars_fragment:$d5b33d7c30034067$var$iridescence_pars_fragment,opaque_fragment:$d5b33d7c30034067$var$opaque_fragment,packing:$d5b33d7c30034067$var$packing,premultiplied_alpha_fragment:$d5b33d7c30034067$var$premultiplied_alpha_fragment,project_vertex:$d5b33d7c30034067$var$project_vertex,dithering_fragment:$d5b33d7c30034067$var$dithering_fragment,dithering_pars_fragment:$d5b33d7c30034067$var$dithering_pars_fragment,roughnessmap_fragment:$d5b33d7c30034067$var$roughnessmap_fragment,roughnessmap_pars_fragment:$d5b33d7c30034067$var$roughnessmap_pars_fragment,shadowmap_pars_fragment:$d5b33d7c30034067$var$shadowmap_pars_fragment,shadowmap_pars_vertex:$d5b33d7c30034067$var$shadowmap_pars_vertex,shadowmap_vertex:$d5b33d7c30034067$var$shadowmap_vertex,shadowmask_pars_fragment:$d5b33d7c30034067$var$shadowmask_pars_fragment,skinbase_vertex:$d5b33d7c30034067$var$skinbase_vertex,skinning_pars_vertex:$d5b33d7c30034067$var$skinning_pars_vertex,skinning_vertex:$d5b33d7c30034067$var$skinning_vertex,skinnormal_vertex:$d5b33d7c30034067$var$skinnormal_vertex,specularmap_fragment:$d5b33d7c30034067$var$specularmap_fragment,specularmap_pars_fragment:$d5b33d7c30034067$var$specularmap_pars_fragment,tonemapping_fragment:$d5b33d7c30034067$var$tonemapping_fragment,tonemapping_pars_fragment:$d5b33d7c30034067$var$tonemapping_pars_fragment,transmission_fragment:$d5b33d7c30034067$var$transmission_fragment,transmission_pars_fragment:$d5b33d7c30034067$var$transmission_pars_fragment,uv_pars_fragment:$d5b33d7c30034067$var$uv_pars_fragment,uv_pars_vertex:$d5b33d7c30034067$var$uv_pars_vertex,uv_vertex:$d5b33d7c30034067$var$uv_vertex,worldpos_vertex:$d5b33d7c30034067$var$worldpos_vertex,background_vert:$d5b33d7c30034067$var$vertex$h,background_frag:$d5b33d7c30034067$var$fragment$h,backgroundCube_vert:$d5b33d7c30034067$var$vertex$g,backgroundCube_frag:$d5b33d7c30034067$var$fragment$g,cube_vert:$d5b33d7c30034067$var$vertex$f,cube_frag:$d5b33d7c30034067$var$fragment$f,depth_vert:$d5b33d7c30034067$var$vertex$e,depth_frag:$d5b33d7c30034067$var$fragment$e,distanceRGBA_vert:$d5b33d7c30034067$var$vertex$d,distanceRGBA_frag:$d5b33d7c30034067$var$fragment$d,equirect_vert:$d5b33d7c30034067$var$vertex$c,equirect_frag:$d5b33d7c30034067$var$fragment$c,linedashed_vert:$d5b33d7c30034067$var$vertex$b,linedashed_frag:$d5b33d7c30034067$var$fragment$b,meshbasic_vert:$d5b33d7c30034067$var$vertex$a,meshbasic_frag:$d5b33d7c30034067$var$fragment$a,meshlambert_vert:$d5b33d7c30034067$var$vertex$9,meshlambert_frag:$d5b33d7c30034067$var$fragment$9,meshmatcap_vert:$d5b33d7c30034067$var$vertex$8,meshmatcap_frag:$d5b33d7c30034067$var$fragment$8,meshnormal_vert:$d5b33d7c30034067$var$vertex$7,meshnormal_frag:$d5b33d7c30034067$var$fragment$7,meshphong_vert:$d5b33d7c30034067$var$vertex$6,meshphong_frag:$d5b33d7c30034067$var$fragment$6,meshphysical_vert:$d5b33d7c30034067$var$vertex$5,meshphysical_frag:$d5b33d7c30034067$var$fragment$5,meshtoon_vert:$d5b33d7c30034067$var$vertex$4,meshtoon_frag:$d5b33d7c30034067$var$fragment$4,points_vert:$d5b33d7c30034067$var$vertex$3,points_frag:$d5b33d7c30034067$var$fragment$3,shadow_vert:$d5b33d7c30034067$var$vertex$2,shadow_frag:$d5b33d7c30034067$var$fragment$2,sprite_vert:$d5b33d7c30034067$var$vertex$1,sprite_frag:$d5b33d7c30034067$var$fragment$1},$d5b33d7c30034067$export$6643083551874bf5={common:{diffuse:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},alphaMap:{value:null},alphaMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},normalScale:{value:/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},alphaTest:{value:0},uvTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918}},sprite:{diffuse:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(16777215)},opacity:{value:1},center:{value:/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},alphaMap:{value:null},alphaMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},alphaTest:{value:0}}},$d5b33d7c30034067$export$bee4a7d47f8f5014={basic:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.common,$d5b33d7c30034067$export$6643083551874bf5.specularmap,$d5b33d7c30034067$export$6643083551874bf5.envmap,$d5b33d7c30034067$export$6643083551874bf5.aomap,$d5b33d7c30034067$export$6643083551874bf5.lightmap,$d5b33d7c30034067$export$6643083551874bf5.fog]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshbasic_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshbasic_frag},lambert:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.common,$d5b33d7c30034067$export$6643083551874bf5.specularmap,$d5b33d7c30034067$export$6643083551874bf5.envmap,$d5b33d7c30034067$export$6643083551874bf5.aomap,$d5b33d7c30034067$export$6643083551874bf5.lightmap,$d5b33d7c30034067$export$6643083551874bf5.emissivemap,$d5b33d7c30034067$export$6643083551874bf5.bumpmap,$d5b33d7c30034067$export$6643083551874bf5.normalmap,$d5b33d7c30034067$export$6643083551874bf5.displacementmap,$d5b33d7c30034067$export$6643083551874bf5.fog,$d5b33d7c30034067$export$6643083551874bf5.lights,{emissive:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(0)}}]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshlambert_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshlambert_frag},phong:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.common,$d5b33d7c30034067$export$6643083551874bf5.specularmap,$d5b33d7c30034067$export$6643083551874bf5.envmap,$d5b33d7c30034067$export$6643083551874bf5.aomap,$d5b33d7c30034067$export$6643083551874bf5.lightmap,$d5b33d7c30034067$export$6643083551874bf5.emissivemap,$d5b33d7c30034067$export$6643083551874bf5.bumpmap,$d5b33d7c30034067$export$6643083551874bf5.normalmap,$d5b33d7c30034067$export$6643083551874bf5.displacementmap,$d5b33d7c30034067$export$6643083551874bf5.fog,$d5b33d7c30034067$export$6643083551874bf5.lights,{emissive:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(0)},specular:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(1118481)},shininess:{value:30}}]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshphong_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshphong_frag},standard:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.common,$d5b33d7c30034067$export$6643083551874bf5.envmap,$d5b33d7c30034067$export$6643083551874bf5.aomap,$d5b33d7c30034067$export$6643083551874bf5.lightmap,$d5b33d7c30034067$export$6643083551874bf5.emissivemap,$d5b33d7c30034067$export$6643083551874bf5.bumpmap,$d5b33d7c30034067$export$6643083551874bf5.normalmap,$d5b33d7c30034067$export$6643083551874bf5.displacementmap,$d5b33d7c30034067$export$6643083551874bf5.roughnessmap,$d5b33d7c30034067$export$6643083551874bf5.metalnessmap,$d5b33d7c30034067$export$6643083551874bf5.fog,$d5b33d7c30034067$export$6643083551874bf5.lights,{emissive:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}// temporary
}]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshphysical_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshphysical_frag},toon:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.common,$d5b33d7c30034067$export$6643083551874bf5.aomap,$d5b33d7c30034067$export$6643083551874bf5.lightmap,$d5b33d7c30034067$export$6643083551874bf5.emissivemap,$d5b33d7c30034067$export$6643083551874bf5.bumpmap,$d5b33d7c30034067$export$6643083551874bf5.normalmap,$d5b33d7c30034067$export$6643083551874bf5.displacementmap,$d5b33d7c30034067$export$6643083551874bf5.gradientmap,$d5b33d7c30034067$export$6643083551874bf5.fog,$d5b33d7c30034067$export$6643083551874bf5.lights,{emissive:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(0)}}]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshtoon_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshtoon_frag},matcap:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.common,$d5b33d7c30034067$export$6643083551874bf5.bumpmap,$d5b33d7c30034067$export$6643083551874bf5.normalmap,$d5b33d7c30034067$export$6643083551874bf5.displacementmap,$d5b33d7c30034067$export$6643083551874bf5.fog,{matcap:{value:null}}]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshmatcap_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshmatcap_frag},points:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.points,$d5b33d7c30034067$export$6643083551874bf5.fog]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.points_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.points_frag},dashed:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.common,$d5b33d7c30034067$export$6643083551874bf5.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.linedashed_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.linedashed_frag},depth:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.common,$d5b33d7c30034067$export$6643083551874bf5.displacementmap]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.depth_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.depth_frag},normal:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.common,$d5b33d7c30034067$export$6643083551874bf5.bumpmap,$d5b33d7c30034067$export$6643083551874bf5.normalmap,$d5b33d7c30034067$export$6643083551874bf5.displacementmap,{opacity:{value:1}}]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshnormal_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshnormal_frag},sprite:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.sprite,$d5b33d7c30034067$export$6643083551874bf5.fog]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.sprite_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.sprite_frag},background:{uniforms:{uvTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.background_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.backgroundCube_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.cube_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.equirect_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.equirect_frag},distanceRGBA:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.common,$d5b33d7c30034067$export$6643083551874bf5.displacementmap,{referencePosition:{value:/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.distanceRGBA_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.distanceRGBA_frag},shadow:{uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$6643083551874bf5.lights,$d5b33d7c30034067$export$6643083551874bf5.fog,{color:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(0)},opacity:{value:1}}]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.shadow_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.shadow_frag}};$d5b33d7c30034067$export$bee4a7d47f8f5014.physical={uniforms:/*@__PURE__*/$d5b33d7c30034067$var$mergeUniforms([$d5b33d7c30034067$export$bee4a7d47f8f5014.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},clearcoatNormalScale:{value:/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},sheen:{value:0},sheenColor:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},transmissionSamplerSize:{value:/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},attenuationDistance:{value:0},attenuationColor:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(0)},specularColor:{value:/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918},anisotropyVector:{value:/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1},anisotropyMap:{value:null},anisotropyMapTransform:{value:/*@__PURE__*/new $d5b33d7c30034067$export$8ff26dafa08918}}]),vertexShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshphysical_vert,fragmentShader:$d5b33d7c30034067$export$955f9f2e84c43c8b.meshphysical_frag};const $d5b33d7c30034067$var$_rgb={r:0,b:0,g:0};function $d5b33d7c30034067$var$WebGLBackground(n,r,i,a,s,o,l){let u,c;let h=new $d5b33d7c30034067$export$892596cec99bc70e(0),d=!0===o?0:1,p=null,f=0,m=null;function g(r,i){r.getRGB($d5b33d7c30034067$var$_rgb,$d5b33d7c30034067$var$getUnlitUniformColorSpace(n)),a.buffers.color.setClear($d5b33d7c30034067$var$_rgb.r,$d5b33d7c30034067$var$_rgb.g,$d5b33d7c30034067$var$_rgb.b,i,l)}return{getClearColor:function(){return h},setClearColor:function(n,r=1){h.set(n),g(h,d=r)},getClearAlpha:function(){return d},setClearAlpha:function(n){g(h,d=n)},render:function(o,_){let y=!1,b=!0===_.isScene?_.background:null;if(b&&b.isTexture){let n=_.backgroundBlurriness>0;// use PMREM if the user wants to blur the background
b=(n?i:r).get(b)}null===b?g(h,d):b&&b.isColor&&(g(b,1),y=!0);let v=n.xr.getEnvironmentBlendMode();"additive"===v?a.buffers.color.setClear(0,0,0,1,l):"alpha-blend"===v&&a.buffers.color.setClear(0,0,0,0,l),(n.autoClear||y)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),b&&(b.isCubeTexture||b.mapping===$d5b33d7c30034067$export$dbf3e70ff37af79)?(void 0===c&&((c=new $d5b33d7c30034067$export$e176487c05830cc5(new $d5b33d7c30034067$export$33e43285f7406bd5(1,1,1),new $d5b33d7c30034067$export$83c7d75d550a8b0d({name:"BackgroundCubeMaterial",uniforms:$d5b33d7c30034067$var$cloneUniforms($d5b33d7c30034067$export$bee4a7d47f8f5014.backgroundCube.uniforms),vertexShader:$d5b33d7c30034067$export$bee4a7d47f8f5014.backgroundCube.vertexShader,fragmentShader:$d5b33d7c30034067$export$bee4a7d47f8f5014.backgroundCube.fragmentShader,side:$d5b33d7c30034067$export$d9f0486e75b5ace,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(n,r,i){this.matrixWorld.copyPosition(i.matrixWorld)},// add "envMap" material property so the renderer can evaluate it like for built-in materials
Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(c)),c.material.uniforms.envMap.value=b,c.material.uniforms.flipEnvMap.value=b.isCubeTexture&&!1===b.isRenderTargetTexture?-1:1,c.material.uniforms.backgroundBlurriness.value=_.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=_.backgroundIntensity,c.material.toneMapped=b.colorSpace!==$d5b33d7c30034067$export$561f394b24edfcaa,(p!==b||f!==b.version||m!==n.toneMapping)&&(c.material.needsUpdate=!0,p=b,f=b.version,m=n.toneMapping),c.layers.enableAll(),// push to the pre-sorted opaque render list
o.unshift(c,c.geometry,c.material,0,0,null)):b&&b.isTexture&&(void 0===u&&((u=new $d5b33d7c30034067$export$e176487c05830cc5(new $d5b33d7c30034067$export$967d831af31f69ce(2,2),new $d5b33d7c30034067$export$83c7d75d550a8b0d({name:"BackgroundMaterial",uniforms:$d5b33d7c30034067$var$cloneUniforms($d5b33d7c30034067$export$bee4a7d47f8f5014.background.uniforms),vertexShader:$d5b33d7c30034067$export$bee4a7d47f8f5014.background.vertexShader,fragmentShader:$d5b33d7c30034067$export$bee4a7d47f8f5014.background.fragmentShader,side:$d5b33d7c30034067$export$2ede184fc2998901,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),// add "map" material property so the renderer can evaluate it like for built-in materials
Object.defineProperty(u.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(u)),u.material.uniforms.t2D.value=b,u.material.uniforms.backgroundIntensity.value=_.backgroundIntensity,u.material.toneMapped=b.colorSpace!==$d5b33d7c30034067$export$561f394b24edfcaa,!0===b.matrixAutoUpdate&&b.updateMatrix(),u.material.uniforms.uvTransform.value.copy(b.matrix),(p!==b||f!==b.version||m!==n.toneMapping)&&(u.material.needsUpdate=!0,p=b,f=b.version,m=n.toneMapping),u.layers.enableAll(),// push to the pre-sorted opaque render list
o.unshift(u,u.geometry,u.material,0,0,null))}}}function $d5b33d7c30034067$var$WebGLBindingStates(n,r,i,a){let s=n.getParameter(n.MAX_VERTEX_ATTRIBS),o=a.isWebGL2?null:r.get("OES_vertex_array_object"),l=a.isWebGL2||null!==o,u={},c=_(null),h=c,d=!1;function p(){return a.isWebGL2?n.createVertexArray():o.createVertexArrayOES()}function f(r){return a.isWebGL2?n.bindVertexArray(r):o.bindVertexArrayOES(r)}function m(r){return a.isWebGL2?n.deleteVertexArray(r):o.deleteVertexArrayOES(r)}function g(n,r,i){let a=!0===i.wireframe,s=u[n.id];void 0===s&&(s={},u[n.id]=s);let o=s[r.id];void 0===o&&(o={},s[r.id]=o);let l=o[a];return void 0===l&&(l=_(p()),o[a]=l),l}function _(n){let r=[],i=[],a=[];for(let n=0;n<s;n++)r[n]=0,i[n]=0,a[n]=0;return{// for backward compatibility on non-VAO support browser
geometry:null,program:null,wireframe:!1,newAttributes:r,enabledAttributes:i,attributeDivisors:a,object:n,attributes:{},index:null}}function y(n,r,i,a){let s=h.attributes,o=r.attributes,l=0,u=i.getAttributes();for(let r in u){let i=u[r];if(i.location>=0){let i=s[r],a=o[r];if(void 0===a&&("instanceMatrix"===r&&n.instanceMatrix&&(a=n.instanceMatrix),"instanceColor"===r&&n.instanceColor&&(a=n.instanceColor)),void 0===i||i.attribute!==a||a&&i.data!==a.data)return!0;l++}}return h.attributesNum!==l||h.index!==a}function b(n,r,i,a){let s={},o=r.attributes,l=0,u=i.getAttributes();for(let r in u){let i=u[r];if(i.location>=0){let i=o[r];void 0===i&&("instanceMatrix"===r&&n.instanceMatrix&&(i=n.instanceMatrix),"instanceColor"===r&&n.instanceColor&&(i=n.instanceColor));let a={};a.attribute=i,i&&i.data&&(a.data=i.data),s[r]=a,l++}}h.attributes=s,h.attributesNum=l,h.index=a}function v(){let n=h.newAttributes;for(let r=0,i=n.length;r<i;r++)n[r]=0}function x(n){w(n,0)}function w(i,s){let o=h.newAttributes,l=h.enabledAttributes,u=h.attributeDivisors;if(o[i]=1,0===l[i]&&(n.enableVertexAttribArray(i),l[i]=1),u[i]!==s){let o=a.isWebGL2?n:r.get("ANGLE_instanced_arrays");o[a.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](i,s),u[i]=s}}function T(){let r=h.newAttributes,i=h.enabledAttributes;for(let a=0,s=i.length;a<s;a++)i[a]!==r[a]&&(n.disableVertexAttribArray(a),i[a]=0)}function S(r,i,a,s,o,l,u){!0===u?n.vertexAttribIPointer(r,i,a,o,l):n.vertexAttribPointer(r,i,a,s,o,l)}function E(s,o,l,u){if(!1===a.isWebGL2&&(s.isInstancedMesh||u.isInstancedBufferGeometry)&&null===r.get("ANGLE_instanced_arrays"))return;v();let c=u.attributes,h=l.getAttributes(),d=o.defaultAttributeValues;for(let r in h){let o=h[r];if(o.location>=0){let l=c[r];if(void 0===l&&("instanceMatrix"===r&&s.instanceMatrix&&(l=s.instanceMatrix),"instanceColor"===r&&s.instanceColor&&(l=s.instanceColor)),void 0!==l){let r=l.normalized,c=l.itemSize,h=i.get(l);// TODO Attribute may not be available on context restore
if(void 0===h)continue;let d=h.buffer,p=h.type,f=h.bytesPerElement,m=!0===a.isWebGL2&&(p===n.INT||p===n.UNSIGNED_INT||l.gpuType===$d5b33d7c30034067$export$5c612977753abe2);if(l.isInterleavedBufferAttribute){let i=l.data,a=i.stride,h=l.offset;if(i.isInstancedInterleavedBuffer){for(let n=0;n<o.locationSize;n++)w(o.location+n,i.meshPerAttribute);!0!==s.isInstancedMesh&&void 0===u._maxInstanceCount&&(u._maxInstanceCount=i.meshPerAttribute*i.count)}else for(let n=0;n<o.locationSize;n++)x(o.location+n);n.bindBuffer(n.ARRAY_BUFFER,d);for(let n=0;n<o.locationSize;n++)S(o.location+n,c/o.locationSize,p,r,a*f,(h+c/o.locationSize*n)*f,m)}else{if(l.isInstancedBufferAttribute){for(let n=0;n<o.locationSize;n++)w(o.location+n,l.meshPerAttribute);!0!==s.isInstancedMesh&&void 0===u._maxInstanceCount&&(u._maxInstanceCount=l.meshPerAttribute*l.count)}else for(let n=0;n<o.locationSize;n++)x(o.location+n);n.bindBuffer(n.ARRAY_BUFFER,d);for(let n=0;n<o.locationSize;n++)S(o.location+n,c/o.locationSize,p,r,c*f,c/o.locationSize*n*f,m)}}else if(void 0!==d){let i=d[r];if(void 0!==i)switch(i.length){case 2:n.vertexAttrib2fv(o.location,i);break;case 3:n.vertexAttrib3fv(o.location,i);break;case 4:n.vertexAttrib4fv(o.location,i);break;default:n.vertexAttrib1fv(o.location,i)}}}}T()}function A(){for(let n in M(),u){let r=u[n];for(let n in r){let i=r[n];for(let n in i)m(i[n].object),delete i[n];delete r[n]}delete u[n]}}function M(){I(),d=!0,h!==c&&f((h=c).object)}// for backward-compatibility
function I(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:function(r,a,s,o,u){let c=!1;if(l){let n=g(o,s,a);h!==n&&f((h=n).object),(c=y(r,o,s,u))&&b(r,o,s,u)}else{let n=!0===a.wireframe;(h.geometry!==o.id||h.program!==s.id||h.wireframe!==n)&&(h.geometry=o.id,h.program=s.id,h.wireframe=n,c=!0)}null!==u&&i.update(u,n.ELEMENT_ARRAY_BUFFER),(c||d)&&(d=!1,E(r,a,s,o),null!==u&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,i.get(u).buffer))},reset:M,resetDefaultState:I,dispose:A,releaseStatesOfGeometry:function(n){if(void 0===u[n.id])return;let r=u[n.id];for(let n in r){let i=r[n];for(let n in i)m(i[n].object),delete i[n];delete r[n]}delete u[n.id]},releaseStatesOfProgram:function(n){for(let r in u){let i=u[r];if(void 0===i[n.id])continue;let a=i[n.id];for(let n in a)m(a[n].object),delete a[n];delete i[n.id]}},initAttributes:v,enableAttribute:x,disableUnusedAttributes:T}}function $d5b33d7c30034067$var$WebGLBufferRenderer(n,r,i,a){let s;let o=a.isWebGL2;function l(n){s=n}function u(r,a){n.drawArrays(s,r,a),i.update(a,s,1)}function c(a,l,u){let c,h;if(0!==u){if(o)c=n,h="drawArraysInstanced";else if(c=r.get("ANGLE_instanced_arrays"),h="drawArraysInstancedANGLE",null===c){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}c[h](s,a,l,u),i.update(l,s,u)}}//
this.setMode=l,this.render=u,this.renderInstances=c}function $d5b33d7c30034067$var$WebGLCapabilities(n,r,i){let a;function s(){if(void 0!==a)return a;if(!0===r.has("EXT_texture_filter_anisotropic")){let i=r.get("EXT_texture_filter_anisotropic");a=n.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else a=0;return a}function o(r){if("highp"===r){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";r="mediump"}return"mediump"===r&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let l="undefined"!=typeof WebGL2RenderingContext&&"WebGL2RenderingContext"===n.constructor.name,u=void 0!==i.precision?i.precision:"highp",c=o(u);c!==u&&(console.warn("THREE.WebGLRenderer:",u,"not supported, using",c,"instead."),u=c);let h=l||r.has("WEBGL_draw_buffers"),d=!0===i.logarithmicDepthBuffer,p=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),f=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),m=n.getParameter(n.MAX_TEXTURE_SIZE),g=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),_=n.getParameter(n.MAX_VERTEX_ATTRIBS),y=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),b=n.getParameter(n.MAX_VARYING_VECTORS),v=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),x=f>0,w=l||r.has("OES_texture_float"),T=x&&w,S=l?n.getParameter(n.MAX_SAMPLES):0;return{isWebGL2:l,drawBuffers:h,getMaxAnisotropy:s,getMaxPrecision:o,precision:u,logarithmicDepthBuffer:d,maxTextures:p,maxVertexTextures:f,maxTextureSize:m,maxCubemapSize:g,maxAttributes:_,maxVertexUniforms:y,maxVaryings:b,maxFragmentUniforms:v,vertexTextures:x,floatFragmentTextures:w,floatVertexTextures:T,maxSamples:S}}function $d5b33d7c30034067$var$WebGLClipping(n){let r=this,i=null,a=0,s=!1,o=!1,l=new $d5b33d7c30034067$export$7ff5ac152ef991b0,u=new $d5b33d7c30034067$export$8ff26dafa08918,c={value:null,needsUpdate:!1};function h(){c.value!==i&&(c.value=i,c.needsUpdate=a>0),r.numPlanes=a,r.numIntersection=0}function d(n,i,a,s){let o=null!==n?n.length:0,h=null;if(0!==o){if(h=c.value,!0!==s||null===h){let r=a+4*o,s=i.matrixWorldInverse;u.getNormalMatrix(s),(null===h||h.length<r)&&(h=new Float32Array(r));for(let r=0,i=a;r!==o;++r,i+=4)l.copy(n[r]).applyMatrix4(s,u),l.normal.toArray(h,i),h[i+3]=l.constant}c.value=h,c.needsUpdate=!0}return r.numPlanes=o,r.numIntersection=0,h}this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(n,r){let i=0!==n.length||r||// enable state of previous frame - the clipping code has to
// run another frame in order to reset the state:
0!==a||s;return s=r,a=n.length,i},this.beginShadows=function(){o=!0,d(null)},this.endShadows=function(){o=!1},this.setGlobalState=function(n,r){i=d(n,r,0)},this.setState=function(r,l,u){let p=r.clippingPlanes,f=r.clipIntersection,m=r.clipShadows,g=n.get(r);if(s&&null!==p&&0!==p.length&&(!o||m)){let n=o?0:a,r=4*n,s=g.clippingState||null;c.value=s,s=d(p,l,r,u);for(let n=0;n!==r;++n)s[n]=i[n];g.clippingState=s,this.numIntersection=f?this.numPlanes:0,this.numPlanes+=n}else // there's no local clipping
o?d(null):h()}}function $d5b33d7c30034067$var$WebGLCubeMaps(n){let r=new WeakMap;function i(n,r){return r===$d5b33d7c30034067$export$d64030b316d3b087?n.mapping=$d5b33d7c30034067$export$8759762a6477f2c4:r===$d5b33d7c30034067$export$ee99d97d46898098&&(n.mapping=$d5b33d7c30034067$export$dc59f8aed047f61d),n}function a(n){let i=n.target;i.removeEventListener("dispose",a);let s=r.get(i);void 0!==s&&(r.delete(i),s.dispose())}return{get:function(s){if(s&&s.isTexture&&!1===s.isRenderTargetTexture){let o=s.mapping;if(o===$d5b33d7c30034067$export$d64030b316d3b087||o===$d5b33d7c30034067$export$ee99d97d46898098){if(r.has(s)){let n=r.get(s).texture;return i(n,s.mapping)}{let o=s.image;if(!o||!(o.height>0))return null;{let l=new $d5b33d7c30034067$export$ac386671d651941e(o.height/2);return l.fromEquirectangularTexture(n,s),r.set(s,l),s.addEventListener("dispose",a),i(l.texture,s.mapping)}}}}return s},dispose:function(){r=new WeakMap}}}class $d5b33d7c30034067$export$9ebf355ee4ed261b extends $d5b33d7c30034067$export$79f141de891a5fed{constructor(n=-1,r=1,i=1,a=-1,s=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=n,this.right=r,this.top=i,this.bottom=a,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(n,r){return super.copy(n,r),this.left=n.left,this.right=n.right,this.top=n.top,this.bottom=n.bottom,this.near=n.near,this.far=n.far,this.zoom=n.zoom,this.view=null===n.view?null:Object.assign({},n.view),this}setViewOffset(n,r,i,a,s,o){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=r,this.view.offsetX=i,this.view.offsetY=a,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){let n=(this.right-this.left)/(2*this.zoom),r=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,a=(this.top+this.bottom)/2,s=i-n,o=i+n,l=a+r,u=a-r;if(null!==this.view&&this.view.enabled){let n=(this.right-this.left)/this.view.fullWidth/this.zoom,r=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=n*this.view.offsetX,o=s+n*this.view.width,l-=r*this.view.offsetY,u=l-r*this.view.height}this.projectionMatrix.makeOrthographic(s,o,l,u,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(n){let r=super.toJSON(n);return r.object.zoom=this.zoom,r.object.left=this.left,r.object.right=this.right,r.object.top=this.top,r.object.bottom=this.bottom,r.object.near=this.near,r.object.far=this.far,null!==this.view&&(r.object.view=Object.assign({},this.view)),r}}const $d5b33d7c30034067$var$LOD_MIN=4,$d5b33d7c30034067$var$EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],$d5b33d7c30034067$var$MAX_SAMPLES=20,$d5b33d7c30034067$var$_flatCamera=/*@__PURE__*/new $d5b33d7c30034067$export$9ebf355ee4ed261b,$d5b33d7c30034067$var$_clearColor=/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e;let $d5b33d7c30034067$var$_oldTarget=null;// Golden Ratio
const $d5b33d7c30034067$var$PHI=(1+Math.sqrt(5))/2,$d5b33d7c30034067$var$INV_PHI=1/$d5b33d7c30034067$var$PHI,$d5b33d7c30034067$var$_axisDirections=[/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(1,1,1),/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(-1,1,1),/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(1,1,-1),/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(-1,1,-1),/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(0,$d5b33d7c30034067$var$PHI,$d5b33d7c30034067$var$INV_PHI),/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(0,$d5b33d7c30034067$var$PHI,-$d5b33d7c30034067$var$INV_PHI),/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699($d5b33d7c30034067$var$INV_PHI,0,$d5b33d7c30034067$var$PHI),/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(-$d5b33d7c30034067$var$INV_PHI,0,$d5b33d7c30034067$var$PHI),/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699($d5b33d7c30034067$var$PHI,$d5b33d7c30034067$var$INV_PHI,0),/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699(-$d5b33d7c30034067$var$PHI,$d5b33d7c30034067$var$INV_PHI,0)];/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/class $d5b33d7c30034067$export$6add42717753e221{constructor(n){this._renderer=n,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */fromScene(n,r=0,i=.1,a=100){$d5b33d7c30034067$var$_oldTarget=this._renderer.getRenderTarget(),this._setSize(256);let s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(n,i,a,s),r>0&&this._blur(s,0,0,r),this._applyPMREM(s),this._cleanup(s),s}/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * or HDR. The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */fromEquirectangular(n,r=null){return this._fromTexture(n,r)}/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * or HDR. The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */fromCubemap(n,r=null){return this._fromTexture(n,r)}/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=$d5b33d7c30034067$var$_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=$d5b33d7c30034067$var$_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}// private interface
_setSize(n){this._lodMax=Math.floor(Math.log2(n)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let n=0;n<this._lodPlanes.length;n++)this._lodPlanes[n].dispose()}_cleanup(n){this._renderer.setRenderTarget($d5b33d7c30034067$var$_oldTarget),n.scissorTest=!1,$d5b33d7c30034067$var$_setViewport(n,0,0,n.width,n.height)}_fromTexture(n,r){n.mapping===$d5b33d7c30034067$export$8759762a6477f2c4||n.mapping===$d5b33d7c30034067$export$dc59f8aed047f61d?this._setSize(0===n.image.length?16:n.image[0].width||n.image[0].image.width):this._setSize(n.image.width/4),$d5b33d7c30034067$var$_oldTarget=this._renderer.getRenderTarget();let i=r||this._allocateTargets();return this._textureToCubeUV(n,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){let n=3*Math.max(this._cubeSize,112),r=4*this._cubeSize,i={magFilter:$d5b33d7c30034067$export$8a72f490b25c56c8,minFilter:$d5b33d7c30034067$export$8a72f490b25c56c8,generateMipmaps:!1,type:$d5b33d7c30034067$export$2697304443f382bc,format:$d5b33d7c30034067$export$3f8bb04b555a363c,colorSpace:$d5b33d7c30034067$export$42429b3acfb233a4,depthBuffer:!1},a=$d5b33d7c30034067$var$_createRenderTarget(n,r,i);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==n||this._pingPongRenderTarget.height!==r){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=$d5b33d7c30034067$var$_createRenderTarget(n,r,i);let{_lodMax:a}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=$d5b33d7c30034067$var$_createPlanes(a)),this._blurMaterial=$d5b33d7c30034067$var$_getBlurShader(a,n,r)}return a}_compileMaterial(n){let r=new $d5b33d7c30034067$export$e176487c05830cc5(this._lodPlanes[0],n);this._renderer.compile(r,$d5b33d7c30034067$var$_flatCamera)}_sceneToCubeUV(n,r,i,a){let s=90,o=1,l=new $d5b33d7c30034067$export$74e4ae24825f68d7(s,o,r,i),u=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],h=this._renderer,d=h.autoClear,p=h.toneMapping;h.getClearColor($d5b33d7c30034067$var$_clearColor),h.toneMapping=$d5b33d7c30034067$export$9fcb6b4294603b2,h.autoClear=!1;let f=new $d5b33d7c30034067$export$55cbcc9b622fe1f5({name:"PMREM.Background",side:$d5b33d7c30034067$export$d9f0486e75b5ace,depthWrite:!1,depthTest:!1}),m=new $d5b33d7c30034067$export$e176487c05830cc5(new $d5b33d7c30034067$export$33e43285f7406bd5,f),g=!1,_=n.background;_?_.isColor&&(f.color.copy(_),n.background=null,g=!0):(f.color.copy($d5b33d7c30034067$var$_clearColor),g=!0);for(let r=0;r<6;r++){let i=r%3;0===i?(l.up.set(0,u[r],0),l.lookAt(c[r],0,0)):1===i?(l.up.set(0,0,u[r]),l.lookAt(0,c[r],0)):(l.up.set(0,u[r],0),l.lookAt(0,0,c[r]));let s=this._cubeSize;$d5b33d7c30034067$var$_setViewport(a,i*s,r>2?s:0,s,s),h.setRenderTarget(a),g&&h.render(m,l),h.render(n,l)}m.geometry.dispose(),m.material.dispose(),h.toneMapping=p,h.autoClear=d,n.background=_}_textureToCubeUV(n,r){let i=this._renderer,a=n.mapping===$d5b33d7c30034067$export$8759762a6477f2c4||n.mapping===$d5b33d7c30034067$export$dc59f8aed047f61d;a?(null===this._cubemapMaterial&&(this._cubemapMaterial=$d5b33d7c30034067$var$_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===n.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=$d5b33d7c30034067$var$_getEquirectMaterial());let s=a?this._cubemapMaterial:this._equirectMaterial,o=new $d5b33d7c30034067$export$e176487c05830cc5(this._lodPlanes[0],s),l=s.uniforms;l.envMap.value=n;let u=this._cubeSize;$d5b33d7c30034067$var$_setViewport(r,0,0,3*u,2*u),i.setRenderTarget(r),i.render(o,$d5b33d7c30034067$var$_flatCamera)}_applyPMREM(n){let r=this._renderer,i=r.autoClear;r.autoClear=!1;for(let r=1;r<this._lodPlanes.length;r++){let i=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),a=$d5b33d7c30034067$var$_axisDirections[(r-1)%$d5b33d7c30034067$var$_axisDirections.length];this._blur(n,r-1,r,i,a)}r.autoClear=i}/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */_blur(n,r,i,a,s){let o=this._pingPongRenderTarget;this._halfBlur(n,o,r,i,a,"latitudinal",s),this._halfBlur(o,n,i,i,a,"longitudinal",s)}_halfBlur(n,r,i,a,s,o,l){let u=this._renderer,c=this._blurMaterial;"latitudinal"!==o&&"longitudinal"!==o&&console.error("blur direction must be either latitudinal or longitudinal!");// Number of standard deviations at which to cut off the discrete approximation.
let h=3,d=new $d5b33d7c30034067$export$e176487c05830cc5(this._lodPlanes[a],c),p=c.uniforms,f=this._sizeLods[i]-1,m=isFinite(s)?Math.PI/(2*f):2*Math.PI/(2*$d5b33d7c30034067$var$MAX_SAMPLES-1),g=s/m,_=isFinite(s)?1+Math.floor(h*g):$d5b33d7c30034067$var$MAX_SAMPLES;_>$d5b33d7c30034067$var$MAX_SAMPLES&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${$d5b33d7c30034067$var$MAX_SAMPLES}`);let y=[],b=0;for(let n=0;n<$d5b33d7c30034067$var$MAX_SAMPLES;++n){let r=n/g,i=Math.exp(-r*r/2);y.push(i),0===n?b+=i:n<_&&(b+=2*i)}for(let n=0;n<y.length;n++)y[n]=y[n]/b;p.envMap.value=n.texture,p.samples.value=_,p.weights.value=y,p.latitudinal.value="latitudinal"===o,l&&(p.poleAxis.value=l);let{_lodMax:v}=this;p.dTheta.value=m,p.mipInt.value=v-i;let x=this._sizeLods[a],w=3*x*(a>v-$d5b33d7c30034067$var$LOD_MIN?a-v+$d5b33d7c30034067$var$LOD_MIN:0),T=4*(this._cubeSize-x);$d5b33d7c30034067$var$_setViewport(r,w,T,3*x,2*x),u.setRenderTarget(r),u.render(d,$d5b33d7c30034067$var$_flatCamera)}}function $d5b33d7c30034067$var$_createPlanes(n){let r=[],i=[],a=[],s=n,o=n-$d5b33d7c30034067$var$LOD_MIN+1+$d5b33d7c30034067$var$EXTRA_LOD_SIGMA.length;for(let l=0;l<o;l++){let o=Math.pow(2,s);i.push(o);let u=1/o;l>n-$d5b33d7c30034067$var$LOD_MIN?u=$d5b33d7c30034067$var$EXTRA_LOD_SIGMA[l-n+$d5b33d7c30034067$var$LOD_MIN-1]:0===l&&(u=0),a.push(u);let c=1/(o-2),h=-c,d=1+c,p=[h,h,d,h,d,d,h,h,d,d,h,d],f=6,m=6,g=3,_=2,y=1,b=new Float32Array(g*m*f),v=new Float32Array(_*m*f),x=new Float32Array(y*m*f);for(let n=0;n<f;n++){let r=n%3*2/3-1,i=n>2?0:-1,a=[r,i,0,r+2/3,i,0,r+2/3,i+1,0,r,i,0,r+2/3,i+1,0,r,i+1,0];b.set(a,g*m*n),v.set(p,_*m*n);let s=[n,n,n,n,n,n];x.set(s,y*m*n)}let w=new $d5b33d7c30034067$export$b7be63a67df8959;w.setAttribute("position",new $d5b33d7c30034067$export$8dea267bd6bde117(b,g)),w.setAttribute("uv",new $d5b33d7c30034067$export$8dea267bd6bde117(v,_)),w.setAttribute("faceIndex",new $d5b33d7c30034067$export$8dea267bd6bde117(x,y)),r.push(w),s>$d5b33d7c30034067$var$LOD_MIN&&s--}return{lodPlanes:r,sizeLods:i,sigmas:a}}function $d5b33d7c30034067$var$_createRenderTarget(n,r,i){let a=new $d5b33d7c30034067$export$3c052beb2e51e23f(n,r,i);return a.texture.mapping=$d5b33d7c30034067$export$dbf3e70ff37af79,a.texture.name="PMREM.cubeUv",a.scissorTest=!0,a}function $d5b33d7c30034067$var$_setViewport(n,r,i,a,s){n.viewport.set(r,i,a,s),n.scissor.set(r,i,a,s)}function $d5b33d7c30034067$var$_getBlurShader(n,r,i){let a=new Float32Array($d5b33d7c30034067$var$MAX_SAMPLES),s=new $d5b33d7c30034067$export$64b5c384219d3699(0,1,0),o=new $d5b33d7c30034067$export$83c7d75d550a8b0d({name:"SphericalGaussianBlur",defines:{n:$d5b33d7c30034067$var$MAX_SAMPLES,CUBEUV_TEXEL_WIDTH:1/r,CUBEUV_TEXEL_HEIGHT:1/i,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:a},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:s}},vertexShader:$d5b33d7c30034067$var$_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:$d5b33d7c30034067$export$63b8d6b580fc65ba,depthTest:!1,depthWrite:!1});return o}function $d5b33d7c30034067$var$_getEquirectMaterial(){return new $d5b33d7c30034067$export$83c7d75d550a8b0d({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:$d5b33d7c30034067$var$_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:$d5b33d7c30034067$export$63b8d6b580fc65ba,depthTest:!1,depthWrite:!1})}function $d5b33d7c30034067$var$_getCubemapMaterial(){return new $d5b33d7c30034067$export$83c7d75d550a8b0d({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:$d5b33d7c30034067$var$_getCommonVertexShader(),fragmentShader:/* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:$d5b33d7c30034067$export$63b8d6b580fc65ba,depthTest:!1,depthWrite:!1})}function $d5b33d7c30034067$var$_getCommonVertexShader(){return/* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function $d5b33d7c30034067$var$WebGLCubeUVMaps(n){let r=new WeakMap,i=null;function a(n){let r=0,i=6;for(let a=0;a<i;a++)void 0!==n[a]&&r++;return r===i}function s(n){let i=n.target;i.removeEventListener("dispose",s);let a=r.get(i);void 0!==a&&(r.delete(i),a.dispose())}return{get:function(o){if(o&&o.isTexture){let l=o.mapping,u=l===$d5b33d7c30034067$export$d64030b316d3b087||l===$d5b33d7c30034067$export$ee99d97d46898098,c=l===$d5b33d7c30034067$export$8759762a6477f2c4||l===$d5b33d7c30034067$export$dc59f8aed047f61d;// equirect/cube map to cubeUV conversion
if(u||c){if(o.isRenderTargetTexture&&!0===o.needsPMREMUpdate){o.needsPMREMUpdate=!1;let a=r.get(o);return null===i&&(i=new $d5b33d7c30034067$export$6add42717753e221(n)),a=u?i.fromEquirectangular(o,a):i.fromCubemap(o,a),r.set(o,a),a.texture}if(r.has(o))return r.get(o).texture;{let l=o.image;if(!(u&&l&&l.height>0||c&&l&&a(l)))return null;{null===i&&(i=new $d5b33d7c30034067$export$6add42717753e221(n));let a=u?i.fromEquirectangular(o):i.fromCubemap(o);return r.set(o,a),o.addEventListener("dispose",s),a.texture}}}}return o},dispose:function(){r=new WeakMap,null!==i&&(i.dispose(),i=null)}}}function $d5b33d7c30034067$var$WebGLExtensions(n){let r={};function i(i){let a;if(void 0!==r[i])return r[i];switch(i){case"WEBGL_depth_texture":a=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":a=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":a=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":a=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:a=n.getExtension(i)}return r[i]=a,a}return{has:function(n){return null!==i(n)},init:function(n){n.isWebGL2?i("EXT_color_buffer_float"):(i("WEBGL_depth_texture"),i("OES_texture_float"),i("OES_texture_half_float"),i("OES_texture_half_float_linear"),i("OES_standard_derivatives"),i("OES_element_index_uint"),i("OES_vertex_array_object"),i("ANGLE_instanced_arrays")),i("OES_texture_float_linear"),i("EXT_color_buffer_half_float"),i("WEBGL_multisampled_render_to_texture")},get:function(n){let r=i(n);return null===r&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),r}}}function $d5b33d7c30034067$var$WebGLGeometries(n,r,i,a){let s={},o=new WeakMap;function l(n){let u=n.target;for(let n in null!==u.index&&r.remove(u.index),u.attributes)r.remove(u.attributes[n]);for(let n in u.morphAttributes){let i=u.morphAttributes[n];for(let n=0,a=i.length;n<a;n++)r.remove(i[n])}u.removeEventListener("dispose",l),delete s[u.id];let c=o.get(u);c&&(r.remove(c),o.delete(u)),a.releaseStatesOfGeometry(u),!0===u.isInstancedBufferGeometry&&delete u._maxInstanceCount,//
i.memory.geometries--}function u(n){let i=[],a=n.index,s=n.attributes.position,l=0;if(null!==a){let n=a.array;l=a.version;for(let r=0,a=n.length;r<a;r+=3){let a=n[r+0],s=n[r+1],o=n[r+2];i.push(a,s,s,o,o,a)}}else{if(void 0===s)return;let n=s.array;l=s.version;for(let r=0,a=n.length/3-1;r<a;r+=3){let n=r+0,a=r+1,s=r+2;i.push(n,a,a,s,s,n)}}let u=new($d5b33d7c30034067$var$arrayNeedsUint32(i)?$d5b33d7c30034067$export$7eb8c9fa25cd5bd6:$d5b33d7c30034067$export$640a853f68025f2e)(i,1);u.version=l;// Updating index buffer in VAO now. See WebGLBindingStates
//
let c=o.get(n);c&&r.remove(c),//
o.set(n,u)}return{get:function(n,r){return!0===s[r.id]||(r.addEventListener("dispose",l),s[r.id]=!0,i.memory.geometries++),r},update:function(i){let a=i.attributes;// Updating index buffer in VAO now. See WebGLBindingStates.
for(let i in a)r.update(a[i],n.ARRAY_BUFFER);// morph targets
let s=i.morphAttributes;for(let i in s){let a=s[i];for(let i=0,s=a.length;i<s;i++)r.update(a[i],n.ARRAY_BUFFER)}},getWireframeAttribute:function(n){let r=o.get(n);if(r){let i=n.index;null!==i&&r.version<i.version&&u(n)}else u(n);return o.get(n)}}}function $d5b33d7c30034067$var$WebGLIndexedBufferRenderer(n,r,i,a){let s,o,l;let u=a.isWebGL2;function c(n){s=n}function h(n){o=n.type,l=n.bytesPerElement}function d(r,a){n.drawElements(s,a,o,r*l),i.update(a,s,1)}function p(a,c,h){let d,p;if(0!==h){if(u)d=n,p="drawElementsInstanced";else if(d=r.get("ANGLE_instanced_arrays"),p="drawElementsInstancedANGLE",null===d){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[p](s,c,o,a*l,h),i.update(c,s,h)}}//
this.setMode=c,this.setIndex=h,this.render=d,this.renderInstances=p}function $d5b33d7c30034067$var$WebGLInfo(n){let r={geometries:0,textures:0},i={frame:0,calls:0,triangles:0,points:0,lines:0};function a(r,a,s){switch(i.calls++,a){case n.TRIANGLES:i.triangles+=s*(r/3);break;case n.LINES:i.lines+=s*(r/2);break;case n.LINE_STRIP:i.lines+=s*(r-1);break;case n.LINE_LOOP:i.lines+=s*r;break;case n.POINTS:i.points+=s*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a)}}function s(){i.calls=0,i.triangles=0,i.points=0,i.lines=0}return{memory:r,render:i,programs:null,autoReset:!0,reset:s,update:a}}function $d5b33d7c30034067$var$numericalSort(n,r){return n[0]-r[0]}function $d5b33d7c30034067$var$absNumericalSort(n,r){return Math.abs(r[1])-Math.abs(n[1])}function $d5b33d7c30034067$var$WebGLMorphtargets(n,r,i){let a={},s=new Float32Array(8),o=new WeakMap,l=new $d5b33d7c30034067$export$fa7daccca11cdbe3,u=[];for(let n=0;n<8;n++)u[n]=[n,0];return{update:function(c,h,d){let p=c.morphTargetInfluences;if(!0===r.isWebGL2){// instead of using attributes, the WebGL 2 code path encodes morph targets
// into an array of data textures. Each layer represents a single morph target.
let a=h.morphAttributes.position||h.morphAttributes.normal||h.morphAttributes.color,s=void 0!==a?a.length:0,u=o.get(h);if(void 0===u||u.count!==s){void 0!==u&&u.texture.dispose();let n=void 0!==h.morphAttributes.position,i=void 0!==h.morphAttributes.normal,a=void 0!==h.morphAttributes.color,c=h.morphAttributes.position||[],d=h.morphAttributes.normal||[],p=h.morphAttributes.color||[],m=0;!0===n&&(m=1),!0===i&&(m=2),!0===a&&(m=3);let g=h.attributes.position.count*m,_=1;g>r.maxTextureSize&&(_=Math.ceil(g/r.maxTextureSize),g=r.maxTextureSize);let y=new Float32Array(g*_*4*s),b=new $d5b33d7c30034067$export$dfac6c8e811406a3(y,g,_,s);b.type=$d5b33d7c30034067$export$f6d331659b644596,b.needsUpdate=!0;// fill buffer
let v=4*m;for(let r=0;r<s;r++){let s=c[r],o=d[r],u=p[r],h=g*_*4*r;for(let r=0;r<s.count;r++){let c=r*v;!0===n&&(l.fromBufferAttribute(s,r),y[h+c+0]=l.x,y[h+c+1]=l.y,y[h+c+2]=l.z,y[h+c+3]=0),!0===i&&(l.fromBufferAttribute(o,r),y[h+c+4]=l.x,y[h+c+5]=l.y,y[h+c+6]=l.z,y[h+c+7]=0),!0===a&&(l.fromBufferAttribute(u,r),y[h+c+8]=l.x,y[h+c+9]=l.y,y[h+c+10]=l.z,y[h+c+11]=4===u.itemSize?l.w:1)}}function f(){b.dispose(),o.delete(h),h.removeEventListener("dispose",f)}u={count:s,texture:b,size:new $d5b33d7c30034067$export$c977b3e384af9ae1(g,_)},o.set(h,u),h.addEventListener("dispose",f)}//
let c=0;for(let n=0;n<p.length;n++)c+=p[n];let m=h.morphTargetsRelative?1:1-c;d.getUniforms().setValue(n,"morphTargetBaseInfluence",m),d.getUniforms().setValue(n,"morphTargetInfluences",p),d.getUniforms().setValue(n,"morphTargetsTexture",u.texture,i),d.getUniforms().setValue(n,"morphTargetsTextureSize",u.size)}else{// When object doesn't have morph target influences defined, we treat it as a 0-length array
// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
let r=void 0===p?0:p.length,i=a[h.id];if(void 0===i||i.length!==r){// initialise list
i=[];for(let n=0;n<r;n++)i[n]=[n,0];a[h.id]=i}// Collect influences
for(let n=0;n<r;n++){let r=i[n];r[0]=n,r[1]=p[n]}i.sort($d5b33d7c30034067$var$absNumericalSort);for(let n=0;n<8;n++)n<r&&i[n][1]?(u[n][0]=i[n][0],u[n][1]=i[n][1]):(u[n][0]=Number.MAX_SAFE_INTEGER,u[n][1]=0);u.sort($d5b33d7c30034067$var$numericalSort);let o=h.morphAttributes.position,l=h.morphAttributes.normal,c=0;for(let n=0;n<8;n++){let r=u[n],i=r[0],a=r[1];i!==Number.MAX_SAFE_INTEGER&&a?(o&&h.getAttribute("morphTarget"+n)!==o[i]&&h.setAttribute("morphTarget"+n,o[i]),l&&h.getAttribute("morphNormal"+n)!==l[i]&&h.setAttribute("morphNormal"+n,l[i]),s[n]=a,c+=a):(o&&!0===h.hasAttribute("morphTarget"+n)&&h.deleteAttribute("morphTarget"+n),l&&!0===h.hasAttribute("morphNormal"+n)&&h.deleteAttribute("morphNormal"+n),s[n]=0)}// GLSL shader uses formula baseinfluence * base + sum(target * influence)
// This allows us to switch between absolute morphs and relative morphs without changing shader code
// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
let f=h.morphTargetsRelative?1:1-c;d.getUniforms().setValue(n,"morphTargetBaseInfluence",f),d.getUniforms().setValue(n,"morphTargetInfluences",s)}}}}function $d5b33d7c30034067$var$WebGLObjects(n,r,i,a){let s=new WeakMap;function o(n){let r=n.target;r.removeEventListener("dispose",o),i.remove(r.instanceMatrix),null!==r.instanceColor&&i.remove(r.instanceColor)}return{update:function(l){let u=a.render.frame,c=l.geometry,h=r.get(l,c);if(s.get(h)!==u&&(r.update(h),s.set(h,u)),l.isInstancedMesh&&(!1===l.hasEventListener("dispose",o)&&l.addEventListener("dispose",o),s.get(l)!==u&&(i.update(l.instanceMatrix,n.ARRAY_BUFFER),null!==l.instanceColor&&i.update(l.instanceColor,n.ARRAY_BUFFER),s.set(l,u))),l.isSkinnedMesh){let n=l.skeleton;s.get(n)!==u&&(n.update(),s.set(n,u))}return h},dispose:function(){s=new WeakMap}}}/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */const $d5b33d7c30034067$var$emptyTexture=/*@__PURE__*/new $d5b33d7c30034067$export$5431306cf43de24a,$d5b33d7c30034067$var$emptyArrayTexture=/*@__PURE__*/new $d5b33d7c30034067$export$dfac6c8e811406a3,$d5b33d7c30034067$var$empty3dTexture=/*@__PURE__*/new $d5b33d7c30034067$export$d7a3086320f856db,$d5b33d7c30034067$var$emptyCubeTexture=/*@__PURE__*/new $d5b33d7c30034067$export$ee2e5a18258a4049,$d5b33d7c30034067$var$arrayCacheF32=[],$d5b33d7c30034067$var$arrayCacheI32=[],$d5b33d7c30034067$var$mat4array=new Float32Array(16),$d5b33d7c30034067$var$mat3array=new Float32Array(9),$d5b33d7c30034067$var$mat2array=new Float32Array(4);// Flattening for arrays of vectors and matrices
function $d5b33d7c30034067$var$flatten(n,r,i){let a=n[0];if(a<=0||a>0)return n;// unoptimized: ! isNaN( firstElem )
// see http://jacksondunstan.com/articles/983
let s=r*i,o=$d5b33d7c30034067$var$arrayCacheF32[s];if(void 0===o&&(o=new Float32Array(s),$d5b33d7c30034067$var$arrayCacheF32[s]=o),0!==r){a.toArray(o,0);for(let a=1,s=0;a!==r;++a)s+=i,n[a].toArray(o,s)}return o}function $d5b33d7c30034067$var$arraysEqual(n,r){if(n.length!==r.length)return!1;for(let i=0,a=n.length;i<a;i++)if(n[i]!==r[i])return!1;return!0}function $d5b33d7c30034067$var$copyArray(n,r){for(let i=0,a=r.length;i<a;i++)n[i]=r[i]}// Texture unit allocation
function $d5b33d7c30034067$var$allocTexUnits(n,r){let i=$d5b33d7c30034067$var$arrayCacheI32[r];void 0===i&&(i=new Int32Array(r),$d5b33d7c30034067$var$arrayCacheI32[r]=i);for(let a=0;a!==r;++a)i[a]=n.allocateTextureUnit();return i}// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function $d5b33d7c30034067$var$setValueV1f(n,r){let i=this.cache;i[0]!==r&&(n.uniform1f(this.addr,r),i[0]=r)}// Single float vector (from flat array or THREE.VectorN)
function $d5b33d7c30034067$var$setValueV2f(n,r){let i=this.cache;if(void 0!==r.x)(i[0]!==r.x||i[1]!==r.y)&&(n.uniform2f(this.addr,r.x,r.y),i[0]=r.x,i[1]=r.y);else{if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniform2fv(this.addr,r),$d5b33d7c30034067$var$copyArray(i,r)}}function $d5b33d7c30034067$var$setValueV3f(n,r){let i=this.cache;if(void 0!==r.x)(i[0]!==r.x||i[1]!==r.y||i[2]!==r.z)&&(n.uniform3f(this.addr,r.x,r.y,r.z),i[0]=r.x,i[1]=r.y,i[2]=r.z);else if(void 0!==r.r)(i[0]!==r.r||i[1]!==r.g||i[2]!==r.b)&&(n.uniform3f(this.addr,r.r,r.g,r.b),i[0]=r.r,i[1]=r.g,i[2]=r.b);else{if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniform3fv(this.addr,r),$d5b33d7c30034067$var$copyArray(i,r)}}function $d5b33d7c30034067$var$setValueV4f(n,r){let i=this.cache;if(void 0!==r.x)(i[0]!==r.x||i[1]!==r.y||i[2]!==r.z||i[3]!==r.w)&&(n.uniform4f(this.addr,r.x,r.y,r.z,r.w),i[0]=r.x,i[1]=r.y,i[2]=r.z,i[3]=r.w);else{if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniform4fv(this.addr,r),$d5b33d7c30034067$var$copyArray(i,r)}}// Single matrix (from flat array or THREE.MatrixN)
function $d5b33d7c30034067$var$setValueM2(n,r){let i=this.cache,a=r.elements;if(void 0===a){if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniformMatrix2fv(this.addr,!1,r),$d5b33d7c30034067$var$copyArray(i,r)}else{if($d5b33d7c30034067$var$arraysEqual(i,a))return;$d5b33d7c30034067$var$mat2array.set(a),n.uniformMatrix2fv(this.addr,!1,$d5b33d7c30034067$var$mat2array),$d5b33d7c30034067$var$copyArray(i,a)}}function $d5b33d7c30034067$var$setValueM3(n,r){let i=this.cache,a=r.elements;if(void 0===a){if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniformMatrix3fv(this.addr,!1,r),$d5b33d7c30034067$var$copyArray(i,r)}else{if($d5b33d7c30034067$var$arraysEqual(i,a))return;$d5b33d7c30034067$var$mat3array.set(a),n.uniformMatrix3fv(this.addr,!1,$d5b33d7c30034067$var$mat3array),$d5b33d7c30034067$var$copyArray(i,a)}}function $d5b33d7c30034067$var$setValueM4(n,r){let i=this.cache,a=r.elements;if(void 0===a){if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniformMatrix4fv(this.addr,!1,r),$d5b33d7c30034067$var$copyArray(i,r)}else{if($d5b33d7c30034067$var$arraysEqual(i,a))return;$d5b33d7c30034067$var$mat4array.set(a),n.uniformMatrix4fv(this.addr,!1,$d5b33d7c30034067$var$mat4array),$d5b33d7c30034067$var$copyArray(i,a)}}// Single integer / boolean
function $d5b33d7c30034067$var$setValueV1i(n,r){let i=this.cache;i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r)}// Single integer / boolean vector (from flat array or THREE.VectorN)
function $d5b33d7c30034067$var$setValueV2i(n,r){let i=this.cache;if(void 0!==r.x)(i[0]!==r.x||i[1]!==r.y)&&(n.uniform2i(this.addr,r.x,r.y),i[0]=r.x,i[1]=r.y);else{if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniform2iv(this.addr,r),$d5b33d7c30034067$var$copyArray(i,r)}}function $d5b33d7c30034067$var$setValueV3i(n,r){let i=this.cache;if(void 0!==r.x)(i[0]!==r.x||i[1]!==r.y||i[2]!==r.z)&&(n.uniform3i(this.addr,r.x,r.y,r.z),i[0]=r.x,i[1]=r.y,i[2]=r.z);else{if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniform3iv(this.addr,r),$d5b33d7c30034067$var$copyArray(i,r)}}function $d5b33d7c30034067$var$setValueV4i(n,r){let i=this.cache;if(void 0!==r.x)(i[0]!==r.x||i[1]!==r.y||i[2]!==r.z||i[3]!==r.w)&&(n.uniform4i(this.addr,r.x,r.y,r.z,r.w),i[0]=r.x,i[1]=r.y,i[2]=r.z,i[3]=r.w);else{if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniform4iv(this.addr,r),$d5b33d7c30034067$var$copyArray(i,r)}}// Single unsigned integer
function $d5b33d7c30034067$var$setValueV1ui(n,r){let i=this.cache;i[0]!==r&&(n.uniform1ui(this.addr,r),i[0]=r)}// Single unsigned integer vector (from flat array or THREE.VectorN)
function $d5b33d7c30034067$var$setValueV2ui(n,r){let i=this.cache;if(void 0!==r.x)(i[0]!==r.x||i[1]!==r.y)&&(n.uniform2ui(this.addr,r.x,r.y),i[0]=r.x,i[1]=r.y);else{if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniform2uiv(this.addr,r),$d5b33d7c30034067$var$copyArray(i,r)}}function $d5b33d7c30034067$var$setValueV3ui(n,r){let i=this.cache;if(void 0!==r.x)(i[0]!==r.x||i[1]!==r.y||i[2]!==r.z)&&(n.uniform3ui(this.addr,r.x,r.y,r.z),i[0]=r.x,i[1]=r.y,i[2]=r.z);else{if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniform3uiv(this.addr,r),$d5b33d7c30034067$var$copyArray(i,r)}}function $d5b33d7c30034067$var$setValueV4ui(n,r){let i=this.cache;if(void 0!==r.x)(i[0]!==r.x||i[1]!==r.y||i[2]!==r.z||i[3]!==r.w)&&(n.uniform4ui(this.addr,r.x,r.y,r.z,r.w),i[0]=r.x,i[1]=r.y,i[2]=r.z,i[3]=r.w);else{if($d5b33d7c30034067$var$arraysEqual(i,r))return;n.uniform4uiv(this.addr,r),$d5b33d7c30034067$var$copyArray(i,r)}}// Single texture (2D / Cube)
function $d5b33d7c30034067$var$setValueT1(n,r,i){let a=this.cache,s=i.allocateTextureUnit();a[0]!==s&&(n.uniform1i(this.addr,s),a[0]=s),i.setTexture2D(r||$d5b33d7c30034067$var$emptyTexture,s)}function $d5b33d7c30034067$var$setValueT3D1(n,r,i){let a=this.cache,s=i.allocateTextureUnit();a[0]!==s&&(n.uniform1i(this.addr,s),a[0]=s),i.setTexture3D(r||$d5b33d7c30034067$var$empty3dTexture,s)}function $d5b33d7c30034067$var$setValueT6(n,r,i){let a=this.cache,s=i.allocateTextureUnit();a[0]!==s&&(n.uniform1i(this.addr,s),a[0]=s),i.setTextureCube(r||$d5b33d7c30034067$var$emptyCubeTexture,s)}function $d5b33d7c30034067$var$setValueT2DArray1(n,r,i){let a=this.cache,s=i.allocateTextureUnit();a[0]!==s&&(n.uniform1i(this.addr,s),a[0]=s),i.setTexture2DArray(r||$d5b33d7c30034067$var$emptyArrayTexture,s)}// Helper to pick the right setter for the singular case
function $d5b33d7c30034067$var$getSingularSetter(n){switch(n){case 5126:return $d5b33d7c30034067$var$setValueV1f;// FLOAT
case 35664:return $d5b33d7c30034067$var$setValueV2f;// _VEC2
case 35665:return $d5b33d7c30034067$var$setValueV3f;// _VEC3
case 35666:return $d5b33d7c30034067$var$setValueV4f;// _VEC4
case 35674:return $d5b33d7c30034067$var$setValueM2;// _MAT2
case 35675:return $d5b33d7c30034067$var$setValueM3;// _MAT3
case 35676:return $d5b33d7c30034067$var$setValueM4;// _MAT4
case 5124:case 35670:return $d5b33d7c30034067$var$setValueV1i;// INT, BOOL
case 35667:case 35671:return $d5b33d7c30034067$var$setValueV2i;// _VEC2
case 35668:case 35672:return $d5b33d7c30034067$var$setValueV3i;// _VEC3
case 35669:case 35673:return $d5b33d7c30034067$var$setValueV4i;// _VEC4
case 5125:return $d5b33d7c30034067$var$setValueV1ui;// UINT
case 36294:return $d5b33d7c30034067$var$setValueV2ui;// _VEC2
case 36295:return $d5b33d7c30034067$var$setValueV3ui;// _VEC3
case 36296:return $d5b33d7c30034067$var$setValueV4ui;// _VEC4
case 35678:case 36198:case 36298:case 36306:case 35682:return $d5b33d7c30034067$var$setValueT1;case 35679:case 36299:case 36307:return $d5b33d7c30034067$var$setValueT3D1;case 35680:case 36300:case 36308:case 36293:return $d5b33d7c30034067$var$setValueT6;case 36289:case 36303:case 36311:case 36292:return $d5b33d7c30034067$var$setValueT2DArray1}}// Array of scalars
function $d5b33d7c30034067$var$setValueV1fArray(n,r){n.uniform1fv(this.addr,r)}// Array of vectors (from flat array or array of THREE.VectorN)
function $d5b33d7c30034067$var$setValueV2fArray(n,r){let i=$d5b33d7c30034067$var$flatten(r,this.size,2);n.uniform2fv(this.addr,i)}function $d5b33d7c30034067$var$setValueV3fArray(n,r){let i=$d5b33d7c30034067$var$flatten(r,this.size,3);n.uniform3fv(this.addr,i)}function $d5b33d7c30034067$var$setValueV4fArray(n,r){let i=$d5b33d7c30034067$var$flatten(r,this.size,4);n.uniform4fv(this.addr,i)}// Array of matrices (from flat array or array of THREE.MatrixN)
function $d5b33d7c30034067$var$setValueM2Array(n,r){let i=$d5b33d7c30034067$var$flatten(r,this.size,4);n.uniformMatrix2fv(this.addr,!1,i)}function $d5b33d7c30034067$var$setValueM3Array(n,r){let i=$d5b33d7c30034067$var$flatten(r,this.size,9);n.uniformMatrix3fv(this.addr,!1,i)}function $d5b33d7c30034067$var$setValueM4Array(n,r){let i=$d5b33d7c30034067$var$flatten(r,this.size,16);n.uniformMatrix4fv(this.addr,!1,i)}// Array of integer / boolean
function $d5b33d7c30034067$var$setValueV1iArray(n,r){n.uniform1iv(this.addr,r)}// Array of integer / boolean vectors (from flat array)
function $d5b33d7c30034067$var$setValueV2iArray(n,r){n.uniform2iv(this.addr,r)}function $d5b33d7c30034067$var$setValueV3iArray(n,r){n.uniform3iv(this.addr,r)}function $d5b33d7c30034067$var$setValueV4iArray(n,r){n.uniform4iv(this.addr,r)}// Array of unsigned integer
function $d5b33d7c30034067$var$setValueV1uiArray(n,r){n.uniform1uiv(this.addr,r)}// Array of unsigned integer vectors (from flat array)
function $d5b33d7c30034067$var$setValueV2uiArray(n,r){n.uniform2uiv(this.addr,r)}function $d5b33d7c30034067$var$setValueV3uiArray(n,r){n.uniform3uiv(this.addr,r)}function $d5b33d7c30034067$var$setValueV4uiArray(n,r){n.uniform4uiv(this.addr,r)}// Array of textures (2D / 3D / Cube / 2DArray)
function $d5b33d7c30034067$var$setValueT1Array(n,r,i){let a=this.cache,s=r.length,o=$d5b33d7c30034067$var$allocTexUnits(i,s);$d5b33d7c30034067$var$arraysEqual(a,o)||(n.uniform1iv(this.addr,o),$d5b33d7c30034067$var$copyArray(a,o));for(let n=0;n!==s;++n)i.setTexture2D(r[n]||$d5b33d7c30034067$var$emptyTexture,o[n])}function $d5b33d7c30034067$var$setValueT3DArray(n,r,i){let a=this.cache,s=r.length,o=$d5b33d7c30034067$var$allocTexUnits(i,s);$d5b33d7c30034067$var$arraysEqual(a,o)||(n.uniform1iv(this.addr,o),$d5b33d7c30034067$var$copyArray(a,o));for(let n=0;n!==s;++n)i.setTexture3D(r[n]||$d5b33d7c30034067$var$empty3dTexture,o[n])}function $d5b33d7c30034067$var$setValueT6Array(n,r,i){let a=this.cache,s=r.length,o=$d5b33d7c30034067$var$allocTexUnits(i,s);$d5b33d7c30034067$var$arraysEqual(a,o)||(n.uniform1iv(this.addr,o),$d5b33d7c30034067$var$copyArray(a,o));for(let n=0;n!==s;++n)i.setTextureCube(r[n]||$d5b33d7c30034067$var$emptyCubeTexture,o[n])}function $d5b33d7c30034067$var$setValueT2DArrayArray(n,r,i){let a=this.cache,s=r.length,o=$d5b33d7c30034067$var$allocTexUnits(i,s);$d5b33d7c30034067$var$arraysEqual(a,o)||(n.uniform1iv(this.addr,o),$d5b33d7c30034067$var$copyArray(a,o));for(let n=0;n!==s;++n)i.setTexture2DArray(r[n]||$d5b33d7c30034067$var$emptyArrayTexture,o[n])}// Helper to pick the right setter for a pure (bottom-level) array
function $d5b33d7c30034067$var$getPureArraySetter(n){switch(n){case 5126:return $d5b33d7c30034067$var$setValueV1fArray;// FLOAT
case 35664:return $d5b33d7c30034067$var$setValueV2fArray;// _VEC2
case 35665:return $d5b33d7c30034067$var$setValueV3fArray;// _VEC3
case 35666:return $d5b33d7c30034067$var$setValueV4fArray;// _VEC4
case 35674:return $d5b33d7c30034067$var$setValueM2Array;// _MAT2
case 35675:return $d5b33d7c30034067$var$setValueM3Array;// _MAT3
case 35676:return $d5b33d7c30034067$var$setValueM4Array;// _MAT4
case 5124:case 35670:return $d5b33d7c30034067$var$setValueV1iArray;// INT, BOOL
case 35667:case 35671:return $d5b33d7c30034067$var$setValueV2iArray;// _VEC2
case 35668:case 35672:return $d5b33d7c30034067$var$setValueV3iArray;// _VEC3
case 35669:case 35673:return $d5b33d7c30034067$var$setValueV4iArray;// _VEC4
case 5125:return $d5b33d7c30034067$var$setValueV1uiArray;// UINT
case 36294:return $d5b33d7c30034067$var$setValueV2uiArray;// _VEC2
case 36295:return $d5b33d7c30034067$var$setValueV3uiArray;// _VEC3
case 36296:return $d5b33d7c30034067$var$setValueV4uiArray;// _VEC4
case 35678:case 36198:case 36298:case 36306:case 35682:return $d5b33d7c30034067$var$setValueT1Array;case 35679:case 36299:case 36307:return $d5b33d7c30034067$var$setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return $d5b33d7c30034067$var$setValueT6Array;case 36289:case 36303:case 36311:case 36292:return $d5b33d7c30034067$var$setValueT2DArrayArray}}// --- Uniform Classes ---
class $d5b33d7c30034067$var$SingleUniform{constructor(n,r,i){this.id=n,this.addr=i,this.cache=[],this.setValue=$d5b33d7c30034067$var$getSingularSetter(r.type);// this.path = activeInfo.name; // DEBUG
}}class $d5b33d7c30034067$var$PureArrayUniform{constructor(n,r,i){this.id=n,this.addr=i,this.cache=[],this.size=r.size,this.setValue=$d5b33d7c30034067$var$getPureArraySetter(r.type);// this.path = activeInfo.name; // DEBUG
}}class $d5b33d7c30034067$var$StructuredUniform{constructor(n){this.id=n,this.seq=[],this.map={}}setValue(n,r,i){let a=this.seq;for(let s=0,o=a.length;s!==o;++s){let o=a[s];o.setValue(n,r[o.id],i)}}}// --- Top-level ---
// Parser - builds up the property tree from the path strings
const $d5b33d7c30034067$var$RePathPart=/(\w+)(\])?(\[|\.)?/g;// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function $d5b33d7c30034067$var$addUniform(n,r){n.seq.push(r),n.map[r.id]=r}function $d5b33d7c30034067$var$parseUniform(n,r,i){let a=n.name,s=a.length;for(// reset RegExp object, because of the early exit of a previous run
$d5b33d7c30034067$var$RePathPart.lastIndex=0;;){let o=$d5b33d7c30034067$var$RePathPart.exec(a),l=$d5b33d7c30034067$var$RePathPart.lastIndex,u=o[1],c="]"===o[2],h=o[3];if(c&&(u|=0),void 0===h||"["===h&&l+2===s){// bare name or "pure" bottom-level array "[0]" suffix
$d5b33d7c30034067$var$addUniform(i,void 0===h?new $d5b33d7c30034067$var$SingleUniform(u,n,r):new $d5b33d7c30034067$var$PureArrayUniform(u,n,r));break}{// step into inner node / create it in case it doesn't exist
let n=i.map,r=n[u];void 0===r&&$d5b33d7c30034067$var$addUniform(i,r=new $d5b33d7c30034067$var$StructuredUniform(u)),i=r}}}// Root Container
class $d5b33d7c30034067$var$WebGLUniforms{constructor(n,r){this.seq=[],this.map={};let i=n.getProgramParameter(r,n.ACTIVE_UNIFORMS);for(let a=0;a<i;++a){let i=n.getActiveUniform(r,a),s=n.getUniformLocation(r,i.name);$d5b33d7c30034067$var$parseUniform(i,s,this)}}setValue(n,r,i,a){let s=this.map[r];void 0!==s&&s.setValue(n,i,a)}setOptional(n,r,i){let a=r[i];void 0!==a&&this.setValue(n,i,a)}static upload(n,r,i,a){for(let s=0,o=r.length;s!==o;++s){let o=r[s],l=i[o.id];!1!==l.needsUpdate&&o.setValue(n,l.value,a)}}static seqWithValue(n,r){let i=[];for(let a=0,s=n.length;a!==s;++a){let s=n[a];s.id in r&&i.push(s)}return i}}function $d5b33d7c30034067$var$WebGLShader(n,r,i){let a=n.createShader(r);return n.shaderSource(a,i),n.compileShader(a),a}let $d5b33d7c30034067$var$programIdCount=0;function $d5b33d7c30034067$var$handleSource(n,r){let i=n.split("\n"),a=[],s=Math.max(r-6,0),o=Math.min(r+6,i.length);for(let n=s;n<o;n++){let s=n+1;a.push(`${s===r?">":" "} ${s}: ${i[n]}`)}return a.join("\n")}function $d5b33d7c30034067$var$getEncodingComponents(n){switch(n){case $d5b33d7c30034067$export$42429b3acfb233a4:return["Linear","( value )"];case $d5b33d7c30034067$export$561f394b24edfcaa:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",n),["Linear","( value )"]}}function $d5b33d7c30034067$var$getShaderErrors(n,r,i){let a=n.getShaderParameter(r,n.COMPILE_STATUS),s=n.getShaderInfoLog(r).trim();if(a&&""===s)return"";let o=/ERROR: 0:(\d+)/.exec(s);if(!o)return s;{// --enable-privileged-webgl-extension
// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
let a=parseInt(o[1]);return i.toUpperCase()+"\n\n"+s+"\n\n"+$d5b33d7c30034067$var$handleSource(n.getShaderSource(r),a)}}function $d5b33d7c30034067$var$getTexelEncodingFunction(n,r){let i=$d5b33d7c30034067$var$getEncodingComponents(r);return"vec4 "+n+"( vec4 value ) { return LinearTo"+i[0]+i[1]+"; }"}function $d5b33d7c30034067$var$getToneMappingFunction(n,r){let i;switch(r){case $d5b33d7c30034067$export$98f52c2a46c598ca:i="Linear";break;case $d5b33d7c30034067$export$74b25e54b3bcd548:i="Reinhard";break;case $d5b33d7c30034067$export$932b3dd283d4a366:i="OptimizedCineon";break;case $d5b33d7c30034067$export$a0d98fe6d7e4af64:i="ACESFilmic";break;case $d5b33d7c30034067$export$2c7b09c1e9abfb5e:i="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",r),i="Linear"}return"vec3 "+n+"( vec3 color ) { return "+i+"ToneMapping( color ); }"}function $d5b33d7c30034067$var$generateExtensions(n){let r=[n.extensionDerivatives||n.envMapCubeUVHeight||n.bumpMap||n.normalMapTangentSpace||n.clearcoatNormalMap||n.flatShading||"physical"===n.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""];return r.filter($d5b33d7c30034067$var$filterEmptyLine).join("\n")}function $d5b33d7c30034067$var$generateDefines(n){let r=[];for(let i in n){let a=n[i];!1!==a&&r.push("#define "+i+" "+a)}return r.join("\n")}function $d5b33d7c30034067$var$fetchAttributeLocations(n,r){let i={},a=n.getProgramParameter(r,n.ACTIVE_ATTRIBUTES);for(let s=0;s<a;s++){let a=n.getActiveAttrib(r,s),o=a.name,l=1;a.type===n.FLOAT_MAT2&&(l=2),a.type===n.FLOAT_MAT3&&(l=3),a.type===n.FLOAT_MAT4&&(l=4),// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
i[o]={type:a.type,location:n.getAttribLocation(r,o),locationSize:l}}return i}function $d5b33d7c30034067$var$filterEmptyLine(n){return""!==n}function $d5b33d7c30034067$var$replaceLightNums(n,r){let i=r.numSpotLightShadows+r.numSpotLightMaps-r.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,r.numDirLights).replace(/NUM_SPOT_LIGHTS/g,r.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,r.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,i).replace(/NUM_RECT_AREA_LIGHTS/g,r.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,r.numPointLights).replace(/NUM_HEMI_LIGHTS/g,r.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,r.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,r.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,r.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,r.numPointLightShadows)}function $d5b33d7c30034067$var$replaceClippingPlaneNums(n,r){return n.replace(/NUM_CLIPPING_PLANES/g,r.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,r.numClippingPlanes-r.numClipIntersection)}// Resolve Includes
const $d5b33d7c30034067$var$includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function $d5b33d7c30034067$var$resolveIncludes(n){return n.replace($d5b33d7c30034067$var$includePattern,$d5b33d7c30034067$var$includeReplacer)}const $d5b33d7c30034067$var$shaderChunkMap=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function $d5b33d7c30034067$var$includeReplacer(n,r){let i=$d5b33d7c30034067$export$955f9f2e84c43c8b[r];if(void 0===i){let n=$d5b33d7c30034067$var$shaderChunkMap.get(r);if(void 0!==n)i=$d5b33d7c30034067$export$955f9f2e84c43c8b[n],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',r,n);else throw Error("Can not resolve #include <"+r+">")}return $d5b33d7c30034067$var$resolveIncludes(i)}// Unroll Loops
const $d5b33d7c30034067$var$unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function $d5b33d7c30034067$var$unrollLoops(n){return n.replace($d5b33d7c30034067$var$unrollLoopPattern,$d5b33d7c30034067$var$loopReplacer)}function $d5b33d7c30034067$var$loopReplacer(n,r,i,a){let s="";for(let n=parseInt(r);n<parseInt(i);n++)s+=a.replace(/\[\s*i\s*\]/g,"[ "+n+" ]").replace(/UNROLLED_LOOP_INDEX/g,n);return s}//
function $d5b33d7c30034067$var$generatePrecision(n){let r="precision "+n.precision+" float;\nprecision "+n.precision+" int;";return"highp"===n.precision?r+="\n#define HIGH_PRECISION":"mediump"===n.precision?r+="\n#define MEDIUM_PRECISION":"lowp"===n.precision&&(r+="\n#define LOW_PRECISION"),r}function $d5b33d7c30034067$var$generateShadowMapTypeDefine(n){let r="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===$d5b33d7c30034067$export$5813f879eee7cd88?r="SHADOWMAP_TYPE_PCF":n.shadowMapType===$d5b33d7c30034067$export$a47c4b43a1be34f0?r="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===$d5b33d7c30034067$export$896ae1ade6c829c4&&(r="SHADOWMAP_TYPE_VSM"),r}function $d5b33d7c30034067$var$generateEnvMapTypeDefine(n){let r="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case $d5b33d7c30034067$export$8759762a6477f2c4:case $d5b33d7c30034067$export$dc59f8aed047f61d:r="ENVMAP_TYPE_CUBE";break;case $d5b33d7c30034067$export$dbf3e70ff37af79:r="ENVMAP_TYPE_CUBE_UV"}return r}function $d5b33d7c30034067$var$generateEnvMapModeDefine(n){let r="ENVMAP_MODE_REFLECTION";return n.envMap&&n.envMapMode===$d5b33d7c30034067$export$dc59f8aed047f61d&&(r="ENVMAP_MODE_REFRACTION"),r}function $d5b33d7c30034067$var$generateEnvMapBlendingDefine(n){let r="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case $d5b33d7c30034067$export$e50ac29801f1774d:r="ENVMAP_BLENDING_MULTIPLY";break;case $d5b33d7c30034067$export$9f9d94f963c85479:r="ENVMAP_BLENDING_MIX";break;case $d5b33d7c30034067$export$e641dc52bc3494aa:r="ENVMAP_BLENDING_ADD"}return r}function $d5b33d7c30034067$var$generateCubeUVSize(n){let r=n.envMapCubeUVHeight;if(null===r)return null;let i=Math.log2(r)-2,a=1/r,s=1/(3*Math.max(Math.pow(2,i),112));return{texelWidth:s,texelHeight:a,maxMip:i}}function $d5b33d7c30034067$var$WebGLProgram(n,r,i,a){let s,o,l,u;// TODO Send this event to Three.js DevTools
// console.log( 'WebGLProgram', cacheKey );
let c=n.getContext(),h=i.defines,d=i.vertexShader,p=i.fragmentShader,f=$d5b33d7c30034067$var$generateShadowMapTypeDefine(i),m=$d5b33d7c30034067$var$generateEnvMapTypeDefine(i),g=$d5b33d7c30034067$var$generateEnvMapModeDefine(i),_=$d5b33d7c30034067$var$generateEnvMapBlendingDefine(i),y=$d5b33d7c30034067$var$generateCubeUVSize(i),b=i.isWebGL2?"":$d5b33d7c30034067$var$generateExtensions(i),v=$d5b33d7c30034067$var$generateDefines(h),x=c.createProgram(),w=i.glslVersion?"#version "+i.glslVersion+"\n":"";i.isRawShaderMaterial?((s=["#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,v].filter($d5b33d7c30034067$var$filterEmptyLine).join("\n")).length>0&&(s+="\n"),(o=[b,"#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,v].filter($d5b33d7c30034067$var$filterEmptyLine).join("\n")).length>0&&(o+="\n")):(s=[$d5b33d7c30034067$var$generatePrecision(i),"#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,v,i.instancing?"#define USE_INSTANCING":"",i.instancingColor?"#define USE_INSTANCING_COLOR":"",i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+g:"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",i.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",i.displacementMap?"#define USE_DISPLACEMENTMAP":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.anisotropyMap?"#define USE_ANISOTROPYMAP":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",i.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",i.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.alphaHash?"#define USE_ALPHAHASH":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",//
i.mapUv?"#define MAP_UV "+i.mapUv:"",i.alphaMapUv?"#define ALPHAMAP_UV "+i.alphaMapUv:"",i.lightMapUv?"#define LIGHTMAP_UV "+i.lightMapUv:"",i.aoMapUv?"#define AOMAP_UV "+i.aoMapUv:"",i.emissiveMapUv?"#define EMISSIVEMAP_UV "+i.emissiveMapUv:"",i.bumpMapUv?"#define BUMPMAP_UV "+i.bumpMapUv:"",i.normalMapUv?"#define NORMALMAP_UV "+i.normalMapUv:"",i.displacementMapUv?"#define DISPLACEMENTMAP_UV "+i.displacementMapUv:"",i.metalnessMapUv?"#define METALNESSMAP_UV "+i.metalnessMapUv:"",i.roughnessMapUv?"#define ROUGHNESSMAP_UV "+i.roughnessMapUv:"",i.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+i.anisotropyMapUv:"",i.clearcoatMapUv?"#define CLEARCOATMAP_UV "+i.clearcoatMapUv:"",i.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+i.clearcoatNormalMapUv:"",i.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+i.clearcoatRoughnessMapUv:"",i.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+i.iridescenceMapUv:"",i.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+i.iridescenceThicknessMapUv:"",i.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+i.sheenColorMapUv:"",i.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+i.sheenRoughnessMapUv:"",i.specularMapUv?"#define SPECULARMAP_UV "+i.specularMapUv:"",i.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+i.specularColorMapUv:"",i.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+i.specularIntensityMapUv:"",i.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+i.transmissionMapUv:"",i.thicknessMapUv?"#define THICKNESSMAP_UV "+i.thicknessMapUv:"",//
i.vertexTangents&&!1===i.flatShading?"#define USE_TANGENT":"",i.vertexColors?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUv1s?"#define USE_UV1":"",i.vertexUv2s?"#define USE_UV2":"",i.vertexUv3s?"#define USE_UV3":"",i.pointsUvs?"#define USE_POINTS_UV":"",i.flatShading?"#define FLAT_SHADED":"",i.skinning?"#define USE_SKINNING":"",i.morphTargets?"#define USE_MORPHTARGETS":"",i.morphNormals&&!1===i.flatShading?"#define USE_MORPHNORMALS":"",i.morphColors&&i.isWebGL2?"#define USE_MORPHCOLORS":"",i.morphTargetsCount>0&&i.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",i.morphTargetsCount>0&&i.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+i.morphTextureStride:"",i.morphTargetsCount>0&&i.isWebGL2?"#define MORPHTARGETS_COUNT "+i.morphTargetsCount:"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+f:"",i.sizeAttenuation?"#define USE_SIZEATTENUATION":"",i.useLegacyLights?"#define LEGACY_LIGHTS":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",i.logarithmicDepthBuffer&&i.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif","\n"].filter($d5b33d7c30034067$var$filterEmptyLine).join("\n"),o=[b,$d5b33d7c30034067$var$generatePrecision(i),"#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,v,i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.matcap?"#define USE_MATCAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+m:"",i.envMap?"#define "+g:"",i.envMap?"#define "+_:"",y?"#define CUBEUV_TEXEL_WIDTH "+y.texelWidth:"",y?"#define CUBEUV_TEXEL_HEIGHT "+y.texelHeight:"",y?"#define CUBEUV_MAX_MIP "+y.maxMip+".0":"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",i.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.anisotropy?"#define USE_ANISOTROPY":"",i.anisotropyMap?"#define USE_ANISOTROPYMAP":"",i.clearcoat?"#define USE_CLEARCOAT":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.iridescence?"#define USE_IRIDESCENCE":"",i.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",i.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",i.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.alphaTest?"#define USE_ALPHATEST":"",i.alphaHash?"#define USE_ALPHAHASH":"",i.sheen?"#define USE_SHEEN":"",i.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.vertexTangents&&!1===i.flatShading?"#define USE_TANGENT":"",i.vertexColors||i.instancingColor?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUv1s?"#define USE_UV1":"",i.vertexUv2s?"#define USE_UV2":"",i.vertexUv3s?"#define USE_UV3":"",i.pointsUvs?"#define USE_POINTS_UV":"",i.gradientMap?"#define USE_GRADIENTMAP":"",i.flatShading?"#define FLAT_SHADED":"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+f:"",i.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",i.useLegacyLights?"#define LEGACY_LIGHTS":"",i.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",i.logarithmicDepthBuffer&&i.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",i.toneMapping!==$d5b33d7c30034067$export$9fcb6b4294603b2?"#define TONE_MAPPING":"",i.toneMapping!==$d5b33d7c30034067$export$9fcb6b4294603b2?$d5b33d7c30034067$export$955f9f2e84c43c8b.tonemapping_pars_fragment:"",i.toneMapping!==$d5b33d7c30034067$export$9fcb6b4294603b2?$d5b33d7c30034067$var$getToneMappingFunction("toneMapping",i.toneMapping):"",i.dithering?"#define DITHERING":"",i.opaque?"#define OPAQUE":"",$d5b33d7c30034067$export$955f9f2e84c43c8b.colorspace_pars_fragment,$d5b33d7c30034067$var$getTexelEncodingFunction("linearToOutputTexel",i.outputColorSpace),i.useDepthPacking?"#define DEPTH_PACKING "+i.depthPacking:"","\n"].filter($d5b33d7c30034067$var$filterEmptyLine).join("\n")),d=$d5b33d7c30034067$var$replaceClippingPlaneNums(d=$d5b33d7c30034067$var$replaceLightNums(d=$d5b33d7c30034067$var$resolveIncludes(d),i),i),p=$d5b33d7c30034067$var$replaceClippingPlaneNums(p=$d5b33d7c30034067$var$replaceLightNums(p=$d5b33d7c30034067$var$resolveIncludes(p),i),i),d=$d5b33d7c30034067$var$unrollLoops(d),p=$d5b33d7c30034067$var$unrollLoops(p),i.isWebGL2&&!0!==i.isRawShaderMaterial&&(// GLSL 3.0 conversion for built-in materials and ShaderMaterial
w="#version 300 es\n",s="precision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\n"+s,o=["#define varying in",i.glslVersion===$d5b33d7c30034067$export$f63012db5506e7dd?"":"layout(location = 0) out highp vec4 pc_fragColor;",i.glslVersion===$d5b33d7c30034067$export$f63012db5506e7dd?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+o);let T=w+s+d,S=w+o+p,E=$d5b33d7c30034067$var$WebGLShader(c,c.VERTEX_SHADER,T),A=$d5b33d7c30034067$var$WebGLShader(c,c.FRAGMENT_SHADER,S);// check for link errors
if(c.attachShader(x,E),c.attachShader(x,A),void 0!==i.index0AttributeName?c.bindAttribLocation(x,0,i.index0AttributeName):!0===i.morphTargets&&c.bindAttribLocation(x,0,"position"),c.linkProgram(x),n.debug.checkShaderErrors){let r=c.getProgramInfoLog(x).trim(),i=c.getShaderInfoLog(E).trim(),a=c.getShaderInfoLog(A).trim(),l=!0,u=!0;if(!1===c.getProgramParameter(x,c.LINK_STATUS)){if(l=!1,"function"==typeof n.debug.onShaderError)n.debug.onShaderError(c,x,E,A);else{// default error reporting
let n=$d5b33d7c30034067$var$getShaderErrors(c,E,"vertex"),i=$d5b33d7c30034067$var$getShaderErrors(c,A,"fragment");console.error("THREE.WebGLProgram: Shader Error "+c.getError()+" - VALIDATE_STATUS "+c.getProgramParameter(x,c.VALIDATE_STATUS)+"\n\nProgram Info Log: "+r+"\n"+n+"\n"+i)}}else""!==r?console.warn("THREE.WebGLProgram: Program Info Log:",r):(""===i||""===a)&&(u=!1);u&&(this.diagnostics={runnable:l,programLog:r,vertexShader:{log:i,prefix:s},fragmentShader:{log:a,prefix:o}})}return(// Clean up
// Crashes in iOS9 and iOS10. #18402
// gl.detachShader( program, glVertexShader );
// gl.detachShader( program, glFragmentShader );
c.deleteShader(E),c.deleteShader(A),this.getUniforms=function(){return void 0===l&&(l=new $d5b33d7c30034067$var$WebGLUniforms(c,x)),l},this.getAttributes=function(){return void 0===u&&(u=$d5b33d7c30034067$var$fetchAttributeLocations(c,x)),u},// free resource
this.destroy=function(){a.releaseStatesOfProgram(this),c.deleteProgram(x),this.program=void 0},//
this.type=i.shaderType,this.name=i.shaderName,this.id=$d5b33d7c30034067$var$programIdCount++,this.cacheKey=r,this.usedTimes=1,this.program=x,this.vertexShader=E,this.fragmentShader=A,this)}let $d5b33d7c30034067$var$_id$1=0;class $d5b33d7c30034067$var$WebGLShaderCache{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(n){let r=n.vertexShader,i=n.fragmentShader,a=this._getShaderStage(r),s=this._getShaderStage(i),o=this._getShaderCacheForMaterial(n);return!1===o.has(a)&&(o.add(a),a.usedTimes++),!1===o.has(s)&&(o.add(s),s.usedTimes++),this}remove(n){let r=this.materialCache.get(n);for(let n of r)n.usedTimes--,0===n.usedTimes&&this.shaderCache.delete(n.code);return this.materialCache.delete(n),this}getVertexShaderID(n){return this._getShaderStage(n.vertexShader).id}getFragmentShaderID(n){return this._getShaderStage(n.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(n){let r=this.materialCache,i=r.get(n);return void 0===i&&(i=new Set,r.set(n,i)),i}_getShaderStage(n){let r=this.shaderCache,i=r.get(n);return void 0===i&&(i=new $d5b33d7c30034067$var$WebGLShaderStage(n),r.set(n,i)),i}}class $d5b33d7c30034067$var$WebGLShaderStage{constructor(n){this.id=$d5b33d7c30034067$var$_id$1++,this.code=n,this.usedTimes=0}}function $d5b33d7c30034067$var$WebGLPrograms(n,r,i,a,s,o,l){let u=new $d5b33d7c30034067$export$89312ce47c0ca777,c=new $d5b33d7c30034067$var$WebGLShaderCache,h=[],d=s.isWebGL2,p=s.logarithmicDepthBuffer,f=s.vertexTextures,m=s.precision,g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function _(n){return 0===n?"uv":`uv${n}`}function y(n,r){n.push(r.precision),n.push(r.outputColorSpace),n.push(r.envMapMode),n.push(r.envMapCubeUVHeight),n.push(r.mapUv),n.push(r.alphaMapUv),n.push(r.lightMapUv),n.push(r.aoMapUv),n.push(r.bumpMapUv),n.push(r.normalMapUv),n.push(r.displacementMapUv),n.push(r.emissiveMapUv),n.push(r.metalnessMapUv),n.push(r.roughnessMapUv),n.push(r.anisotropyMapUv),n.push(r.clearcoatMapUv),n.push(r.clearcoatNormalMapUv),n.push(r.clearcoatRoughnessMapUv),n.push(r.iridescenceMapUv),n.push(r.iridescenceThicknessMapUv),n.push(r.sheenColorMapUv),n.push(r.sheenRoughnessMapUv),n.push(r.specularMapUv),n.push(r.specularColorMapUv),n.push(r.specularIntensityMapUv),n.push(r.transmissionMapUv),n.push(r.thicknessMapUv),n.push(r.combine),n.push(r.fogExp2),n.push(r.sizeAttenuation),n.push(r.morphTargetsCount),n.push(r.morphAttributeCount),n.push(r.numDirLights),n.push(r.numPointLights),n.push(r.numSpotLights),n.push(r.numSpotLightMaps),n.push(r.numHemiLights),n.push(r.numRectAreaLights),n.push(r.numDirLightShadows),n.push(r.numPointLightShadows),n.push(r.numSpotLightShadows),n.push(r.numSpotLightShadowsWithMaps),n.push(r.shadowMapType),n.push(r.toneMapping),n.push(r.numClippingPlanes),n.push(r.numClipIntersection),n.push(r.depthPacking)}function b(n,r){u.disableAll(),r.isWebGL2&&u.enable(0),r.supportsVertexTextures&&u.enable(1),r.instancing&&u.enable(2),r.instancingColor&&u.enable(3),r.matcap&&u.enable(4),r.envMap&&u.enable(5),r.normalMapObjectSpace&&u.enable(6),r.normalMapTangentSpace&&u.enable(7),r.clearcoat&&u.enable(8),r.iridescence&&u.enable(9),r.alphaTest&&u.enable(10),r.vertexColors&&u.enable(11),r.vertexAlphas&&u.enable(12),r.vertexUv1s&&u.enable(13),r.vertexUv2s&&u.enable(14),r.vertexUv3s&&u.enable(15),r.vertexTangents&&u.enable(16),r.anisotropy&&u.enable(17),n.push(u.mask),u.disableAll(),r.fog&&u.enable(0),r.useFog&&u.enable(1),r.flatShading&&u.enable(2),r.logarithmicDepthBuffer&&u.enable(3),r.skinning&&u.enable(4),r.morphTargets&&u.enable(5),r.morphNormals&&u.enable(6),r.morphColors&&u.enable(7),r.premultipliedAlpha&&u.enable(8),r.shadowMapEnabled&&u.enable(9),r.useLegacyLights&&u.enable(10),r.doubleSided&&u.enable(11),r.flipSided&&u.enable(12),r.useDepthPacking&&u.enable(13),r.dithering&&u.enable(14),r.transmission&&u.enable(15),r.sheen&&u.enable(16),r.opaque&&u.enable(17),r.pointsUvs&&u.enable(18),r.decodeVideoTexture&&u.enable(19),n.push(u.mask)}return{getParameters:function(o,u,h,y,b){let v,x,w,T;let S=y.fog,E=b.geometry,A=o.isMeshStandardMaterial?y.environment:null,M=(o.isMeshStandardMaterial?i:r).get(o.envMap||A),I=M&&M.mapping===$d5b33d7c30034067$export$dbf3e70ff37af79?M.image.height:null,P=g[o.type];null!==o.precision&&(m=s.getMaxPrecision(o.precision))!==o.precision&&console.warn("THREE.WebGLProgram.getParameters:",o.precision,"not supported, using",m,"instead.");//
let O=E.morphAttributes.position||E.morphAttributes.normal||E.morphAttributes.color,R=void 0!==O?O.length:0,C=0;if(void 0!==E.morphAttributes.position&&(C=1),void 0!==E.morphAttributes.normal&&(C=2),void 0!==E.morphAttributes.color&&(C=3),P){let n=$d5b33d7c30034067$export$bee4a7d47f8f5014[P];v=n.vertexShader,x=n.fragmentShader}else v=o.vertexShader,x=o.fragmentShader,c.update(o),w=c.getVertexShaderID(o),T=c.getFragmentShaderID(o);let L=n.getRenderTarget(),D=!0===b.isInstancedMesh,N=!!o.map,k=!!o.matcap,U=!!M,F=!!o.aoMap,B=!!o.lightMap,z=!!o.bumpMap,V=!!o.normalMap,G=!!o.displacementMap,j=!!o.emissiveMap,H=!!o.metalnessMap,$=!!o.roughnessMap,W=o.anisotropy>0,X=o.clearcoat>0,q=o.iridescence>0,Y=o.sheen>0,K=o.transmission>0,Z=W&&!!o.anisotropyMap,J=X&&!!o.clearcoatMap,Q=X&&!!o.clearcoatNormalMap,ee=X&&!!o.clearcoatRoughnessMap,et=q&&!!o.iridescenceMap,en=q&&!!o.iridescenceThicknessMap,er=Y&&!!o.sheenColorMap,ei=Y&&!!o.sheenRoughnessMap,ea=!!o.specularMap,es=!!o.specularColorMap,eo=!!o.specularIntensityMap,el=K&&!!o.transmissionMap,eu=K&&!!o.thicknessMap,ec=!!o.gradientMap,eh=!!o.alphaMap,ed=o.alphaTest>0,ep=!!o.alphaHash,ef=!!o.extensions,em=!!E.attributes.uv1,eg=!!E.attributes.uv2,e_=!!E.attributes.uv3,ey=$d5b33d7c30034067$export$9fcb6b4294603b2;o.toneMapped&&(null===L||!0===L.isXRRenderTarget)&&(ey=n.toneMapping);let eb={isWebGL2:d,shaderID:P,shaderType:o.type,shaderName:o.name,vertexShader:v,fragmentShader:x,defines:o.defines,customVertexShaderID:w,customFragmentShaderID:T,isRawShaderMaterial:!0===o.isRawShaderMaterial,glslVersion:o.glslVersion,precision:m,instancing:D,instancingColor:D&&null!==b.instanceColor,supportsVertexTextures:f,outputColorSpace:null===L?n.outputColorSpace:!0===L.isXRRenderTarget?L.texture.colorSpace:$d5b33d7c30034067$export$42429b3acfb233a4,map:N,matcap:k,envMap:U,envMapMode:U&&M.mapping,envMapCubeUVHeight:I,aoMap:F,lightMap:B,bumpMap:z,normalMap:V,displacementMap:f&&G,emissiveMap:j,normalMapObjectSpace:V&&o.normalMapType===$d5b33d7c30034067$export$9990ad26f9db5b2c,normalMapTangentSpace:V&&o.normalMapType===$d5b33d7c30034067$export$2852a58ebdac27b8,metalnessMap:H,roughnessMap:$,anisotropy:W,anisotropyMap:Z,clearcoat:X,clearcoatMap:J,clearcoatNormalMap:Q,clearcoatRoughnessMap:ee,iridescence:q,iridescenceMap:et,iridescenceThicknessMap:en,sheen:Y,sheenColorMap:er,sheenRoughnessMap:ei,specularMap:ea,specularColorMap:es,specularIntensityMap:eo,transmission:K,transmissionMap:el,thicknessMap:eu,gradientMap:ec,opaque:!1===o.transparent&&o.blending===$d5b33d7c30034067$export$5b29a26d96ee6af0,alphaMap:eh,alphaTest:ed,alphaHash:ep,combine:o.combine,//
mapUv:N&&_(o.map.channel),aoMapUv:F&&_(o.aoMap.channel),lightMapUv:B&&_(o.lightMap.channel),bumpMapUv:z&&_(o.bumpMap.channel),normalMapUv:V&&_(o.normalMap.channel),displacementMapUv:G&&_(o.displacementMap.channel),emissiveMapUv:j&&_(o.emissiveMap.channel),metalnessMapUv:H&&_(o.metalnessMap.channel),roughnessMapUv:$&&_(o.roughnessMap.channel),anisotropyMapUv:Z&&_(o.anisotropyMap.channel),clearcoatMapUv:J&&_(o.clearcoatMap.channel),clearcoatNormalMapUv:Q&&_(o.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:ee&&_(o.clearcoatRoughnessMap.channel),iridescenceMapUv:et&&_(o.iridescenceMap.channel),iridescenceThicknessMapUv:en&&_(o.iridescenceThicknessMap.channel),sheenColorMapUv:er&&_(o.sheenColorMap.channel),sheenRoughnessMapUv:ei&&_(o.sheenRoughnessMap.channel),specularMapUv:ea&&_(o.specularMap.channel),specularColorMapUv:es&&_(o.specularColorMap.channel),specularIntensityMapUv:eo&&_(o.specularIntensityMap.channel),transmissionMapUv:el&&_(o.transmissionMap.channel),thicknessMapUv:eu&&_(o.thicknessMap.channel),alphaMapUv:eh&&_(o.alphaMap.channel),//
vertexTangents:!!E.attributes.tangent&&(V||W),vertexColors:o.vertexColors,vertexAlphas:!0===o.vertexColors&&!!E.attributes.color&&4===E.attributes.color.itemSize,vertexUv1s:em,vertexUv2s:eg,vertexUv3s:e_,pointsUvs:!0===b.isPoints&&!!E.attributes.uv&&(N||eh),fog:!!S,useFog:!0===o.fog,fogExp2:S&&S.isFogExp2,flatShading:!0===o.flatShading,sizeAttenuation:!0===o.sizeAttenuation,logarithmicDepthBuffer:p,skinning:!0===b.isSkinnedMesh,morphTargets:void 0!==E.morphAttributes.position,morphNormals:void 0!==E.morphAttributes.normal,morphColors:void 0!==E.morphAttributes.color,morphTargetsCount:R,morphTextureStride:C,numDirLights:u.directional.length,numPointLights:u.point.length,numSpotLights:u.spot.length,numSpotLightMaps:u.spotLightMap.length,numRectAreaLights:u.rectArea.length,numHemiLights:u.hemi.length,numDirLightShadows:u.directionalShadowMap.length,numPointLightShadows:u.pointShadowMap.length,numSpotLightShadows:u.spotShadowMap.length,numSpotLightShadowsWithMaps:u.numSpotLightShadowsWithMaps,numClippingPlanes:l.numPlanes,numClipIntersection:l.numIntersection,dithering:o.dithering,shadowMapEnabled:n.shadowMap.enabled&&h.length>0,shadowMapType:n.shadowMap.type,toneMapping:ey,useLegacyLights:n._useLegacyLights,decodeVideoTexture:N&&!0===o.map.isVideoTexture&&o.map.colorSpace===$d5b33d7c30034067$export$561f394b24edfcaa,premultipliedAlpha:o.premultipliedAlpha,doubleSided:o.side===$d5b33d7c30034067$export$3b296b6f144d5b03,flipSided:o.side===$d5b33d7c30034067$export$d9f0486e75b5ace,useDepthPacking:o.depthPacking>=0,depthPacking:o.depthPacking||0,index0AttributeName:o.index0AttributeName,extensionDerivatives:ef&&!0===o.extensions.derivatives,extensionFragDepth:ef&&!0===o.extensions.fragDepth,extensionDrawBuffers:ef&&!0===o.extensions.drawBuffers,extensionShaderTextureLOD:ef&&!0===o.extensions.shaderTextureLOD,rendererExtensionFragDepth:d||a.has("EXT_frag_depth"),rendererExtensionDrawBuffers:d||a.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:d||a.has("EXT_shader_texture_lod"),customProgramCacheKey:o.customProgramCacheKey()};return eb},getProgramCacheKey:function(r){let i=[];if(r.shaderID?i.push(r.shaderID):(i.push(r.customVertexShaderID),i.push(r.customFragmentShaderID)),void 0!==r.defines)for(let n in r.defines)i.push(n),i.push(r.defines[n]);return!1===r.isRawShaderMaterial&&(y(i,r),b(i,r),i.push(n.outputColorSpace)),i.push(r.customProgramCacheKey),i.join()},getUniforms:function(n){let r;let i=g[n.type];if(i){let n=$d5b33d7c30034067$export$bee4a7d47f8f5014[i];r=$d5b33d7c30034067$export$d8ecdf8615bfea69.clone(n.uniforms)}else r=n.uniforms;return r},acquireProgram:function(r,i){let a;// Check if code has been already compiled
for(let n=0,r=h.length;n<r;n++){let r=h[n];if(r.cacheKey===i){a=r,++a.usedTimes;break}}return void 0===a&&(a=new $d5b33d7c30034067$var$WebGLProgram(n,i,r,o),h.push(a)),a},releaseProgram:function(n){if(0==--n.usedTimes){// Remove from unordered set
let r=h.indexOf(n);h[r]=h[h.length-1],h.pop(),// Free WebGL resources
n.destroy()}},releaseShaderCache:function(n){c.remove(n)},// Exposed for resource monitoring & error feedback via renderer.info:
programs:h,dispose:function(){c.dispose()}}}function $d5b33d7c30034067$var$WebGLProperties(){let n=new WeakMap;return{get:function(r){let i=n.get(r);return void 0===i&&(i={},n.set(r,i)),i},remove:function(r){n.delete(r)},update:function(r,i,a){n.get(r)[i]=a},dispose:function(){n=new WeakMap}}}function $d5b33d7c30034067$var$painterSortStable(n,r){return n.groupOrder!==r.groupOrder?n.groupOrder-r.groupOrder:n.renderOrder!==r.renderOrder?n.renderOrder-r.renderOrder:n.material.id!==r.material.id?n.material.id-r.material.id:n.z!==r.z?n.z-r.z:n.id-r.id}function $d5b33d7c30034067$var$reversePainterSortStable(n,r){return n.groupOrder!==r.groupOrder?n.groupOrder-r.groupOrder:n.renderOrder!==r.renderOrder?n.renderOrder-r.renderOrder:n.z!==r.z?r.z-n.z:n.id-r.id}function $d5b33d7c30034067$var$WebGLRenderList(){let n=[],r=0,i=[],a=[],s=[];function o(){r=0,i.length=0,a.length=0,s.length=0}function l(i,a,s,o,l,u){let c=n[r];return void 0===c?(c={id:i.id,object:i,geometry:a,material:s,groupOrder:o,renderOrder:i.renderOrder,z:l,group:u},n[r]=c):(c.id=i.id,c.object=i,c.geometry=a,c.material=s,c.groupOrder=o,c.renderOrder=i.renderOrder,c.z=l,c.group=u),r++,c}function u(n,r,o,u,c,h){let d=l(n,r,o,u,c,h);o.transmission>0?a.push(d):!0===o.transparent?s.push(d):i.push(d)}function c(n,r,o,u,c,h){let d=l(n,r,o,u,c,h);o.transmission>0?a.unshift(d):!0===o.transparent?s.unshift(d):i.unshift(d)}function h(n,r){i.length>1&&i.sort(n||$d5b33d7c30034067$var$painterSortStable),a.length>1&&a.sort(r||$d5b33d7c30034067$var$reversePainterSortStable),s.length>1&&s.sort(r||$d5b33d7c30034067$var$reversePainterSortStable)}return{opaque:i,transmissive:a,transparent:s,init:o,push:u,unshift:c,finish:function(){// Clear references from inactive renderItems in the list
for(let i=r,a=n.length;i<a;i++){let r=n[i];if(null===r.id)break;r.id=null,r.object=null,r.geometry=null,r.material=null,r.group=null}},sort:h}}function $d5b33d7c30034067$var$WebGLRenderLists(){let n=new WeakMap;return{get:function(r,i){let a;let s=n.get(r);return void 0===s?(a=new $d5b33d7c30034067$var$WebGLRenderList,n.set(r,[a])):i>=s.length?(a=new $d5b33d7c30034067$var$WebGLRenderList,s.push(a)):a=s[i],a},dispose:function(){n=new WeakMap}}}function $d5b33d7c30034067$var$UniformsCache(){let n={};return{get:function(r){let i;if(void 0!==n[r.id])return n[r.id];switch(r.type){case"DirectionalLight":i={direction:new $d5b33d7c30034067$export$64b5c384219d3699,color:new $d5b33d7c30034067$export$892596cec99bc70e};break;case"SpotLight":i={position:new $d5b33d7c30034067$export$64b5c384219d3699,direction:new $d5b33d7c30034067$export$64b5c384219d3699,color:new $d5b33d7c30034067$export$892596cec99bc70e,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":i={position:new $d5b33d7c30034067$export$64b5c384219d3699,color:new $d5b33d7c30034067$export$892596cec99bc70e,distance:0,decay:0};break;case"HemisphereLight":i={direction:new $d5b33d7c30034067$export$64b5c384219d3699,skyColor:new $d5b33d7c30034067$export$892596cec99bc70e,groundColor:new $d5b33d7c30034067$export$892596cec99bc70e};break;case"RectAreaLight":i={color:new $d5b33d7c30034067$export$892596cec99bc70e,position:new $d5b33d7c30034067$export$64b5c384219d3699,halfWidth:new $d5b33d7c30034067$export$64b5c384219d3699,halfHeight:new $d5b33d7c30034067$export$64b5c384219d3699}}return n[r.id]=i,i}}}function $d5b33d7c30034067$var$ShadowUniformsCache(){let n={};return{get:function(r){let i;if(void 0!==n[r.id])return n[r.id];switch(r.type){case"DirectionalLight":case"SpotLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new $d5b33d7c30034067$export$c977b3e384af9ae1};break;case"PointLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new $d5b33d7c30034067$export$c977b3e384af9ae1,shadowCameraNear:1,shadowCameraFar:1e3}}return n[r.id]=i,i}}}let $d5b33d7c30034067$var$nextVersion=0;function $d5b33d7c30034067$var$shadowCastingAndTexturingLightsFirst(n,r){return(r.castShadow?2:0)-(n.castShadow?2:0)+(r.map?1:0)-(n.map?1:0)}function $d5b33d7c30034067$var$WebGLLights(n,r){let i=new $d5b33d7c30034067$var$UniformsCache,a=$d5b33d7c30034067$var$ShadowUniformsCache(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let n=0;n<9;n++)s.probe.push(new $d5b33d7c30034067$export$64b5c384219d3699);let o=new $d5b33d7c30034067$export$64b5c384219d3699,l=new $d5b33d7c30034067$export$2ae72fc923e5eb5,u=new $d5b33d7c30034067$export$2ae72fc923e5eb5;return{setup:function(o,l){let u=0,c=0,h=0;for(let n=0;n<9;n++)s.probe[n].set(0,0,0);let d=0,p=0,f=0,m=0,g=0,_=0,y=0,b=0,v=0,x=0;// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]
o.sort($d5b33d7c30034067$var$shadowCastingAndTexturingLightsFirst);// artist-friendly light intensity scaling factor
let w=!0===l?Math.PI:1;for(let n=0,r=o.length;n<r;n++){let r=o[n],l=r.color,T=r.intensity,S=r.distance,E=r.shadow&&r.shadow.map?r.shadow.map.texture:null;if(r.isAmbientLight)u+=l.r*T*w,c+=l.g*T*w,h+=l.b*T*w;else if(r.isLightProbe)for(let n=0;n<9;n++)s.probe[n].addScaledVector(r.sh.coefficients[n],T);else if(r.isDirectionalLight){let n=i.get(r);if(n.color.copy(r.color).multiplyScalar(r.intensity*w),r.castShadow){let n=r.shadow,i=a.get(r);i.shadowBias=n.bias,i.shadowNormalBias=n.normalBias,i.shadowRadius=n.radius,i.shadowMapSize=n.mapSize,s.directionalShadow[d]=i,s.directionalShadowMap[d]=E,s.directionalShadowMatrix[d]=r.shadow.matrix,_++}s.directional[d]=n,d++}else if(r.isSpotLight){let n=i.get(r);n.position.setFromMatrixPosition(r.matrixWorld),n.color.copy(l).multiplyScalar(T*w),n.distance=S,n.coneCos=Math.cos(r.angle),n.penumbraCos=Math.cos(r.angle*(1-r.penumbra)),n.decay=r.decay,s.spot[f]=n;let o=r.shadow;if(r.map&&(s.spotLightMap[v]=r.map,v++,// make sure the lightMatrix is up to date
// TODO : do it if required only
o.updateMatrices(r),r.castShadow&&x++),s.spotLightMatrix[f]=o.matrix,r.castShadow){let n=a.get(r);n.shadowBias=o.bias,n.shadowNormalBias=o.normalBias,n.shadowRadius=o.radius,n.shadowMapSize=o.mapSize,s.spotShadow[f]=n,s.spotShadowMap[f]=E,b++}f++}else if(r.isRectAreaLight){let n=i.get(r);n.color.copy(l).multiplyScalar(T),n.halfWidth.set(.5*r.width,0,0),n.halfHeight.set(0,.5*r.height,0),s.rectArea[m]=n,m++}else if(r.isPointLight){let n=i.get(r);if(n.color.copy(r.color).multiplyScalar(r.intensity*w),n.distance=r.distance,n.decay=r.decay,r.castShadow){let n=r.shadow,i=a.get(r);i.shadowBias=n.bias,i.shadowNormalBias=n.normalBias,i.shadowRadius=n.radius,i.shadowMapSize=n.mapSize,i.shadowCameraNear=n.camera.near,i.shadowCameraFar=n.camera.far,s.pointShadow[p]=i,s.pointShadowMap[p]=E,s.pointShadowMatrix[p]=r.shadow.matrix,y++}s.point[p]=n,p++}else if(r.isHemisphereLight){let n=i.get(r);n.skyColor.copy(r.color).multiplyScalar(T*w),n.groundColor.copy(r.groundColor).multiplyScalar(T*w),s.hemi[g]=n,g++}}m>0&&(r.isWebGL2?(// WebGL 2
s.rectAreaLTC1=$d5b33d7c30034067$export$6643083551874bf5.LTC_FLOAT_1,s.rectAreaLTC2=$d5b33d7c30034067$export$6643083551874bf5.LTC_FLOAT_2):!0===n.has("OES_texture_float_linear")?(s.rectAreaLTC1=$d5b33d7c30034067$export$6643083551874bf5.LTC_FLOAT_1,s.rectAreaLTC2=$d5b33d7c30034067$export$6643083551874bf5.LTC_FLOAT_2):!0===n.has("OES_texture_half_float_linear")?(s.rectAreaLTC1=$d5b33d7c30034067$export$6643083551874bf5.LTC_HALF_1,s.rectAreaLTC2=$d5b33d7c30034067$export$6643083551874bf5.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),s.ambient[0]=u,s.ambient[1]=c,s.ambient[2]=h;let T=s.hash;(T.directionalLength!==d||T.pointLength!==p||T.spotLength!==f||T.rectAreaLength!==m||T.hemiLength!==g||T.numDirectionalShadows!==_||T.numPointShadows!==y||T.numSpotShadows!==b||T.numSpotMaps!==v)&&(s.directional.length=d,s.spot.length=f,s.rectArea.length=m,s.point.length=p,s.hemi.length=g,s.directionalShadow.length=_,s.directionalShadowMap.length=_,s.pointShadow.length=y,s.pointShadowMap.length=y,s.spotShadow.length=b,s.spotShadowMap.length=b,s.directionalShadowMatrix.length=_,s.pointShadowMatrix.length=y,s.spotLightMatrix.length=b+v-x,s.spotLightMap.length=v,s.numSpotLightShadowsWithMaps=x,T.directionalLength=d,T.pointLength=p,T.spotLength=f,T.rectAreaLength=m,T.hemiLength=g,T.numDirectionalShadows=_,T.numPointShadows=y,T.numSpotShadows=b,T.numSpotMaps=v,s.version=$d5b33d7c30034067$var$nextVersion++)},setupView:function(n,r){let i=0,a=0,c=0,h=0,d=0,p=r.matrixWorldInverse;for(let r=0,f=n.length;r<f;r++){let f=n[r];if(f.isDirectionalLight){let n=s.directional[i];n.direction.setFromMatrixPosition(f.matrixWorld),o.setFromMatrixPosition(f.target.matrixWorld),n.direction.sub(o),n.direction.transformDirection(p),i++}else if(f.isSpotLight){let n=s.spot[c];n.position.setFromMatrixPosition(f.matrixWorld),n.position.applyMatrix4(p),n.direction.setFromMatrixPosition(f.matrixWorld),o.setFromMatrixPosition(f.target.matrixWorld),n.direction.sub(o),n.direction.transformDirection(p),c++}else if(f.isRectAreaLight){let n=s.rectArea[h];n.position.setFromMatrixPosition(f.matrixWorld),n.position.applyMatrix4(p),// extract local rotation of light to derive width/height half vectors
u.identity(),l.copy(f.matrixWorld),l.premultiply(p),u.extractRotation(l),n.halfWidth.set(.5*f.width,0,0),n.halfHeight.set(0,.5*f.height,0),n.halfWidth.applyMatrix4(u),n.halfHeight.applyMatrix4(u),h++}else if(f.isPointLight){let n=s.point[a];n.position.setFromMatrixPosition(f.matrixWorld),n.position.applyMatrix4(p),a++}else if(f.isHemisphereLight){let n=s.hemi[d];n.direction.setFromMatrixPosition(f.matrixWorld),n.direction.transformDirection(p),d++}}},state:s}}function $d5b33d7c30034067$var$WebGLRenderState(n,r){let i=new $d5b33d7c30034067$var$WebGLLights(n,r),a=[],s=[];function o(){a.length=0,s.length=0}function l(n){a.push(n)}function u(n){s.push(n)}function c(n){i.setup(a,n)}function h(n){i.setupView(a,n)}let d={lightsArray:a,shadowsArray:s,lights:i};return{init:o,state:d,setupLights:c,setupLightsView:h,pushLight:l,pushShadow:u}}function $d5b33d7c30034067$var$WebGLRenderStates(n,r){let i=new WeakMap;return{get:function(a,s=0){let o;let l=i.get(a);return void 0===l?(o=new $d5b33d7c30034067$var$WebGLRenderState(n,r),i.set(a,[o])):s>=l.length?(o=new $d5b33d7c30034067$var$WebGLRenderState(n,r),l.push(o)):o=l[s],o},dispose:function(){i=new WeakMap}}}class $d5b33d7c30034067$export$2698c22ec13825db extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=$d5b33d7c30034067$export$deeb383078690b50,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(n)}copy(n){return super.copy(n),this.depthPacking=n.depthPacking,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this}}class $d5b33d7c30034067$export$33e187ed002f2a19 extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(n)}copy(n){return super.copy(n),this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this}}const $d5b33d7c30034067$var$vertex="void main() {\n	gl_Position = vec4( position, 1.0 );\n}",$d5b33d7c30034067$var$fragment="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";function $d5b33d7c30034067$var$WebGLShadowMap(n,r,i){let a=new $d5b33d7c30034067$export$35efe6f4c85463d2,s=new $d5b33d7c30034067$export$c977b3e384af9ae1,o=new $d5b33d7c30034067$export$c977b3e384af9ae1,l=new $d5b33d7c30034067$export$fa7daccca11cdbe3,u=new $d5b33d7c30034067$export$2698c22ec13825db({depthPacking:$d5b33d7c30034067$export$8f910f4c4f73df11}),c=new $d5b33d7c30034067$export$33e187ed002f2a19,h={},d=i.maxTextureSize,p={[$d5b33d7c30034067$export$2ede184fc2998901]:$d5b33d7c30034067$export$d9f0486e75b5ace,[$d5b33d7c30034067$export$d9f0486e75b5ace]:$d5b33d7c30034067$export$2ede184fc2998901,[$d5b33d7c30034067$export$3b296b6f144d5b03]:$d5b33d7c30034067$export$3b296b6f144d5b03},f=new $d5b33d7c30034067$export$83c7d75d550a8b0d({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new $d5b33d7c30034067$export$c977b3e384af9ae1},radius:{value:4}},vertexShader:$d5b33d7c30034067$var$vertex,fragmentShader:$d5b33d7c30034067$var$fragment}),m=f.clone();m.defines.HORIZONTAL_PASS=1;let g=new $d5b33d7c30034067$export$b7be63a67df8959;g.setAttribute("position",new $d5b33d7c30034067$export$8dea267bd6bde117(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));let _=new $d5b33d7c30034067$export$e176487c05830cc5(g,f),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=$d5b33d7c30034067$export$5813f879eee7cd88;let b=this.type;function v(i,a){let o=r.update(_);f.defines.VSM_SAMPLES!==i.blurSamples&&(f.defines.VSM_SAMPLES=i.blurSamples,m.defines.VSM_SAMPLES=i.blurSamples,f.needsUpdate=!0,m.needsUpdate=!0),null===i.mapPass&&(i.mapPass=new $d5b33d7c30034067$export$3c052beb2e51e23f(s.x,s.y)),// vertical pass
f.uniforms.shadow_pass.value=i.map.texture,f.uniforms.resolution.value=i.mapSize,f.uniforms.radius.value=i.radius,n.setRenderTarget(i.mapPass),n.clear(),n.renderBufferDirect(a,null,o,f,_,null),// horizontal pass
m.uniforms.shadow_pass.value=i.mapPass.texture,m.uniforms.resolution.value=i.mapSize,m.uniforms.radius.value=i.radius,n.setRenderTarget(i.map),n.clear(),n.renderBufferDirect(a,null,o,m,_,null)}function x(r,i,a,s){let o=null,l=!0===a.isPointLight?r.customDistanceMaterial:r.customDepthMaterial;if(void 0!==l)o=l;else if(o=!0===a.isPointLight?c:u,n.localClippingEnabled&&!0===i.clipShadows&&Array.isArray(i.clippingPlanes)&&0!==i.clippingPlanes.length||i.displacementMap&&0!==i.displacementScale||i.alphaMap&&i.alphaTest>0||i.map&&i.alphaTest>0){// in this case we need a unique material instance reflecting the
// appropriate state
let n=o.uuid,r=i.uuid,a=h[n];void 0===a&&(a={},h[n]=a);let s=a[r];void 0===s&&(s=o.clone(),a[r]=s),o=s}if(o.visible=i.visible,o.wireframe=i.wireframe,s===$d5b33d7c30034067$export$896ae1ade6c829c4?o.side=null!==i.shadowSide?i.shadowSide:i.side:o.side=null!==i.shadowSide?i.shadowSide:p[i.side],o.alphaMap=i.alphaMap,o.alphaTest=i.alphaTest,o.map=i.map,o.clipShadows=i.clipShadows,o.clippingPlanes=i.clippingPlanes,o.clipIntersection=i.clipIntersection,o.displacementMap=i.displacementMap,o.displacementScale=i.displacementScale,o.displacementBias=i.displacementBias,o.wireframeLinewidth=i.wireframeLinewidth,o.linewidth=i.linewidth,!0===a.isPointLight&&!0===o.isMeshDistanceMaterial){let r=n.properties.get(o);r.light=a}return o}function w(i,s,o,l,u){if(!1===i.visible)return;let c=i.layers.test(s.layers);if(c&&(i.isMesh||i.isLine||i.isPoints)&&(i.castShadow||i.receiveShadow&&u===$d5b33d7c30034067$export$896ae1ade6c829c4)&&(!i.frustumCulled||a.intersectsObject(i))){i.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse,i.matrixWorld);let a=r.update(i),s=i.material;if(Array.isArray(s)){let r=a.groups;for(let c=0,h=r.length;c<h;c++){let h=r[c],d=s[h.materialIndex];if(d&&d.visible){let r=x(i,d,l,u);n.renderBufferDirect(o,null,a,r,i,h)}}}else if(s.visible){let r=x(i,s,l,u);n.renderBufferDirect(o,null,a,r,i,null)}}let h=i.children;for(let n=0,r=h.length;n<r;n++)w(h[n],s,o,l,u)}this.render=function(r,i,u){if(!1===y.enabled||!1===y.autoUpdate&&!1===y.needsUpdate||0===r.length)return;let c=n.getRenderTarget(),h=n.getActiveCubeFace(),p=n.getActiveMipmapLevel(),f=n.state;// Set GL state for depth map.
f.setBlending($d5b33d7c30034067$export$63b8d6b580fc65ba),f.buffers.color.setClear(1,1,1,1),f.buffers.depth.setTest(!0),f.setScissorTest(!1);// check for shadow map type changes
let m=b!==$d5b33d7c30034067$export$896ae1ade6c829c4&&this.type===$d5b33d7c30034067$export$896ae1ade6c829c4,g=b===$d5b33d7c30034067$export$896ae1ade6c829c4&&this.type!==$d5b33d7c30034067$export$896ae1ade6c829c4;// render depth map
for(let c=0,h=r.length;c<h;c++){let h=r[c],p=h.shadow;if(void 0===p){console.warn("THREE.WebGLShadowMap:",h,"has no shadow.");continue}if(!1===p.autoUpdate&&!1===p.needsUpdate)continue;s.copy(p.mapSize);let _=p.getFrameExtents();if(s.multiply(_),o.copy(p.mapSize),(s.x>d||s.y>d)&&(s.x>d&&(o.x=Math.floor(d/_.x),s.x=o.x*_.x,p.mapSize.x=o.x),s.y>d&&(o.y=Math.floor(d/_.y),s.y=o.y*_.y,p.mapSize.y=o.y)),null===p.map||!0===m||!0===g){let n=this.type!==$d5b33d7c30034067$export$896ae1ade6c829c4?{minFilter:$d5b33d7c30034067$export$727aa5ec3fe39bf0,magFilter:$d5b33d7c30034067$export$727aa5ec3fe39bf0}:{};null!==p.map&&p.map.dispose(),p.map=new $d5b33d7c30034067$export$3c052beb2e51e23f(s.x,s.y,n),p.map.texture.name=h.name+".shadowMap",p.camera.updateProjectionMatrix()}n.setRenderTarget(p.map),n.clear();let y=p.getViewportCount();for(let n=0;n<y;n++){let r=p.getViewport(n);l.set(o.x*r.x,o.y*r.y,o.x*r.z,o.y*r.w),f.viewport(l),p.updateMatrices(h,n),a=p.getFrustum(),w(i,u,p.camera,h,this.type)}!0!==p.isPointLightShadow&&this.type===$d5b33d7c30034067$export$896ae1ade6c829c4&&v(p,u),p.needsUpdate=!1}b=this.type,y.needsUpdate=!1,n.setRenderTarget(c,h,p)}}function $d5b33d7c30034067$var$WebGLState(n,r,i){let a=i.isWebGL2;function s(){let r=!1,i=new $d5b33d7c30034067$export$fa7daccca11cdbe3,a=null,s=new $d5b33d7c30034067$export$fa7daccca11cdbe3(0,0,0,0);return{setMask:function(i){a===i||r||(n.colorMask(i,i,i,i),a=i)},setLocked:function(n){r=n},setClear:function(r,a,o,l,u){!0===u&&(r*=l,a*=l,o*=l),i.set(r,a,o,l),!1===s.equals(i)&&(n.clearColor(r,a,o,l),s.copy(i))},reset:function(){r=!1,a=null,s.set(-1,0,0,0)}}}function o(){let r=!1,i=null,a=null,s=null;return{setTest:function(r){r?$(n.DEPTH_TEST):W(n.DEPTH_TEST)},setMask:function(a){i===a||r||(n.depthMask(a),i=a)},setFunc:function(r){if(a!==r){switch(r){case $d5b33d7c30034067$export$69025ce147cee220:n.depthFunc(n.NEVER);break;case $d5b33d7c30034067$export$7182eb52ea3b3f04:n.depthFunc(n.ALWAYS);break;case $d5b33d7c30034067$export$eedccec66ab7ebe:n.depthFunc(n.LESS);break;case $d5b33d7c30034067$export$296f78a0b892f81a:n.depthFunc(n.LEQUAL);break;case $d5b33d7c30034067$export$a60d398fc7b7590e:n.depthFunc(n.EQUAL);break;case $d5b33d7c30034067$export$7d7234c1240a1fc4:n.depthFunc(n.GEQUAL);break;case $d5b33d7c30034067$export$c5e2c52991f30937:n.depthFunc(n.GREATER);break;case $d5b33d7c30034067$export$2f843afa843d8916:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}a=r}},setLocked:function(n){r=n},setClear:function(r){s!==r&&(n.clearDepth(r),s=r)},reset:function(){r=!1,i=null,a=null,s=null}}}function l(){let r=!1,i=null,a=null,s=null,o=null,l=null,u=null,c=null,h=null;return{setTest:function(i){r||(i?$(n.STENCIL_TEST):W(n.STENCIL_TEST))},setMask:function(a){i===a||r||(n.stencilMask(a),i=a)},setFunc:function(r,i,l){(a!==r||s!==i||o!==l)&&(n.stencilFunc(r,i,l),a=r,s=i,o=l)},setOp:function(r,i,a){(l!==r||u!==i||c!==a)&&(n.stencilOp(r,i,a),l=r,u=i,c=a)},setLocked:function(n){r=n},setClear:function(r){h!==r&&(n.clearStencil(r),h=r)},reset:function(){r=!1,i=null,a=null,s=null,o=null,l=null,u=null,c=null,h=null}}}//
let u=new s,c=new o,h=new l,d=new WeakMap,p=new WeakMap,f={},m={},g=new WeakMap,_=[],y=null,b=!1,v=null,x=null,w=null,T=null,S=null,E=null,A=null,M=!1,I=null,P=null,O=null,R=null,C=null,L=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS),D=!1,N=0,k=n.getParameter(n.VERSION);-1!==k.indexOf("WebGL")?D=(N=parseFloat(/^WebGL (\d)/.exec(k)[1]))>=1:-1!==k.indexOf("OpenGL ES")&&(D=(N=parseFloat(/^OpenGL ES (\d)/.exec(k)[1]))>=2);let U=null,F={},B=n.getParameter(n.SCISSOR_BOX),z=n.getParameter(n.VIEWPORT),V=new $d5b33d7c30034067$export$fa7daccca11cdbe3().fromArray(B),G=new $d5b33d7c30034067$export$fa7daccca11cdbe3().fromArray(z);function j(r,i,s,o){let l=new Uint8Array(4),u=n.createTexture();// 4 is required to match default unpack alignment of 4.
n.bindTexture(r,u),n.texParameteri(r,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(r,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let u=0;u<s;u++)a&&(r===n.TEXTURE_3D||r===n.TEXTURE_2D_ARRAY)?n.texImage3D(i,0,n.RGBA,1,1,o,0,n.RGBA,n.UNSIGNED_BYTE,l):n.texImage2D(i+u,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,l);return u}let H={};//
function $(r){!0!==f[r]&&(n.enable(r),f[r]=!0)}function W(r){!1!==f[r]&&(n.disable(r),f[r]=!1)}function X(r,i){return m[r]!==i&&(n.bindFramebuffer(r,i),m[r]=i,a&&(r===n.DRAW_FRAMEBUFFER&&(m[n.FRAMEBUFFER]=i),r===n.FRAMEBUFFER&&(m[n.DRAW_FRAMEBUFFER]=i)),!0)}function q(a,s){let o=_,l=!1;if(a){if(void 0===(o=g.get(s))&&(o=[],g.set(s,o)),a.isWebGLMultipleRenderTargets){let r=a.texture;if(o.length!==r.length||o[0]!==n.COLOR_ATTACHMENT0){for(let i=0,a=r.length;i<a;i++)o[i]=n.COLOR_ATTACHMENT0+i;o.length=r.length,l=!0}}else o[0]!==n.COLOR_ATTACHMENT0&&(o[0]=n.COLOR_ATTACHMENT0,l=!0)}else o[0]!==n.BACK&&(o[0]=n.BACK,l=!0);l&&(i.isWebGL2?n.drawBuffers(o):r.get("WEBGL_draw_buffers").drawBuffersWEBGL(o))}function Y(r){return y!==r&&(n.useProgram(r),y=r,!0)}H[n.TEXTURE_2D]=j(n.TEXTURE_2D,n.TEXTURE_2D,1),H[n.TEXTURE_CUBE_MAP]=j(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),a&&(H[n.TEXTURE_2D_ARRAY]=j(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),H[n.TEXTURE_3D]=j(n.TEXTURE_3D,n.TEXTURE_3D,1,1)),// init
u.setClear(0,0,0,1),c.setClear(1),h.setClear(0),$(n.DEPTH_TEST),c.setFunc($d5b33d7c30034067$export$296f78a0b892f81a),ee(!1),et($d5b33d7c30034067$export$b9a7b4fc5cb15f9b),$(n.CULL_FACE),J($d5b33d7c30034067$export$63b8d6b580fc65ba);let K={[$d5b33d7c30034067$export$20183a0484ce21a0]:n.FUNC_ADD,[$d5b33d7c30034067$export$73e0df5177988548]:n.FUNC_SUBTRACT,[$d5b33d7c30034067$export$28e582859cbec660]:n.FUNC_REVERSE_SUBTRACT};if(a)K[$d5b33d7c30034067$export$c8c1508da8d0600c]=n.MIN,K[$d5b33d7c30034067$export$99948c02fb51055f]=n.MAX;else{let n=r.get("EXT_blend_minmax");null!==n&&(K[$d5b33d7c30034067$export$c8c1508da8d0600c]=n.MIN_EXT,K[$d5b33d7c30034067$export$99948c02fb51055f]=n.MAX_EXT)}let Z={[$d5b33d7c30034067$export$2110f05edf778d3d]:n.ZERO,[$d5b33d7c30034067$export$8805bad65e24940e]:n.ONE,[$d5b33d7c30034067$export$7fbe15b28d28cf52]:n.SRC_COLOR,[$d5b33d7c30034067$export$d5773124e86cf28c]:n.SRC_ALPHA,[$d5b33d7c30034067$export$c05e2a1fc8609506]:n.SRC_ALPHA_SATURATE,[$d5b33d7c30034067$export$ef5f2dd8ffac5574]:n.DST_COLOR,[$d5b33d7c30034067$export$a78aed1ca2a87192]:n.DST_ALPHA,[$d5b33d7c30034067$export$947829af9f2c17f6]:n.ONE_MINUS_SRC_COLOR,[$d5b33d7c30034067$export$11d468cc7f19e971]:n.ONE_MINUS_SRC_ALPHA,[$d5b33d7c30034067$export$56b85b2686ab16]:n.ONE_MINUS_DST_COLOR,[$d5b33d7c30034067$export$5d0fe17fd8773bac]:n.ONE_MINUS_DST_ALPHA};function J(r,i,a,s,o,l,u,c){if(r===$d5b33d7c30034067$export$63b8d6b580fc65ba){!0===b&&(W(n.BLEND),b=!1);return}if(!1===b&&($(n.BLEND),b=!0),r!==$d5b33d7c30034067$export$eda4864c68df1fa2){if(r!==v||c!==M){if((x!==$d5b33d7c30034067$export$20183a0484ce21a0||S!==$d5b33d7c30034067$export$20183a0484ce21a0)&&(n.blendEquation(n.FUNC_ADD),x=$d5b33d7c30034067$export$20183a0484ce21a0,S=$d5b33d7c30034067$export$20183a0484ce21a0),c)switch(r){case $d5b33d7c30034067$export$5b29a26d96ee6af0:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case $d5b33d7c30034067$export$777d8f9551c2216b:n.blendFunc(n.ONE,n.ONE);break;case $d5b33d7c30034067$export$cdfa06f868e2e467:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case $d5b33d7c30034067$export$4138e1c684b46a20:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",r)}else switch(r){case $d5b33d7c30034067$export$5b29a26d96ee6af0:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case $d5b33d7c30034067$export$777d8f9551c2216b:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case $d5b33d7c30034067$export$cdfa06f868e2e467:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case $d5b33d7c30034067$export$4138e1c684b46a20:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",r)}w=null,T=null,E=null,A=null,v=r,M=c}return}// custom blending
o=o||i,l=l||a,u=u||s,(i!==x||o!==S)&&(n.blendEquationSeparate(K[i],K[o]),x=i,S=o),(a!==w||s!==T||l!==E||u!==A)&&(n.blendFuncSeparate(Z[a],Z[s],Z[l],Z[u]),w=a,T=s,E=l,A=u),v=r,M=!1}function Q(r,i){r.side===$d5b33d7c30034067$export$3b296b6f144d5b03?W(n.CULL_FACE):$(n.CULL_FACE);let a=r.side===$d5b33d7c30034067$export$d9f0486e75b5ace;i&&(a=!a),ee(a),r.blending===$d5b33d7c30034067$export$5b29a26d96ee6af0&&!1===r.transparent?J($d5b33d7c30034067$export$63b8d6b580fc65ba):J(r.blending,r.blendEquation,r.blendSrc,r.blendDst,r.blendEquationAlpha,r.blendSrcAlpha,r.blendDstAlpha,r.premultipliedAlpha),c.setFunc(r.depthFunc),c.setTest(r.depthTest),c.setMask(r.depthWrite),u.setMask(r.colorWrite);let s=r.stencilWrite;h.setTest(s),s&&(h.setMask(r.stencilWriteMask),h.setFunc(r.stencilFunc,r.stencilRef,r.stencilFuncMask),h.setOp(r.stencilFail,r.stencilZFail,r.stencilZPass)),en(r.polygonOffset,r.polygonOffsetFactor,r.polygonOffsetUnits),!0===r.alphaToCoverage?$(n.SAMPLE_ALPHA_TO_COVERAGE):W(n.SAMPLE_ALPHA_TO_COVERAGE)}//
function ee(r){I!==r&&(r?n.frontFace(n.CW):n.frontFace(n.CCW),I=r)}function et(r){r!==$d5b33d7c30034067$export$3237e1f2c1ea1f44?($(n.CULL_FACE),r!==P&&(r===$d5b33d7c30034067$export$b9a7b4fc5cb15f9b?n.cullFace(n.BACK):r===$d5b33d7c30034067$export$b8058bcc7037d3f3?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):W(n.CULL_FACE),P=r}function en(r,i,a){r?($(n.POLYGON_OFFSET_FILL),(R!==i||C!==a)&&(n.polygonOffset(i,a),R=i,C=a)):W(n.POLYGON_OFFSET_FILL)}function er(r){r?$(n.SCISSOR_TEST):W(n.SCISSOR_TEST)}//
function ei(){// reset state
n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),!0===a&&(n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),// reset internals
f={},U=null,F={},m={},g=new WeakMap,_=[],y=null,b=!1,v=null,x=null,w=null,T=null,S=null,E=null,A=null,M=!1,I=null,P=null,O=null,R=null,C=null,V.set(0,0,n.canvas.width,n.canvas.height),G.set(0,0,n.canvas.width,n.canvas.height),u.reset(),c.reset(),h.reset()}return{buffers:{color:u,depth:c,stencil:h},enable:$,disable:W,bindFramebuffer:X,drawBuffers:q,useProgram:Y,setBlending:J,setMaterial:Q,setFlipSided:ee,setCullFace:et,setLineWidth:function(r){r!==O&&(D&&n.lineWidth(r),O=r)},setPolygonOffset:en,setScissorTest:er,activeTexture:// texture
function(r){void 0===r&&(r=n.TEXTURE0+L-1),U!==r&&(n.activeTexture(r),U=r)},bindTexture:function(r,i,a){void 0===a&&(a=null===U?n.TEXTURE0+L-1:U);let s=F[a];void 0===s&&(s={type:void 0,texture:void 0},F[a]=s),(s.type!==r||s.texture!==i)&&(U!==a&&(n.activeTexture(a),U=a),n.bindTexture(r,i||H[r]),s.type=r,s.texture=i)},unbindTexture:function(){let r=F[U];void 0!==r&&void 0!==r.type&&(n.bindTexture(r.type,null),r.type=void 0,r.texture=void 0)},compressedTexImage2D:function(){try{n.compressedTexImage2D.apply(n,arguments)}catch(n){console.error("THREE.WebGLState:",n)}},compressedTexImage3D:function(){try{n.compressedTexImage3D.apply(n,arguments)}catch(n){console.error("THREE.WebGLState:",n)}},texImage2D:function(){try{n.texImage2D.apply(n,arguments)}catch(n){console.error("THREE.WebGLState:",n)}},texImage3D:function(){try{n.texImage3D.apply(n,arguments)}catch(n){console.error("THREE.WebGLState:",n)}},updateUBOMapping:function(r,i){let a=p.get(i);void 0===a&&(a=new WeakMap,p.set(i,a));let s=a.get(r);void 0===s&&(s=n.getUniformBlockIndex(i,r.name),a.set(r,s))},uniformBlockBinding:function(r,i){let a=p.get(i),s=a.get(r);d.get(i)!==s&&(// bind shader specific block index to global block point
n.uniformBlockBinding(i,s,r.__bindingPointIndex),d.set(i,s))},texStorage2D:function(){try{n.texStorage2D.apply(n,arguments)}catch(n){console.error("THREE.WebGLState:",n)}},texStorage3D:function(){try{n.texStorage3D.apply(n,arguments)}catch(n){console.error("THREE.WebGLState:",n)}},texSubImage2D:function(){try{n.texSubImage2D.apply(n,arguments)}catch(n){console.error("THREE.WebGLState:",n)}},texSubImage3D:function(){try{n.texSubImage3D.apply(n,arguments)}catch(n){console.error("THREE.WebGLState:",n)}},compressedTexSubImage2D:function(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(n){console.error("THREE.WebGLState:",n)}},compressedTexSubImage3D:function(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(n){console.error("THREE.WebGLState:",n)}},scissor://
function(r){!1===V.equals(r)&&(n.scissor(r.x,r.y,r.z,r.w),V.copy(r))},viewport:function(r){!1===G.equals(r)&&(n.viewport(r.x,r.y,r.z,r.w),G.copy(r))},reset:ei}}function $d5b33d7c30034067$var$WebGLTextures(n,r,i,a,s,o,l){let u;let c=s.isWebGL2,h=s.maxTextures,d=s.maxCubemapSize,p=s.maxTextureSize,f=s.maxSamples,m=r.has("WEBGL_multisampled_render_to_texture")?r.get("WEBGL_multisampled_render_to_texture"):null,g="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),_=new WeakMap,y=new WeakMap,b=!1;try{b="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(n){// Ignore any errors
}function v(n,r){// Use OffscreenCanvas when available. Specially needed in web workers
return b?new OffscreenCanvas(n,r):$d5b33d7c30034067$var$createElementNS("canvas")}function x(n,r,i,a){let s=1;// only perform resize if necessary
if((n.width>a||n.height>a)&&(s=a/Math.max(n.width,n.height)),s<1||!0===r){// only perform resize for certain image types
if("undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap){let a=r?$d5b33d7c30034067$var$floorPowerOfTwo:Math.floor,o=a(s*n.width),l=a(s*n.height);void 0===u&&(u=v(o,l));// cube textures can't reuse the same canvas
let c=i?v(o,l):u;c.width=o,c.height=l;let h=c.getContext("2d");return h.drawImage(n,0,0,o,l),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+n.width+"x"+n.height+") to ("+o+"x"+l+")."),c}"data"in n&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+n.width+"x"+n.height+").")}return n}function w(n){return $d5b33d7c30034067$var$isPowerOfTwo(n.width)&&$d5b33d7c30034067$var$isPowerOfTwo(n.height)}function T(n){return!c&&(n.wrapS!==$d5b33d7c30034067$export$9d9334239a5a5e06||n.wrapT!==$d5b33d7c30034067$export$9d9334239a5a5e06||n.minFilter!==$d5b33d7c30034067$export$727aa5ec3fe39bf0&&n.minFilter!==$d5b33d7c30034067$export$8a72f490b25c56c8)}function S(n,r){return n.generateMipmaps&&r&&n.minFilter!==$d5b33d7c30034067$export$727aa5ec3fe39bf0&&n.minFilter!==$d5b33d7c30034067$export$8a72f490b25c56c8}function E(r){n.generateMipmap(r)}function A(i,a,s,o,l=!1){if(!1===c)return a;if(null!==i){if(void 0!==n[i])return n[i];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+i+"'")}let u=a;return a===n.RED&&(s===n.FLOAT&&(u=n.R32F),s===n.HALF_FLOAT&&(u=n.R16F),s===n.UNSIGNED_BYTE&&(u=n.R8)),a===n.RED_INTEGER&&(s===n.UNSIGNED_BYTE&&(u=n.R8UI),s===n.UNSIGNED_SHORT&&(u=n.R16UI),s===n.UNSIGNED_INT&&(u=n.R32UI),s===n.BYTE&&(u=n.R8I),s===n.SHORT&&(u=n.R16I),s===n.INT&&(u=n.R32I)),a===n.RG&&(s===n.FLOAT&&(u=n.RG32F),s===n.HALF_FLOAT&&(u=n.RG16F),s===n.UNSIGNED_BYTE&&(u=n.RG8)),a===n.RGBA&&(s===n.FLOAT&&(u=n.RGBA32F),s===n.HALF_FLOAT&&(u=n.RGBA16F),s===n.UNSIGNED_BYTE&&(u=o===$d5b33d7c30034067$export$561f394b24edfcaa&&!1===l?n.SRGB8_ALPHA8:n.RGBA8),s===n.UNSIGNED_SHORT_4_4_4_4&&(u=n.RGBA4),s===n.UNSIGNED_SHORT_5_5_5_1&&(u=n.RGB5_A1)),(u===n.R16F||u===n.R32F||u===n.RG16F||u===n.RG32F||u===n.RGBA16F||u===n.RGBA32F)&&r.get("EXT_color_buffer_float"),u}function M(n,r,i){return!0===S(n,i)||n.isFramebufferTexture&&n.minFilter!==$d5b33d7c30034067$export$727aa5ec3fe39bf0&&n.minFilter!==$d5b33d7c30034067$export$8a72f490b25c56c8?Math.log2(Math.max(r.width,r.height))+1:void 0!==n.mipmaps&&n.mipmaps.length>0?n.mipmaps.length:n.isCompressedTexture&&Array.isArray(n.image)?r.mipmaps.length:1}// Fallback filters for non-power-of-2 textures
function I(r){return r===$d5b33d7c30034067$export$727aa5ec3fe39bf0||r===$d5b33d7c30034067$export$d129e38cf6feaa8c||r===$d5b33d7c30034067$export$d2327c1afe5bfdf2?n.NEAREST:n.LINEAR}//
function P(n){let r=n.target;r.removeEventListener("dispose",P),R(r),r.isVideoTexture&&_.delete(r)}function O(n){let r=n.target;r.removeEventListener("dispose",O),L(r)}//
function R(n){let r=a.get(n);if(void 0===r.__webglInit)return;// check if it's necessary to remove the WebGLTexture object
let i=n.source,s=y.get(i);if(s){let a=s[r.__cacheKey];a.usedTimes--,0===a.usedTimes&&C(n),0===Object.keys(s).length&&y.delete(i)}a.remove(n)}function C(r){let i=a.get(r);n.deleteTexture(i.__webglTexture);let s=r.source,o=y.get(s);delete o[i.__cacheKey],l.memory.textures--}function L(r){let i=r.texture,s=a.get(r),o=a.get(i);if(void 0!==o.__webglTexture&&(n.deleteTexture(o.__webglTexture),l.memory.textures--),r.depthTexture&&r.depthTexture.dispose(),r.isWebGLCubeRenderTarget)for(let r=0;r<6;r++){if(Array.isArray(s.__webglFramebuffer[r]))for(let i=0;i<s.__webglFramebuffer[r].length;i++)n.deleteFramebuffer(s.__webglFramebuffer[r][i]);else n.deleteFramebuffer(s.__webglFramebuffer[r]);s.__webglDepthbuffer&&n.deleteRenderbuffer(s.__webglDepthbuffer[r])}else{if(Array.isArray(s.__webglFramebuffer))for(let r=0;r<s.__webglFramebuffer.length;r++)n.deleteFramebuffer(s.__webglFramebuffer[r]);else n.deleteFramebuffer(s.__webglFramebuffer);if(s.__webglDepthbuffer&&n.deleteRenderbuffer(s.__webglDepthbuffer),s.__webglMultisampledFramebuffer&&n.deleteFramebuffer(s.__webglMultisampledFramebuffer),s.__webglColorRenderbuffer)for(let r=0;r<s.__webglColorRenderbuffer.length;r++)s.__webglColorRenderbuffer[r]&&n.deleteRenderbuffer(s.__webglColorRenderbuffer[r]);s.__webglDepthRenderbuffer&&n.deleteRenderbuffer(s.__webglDepthRenderbuffer)}if(r.isWebGLMultipleRenderTargets)for(let r=0,s=i.length;r<s;r++){let s=a.get(i[r]);s.__webglTexture&&(n.deleteTexture(s.__webglTexture),l.memory.textures--),a.remove(i[r])}a.remove(i),a.remove(r)}//
let D=0;function N(){D=0}function k(){let n=D;return n>=h&&console.warn("THREE.WebGLTextures: Trying to use "+n+" texture units while this GPU supports only "+h),D+=1,n}function U(n){let r=[];return r.push(n.wrapS),r.push(n.wrapT),r.push(n.wrapR||0),r.push(n.magFilter),r.push(n.minFilter),r.push(n.anisotropy),r.push(n.internalFormat),r.push(n.format),r.push(n.type),r.push(n.generateMipmaps),r.push(n.premultiplyAlpha),r.push(n.flipY),r.push(n.unpackAlignment),r.push(n.colorSpace),r.join()}//
function F(r,s){let o=a.get(r);if(r.isVideoTexture&&ea(r),!1===r.isRenderTargetTexture&&r.version>0&&o.__version!==r.version){let n=r.image;if(null===n)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(!1===n.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{X(o,r,s);return}}i.bindTexture(n.TEXTURE_2D,o.__webglTexture,n.TEXTURE0+s)}function B(r,s){let o=a.get(r);if(r.version>0&&o.__version!==r.version){X(o,r,s);return}i.bindTexture(n.TEXTURE_2D_ARRAY,o.__webglTexture,n.TEXTURE0+s)}function z(r,s){let o=a.get(r);if(r.version>0&&o.__version!==r.version){X(o,r,s);return}i.bindTexture(n.TEXTURE_3D,o.__webglTexture,n.TEXTURE0+s)}function V(r,s){let o=a.get(r);if(r.version>0&&o.__version!==r.version){q(o,r,s);return}i.bindTexture(n.TEXTURE_CUBE_MAP,o.__webglTexture,n.TEXTURE0+s)}let G={[$d5b33d7c30034067$export$533346c8e8dac0f5]:n.REPEAT,[$d5b33d7c30034067$export$9d9334239a5a5e06]:n.CLAMP_TO_EDGE,[$d5b33d7c30034067$export$c7e7c00b14f51a4f]:n.MIRRORED_REPEAT},j={[$d5b33d7c30034067$export$727aa5ec3fe39bf0]:n.NEAREST,[$d5b33d7c30034067$export$d129e38cf6feaa8c]:n.NEAREST_MIPMAP_NEAREST,[$d5b33d7c30034067$export$d2327c1afe5bfdf2]:n.NEAREST_MIPMAP_LINEAR,[$d5b33d7c30034067$export$8a72f490b25c56c8]:n.LINEAR,[$d5b33d7c30034067$export$19a719f377145a13]:n.LINEAR_MIPMAP_NEAREST,[$d5b33d7c30034067$export$5d8599b6a933fb1b]:n.LINEAR_MIPMAP_LINEAR},H={[$d5b33d7c30034067$export$d9e2d19a747baaab]:n.NEVER,[$d5b33d7c30034067$export$187b73a3e352c145]:n.ALWAYS,[$d5b33d7c30034067$export$36bcf49c713b3eb7]:n.LESS,[$d5b33d7c30034067$export$64eea11eb407ddf1]:n.LEQUAL,[$d5b33d7c30034067$export$66f28d946fc6a0d5]:n.EQUAL,[$d5b33d7c30034067$export$1cdcb70d53d65f61]:n.GEQUAL,[$d5b33d7c30034067$export$155af022118f3a38]:n.GREATER,[$d5b33d7c30034067$export$67ab95dde6bed156]:n.NOTEQUAL};function $(i,o,l){if(l?(n.texParameteri(i,n.TEXTURE_WRAP_S,G[o.wrapS]),n.texParameteri(i,n.TEXTURE_WRAP_T,G[o.wrapT]),(i===n.TEXTURE_3D||i===n.TEXTURE_2D_ARRAY)&&n.texParameteri(i,n.TEXTURE_WRAP_R,G[o.wrapR]),n.texParameteri(i,n.TEXTURE_MAG_FILTER,j[o.magFilter]),n.texParameteri(i,n.TEXTURE_MIN_FILTER,j[o.minFilter])):(n.texParameteri(i,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(i,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),(i===n.TEXTURE_3D||i===n.TEXTURE_2D_ARRAY)&&n.texParameteri(i,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),(o.wrapS!==$d5b33d7c30034067$export$9d9334239a5a5e06||o.wrapT!==$d5b33d7c30034067$export$9d9334239a5a5e06)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(i,n.TEXTURE_MAG_FILTER,I(o.magFilter)),n.texParameteri(i,n.TEXTURE_MIN_FILTER,I(o.minFilter)),o.minFilter!==$d5b33d7c30034067$export$727aa5ec3fe39bf0&&o.minFilter!==$d5b33d7c30034067$export$8a72f490b25c56c8&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),o.compareFunction&&(n.texParameteri(i,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(i,n.TEXTURE_COMPARE_FUNC,H[o.compareFunction])),!0===r.has("EXT_texture_filter_anisotropic")){let l=r.get("EXT_texture_filter_anisotropic");o.magFilter!==$d5b33d7c30034067$export$727aa5ec3fe39bf0&&(o.minFilter===$d5b33d7c30034067$export$d2327c1afe5bfdf2||o.minFilter===$d5b33d7c30034067$export$5d8599b6a933fb1b)&&(o.type!==$d5b33d7c30034067$export$f6d331659b644596||!1!==r.has("OES_texture_float_linear"))&&(!1!==c||o.type!==$d5b33d7c30034067$export$2697304443f382bc||!1!==r.has("OES_texture_half_float_linear"))&&(o.anisotropy>1||a.get(o).__currentAnisotropy)&&(n.texParameterf(i,l.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(o.anisotropy,s.getMaxAnisotropy())),a.get(o).__currentAnisotropy=o.anisotropy)}}function W(r,i){let a=!1;void 0===r.__webglInit&&(r.__webglInit=!0,i.addEventListener("dispose",P));// create Source <-> WebGLTextures mapping if necessary
let s=i.source,o=y.get(s);void 0===o&&(o={},y.set(s,o));// check if there is already a WebGLTexture object for the given texture parameters
let u=U(i);if(u!==r.__cacheKey){void 0===o[u]&&(// create new entry
o[u]={texture:n.createTexture(),usedTimes:0},l.memory.textures++,// when a new instance of WebGLTexture was created, a texture upload is required
// even if the image contents are identical
a=!0),o[u].usedTimes++;// every time the texture cache key changes, it's necessary to check if an instance of
// WebGLTexture can be deleted in order to avoid a memory leak.
let s=o[r.__cacheKey];void 0!==s&&(o[r.__cacheKey].usedTimes--,0===s.usedTimes&&C(i)),// store references to cache key and WebGLTexture object
r.__cacheKey=u,r.__webglTexture=o[u].texture}return a}function X(r,s,l){let u=n.TEXTURE_2D;(s.isDataArrayTexture||s.isCompressedArrayTexture)&&(u=n.TEXTURE_2D_ARRAY),s.isData3DTexture&&(u=n.TEXTURE_3D);let h=W(r,s),d=s.source;i.bindTexture(u,r.__webglTexture,n.TEXTURE0+l);let f=a.get(d);if(d.version!==f.__version||!0===h){let r;i.activeTexture(n.TEXTURE0+l),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,s.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,s.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,n.NONE);let a=T(s)&&!1===w(s.image),m=x(s.image,a,!1,p);m=es(s,m);let g=w(m)||c,_=o.convert(s.format,s.colorSpace),y=o.convert(s.type),b=A(s.internalFormat,_,y,s.colorSpace,s.isVideoTexture);$(u,s,g);let v=s.mipmaps,I=c&&!0!==s.isVideoTexture,P=void 0===f.__version||!0===h,O=M(s,m,g);if(s.isDepthTexture)// populate depth texture with dummy data
b=n.DEPTH_COMPONENT,c?b=s.type===$d5b33d7c30034067$export$f6d331659b644596?n.DEPTH_COMPONENT32F:s.type===$d5b33d7c30034067$export$c3c7fc4518ebba96?n.DEPTH_COMPONENT24:s.type===$d5b33d7c30034067$export$6c8ea339bfab1301?n.DEPTH24_STENCIL8:n.DEPTH_COMPONENT16:s.type===$d5b33d7c30034067$export$f6d331659b644596&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),s.format===$d5b33d7c30034067$export$c1b6b5136be58045&&b===n.DEPTH_COMPONENT&&s.type!==$d5b33d7c30034067$export$c63dc51868b06a9d&&s.type!==$d5b33d7c30034067$export$c3c7fc4518ebba96&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),s.type=$d5b33d7c30034067$export$c3c7fc4518ebba96,y=o.convert(s.type)),s.format===$d5b33d7c30034067$export$1e113ac2d0905829&&b===n.DEPTH_COMPONENT&&(// Depth stencil textures need the DEPTH_STENCIL internal format
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
b=n.DEPTH_STENCIL,s.type!==$d5b33d7c30034067$export$6c8ea339bfab1301&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),s.type=$d5b33d7c30034067$export$6c8ea339bfab1301,y=o.convert(s.type))),P&&(I?i.texStorage2D(n.TEXTURE_2D,1,b,m.width,m.height):i.texImage2D(n.TEXTURE_2D,0,b,m.width,m.height,0,_,y,null));else if(s.isDataTexture){// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(v.length>0&&g){I&&P&&i.texStorage2D(n.TEXTURE_2D,O,b,v[0].width,v[0].height);for(let a=0,s=v.length;a<s;a++)r=v[a],I?i.texSubImage2D(n.TEXTURE_2D,a,0,0,r.width,r.height,_,y,r.data):i.texImage2D(n.TEXTURE_2D,a,b,r.width,r.height,0,_,y,r.data);s.generateMipmaps=!1}else I?(P&&i.texStorage2D(n.TEXTURE_2D,O,b,m.width,m.height),i.texSubImage2D(n.TEXTURE_2D,0,0,0,m.width,m.height,_,y,m.data)):i.texImage2D(n.TEXTURE_2D,0,b,m.width,m.height,0,_,y,m.data)}else if(s.isCompressedTexture){if(s.isCompressedArrayTexture){I&&P&&i.texStorage3D(n.TEXTURE_2D_ARRAY,O,b,v[0].width,v[0].height,m.depth);for(let a=0,o=v.length;a<o;a++)r=v[a],s.format!==$d5b33d7c30034067$export$3f8bb04b555a363c?null!==_?I?i.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,a,0,0,0,r.width,r.height,m.depth,_,r.data,0,0):i.compressedTexImage3D(n.TEXTURE_2D_ARRAY,a,b,r.width,r.height,m.depth,0,r.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):I?i.texSubImage3D(n.TEXTURE_2D_ARRAY,a,0,0,0,r.width,r.height,m.depth,_,y,r.data):i.texImage3D(n.TEXTURE_2D_ARRAY,a,b,r.width,r.height,m.depth,0,_,y,r.data)}else{I&&P&&i.texStorage2D(n.TEXTURE_2D,O,b,v[0].width,v[0].height);for(let a=0,o=v.length;a<o;a++)r=v[a],s.format!==$d5b33d7c30034067$export$3f8bb04b555a363c?null!==_?I?i.compressedTexSubImage2D(n.TEXTURE_2D,a,0,0,r.width,r.height,_,r.data):i.compressedTexImage2D(n.TEXTURE_2D,a,b,r.width,r.height,0,r.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):I?i.texSubImage2D(n.TEXTURE_2D,a,0,0,r.width,r.height,_,y,r.data):i.texImage2D(n.TEXTURE_2D,a,b,r.width,r.height,0,_,y,r.data)}}else if(s.isDataArrayTexture)I?(P&&i.texStorage3D(n.TEXTURE_2D_ARRAY,O,b,m.width,m.height,m.depth),i.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,m.width,m.height,m.depth,_,y,m.data)):i.texImage3D(n.TEXTURE_2D_ARRAY,0,b,m.width,m.height,m.depth,0,_,y,m.data);else if(s.isData3DTexture)I?(P&&i.texStorage3D(n.TEXTURE_3D,O,b,m.width,m.height,m.depth),i.texSubImage3D(n.TEXTURE_3D,0,0,0,0,m.width,m.height,m.depth,_,y,m.data)):i.texImage3D(n.TEXTURE_3D,0,b,m.width,m.height,m.depth,0,_,y,m.data);else if(s.isFramebufferTexture){if(P){if(I)i.texStorage2D(n.TEXTURE_2D,O,b,m.width,m.height);else{let r=m.width,a=m.height;for(let s=0;s<O;s++)i.texImage2D(n.TEXTURE_2D,s,b,r,a,0,_,y,null),r>>=1,a>>=1}}}else // regular Texture (image, video, canvas)
// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(v.length>0&&g){I&&P&&i.texStorage2D(n.TEXTURE_2D,O,b,v[0].width,v[0].height);for(let a=0,s=v.length;a<s;a++)r=v[a],I?i.texSubImage2D(n.TEXTURE_2D,a,0,0,_,y,r):i.texImage2D(n.TEXTURE_2D,a,b,_,y,r);s.generateMipmaps=!1}else I?(P&&i.texStorage2D(n.TEXTURE_2D,O,b,m.width,m.height),i.texSubImage2D(n.TEXTURE_2D,0,0,0,_,y,m)):i.texImage2D(n.TEXTURE_2D,0,b,_,y,m);S(s,g)&&E(u),f.__version=d.version,s.onUpdate&&s.onUpdate(s)}r.__version=s.version}function q(r,s,l){if(6!==s.image.length)return;let u=W(r,s),h=s.source;i.bindTexture(n.TEXTURE_CUBE_MAP,r.__webglTexture,n.TEXTURE0+l);let p=a.get(h);if(h.version!==p.__version||!0===u){let r;i.activeTexture(n.TEXTURE0+l),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,s.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,s.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,n.NONE);let a=s.isCompressedTexture||s.image[0].isCompressedTexture,f=s.image[0]&&s.image[0].isDataTexture,m=[];for(let n=0;n<6;n++)a||f?m[n]=f?s.image[n].image:s.image[n]:m[n]=x(s.image[n],!1,!0,d),m[n]=es(s,m[n]);let g=m[0],_=w(g)||c,y=o.convert(s.format,s.colorSpace),b=o.convert(s.type),v=A(s.internalFormat,y,b,s.colorSpace),T=c&&!0!==s.isVideoTexture,I=void 0===p.__version||!0===u,P=M(s,g,_);if($(n.TEXTURE_CUBE_MAP,s,_),a){T&&I&&i.texStorage2D(n.TEXTURE_CUBE_MAP,P,v,g.width,g.height);for(let a=0;a<6;a++){r=m[a].mipmaps;for(let o=0;o<r.length;o++){let l=r[o];s.format!==$d5b33d7c30034067$export$3f8bb04b555a363c?null!==y?T?i.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,o,0,0,l.width,l.height,y,l.data):i.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,o,v,l.width,l.height,0,l.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):T?i.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,o,0,0,l.width,l.height,y,b,l.data):i.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,o,v,l.width,l.height,0,y,b,l.data)}}}else{r=s.mipmaps,T&&I&&(r.length>0&&P++,i.texStorage2D(n.TEXTURE_CUBE_MAP,P,v,m[0].width,m[0].height));for(let a=0;a<6;a++)if(f){T?i.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,0,0,0,m[a].width,m[a].height,y,b,m[a].data):i.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,0,v,m[a].width,m[a].height,0,y,b,m[a].data);for(let s=0;s<r.length;s++){let o=r[s],l=o.image[a].image;T?i.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,s+1,0,0,l.width,l.height,y,b,l.data):i.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,s+1,v,l.width,l.height,0,y,b,l.data)}}else{T?i.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,0,0,0,y,b,m[a]):i.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,0,v,y,b,m[a]);for(let s=0;s<r.length;s++){let o=r[s];T?i.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,s+1,0,0,y,b,o.image[a]):i.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+a,s+1,v,y,b,o.image[a])}}}S(s,_)&&E(n.TEXTURE_CUBE_MAP),p.__version=h.version,s.onUpdate&&s.onUpdate(s)}r.__version=s.version}// Render targets
// Setup storage for target texture and bind it to correct framebuffer
function Y(r,s,l,u,c,h){let d=o.convert(l.format,l.colorSpace),p=o.convert(l.type),f=A(l.internalFormat,d,p,l.colorSpace),g=a.get(s);if(!g.__hasExternalTextures){let r=Math.max(1,s.width>>h),a=Math.max(1,s.height>>h);c===n.TEXTURE_3D||c===n.TEXTURE_2D_ARRAY?i.texImage3D(c,h,f,r,a,s.depth,0,d,p,null):i.texImage2D(c,h,f,r,a,0,d,p,null)}i.bindFramebuffer(n.FRAMEBUFFER,r),ei(s)?m.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,u,c,a.get(l).__webglTexture,0,er(s)):(c===n.TEXTURE_2D||c>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&c<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,u,c,a.get(l).__webglTexture,h),i.bindFramebuffer(n.FRAMEBUFFER,null)}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
function K(r,i,a){if(n.bindRenderbuffer(n.RENDERBUFFER,r),i.depthBuffer&&!i.stencilBuffer){let s=n.DEPTH_COMPONENT16;if(a||ei(i)){let r=i.depthTexture;r&&r.isDepthTexture&&(r.type===$d5b33d7c30034067$export$f6d331659b644596?s=n.DEPTH_COMPONENT32F:r.type===$d5b33d7c30034067$export$c3c7fc4518ebba96&&(s=n.DEPTH_COMPONENT24));let a=er(i);ei(i)?m.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,a,s,i.width,i.height):n.renderbufferStorageMultisample(n.RENDERBUFFER,a,s,i.width,i.height)}else n.renderbufferStorage(n.RENDERBUFFER,s,i.width,i.height);n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,r)}else if(i.depthBuffer&&i.stencilBuffer){let s=er(i);a&&!1===ei(i)?n.renderbufferStorageMultisample(n.RENDERBUFFER,s,n.DEPTH24_STENCIL8,i.width,i.height):ei(i)?m.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,s,n.DEPTH24_STENCIL8,i.width,i.height):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,i.width,i.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,r)}else{let r=!0===i.isWebGLMultipleRenderTargets?i.texture:[i.texture];for(let s=0;s<r.length;s++){let l=r[s],u=o.convert(l.format,l.colorSpace),c=o.convert(l.type),h=A(l.internalFormat,u,c,l.colorSpace),d=er(i);a&&!1===ei(i)?n.renderbufferStorageMultisample(n.RENDERBUFFER,d,h,i.width,i.height):ei(i)?m.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,d,h,i.width,i.height):n.renderbufferStorage(n.RENDERBUFFER,h,i.width,i.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}// Setup resources for a Depth Texture for a FBO (needs an extension)
function Z(r,s){let o=s&&s.isWebGLCubeRenderTarget;if(o)throw Error("Depth Texture with cube render targets is not supported");if(i.bindFramebuffer(n.FRAMEBUFFER,r),!(s.depthTexture&&s.depthTexture.isDepthTexture))throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");a.get(s.depthTexture).__webglTexture&&s.depthTexture.image.width===s.width&&s.depthTexture.image.height===s.height||(s.depthTexture.image.width=s.width,s.depthTexture.image.height=s.height,s.depthTexture.needsUpdate=!0),F(s.depthTexture,0);let l=a.get(s.depthTexture).__webglTexture,u=er(s);if(s.depthTexture.format===$d5b33d7c30034067$export$c1b6b5136be58045)ei(s)?m.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,l,0,u):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,l,0);else if(s.depthTexture.format===$d5b33d7c30034067$export$1e113ac2d0905829)ei(s)?m.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,l,0,u):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,l,0);else throw Error("Unknown depthTexture format")}// Setup GL resources for a non-texture depth buffer
function J(r){let s=a.get(r),o=!0===r.isWebGLCubeRenderTarget;if(r.depthTexture&&!s.__autoAllocateDepthBuffer){if(o)throw Error("target.depthTexture not supported in Cube render targets");Z(s.__webglFramebuffer,r)}else if(o){s.__webglDepthbuffer=[];for(let a=0;a<6;a++)i.bindFramebuffer(n.FRAMEBUFFER,s.__webglFramebuffer[a]),s.__webglDepthbuffer[a]=n.createRenderbuffer(),K(s.__webglDepthbuffer[a],r,!1)}else i.bindFramebuffer(n.FRAMEBUFFER,s.__webglFramebuffer),s.__webglDepthbuffer=n.createRenderbuffer(),K(s.__webglDepthbuffer,r,!1);i.bindFramebuffer(n.FRAMEBUFFER,null)}// rebind framebuffer with external textures
function Q(r,i,s){let o=a.get(r);void 0!==i&&Y(o.__webglFramebuffer,r,r.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),void 0!==s&&J(r)}// Set up GL resources for the render target
function ee(r){let u=r.texture,h=a.get(r),d=a.get(u);r.addEventListener("dispose",O),!0!==r.isWebGLMultipleRenderTargets&&(void 0===d.__webglTexture&&(d.__webglTexture=n.createTexture()),d.__version=u.version,l.memory.textures++);let p=!0===r.isWebGLCubeRenderTarget,f=!0===r.isWebGLMultipleRenderTargets,m=w(r)||c;// Setup framebuffer
if(p){h.__webglFramebuffer=[];for(let r=0;r<6;r++)if(c&&u.mipmaps&&u.mipmaps.length>0){h.__webglFramebuffer[r]=[];for(let i=0;i<u.mipmaps.length;i++)h.__webglFramebuffer[r][i]=n.createFramebuffer()}else h.__webglFramebuffer[r]=n.createFramebuffer()}else{if(c&&u.mipmaps&&u.mipmaps.length>0){h.__webglFramebuffer=[];for(let r=0;r<u.mipmaps.length;r++)h.__webglFramebuffer[r]=n.createFramebuffer()}else h.__webglFramebuffer=n.createFramebuffer();if(f){if(s.drawBuffers){let i=r.texture;for(let r=0,s=i.length;r<s;r++){let s=a.get(i[r]);void 0===s.__webglTexture&&(s.__webglTexture=n.createTexture(),l.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.")}if(c&&r.samples>0&&!1===ei(r)){let a=f?u:[u];h.__webglMultisampledFramebuffer=n.createFramebuffer(),h.__webglColorRenderbuffer=[],i.bindFramebuffer(n.FRAMEBUFFER,h.__webglMultisampledFramebuffer);for(let i=0;i<a.length;i++){let s=a[i];h.__webglColorRenderbuffer[i]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,h.__webglColorRenderbuffer[i]);let l=o.convert(s.format,s.colorSpace),u=o.convert(s.type),c=A(s.internalFormat,l,u,s.colorSpace,!0===r.isXRRenderTarget),d=er(r);n.renderbufferStorageMultisample(n.RENDERBUFFER,d,c,r.width,r.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+i,n.RENDERBUFFER,h.__webglColorRenderbuffer[i])}n.bindRenderbuffer(n.RENDERBUFFER,null),r.depthBuffer&&(h.__webglDepthRenderbuffer=n.createRenderbuffer(),K(h.__webglDepthRenderbuffer,r,!0)),i.bindFramebuffer(n.FRAMEBUFFER,null)}}// Setup color buffer
if(p){i.bindTexture(n.TEXTURE_CUBE_MAP,d.__webglTexture),$(n.TEXTURE_CUBE_MAP,u,m);for(let i=0;i<6;i++)if(c&&u.mipmaps&&u.mipmaps.length>0)for(let a=0;a<u.mipmaps.length;a++)Y(h.__webglFramebuffer[i][a],r,u,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+i,a);else Y(h.__webglFramebuffer[i],r,u,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+i,0);S(u,m)&&E(n.TEXTURE_CUBE_MAP),i.unbindTexture()}else if(f){let s=r.texture;for(let o=0,l=s.length;o<l;o++){let l=s[o],u=a.get(l);i.bindTexture(n.TEXTURE_2D,u.__webglTexture),$(n.TEXTURE_2D,l,m),Y(h.__webglFramebuffer,r,l,n.COLOR_ATTACHMENT0+o,n.TEXTURE_2D,0),S(l,m)&&E(n.TEXTURE_2D)}i.unbindTexture()}else{let a=n.TEXTURE_2D;if((r.isWebGL3DRenderTarget||r.isWebGLArrayRenderTarget)&&(c?a=r.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),i.bindTexture(a,d.__webglTexture),$(a,u,m),c&&u.mipmaps&&u.mipmaps.length>0)for(let i=0;i<u.mipmaps.length;i++)Y(h.__webglFramebuffer[i],r,u,n.COLOR_ATTACHMENT0,a,i);else Y(h.__webglFramebuffer,r,u,n.COLOR_ATTACHMENT0,a,0);S(u,m)&&E(a),i.unbindTexture()}r.depthBuffer&&J(r)}function et(r){let s=w(r)||c,o=!0===r.isWebGLMultipleRenderTargets?r.texture:[r.texture];for(let l=0,u=o.length;l<u;l++){let u=o[l];if(S(u,s)){let s=r.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:n.TEXTURE_2D,o=a.get(u).__webglTexture;i.bindTexture(s,o),E(s),i.unbindTexture()}}}function en(r){if(c&&r.samples>0&&!1===ei(r)){let s=r.isWebGLMultipleRenderTargets?r.texture:[r.texture],o=r.width,l=r.height,u=n.COLOR_BUFFER_BIT,c=[],h=r.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,d=a.get(r),p=!0===r.isWebGLMultipleRenderTargets;// If MRT we need to remove FBO attachments
if(p)for(let r=0;r<s.length;r++)i.bindFramebuffer(n.FRAMEBUFFER,d.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+r,n.RENDERBUFFER,null),i.bindFramebuffer(n.FRAMEBUFFER,d.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+r,n.TEXTURE_2D,null,0);i.bindFramebuffer(n.READ_FRAMEBUFFER,d.__webglMultisampledFramebuffer),i.bindFramebuffer(n.DRAW_FRAMEBUFFER,d.__webglFramebuffer);for(let i=0;i<s.length;i++){c.push(n.COLOR_ATTACHMENT0+i),r.depthBuffer&&c.push(h);let f=void 0!==d.__ignoreDepthValues&&d.__ignoreDepthValues;if(!1===f&&(r.depthBuffer&&(u|=n.DEPTH_BUFFER_BIT),r.stencilBuffer&&(u|=n.STENCIL_BUFFER_BIT)),p&&n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,d.__webglColorRenderbuffer[i]),!0===f&&(n.invalidateFramebuffer(n.READ_FRAMEBUFFER,[h]),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[h])),p){let r=a.get(s[i]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0)}n.blitFramebuffer(0,0,o,l,0,0,o,l,u,n.NEAREST),g&&n.invalidateFramebuffer(n.READ_FRAMEBUFFER,c)}// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
if(i.bindFramebuffer(n.READ_FRAMEBUFFER,null),i.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),p)for(let r=0;r<s.length;r++){i.bindFramebuffer(n.FRAMEBUFFER,d.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+r,n.RENDERBUFFER,d.__webglColorRenderbuffer[r]);let o=a.get(s[r]).__webglTexture;i.bindFramebuffer(n.FRAMEBUFFER,d.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+r,n.TEXTURE_2D,o,0)}i.bindFramebuffer(n.DRAW_FRAMEBUFFER,d.__webglMultisampledFramebuffer)}}function er(n){return Math.min(f,n.samples)}function ei(n){let i=a.get(n);return c&&n.samples>0&&!0===r.has("WEBGL_multisampled_render_to_texture")&&!1!==i.__useRenderToTexture}function ea(n){let r=l.render.frame;// Check the last frame we updated the VideoTexture
_.get(n)!==r&&(_.set(n,r),n.update())}function es(n,i){let a=n.colorSpace,s=n.format,o=n.type;return!0===n.isCompressedTexture||!0===n.isVideoTexture||n.format===$d5b33d7c30034067$export$ca1dce8b5e1de74d||a!==$d5b33d7c30034067$export$42429b3acfb233a4&&a!==$d5b33d7c30034067$export$bfcb490c2dd3db51&&(a===$d5b33d7c30034067$export$561f394b24edfcaa||a===$d5b33d7c30034067$export$626af19ae879bdf6?!1===c?!0===r.has("EXT_sRGB")&&s===$d5b33d7c30034067$export$3f8bb04b555a363c?(n.format=$d5b33d7c30034067$export$ca1dce8b5e1de74d,// it's not possible to generate mips in WebGL 1 with this extension
n.minFilter=$d5b33d7c30034067$export$8a72f490b25c56c8,n.generateMipmaps=!1):i=$d5b33d7c30034067$export$698882cf06df44aa.sRGBToLinear(i):(s!==$d5b33d7c30034067$export$3f8bb04b555a363c||o!==$d5b33d7c30034067$export$2e8ce08d3f6f5e10)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",a)),i}//
this.allocateTextureUnit=k,this.resetTextureUnits=N,this.setTexture2D=F,this.setTexture2DArray=B,this.setTexture3D=z,this.setTextureCube=V,this.rebindTextures=Q,this.setupRenderTarget=ee,this.updateRenderTargetMipmap=et,this.updateMultisampleRenderTarget=en,this.setupDepthRenderbuffer=J,this.setupFrameBufferTexture=Y,this.useMultisampledRTT=ei}const $d5b33d7c30034067$var$LinearTransferFunction=0,$d5b33d7c30034067$var$SRGBTransferFunction=1;function $d5b33d7c30034067$export$ddaebcad857649a8(n,r,i){let a=i.isWebGL2;return{convert:function(i,s=$d5b33d7c30034067$export$bfcb490c2dd3db51){let o;let l=s===$d5b33d7c30034067$export$561f394b24edfcaa||s===$d5b33d7c30034067$export$626af19ae879bdf6?$d5b33d7c30034067$var$SRGBTransferFunction:$d5b33d7c30034067$var$LinearTransferFunction;if(i===$d5b33d7c30034067$export$2e8ce08d3f6f5e10)return n.UNSIGNED_BYTE;if(i===$d5b33d7c30034067$export$b3969b01faf587f2)return n.UNSIGNED_SHORT_4_4_4_4;if(i===$d5b33d7c30034067$export$18886f8ae33e90de)return n.UNSIGNED_SHORT_5_5_5_1;if(i===$d5b33d7c30034067$export$545fce0311a9796a)return n.BYTE;if(i===$d5b33d7c30034067$export$88572337f312435f)return n.SHORT;if(i===$d5b33d7c30034067$export$c63dc51868b06a9d)return n.UNSIGNED_SHORT;if(i===$d5b33d7c30034067$export$5c612977753abe2)return n.INT;if(i===$d5b33d7c30034067$export$c3c7fc4518ebba96)return n.UNSIGNED_INT;if(i===$d5b33d7c30034067$export$f6d331659b644596)return n.FLOAT;if(i===$d5b33d7c30034067$export$2697304443f382bc)return a?n.HALF_FLOAT:null!==(o=r.get("OES_texture_half_float"))?o.HALF_FLOAT_OES:null;if(i===$d5b33d7c30034067$export$988473390501ed4b)return n.ALPHA;if(i===$d5b33d7c30034067$export$3f8bb04b555a363c)return n.RGBA;if(i===$d5b33d7c30034067$export$cc09ccbf6d1ed449)return n.LUMINANCE;if(i===$d5b33d7c30034067$export$9053a81c4a69c289)return n.LUMINANCE_ALPHA;if(i===$d5b33d7c30034067$export$c1b6b5136be58045)return n.DEPTH_COMPONENT;if(i===$d5b33d7c30034067$export$1e113ac2d0905829)return n.DEPTH_STENCIL;// WebGL 1 sRGB fallback
if(i===$d5b33d7c30034067$export$ca1dce8b5e1de74d)return null!==(o=r.get("EXT_sRGB"))?o.SRGB_ALPHA_EXT:null;// WebGL2 formats.
if(i===$d5b33d7c30034067$export$4e041a7967d15c4b)return n.RED;if(i===$d5b33d7c30034067$export$aa92e870a709d190)return n.RED_INTEGER;if(i===$d5b33d7c30034067$export$6cdf0b461c7ce8a0)return n.RG;if(i===$d5b33d7c30034067$export$1ba1c45f9f77d4d7)return n.RG_INTEGER;if(i===$d5b33d7c30034067$export$c200e7d26f592f21)return n.RGBA_INTEGER;// S3TC
if(i===$d5b33d7c30034067$export$21d1799c6d552fc0||i===$d5b33d7c30034067$export$afa304c3e981b668||i===$d5b33d7c30034067$export$d2a1a68024a3e56c||i===$d5b33d7c30034067$export$9a79c424327dacf9){if(l===$d5b33d7c30034067$var$SRGBTransferFunction){if(null===(o=r.get("WEBGL_compressed_texture_s3tc_srgb")))return null;if(i===$d5b33d7c30034067$export$21d1799c6d552fc0)return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===$d5b33d7c30034067$export$afa304c3e981b668)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===$d5b33d7c30034067$export$d2a1a68024a3e56c)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===$d5b33d7c30034067$export$9a79c424327dacf9)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(null===(o=r.get("WEBGL_compressed_texture_s3tc")))return null;if(i===$d5b33d7c30034067$export$21d1799c6d552fc0)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===$d5b33d7c30034067$export$afa304c3e981b668)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===$d5b33d7c30034067$export$d2a1a68024a3e56c)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===$d5b33d7c30034067$export$9a79c424327dacf9)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}}// PVRTC
if(i===$d5b33d7c30034067$export$19ada9bbb1af3573||i===$d5b33d7c30034067$export$d0f0355bb3d948e4||i===$d5b33d7c30034067$export$b82296714358084c||i===$d5b33d7c30034067$export$b71692456c47b6c3){if(null===(o=r.get("WEBGL_compressed_texture_pvrtc")))return null;if(i===$d5b33d7c30034067$export$19ada9bbb1af3573)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===$d5b33d7c30034067$export$d0f0355bb3d948e4)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===$d5b33d7c30034067$export$b82296714358084c)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===$d5b33d7c30034067$export$b71692456c47b6c3)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}// ETC1
if(i===$d5b33d7c30034067$export$6ab91af2d757aee7)return null!==(o=r.get("WEBGL_compressed_texture_etc1"))?o.COMPRESSED_RGB_ETC1_WEBGL:null;// ETC2
if(i===$d5b33d7c30034067$export$7800993ef8106a6a||i===$d5b33d7c30034067$export$23ed8300a860e7d8){if(null===(o=r.get("WEBGL_compressed_texture_etc")))return null;if(i===$d5b33d7c30034067$export$7800993ef8106a6a)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ETC2:o.COMPRESSED_RGB8_ETC2;if(i===$d5b33d7c30034067$export$23ed8300a860e7d8)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:o.COMPRESSED_RGBA8_ETC2_EAC}// ASTC
if(i===$d5b33d7c30034067$export$dc5570b4a2b92d48||i===$d5b33d7c30034067$export$68880cd325f8b2fb||i===$d5b33d7c30034067$export$7d2c0be323373d95||i===$d5b33d7c30034067$export$22b52da301fc3a3e||i===$d5b33d7c30034067$export$c009e2cb4a66485e||i===$d5b33d7c30034067$export$118fff5afa255b63||i===$d5b33d7c30034067$export$120713c829ae0667||i===$d5b33d7c30034067$export$c79eeabbf53313e9||i===$d5b33d7c30034067$export$443cf6567cdd6424||i===$d5b33d7c30034067$export$6573984fc9840780||i===$d5b33d7c30034067$export$e7aee563f30091de||i===$d5b33d7c30034067$export$2eb8634622ddeab7||i===$d5b33d7c30034067$export$202b1ce7b5d25742||i===$d5b33d7c30034067$export$18ab77abd087e467){if(null===(o=r.get("WEBGL_compressed_texture_astc")))return null;if(i===$d5b33d7c30034067$export$dc5570b4a2b92d48)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:o.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===$d5b33d7c30034067$export$68880cd325f8b2fb)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:o.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===$d5b33d7c30034067$export$7d2c0be323373d95)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:o.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===$d5b33d7c30034067$export$22b52da301fc3a3e)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:o.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===$d5b33d7c30034067$export$c009e2cb4a66485e)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:o.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===$d5b33d7c30034067$export$118fff5afa255b63)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:o.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===$d5b33d7c30034067$export$120713c829ae0667)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:o.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===$d5b33d7c30034067$export$c79eeabbf53313e9)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:o.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===$d5b33d7c30034067$export$443cf6567cdd6424)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:o.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===$d5b33d7c30034067$export$6573984fc9840780)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:o.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===$d5b33d7c30034067$export$e7aee563f30091de)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:o.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===$d5b33d7c30034067$export$2eb8634622ddeab7)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:o.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===$d5b33d7c30034067$export$202b1ce7b5d25742)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:o.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===$d5b33d7c30034067$export$18ab77abd087e467)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:o.COMPRESSED_RGBA_ASTC_12x12_KHR}// BPTC
if(i===$d5b33d7c30034067$export$ce40b115e188bc81||i===$d5b33d7c30034067$export$d279c5c4bac5121e||i===$d5b33d7c30034067$export$cde52d17225fdbd3){if(null===(o=r.get("EXT_texture_compression_bptc")))return null;if(i===$d5b33d7c30034067$export$ce40b115e188bc81)return l===$d5b33d7c30034067$var$SRGBTransferFunction?o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:o.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(i===$d5b33d7c30034067$export$d279c5c4bac5121e)return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(i===$d5b33d7c30034067$export$cde52d17225fdbd3)return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}// RGTC
if(i===$d5b33d7c30034067$export$b1688df4c4c21670||i===$d5b33d7c30034067$export$fc15e5d8261eed58||i===$d5b33d7c30034067$export$d220f6ade8463a0f||i===$d5b33d7c30034067$export$768646d09dc1b6ef){if(null===(o=r.get("EXT_texture_compression_rgtc")))return null;if(i===$d5b33d7c30034067$export$ce40b115e188bc81)return o.COMPRESSED_RED_RGTC1_EXT;if(i===$d5b33d7c30034067$export$fc15e5d8261eed58)return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(i===$d5b33d7c30034067$export$d220f6ade8463a0f)return o.COMPRESSED_RED_GREEN_RGTC2_EXT;if(i===$d5b33d7c30034067$export$768646d09dc1b6ef)return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return(//
i===$d5b33d7c30034067$export$6c8ea339bfab1301?a?n.UNSIGNED_INT_24_8:null!==(o=r.get("WEBGL_depth_texture"))?o.UNSIGNED_INT_24_8_WEBGL:null:void 0!==n[i]?n[i]:null)}}}class $d5b33d7c30034067$export$56b937d9e5581166 extends $d5b33d7c30034067$export$74e4ae24825f68d7{constructor(n=[]){super(),this.isArrayCamera=!0,this.cameras=n}}class $d5b33d7c30034067$export$eb2fcfdbd7ba97d4 extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(){super(),this.isGroup=!0,this.type="Group"}}const $d5b33d7c30034067$var$_moveEvent={type:"move"};class $d5b33d7c30034067$var$WebXRController{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new $d5b33d7c30034067$export$eb2fcfdbd7ba97d4,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new $d5b33d7c30034067$export$eb2fcfdbd7ba97d4,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new $d5b33d7c30034067$export$64b5c384219d3699,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new $d5b33d7c30034067$export$64b5c384219d3699),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new $d5b33d7c30034067$export$eb2fcfdbd7ba97d4,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new $d5b33d7c30034067$export$64b5c384219d3699,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new $d5b33d7c30034067$export$64b5c384219d3699),this._grip}dispatchEvent(n){return null!==this._targetRay&&this._targetRay.dispatchEvent(n),null!==this._grip&&this._grip.dispatchEvent(n),null!==this._hand&&this._hand.dispatchEvent(n),this}connect(n){if(n&&n.hand){let r=this._hand;if(r)for(let i of n.hand.values())this._getHandJoint(r,i)}return this.dispatchEvent({type:"connected",data:n}),this}disconnect(n){return this.dispatchEvent({type:"disconnected",data:n}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(n,r,i){let a=null,s=null,o=null,l=this._targetRay,u=this._grip,c=this._hand;if(n&&"visible-blurred"!==r.session.visibilityState){if(c&&n.hand){for(let a of(o=!0,n.hand.values())){// Update the joints groups with the XRJoint poses
let n=r.getJointPose(a,i),s=this._getHandJoint(c,a);null!==n&&(s.matrix.fromArray(n.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),s.matrixWorldNeedsUpdate=!0,s.jointRadius=n.radius),s.visible=null!==n}// Custom events
// Check pinchz
let a=c.joints["index-finger-tip"],s=c.joints["thumb-tip"],l=a.position.distanceTo(s.position),u=.02,h=.005;c.inputState.pinching&&l>u+h?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:n.handedness,target:this})):!c.inputState.pinching&&l<=u-h&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:n.handedness,target:this}))}else null!==u&&n.gripSpace&&null!==(s=r.getPose(n.gripSpace,i))&&(u.matrix.fromArray(s.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),u.matrixWorldNeedsUpdate=!0,s.linearVelocity?(u.hasLinearVelocity=!0,u.linearVelocity.copy(s.linearVelocity)):u.hasLinearVelocity=!1,s.angularVelocity?(u.hasAngularVelocity=!0,u.angularVelocity.copy(s.angularVelocity)):u.hasAngularVelocity=!1);null!==l&&(null===(a=r.getPose(n.targetRaySpace,i))&&null!==s&&(a=s),null!==a&&(l.matrix.fromArray(a.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,a.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(a.linearVelocity)):l.hasLinearVelocity=!1,a.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(a.angularVelocity)):l.hasAngularVelocity=!1,this.dispatchEvent($d5b33d7c30034067$var$_moveEvent)))}return null!==l&&(l.visible=null!==a),null!==u&&(u.visible=null!==s),null!==c&&(c.visible=null!==o),this}// private method
_getHandJoint(n,r){if(void 0===n.joints[r.jointName]){let i=new $d5b33d7c30034067$export$eb2fcfdbd7ba97d4;i.matrixAutoUpdate=!1,i.visible=!1,n.joints[r.jointName]=i,n.add(i)}return n.joints[r.jointName]}}class $d5b33d7c30034067$export$fc830aa069cc8c2f extends $d5b33d7c30034067$export$5431306cf43de24a{constructor(n,r,i,a,s,o,l,u,c,h){if((h=void 0!==h?h:$d5b33d7c30034067$export$c1b6b5136be58045)!==$d5b33d7c30034067$export$c1b6b5136be58045&&h!==$d5b33d7c30034067$export$1e113ac2d0905829)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===i&&h===$d5b33d7c30034067$export$c1b6b5136be58045&&(i=$d5b33d7c30034067$export$c3c7fc4518ebba96),void 0===i&&h===$d5b33d7c30034067$export$1e113ac2d0905829&&(i=$d5b33d7c30034067$export$6c8ea339bfab1301),super(null,a,s,o,l,u,h,i,c),this.isDepthTexture=!0,this.image={width:n,height:r},this.magFilter=void 0!==l?l:$d5b33d7c30034067$export$727aa5ec3fe39bf0,this.minFilter=void 0!==u?u:$d5b33d7c30034067$export$727aa5ec3fe39bf0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(n){return super.copy(n),this.compareFunction=n.compareFunction,this}toJSON(n){let r=super.toJSON(n);return null!==this.compareFunction&&(r.compareFunction=this.compareFunction),r}}class $d5b33d7c30034067$var$WebXRManager extends $d5b33d7c30034067$export$ec8b666c5fe2c75a{constructor(n,r){super();let i=this,a=null,s=1,o=null,l="local-floor",u=1,c=null,h=null,d=null,p=null,f=null,m=null,g=r.getContextAttributes(),_=null,y=null,b=[],v=[],x=new $d5b33d7c30034067$export$74e4ae24825f68d7;x.layers.enable(1),x.viewport=new $d5b33d7c30034067$export$fa7daccca11cdbe3;let w=new $d5b33d7c30034067$export$74e4ae24825f68d7;w.layers.enable(2),w.viewport=new $d5b33d7c30034067$export$fa7daccca11cdbe3;let T=[x,w],S=new $d5b33d7c30034067$export$56b937d9e5581166;S.layers.enable(1),S.layers.enable(2);let E=null,A=null;//
function M(n){let r=v.indexOf(n.inputSource);if(-1===r)return;let i=b[r];void 0!==i&&(i.update(n.inputSource,n.frame,c||o),i.dispatchEvent({type:n.type,data:n.inputSource}))}function I(){a.removeEventListener("select",M),a.removeEventListener("selectstart",M),a.removeEventListener("selectend",M),a.removeEventListener("squeeze",M),a.removeEventListener("squeezestart",M),a.removeEventListener("squeezeend",M),a.removeEventListener("end",I),a.removeEventListener("inputsourceschange",P);for(let n=0;n<b.length;n++){let r=v[n];null!==r&&(v[n]=null,b[n].disconnect(r))}E=null,A=null,// restore framebuffer/rendering state
n.setRenderTarget(_),f=null,p=null,d=null,a=null,y=null,//
U.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}function P(n){// Notify disconnected
for(let r=0;r<n.removed.length;r++){let i=n.removed[r],a=v.indexOf(i);a>=0&&(v[a]=null,b[a].disconnect(i))}// Notify connected
for(let r=0;r<n.added.length;r++){let i=n.added[r],a=v.indexOf(i);if(-1===a){// Assign input source a controller that currently has no input source
for(let n=0;n<b.length;n++){if(n>=v.length){v.push(i),a=n;break}if(null===v[n]){v[n]=i,a=n;break}}// If all controllers do currently receive input we ignore new ones
if(-1===a)break}let s=b[a];s&&s.connect(i)}}//
this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(n){let r=b[n];return void 0===r&&(r=new $d5b33d7c30034067$var$WebXRController,b[n]=r),r.getTargetRaySpace()},this.getControllerGrip=function(n){let r=b[n];return void 0===r&&(r=new $d5b33d7c30034067$var$WebXRController,b[n]=r),r.getGripSpace()},this.getHand=function(n){let r=b[n];return void 0===r&&(r=new $d5b33d7c30034067$var$WebXRController,b[n]=r),r.getHandSpace()},this.setFramebufferScaleFactor=function(n){s=n,!0===i.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(n){l=n,!0===i.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||o},this.setReferenceSpace=function(n){c=n},this.getBaseLayer=function(){return null!==p?p:f},this.getBinding=function(){return d},this.getFrame=function(){return m},this.getSession=function(){return a},this.setSession=async function(h){if(null!==(a=h)){if(_=n.getRenderTarget(),a.addEventListener("select",M),a.addEventListener("selectstart",M),a.addEventListener("selectend",M),a.addEventListener("squeeze",M),a.addEventListener("squeezestart",M),a.addEventListener("squeezeend",M),a.addEventListener("end",I),a.addEventListener("inputsourceschange",P),!0!==g.xrCompatible&&await r.makeXRCompatible(),void 0===a.renderState.layers||!1===n.capabilities.isWebGL2){let i={antialias:void 0!==a.renderState.layers||g.antialias,alpha:!0,depth:g.depth,stencil:g.stencil,framebufferScaleFactor:s};f=new XRWebGLLayer(a,r,i),a.updateRenderState({baseLayer:f}),y=new $d5b33d7c30034067$export$3c052beb2e51e23f(f.framebufferWidth,f.framebufferHeight,{format:$d5b33d7c30034067$export$3f8bb04b555a363c,type:$d5b33d7c30034067$export$2e8ce08d3f6f5e10,colorSpace:n.outputColorSpace,stencilBuffer:g.stencil})}else{let i=null,o=null,l=null;g.depth&&(l=g.stencil?r.DEPTH24_STENCIL8:r.DEPTH_COMPONENT24,i=g.stencil?$d5b33d7c30034067$export$1e113ac2d0905829:$d5b33d7c30034067$export$c1b6b5136be58045,o=g.stencil?$d5b33d7c30034067$export$6c8ea339bfab1301:$d5b33d7c30034067$export$c3c7fc4518ebba96);let u={colorFormat:r.RGBA8,depthFormat:l,scaleFactor:s};p=(d=new XRWebGLBinding(a,r)).createProjectionLayer(u),a.updateRenderState({layers:[p]}),y=new $d5b33d7c30034067$export$3c052beb2e51e23f(p.textureWidth,p.textureHeight,{format:$d5b33d7c30034067$export$3f8bb04b555a363c,type:$d5b33d7c30034067$export$2e8ce08d3f6f5e10,depthTexture:new $d5b33d7c30034067$export$fc830aa069cc8c2f(p.textureWidth,p.textureHeight,o,void 0,void 0,void 0,void 0,void 0,void 0,i),stencilBuffer:g.stencil,colorSpace:n.outputColorSpace,samples:g.antialias?4:0});let c=n.properties.get(y);c.__ignoreDepthValues=p.ignoreDepthValues}y.isXRRenderTarget=!0,this.setFoveation(u),c=null,o=await a.requestReferenceSpace(l),U.setContext(a),U.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==a)return a.environmentBlendMode};//
let O=new $d5b33d7c30034067$export$64b5c384219d3699,R=new $d5b33d7c30034067$export$64b5c384219d3699;/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */function C(n,r,i){O.setFromMatrixPosition(r.matrixWorld),R.setFromMatrixPosition(i.matrixWorld);let a=O.distanceTo(R),s=r.projectionMatrix.elements,o=i.projectionMatrix.elements,l=s[14]/(s[10]-1),u=s[14]/(s[10]+1),c=(s[9]+1)/s[5],h=(s[9]-1)/s[5],d=(s[8]-1)/s[0],p=(o[8]+1)/o[0],f=l*d,m=l*p,g=a/(-d+p),_=-(g*d);// TODO: Better way to apply this offset?
r.matrixWorld.decompose(n.position,n.quaternion,n.scale),n.translateX(_),n.translateZ(g),n.matrixWorld.compose(n.position,n.quaternion,n.scale),n.matrixWorldInverse.copy(n.matrixWorld).invert();// Find the union of the frustum values of the cameras and scale
// the values so that the near plane's position does not change in world space,
// although must now be relative to the new union camera.
let y=l+g,b=u+g,v=f-_,x=m+(a-_),w=c*u/b*y,T=h*u/b*y;n.projectionMatrix.makePerspective(v,x,w,T,y,b),n.projectionMatrixInverse.copy(n.projectionMatrix).invert()}function L(n,r){null===r?n.matrixWorld.copy(n.matrix):n.matrixWorld.multiplyMatrices(r.matrixWorld,n.matrix),n.matrixWorldInverse.copy(n.matrixWorld).invert()}function D(n,r,i){null===i?n.matrix.copy(r.matrixWorld):(n.matrix.copy(i.matrixWorld),n.matrix.invert(),n.matrix.multiply(r.matrixWorld)),n.matrix.decompose(n.position,n.quaternion,n.scale),n.updateMatrixWorld(!0),n.projectionMatrix.copy(r.projectionMatrix),n.projectionMatrixInverse.copy(r.projectionMatrixInverse),n.isPerspectiveCamera&&(n.fov=2*$d5b33d7c30034067$var$RAD2DEG*Math.atan(1/n.projectionMatrix.elements[5]),n.zoom=1)}this.updateCamera=function(n){if(null===a)return;S.near=w.near=x.near=n.near,S.far=w.far=x.far=n.far,(E!==S.near||A!==S.far)&&(// Note that the new renderState won't apply until the next frame. See #18320
a.updateRenderState({depthNear:S.near,depthFar:S.far}),E=S.near,A=S.far);let r=n.parent,i=S.cameras;L(S,r);for(let n=0;n<i.length;n++)L(i[n],r);2===i.length?C(S,x,w):S.projectionMatrix.copy(x.projectionMatrix),// update user camera and its children
D(n,S,r)},this.getCamera=function(){return S},this.getFoveation=function(){if(null!==p||null!==f)return u},this.setFoveation=function(n){// 0 = no foveation = full resolution
// 1 = maximum foveation = the edges render at lower resolution
u=n,null!==p&&(p.fixedFoveation=n),null!==f&&void 0!==f.fixedFoveation&&(f.fixedFoveation=n)};// Animation Loop
let N=null;function k(r,a){if(h=a.getViewerPose(c||o),m=a,null!==h){let r=h.views;null!==f&&(n.setRenderTargetFramebuffer(y,f.framebuffer),n.setRenderTarget(y));let i=!1;// check if it's necessary to rebuild cameraXR's camera list
r.length!==S.cameras.length&&(S.cameras.length=0,i=!0);for(let a=0;a<r.length;a++){let s=r[a],o=null;if(null!==f)o=f.getViewport(s);else{let r=d.getViewSubImage(p,s);o=r.viewport,0===a&&(n.setRenderTargetTextures(y,r.colorTexture,p.ignoreDepthValues?void 0:r.depthStencilTexture),n.setRenderTarget(y))}let l=T[a];void 0===l&&((l=new $d5b33d7c30034067$export$74e4ae24825f68d7).layers.enable(a),l.viewport=new $d5b33d7c30034067$export$fa7daccca11cdbe3,T[a]=l),l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.quaternion,l.scale),l.projectionMatrix.fromArray(s.projectionMatrix),l.projectionMatrixInverse.copy(l.projectionMatrix).invert(),l.viewport.set(o.x,o.y,o.width,o.height),0===a&&(S.matrix.copy(l.matrix),S.matrix.decompose(S.position,S.quaternion,S.scale)),!0===i&&S.cameras.push(l)}}//
for(let n=0;n<b.length;n++){let r=v[n],i=b[n];null!==r&&void 0!==i&&i.update(r,a,c||o)}N&&N(r,a),a.detectedPlanes&&i.dispatchEvent({type:"planesdetected",data:a}),m=null}let U=new $d5b33d7c30034067$var$WebGLAnimation;U.setAnimationLoop(k),this.setAnimationLoop=function(n){N=n},this.dispose=function(){}}}function $d5b33d7c30034067$var$WebGLMaterials(n,r){function i(n,r){!0===n.matrixAutoUpdate&&n.updateMatrix(),r.value.copy(n.matrix)}function a(a,s){a.opacity.value=s.opacity,s.color&&a.diffuse.value.copy(s.color),s.emissive&&a.emissive.value.copy(s.emissive).multiplyScalar(s.emissiveIntensity),s.map&&(a.map.value=s.map,i(s.map,a.mapTransform)),s.alphaMap&&(a.alphaMap.value=s.alphaMap,i(s.alphaMap,a.alphaMapTransform)),s.bumpMap&&(a.bumpMap.value=s.bumpMap,i(s.bumpMap,a.bumpMapTransform),a.bumpScale.value=s.bumpScale,s.side===$d5b33d7c30034067$export$d9f0486e75b5ace&&(a.bumpScale.value*=-1)),s.normalMap&&(a.normalMap.value=s.normalMap,i(s.normalMap,a.normalMapTransform),a.normalScale.value.copy(s.normalScale),s.side===$d5b33d7c30034067$export$d9f0486e75b5ace&&a.normalScale.value.negate()),s.displacementMap&&(a.displacementMap.value=s.displacementMap,i(s.displacementMap,a.displacementMapTransform),a.displacementScale.value=s.displacementScale,a.displacementBias.value=s.displacementBias),s.emissiveMap&&(a.emissiveMap.value=s.emissiveMap,i(s.emissiveMap,a.emissiveMapTransform)),s.specularMap&&(a.specularMap.value=s.specularMap,i(s.specularMap,a.specularMapTransform)),s.alphaTest>0&&(a.alphaTest.value=s.alphaTest);let o=r.get(s).envMap;if(o&&(a.envMap.value=o,a.flipEnvMap.value=o.isCubeTexture&&!1===o.isRenderTargetTexture?-1:1,a.reflectivity.value=s.reflectivity,a.ior.value=s.ior,a.refractionRatio.value=s.refractionRatio),s.lightMap){a.lightMap.value=s.lightMap;// artist-friendly light intensity scaling factor
let r=!0===n._useLegacyLights?Math.PI:1;a.lightMapIntensity.value=s.lightMapIntensity*r,i(s.lightMap,a.lightMapTransform)}s.aoMap&&(a.aoMap.value=s.aoMap,a.aoMapIntensity.value=s.aoMapIntensity,i(s.aoMap,a.aoMapTransform))}function s(n,r){n.diffuse.value.copy(r.color),n.opacity.value=r.opacity,r.map&&(n.map.value=r.map,i(r.map,n.mapTransform))}function o(n,r){n.dashSize.value=r.dashSize,n.totalSize.value=r.dashSize+r.gapSize,n.scale.value=r.scale}function l(n,r,a,s){n.diffuse.value.copy(r.color),n.opacity.value=r.opacity,n.size.value=r.size*a,n.scale.value=.5*s,r.map&&(n.map.value=r.map,i(r.map,n.uvTransform)),r.alphaMap&&(n.alphaMap.value=r.alphaMap,i(r.alphaMap,n.alphaMapTransform)),r.alphaTest>0&&(n.alphaTest.value=r.alphaTest)}function u(n,r){n.diffuse.value.copy(r.color),n.opacity.value=r.opacity,n.rotation.value=r.rotation,r.map&&(n.map.value=r.map,i(r.map,n.mapTransform)),r.alphaMap&&(n.alphaMap.value=r.alphaMap,i(r.alphaMap,n.alphaMapTransform)),r.alphaTest>0&&(n.alphaTest.value=r.alphaTest)}function c(n,r){n.specular.value.copy(r.specular),n.shininess.value=Math.max(r.shininess,1e-4)}function h(n,r){r.gradientMap&&(n.gradientMap.value=r.gradientMap)}function d(n,a){n.metalness.value=a.metalness,a.metalnessMap&&(n.metalnessMap.value=a.metalnessMap,i(a.metalnessMap,n.metalnessMapTransform)),n.roughness.value=a.roughness,a.roughnessMap&&(n.roughnessMap.value=a.roughnessMap,i(a.roughnessMap,n.roughnessMapTransform));let s=r.get(a).envMap;s&&(n.envMapIntensity.value=a.envMapIntensity)}function p(n,r,a){n.ior.value=r.ior,r.sheen>0&&(n.sheenColor.value.copy(r.sheenColor).multiplyScalar(r.sheen),n.sheenRoughness.value=r.sheenRoughness,r.sheenColorMap&&(n.sheenColorMap.value=r.sheenColorMap,i(r.sheenColorMap,n.sheenColorMapTransform)),r.sheenRoughnessMap&&(n.sheenRoughnessMap.value=r.sheenRoughnessMap,i(r.sheenRoughnessMap,n.sheenRoughnessMapTransform))),r.clearcoat>0&&(n.clearcoat.value=r.clearcoat,n.clearcoatRoughness.value=r.clearcoatRoughness,r.clearcoatMap&&(n.clearcoatMap.value=r.clearcoatMap,i(r.clearcoatMap,n.clearcoatMapTransform)),r.clearcoatRoughnessMap&&(n.clearcoatRoughnessMap.value=r.clearcoatRoughnessMap,i(r.clearcoatRoughnessMap,n.clearcoatRoughnessMapTransform)),r.clearcoatNormalMap&&(n.clearcoatNormalMap.value=r.clearcoatNormalMap,i(r.clearcoatNormalMap,n.clearcoatNormalMapTransform),n.clearcoatNormalScale.value.copy(r.clearcoatNormalScale),r.side===$d5b33d7c30034067$export$d9f0486e75b5ace&&n.clearcoatNormalScale.value.negate())),r.iridescence>0&&(n.iridescence.value=r.iridescence,n.iridescenceIOR.value=r.iridescenceIOR,n.iridescenceThicknessMinimum.value=r.iridescenceThicknessRange[0],n.iridescenceThicknessMaximum.value=r.iridescenceThicknessRange[1],r.iridescenceMap&&(n.iridescenceMap.value=r.iridescenceMap,i(r.iridescenceMap,n.iridescenceMapTransform)),r.iridescenceThicknessMap&&(n.iridescenceThicknessMap.value=r.iridescenceThicknessMap,i(r.iridescenceThicknessMap,n.iridescenceThicknessMapTransform))),r.transmission>0&&(n.transmission.value=r.transmission,n.transmissionSamplerMap.value=a.texture,n.transmissionSamplerSize.value.set(a.width,a.height),r.transmissionMap&&(n.transmissionMap.value=r.transmissionMap,i(r.transmissionMap,n.transmissionMapTransform)),n.thickness.value=r.thickness,r.thicknessMap&&(n.thicknessMap.value=r.thicknessMap,i(r.thicknessMap,n.thicknessMapTransform)),n.attenuationDistance.value=r.attenuationDistance,n.attenuationColor.value.copy(r.attenuationColor)),r.anisotropy>0&&(n.anisotropyVector.value.set(r.anisotropy*Math.cos(r.anisotropyRotation),r.anisotropy*Math.sin(r.anisotropyRotation)),r.anisotropyMap&&(n.anisotropyMap.value=r.anisotropyMap,i(r.anisotropyMap,n.anisotropyMapTransform))),n.specularIntensity.value=r.specularIntensity,n.specularColor.value.copy(r.specularColor),r.specularColorMap&&(n.specularColorMap.value=r.specularColorMap,i(r.specularColorMap,n.specularColorMapTransform)),r.specularIntensityMap&&(n.specularIntensityMap.value=r.specularIntensityMap,i(r.specularIntensityMap,n.specularIntensityMapTransform))}function f(n,r){r.matcap&&(n.matcap.value=r.matcap)}function m(n,i){let a=r.get(i).light;n.referencePosition.value.setFromMatrixPosition(a.matrixWorld),n.nearDistance.value=a.shadow.camera.near,n.farDistance.value=a.shadow.camera.far}return{refreshFogUniforms:function(r,i){i.color.getRGB(r.fogColor.value,$d5b33d7c30034067$var$getUnlitUniformColorSpace(n)),i.isFog?(r.fogNear.value=i.near,r.fogFar.value=i.far):i.isFogExp2&&(r.fogDensity.value=i.density)},refreshMaterialUniforms:function(n,r,i,g,_){r.isMeshBasicMaterial?a(n,r):r.isMeshLambertMaterial?a(n,r):r.isMeshToonMaterial?(a(n,r),h(n,r)):r.isMeshPhongMaterial?(a(n,r),c(n,r)):r.isMeshStandardMaterial?(a(n,r),d(n,r),r.isMeshPhysicalMaterial&&p(n,r,_)):r.isMeshMatcapMaterial?(a(n,r),f(n,r)):r.isMeshDepthMaterial?a(n,r):r.isMeshDistanceMaterial?(a(n,r),m(n,r)):r.isMeshNormalMaterial?a(n,r):r.isLineBasicMaterial?(s(n,r),r.isLineDashedMaterial&&o(n,r)):r.isPointsMaterial?l(n,r,i,g):r.isSpriteMaterial?u(n,r):r.isShadowMaterial?(n.color.value.copy(r.color),n.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1);// #15581
}}}function $d5b33d7c30034067$var$WebGLUniformsGroups(n,r,i,a){let s={},o={},l=[],u=i.isWebGL2?n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS):0;function c(r){// the setup of an UBO is independent of a particular shader program but global
let i=h();r.__bindingPointIndex=i;let a=n.createBuffer(),s=r.__size,o=r.usage;return n.bindBuffer(n.UNIFORM_BUFFER,a),n.bufferData(n.UNIFORM_BUFFER,s,o),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,i,a),a}function h(){for(let n=0;n<u;n++)if(-1===l.indexOf(n))return l.push(n),n;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(r){let i=s[r.id],a=r.uniforms,o=r.__cache;n.bindBuffer(n.UNIFORM_BUFFER,i);for(let r=0,i=a.length;r<i;r++){let i=a[r];// partly update the buffer if necessary
if(!0===p(i,r,o)){let r=i.__offset,a=Array.isArray(i.value)?i.value:[i.value],s=0;for(let o=0;o<a.length;o++){let l=a[o],u=m(l);"number"==typeof l?(i.__data[0]=l,n.bufferSubData(n.UNIFORM_BUFFER,r+s,i.__data)):l.isMatrix3?(// manually converting 3x3 to 3x4
i.__data[0]=l.elements[0],i.__data[1]=l.elements[1],i.__data[2]=l.elements[2],i.__data[3]=l.elements[0],i.__data[4]=l.elements[3],i.__data[5]=l.elements[4],i.__data[6]=l.elements[5],i.__data[7]=l.elements[0],i.__data[8]=l.elements[6],i.__data[9]=l.elements[7],i.__data[10]=l.elements[8],i.__data[11]=l.elements[0]):(l.toArray(i.__data,s),s+=u.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,r,i.__data)}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function p(n,r,i){let a=n.value;if(void 0===i[r]){// cache entry does not exist so far
if("number"==typeof a)i[r]=a;else{let n=Array.isArray(a)?a:[a],s=[];for(let r=0;r<n.length;r++)s.push(n[r].clone());i[r]=s}return!0}// compare current value with cached entry
if("number"==typeof a){if(i[r]!==a)return i[r]=a,!0}else{let n=Array.isArray(i[r])?i[r]:[i[r]],s=Array.isArray(a)?a:[a];for(let r=0;r<n.length;r++){let i=n[r];if(!1===i.equals(s[r]))return i.copy(s[r]),!0}}return!1}function f(n){// determine total buffer size according to the STD140 layout
// Hint: STD140 is the only supported layout in WebGL 2
let r=n.uniforms,i=0,a=16,s=0;for(let n=0,o=r.length;n<o;n++){let o=r[n],l={boundary:0,storage:0// bytes
},u=Array.isArray(o.value)?o.value:[o.value];for(let n=0,r=u.length;n<r;n++){let r=u[n],i=m(r);l.boundary+=i.boundary,l.storage+=i.storage}//
if(// the following two properties will be used for partial buffer updates
o.__data=new Float32Array(l.storage/Float32Array.BYTES_PER_ELEMENT),o.__offset=i,n>0){s=i%a;let n=a-s;// check for chunk overflow
0!==s&&n-l.boundary<0&&(// add padding and adjust offset
i+=a-s,o.__offset=i)}i+=l.storage}return(// ensure correct final padding
(s=i%a)>0&&(i+=a-s),//
n.__size=i,n.__cache={},this)}function m(n){let r={boundary:0,storage:0// bytes
};return"number"==typeof n?(// float/int
r.boundary=4,r.storage=4):n.isVector2?(// vec2
r.boundary=8,r.storage=8):n.isVector3||n.isColor?(// vec3
r.boundary=16,r.storage=12):n.isVector4?(// vec4
r.boundary=16,r.storage=16):n.isMatrix3?(// mat3 (in STD140 a 3x3 matrix is represented as 3x4)
r.boundary=48,r.storage=48):n.isMatrix4?(// mat4
r.boundary=64,r.storage=64):n.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",n),r}function g(r){let i=r.target;i.removeEventListener("dispose",g);let a=l.indexOf(i.__bindingPointIndex);l.splice(a,1),n.deleteBuffer(s[i.id]),delete s[i.id],delete o[i.id]}return{bind:function(n,r){let i=r.program;a.uniformBlockBinding(n,i)},update:function(n,i){let l=s[n.id];void 0===l&&(f(n),l=c(n),s[n.id]=l,n.addEventListener("dispose",g));// ensure to update the binding points/block indices mapping for this program
let u=i.program;a.updateUBOMapping(n,u);// update UBO once per frame
let h=r.render.frame;o[n.id]!==h&&(d(n),o[n.id]=h)},dispose:function(){for(let r in s)n.deleteBuffer(s[r]);l=[],s={},o={}}}}class $d5b33d7c30034067$export$f6cc00ef28d7cf97{constructor(n={}){let r,i,a,s,o,l,u,c,h,d,p,f,m,g,_,y,b,v,x,w,T,S,E,A,M;let{canvas:I=$d5b33d7c30034067$export$1033a2df66368859(),context:P=null,depth:O=!0,stencil:R=!0,alpha:C=!1,antialias:L=!1,premultipliedAlpha:D=!0,preserveDrawingBuffer:N=!1,powerPreference:k="default",failIfMajorPerformanceCaveat:U=!1}=n;this.isWebGLRenderer=!0,r=null!==P?P.getContextAttributes().alpha:C;let F=new Uint32Array(4),B=new Int32Array(4),z=null,V=null,G=[],j=[];// public properties
this.domElement=I,// Debug configuration container
this.debug={/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */checkShaderErrors:!0,/**
			 * Callback for custom error reporting.
			 * @type {?Function}
			 */onShaderError:null},// clearing
this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,// scene graph
this.sortObjects=!0,// user-defined clipping
this.clippingPlanes=[],this.localClippingEnabled=!1,// physically based shading
this.outputColorSpace=$d5b33d7c30034067$export$561f394b24edfcaa,// physical lights
this._useLegacyLights=!1,// tone mapping
this.toneMapping=$d5b33d7c30034067$export$9fcb6b4294603b2,this.toneMappingExposure=1;// internal properties
let H=this,$=!1,W=0,X=0,q=null,Y=-1,K=null,Z=new $d5b33d7c30034067$export$fa7daccca11cdbe3,J=new $d5b33d7c30034067$export$fa7daccca11cdbe3,Q=null,ee=new $d5b33d7c30034067$export$892596cec99bc70e(0),et=0,en=I.width,er=I.height,ei=1,ea=null,es=null,eo=new $d5b33d7c30034067$export$fa7daccca11cdbe3(0,0,en,er),el=new $d5b33d7c30034067$export$fa7daccca11cdbe3(0,0,en,er),eu=!1,ec=new $d5b33d7c30034067$export$35efe6f4c85463d2,eh=!1,ed=!1,ep=null,ef=new $d5b33d7c30034067$export$2ae72fc923e5eb5,em=new $d5b33d7c30034067$export$c977b3e384af9ae1,eg=new $d5b33d7c30034067$export$64b5c384219d3699,e_={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function ey(){return null===q?ei:1}// initialize
let eb=P;function ev(n,r){for(let i=0;i<n.length;i++){let a=n[i],s=I.getContext(a,r);if(null!==s)return s}return null}try{let n={alpha:!0,depth:O,stencil:R,antialias:L,premultipliedAlpha:D,preserveDrawingBuffer:N,powerPreference:k,failIfMajorPerformanceCaveat:U};if("setAttribute"in I&&I.setAttribute("data-engine",`three.js r${$d5b33d7c30034067$export$3545e07a80636437}`),// event listeners must be registered before WebGL context is created, see #12753
I.addEventListener("webglcontextlost",eT,!1),I.addEventListener("webglcontextrestored",eS,!1),I.addEventListener("webglcontextcreationerror",eE,!1),null===eb){let r=["webgl2","webgl","experimental-webgl"];if(!0===H.isWebGL1Renderer&&r.shift(),eb=ev(r,n),null===eb){if(ev(r))throw Error("Error creating WebGL context with your selected attributes.");throw Error("Error creating WebGL context.")}}"undefined"!=typeof WebGLRenderingContext&&eb instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),void 0===eb.getShaderPrecisionFormat&&(eb.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(n){throw console.error("THREE.WebGLRenderer: "+n.message),n}function ex(){i=new $d5b33d7c30034067$var$WebGLExtensions(eb),a=new $d5b33d7c30034067$var$WebGLCapabilities(eb,i,n),i.init(a),E=new $d5b33d7c30034067$export$ddaebcad857649a8(eb,i,a),s=new $d5b33d7c30034067$var$WebGLState(eb,i,a),o=new $d5b33d7c30034067$var$WebGLInfo(eb),l=new $d5b33d7c30034067$var$WebGLProperties,u=new $d5b33d7c30034067$var$WebGLTextures(eb,i,s,l,a,E,o),c=new $d5b33d7c30034067$var$WebGLCubeMaps(H),h=new $d5b33d7c30034067$var$WebGLCubeUVMaps(H),d=new $d5b33d7c30034067$var$WebGLAttributes(eb,a),A=new $d5b33d7c30034067$var$WebGLBindingStates(eb,i,d,a),p=new $d5b33d7c30034067$var$WebGLGeometries(eb,d,o,A),f=new $d5b33d7c30034067$var$WebGLObjects(eb,p,d,o),w=new $d5b33d7c30034067$var$WebGLMorphtargets(eb,a,u),b=new $d5b33d7c30034067$var$WebGLClipping(l),m=new $d5b33d7c30034067$var$WebGLPrograms(H,c,h,i,a,A,b),g=new $d5b33d7c30034067$var$WebGLMaterials(H,l),_=new $d5b33d7c30034067$var$WebGLRenderLists,y=new $d5b33d7c30034067$var$WebGLRenderStates(i,a),x=new $d5b33d7c30034067$var$WebGLBackground(H,c,h,s,f,r,D),v=new $d5b33d7c30034067$var$WebGLShadowMap(H,f,a),M=new $d5b33d7c30034067$var$WebGLUniformsGroups(eb,o,a,s),T=new $d5b33d7c30034067$var$WebGLBufferRenderer(eb,i,o,a),S=new $d5b33d7c30034067$var$WebGLIndexedBufferRenderer(eb,i,o,a),o.programs=m.programs,H.capabilities=a,H.extensions=i,H.properties=l,H.renderLists=_,H.shadowMap=v,H.state=s,H.info=o}ex();// xr
let ew=new $d5b33d7c30034067$var$WebXRManager(H,eb);// Events
function eT(n){n.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),$=!0}function eS(){console.log("THREE.WebGLRenderer: Context Restored."),$=!1;let n=o.autoReset,r=v.enabled,i=v.autoUpdate,a=v.needsUpdate,s=v.type;ex(),o.autoReset=n,v.enabled=r,v.autoUpdate=i,v.needsUpdate=a,v.type=s}function eE(n){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",n.statusMessage)}function eA(n){let r=n.target;r.removeEventListener("dispose",eA),eM(r)}// Buffer deallocation
function eM(n){eI(n),l.remove(n)}function eI(n){let r=l.get(n).programs;void 0!==r&&(r.forEach(function(n){m.releaseProgram(n)}),n.isShaderMaterial&&m.releaseShaderCache(n))}this.xr=ew,// API
this.getContext=function(){return eb},this.getContextAttributes=function(){return eb.getContextAttributes()},this.forceContextLoss=function(){let n=i.get("WEBGL_lose_context");n&&n.loseContext()},this.forceContextRestore=function(){let n=i.get("WEBGL_lose_context");n&&n.restoreContext()},this.getPixelRatio=function(){return ei},this.setPixelRatio=function(n){void 0!==n&&(ei=n,this.setSize(en,er,!1))},this.getSize=function(n){return n.set(en,er)},this.setSize=function(n,r,i=!0){if(ew.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}en=n,er=r,I.width=Math.floor(n*ei),I.height=Math.floor(r*ei),!0===i&&(I.style.width=n+"px",I.style.height=r+"px"),this.setViewport(0,0,n,r)},this.getDrawingBufferSize=function(n){return n.set(en*ei,er*ei).floor()},this.setDrawingBufferSize=function(n,r,i){en=n,er=r,ei=i,I.width=Math.floor(n*i),I.height=Math.floor(r*i),this.setViewport(0,0,n,r)},this.getCurrentViewport=function(n){return n.copy(Z)},this.getViewport=function(n){return n.copy(eo)},this.setViewport=function(n,r,i,a){n.isVector4?eo.set(n.x,n.y,n.z,n.w):eo.set(n,r,i,a),s.viewport(Z.copy(eo).multiplyScalar(ei).floor())},this.getScissor=function(n){return n.copy(el)},this.setScissor=function(n,r,i,a){n.isVector4?el.set(n.x,n.y,n.z,n.w):el.set(n,r,i,a),s.scissor(J.copy(el).multiplyScalar(ei).floor())},this.getScissorTest=function(){return eu},this.setScissorTest=function(n){s.setScissorTest(eu=n)},this.setOpaqueSort=function(n){ea=n},this.setTransparentSort=function(n){es=n},// Clearing
this.getClearColor=function(n){return n.copy(x.getClearColor())},this.setClearColor=function(){x.setClearColor.apply(x,arguments)},this.getClearAlpha=function(){return x.getClearAlpha()},this.setClearAlpha=function(){x.setClearAlpha.apply(x,arguments)},this.clear=function(n=!0,r=!0,i=!0){let a=0;if(n){// check if we're trying to clear an integer target
let n=!1;if(null!==q){let r=q.texture.format;n=r===$d5b33d7c30034067$export$c200e7d26f592f21||r===$d5b33d7c30034067$export$1ba1c45f9f77d4d7||r===$d5b33d7c30034067$export$aa92e870a709d190}// use the appropriate clear functions to clear the target if it's a signed
// or unsigned integer target
if(n){let n=q.texture.type,r=n===$d5b33d7c30034067$export$2e8ce08d3f6f5e10||n===$d5b33d7c30034067$export$c3c7fc4518ebba96||n===$d5b33d7c30034067$export$c63dc51868b06a9d||n===$d5b33d7c30034067$export$6c8ea339bfab1301||n===$d5b33d7c30034067$export$b3969b01faf587f2||n===$d5b33d7c30034067$export$18886f8ae33e90de,i=x.getClearColor(),a=x.getClearAlpha(),s=i.r,o=i.g,l=i.b;r?(F[0]=s,F[1]=o,F[2]=l,F[3]=a,eb.clearBufferuiv(eb.COLOR,0,F)):(B[0]=s,B[1]=o,B[2]=l,B[3]=a,eb.clearBufferiv(eb.COLOR,0,B))}else a|=eb.COLOR_BUFFER_BIT}r&&(a|=eb.DEPTH_BUFFER_BIT),i&&(a|=eb.STENCIL_BUFFER_BIT),eb.clear(a)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},//
this.dispose=function(){I.removeEventListener("webglcontextlost",eT,!1),I.removeEventListener("webglcontextrestored",eS,!1),I.removeEventListener("webglcontextcreationerror",eE,!1),_.dispose(),y.dispose(),l.dispose(),c.dispose(),h.dispose(),f.dispose(),A.dispose(),M.dispose(),m.dispose(),ew.dispose(),ew.removeEventListener("sessionstart",eR),ew.removeEventListener("sessionend",eC),ep&&(ep.dispose(),ep=null),eL.stop()},// Buffer rendering
this.renderBufferDirect=function(n,r,i,a,o,l){let u;null===r&&(r=e_);let c=o.isMesh&&0>o.matrixWorld.determinant(),h=eV(n,r,i,a,o);s.setMaterial(a,c);//
let f=i.index,m=1;if(!0===a.wireframe){if(void 0===(f=p.getWireframeAttribute(i)))return;m=2}//
let g=i.drawRange,_=i.attributes.position,y=g.start*m,b=(g.start+g.count)*m;null!==l&&(y=Math.max(y,l.start*m),b=Math.min(b,(l.start+l.count)*m)),null!==f?(y=Math.max(y,0),b=Math.min(b,f.count)):null!=_&&(y=Math.max(y,0),b=Math.min(b,_.count));let v=b-y;if(v<0||v===1/0)return;//
A.setup(o,a,h,i,f);let x=T;//
if(null!==f&&(u=d.get(f),(x=S).setIndex(u)),o.isMesh)!0===a.wireframe?(s.setLineWidth(a.wireframeLinewidth*ey()),x.setMode(eb.LINES)):x.setMode(eb.TRIANGLES);else if(o.isLine){let n=a.linewidth;void 0===n&&(n=1),s.setLineWidth(n*ey()),o.isLineSegments?x.setMode(eb.LINES):o.isLineLoop?x.setMode(eb.LINE_LOOP):x.setMode(eb.LINE_STRIP)}else o.isPoints?x.setMode(eb.POINTS):o.isSprite&&x.setMode(eb.TRIANGLES);if(o.isInstancedMesh)x.renderInstances(y,v,o.count);else if(i.isInstancedBufferGeometry){let n=void 0!==i._maxInstanceCount?i._maxInstanceCount:1/0,r=Math.min(i.instanceCount,n);x.renderInstances(y,v,r)}else x.render(y,v)},// Compile
this.compile=function(n,r){function i(n,r,i){!0===n.transparent&&n.side===$d5b33d7c30034067$export$3b296b6f144d5b03&&!1===n.forceSinglePass?(n.side=$d5b33d7c30034067$export$d9f0486e75b5ace,n.needsUpdate=!0,eB(n,r,i),n.side=$d5b33d7c30034067$export$2ede184fc2998901,n.needsUpdate=!0,eB(n,r,i),n.side=$d5b33d7c30034067$export$3b296b6f144d5b03):eB(n,r,i)}(V=y.get(n)).init(),j.push(V),n.traverseVisible(function(n){n.isLight&&n.layers.test(r.layers)&&(V.pushLight(n),n.castShadow&&V.pushShadow(n))}),V.setupLights(H._useLegacyLights),n.traverse(function(r){let a=r.material;if(a){if(Array.isArray(a))for(let s=0;s<a.length;s++){let o=a[s];i(o,n,r)}else i(a,n,r)}}),j.pop(),V=null};// Animation Loop
let eP=null;function eO(n){eP&&eP(n)}function eR(){eL.stop()}function eC(){eL.start()}let eL=new $d5b33d7c30034067$var$WebGLAnimation;function eD(n,r,i,a){if(!1===n.visible)return;let s=n.layers.test(r.layers);if(s){if(n.isGroup)i=n.renderOrder;else if(n.isLOD)!0===n.autoUpdate&&n.update(r);else if(n.isLight)V.pushLight(n),n.castShadow&&V.pushShadow(n);else if(n.isSprite){if(!n.frustumCulled||ec.intersectsSprite(n)){a&&eg.setFromMatrixPosition(n.matrixWorld).applyMatrix4(ef);let r=f.update(n),s=n.material;s.visible&&z.push(n,r,s,i,eg.z,null)}}else if((n.isMesh||n.isLine||n.isPoints)&&(!n.frustumCulled||ec.intersectsObject(n))){let r=f.update(n),s=n.material;if(a&&(void 0!==n.boundingSphere?(null===n.boundingSphere&&n.computeBoundingSphere(),eg.copy(n.boundingSphere.center)):(null===r.boundingSphere&&r.computeBoundingSphere(),eg.copy(r.boundingSphere.center)),eg.applyMatrix4(n.matrixWorld).applyMatrix4(ef)),Array.isArray(s)){let a=r.groups;for(let o=0,l=a.length;o<l;o++){let l=a[o],u=s[l.materialIndex];u&&u.visible&&z.push(n,r,u,i,eg.z,l)}}else s.visible&&z.push(n,r,s,i,eg.z,null)}}let o=n.children;for(let n=0,s=o.length;n<s;n++)eD(o[n],r,i,a)}function eN(n,r,i,a){let o=n.opaque,l=n.transmissive,u=n.transparent;V.setupLightsView(i),!0===eh&&b.setGlobalState(H.clippingPlanes,i),l.length>0&&ek(o,l,r,i),a&&s.viewport(Z.copy(a)),o.length>0&&eU(o,r,i),l.length>0&&eU(l,r,i),u.length>0&&eU(u,r,i),// Ensure depth buffer writing is enabled so it can be cleared on next render
s.buffers.depth.setTest(!0),s.buffers.depth.setMask(!0),s.buffers.color.setMask(!0),s.setPolygonOffset(!1)}function ek(n,r,s,o){let l=a.isWebGL2;null===ep&&(ep=new $d5b33d7c30034067$export$3c052beb2e51e23f(1,1,{generateMipmaps:!0,type:i.has("EXT_color_buffer_half_float")?$d5b33d7c30034067$export$2697304443f382bc:$d5b33d7c30034067$export$2e8ce08d3f6f5e10,minFilter:$d5b33d7c30034067$export$5d8599b6a933fb1b,samples:l?4:0})),H.getDrawingBufferSize(em),l?ep.setSize(em.x,em.y):ep.setSize($d5b33d7c30034067$var$floorPowerOfTwo(em.x),$d5b33d7c30034067$var$floorPowerOfTwo(em.y));//
let c=H.getRenderTarget();H.setRenderTarget(ep),H.getClearColor(ee),(et=H.getClearAlpha())<1&&H.setClearColor(16777215,.5),H.clear();// Turn off the features which can affect the frag color for opaque objects pass.
// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
let h=H.toneMapping;H.toneMapping=$d5b33d7c30034067$export$9fcb6b4294603b2,eU(n,s,o),u.updateMultisampleRenderTarget(ep),u.updateRenderTargetMipmap(ep);let d=!1;for(let n=0,i=r.length;n<i;n++){let i=r[n],a=i.object,l=i.geometry,u=i.material,c=i.group;if(u.side===$d5b33d7c30034067$export$3b296b6f144d5b03&&a.layers.test(o.layers)){let n=u.side;u.side=$d5b33d7c30034067$export$d9f0486e75b5ace,u.needsUpdate=!0,eF(a,s,o,l,u,c),u.side=n,u.needsUpdate=!0,d=!0}}!0===d&&(u.updateMultisampleRenderTarget(ep),u.updateRenderTargetMipmap(ep)),H.setRenderTarget(c),H.setClearColor(ee,et),H.toneMapping=h}function eU(n,r,i){let a=!0===r.isScene?r.overrideMaterial:null;for(let s=0,o=n.length;s<o;s++){let o=n[s],l=o.object,u=o.geometry,c=null===a?o.material:a,h=o.group;l.layers.test(i.layers)&&eF(l,r,i,u,c,h)}}function eF(n,r,i,a,s,o){n.onBeforeRender(H,r,i,a,s,o),n.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,n.matrixWorld),n.normalMatrix.getNormalMatrix(n.modelViewMatrix),s.onBeforeRender(H,r,i,a,n,o),!0===s.transparent&&s.side===$d5b33d7c30034067$export$3b296b6f144d5b03&&!1===s.forceSinglePass?(s.side=$d5b33d7c30034067$export$d9f0486e75b5ace,s.needsUpdate=!0,H.renderBufferDirect(i,r,a,s,n,o),s.side=$d5b33d7c30034067$export$2ede184fc2998901,s.needsUpdate=!0,H.renderBufferDirect(i,r,a,s,n,o),s.side=$d5b33d7c30034067$export$3b296b6f144d5b03):H.renderBufferDirect(i,r,a,s,n,o),n.onAfterRender(H,r,i,a,s,o)}function eB(n,r,i){!0!==r.isScene&&(r=e_);let a=l.get(n),s=V.state.lights,o=V.state.shadowsArray,u=s.state.version,d=m.getParameters(n,s.state,o,r,i),p=m.getProgramCacheKey(d),f=a.programs;// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
a.environment=n.isMeshStandardMaterial?r.environment:null,a.fog=r.fog,a.envMap=(n.isMeshStandardMaterial?h:c).get(n.envMap||a.environment),void 0===f&&(// new material
n.addEventListener("dispose",eA),f=new Map,a.programs=f);let g=f.get(p);if(void 0!==g){if(a.currentProgram===g&&a.lightsStateVersion===u)return ez(n,d),g}else d.uniforms=m.getUniforms(n),n.onBuild(i,d,H),n.onBeforeCompile(d,H),g=m.acquireProgram(d,p),f.set(p,g),a.uniforms=d.uniforms;let _=a.uniforms;(n.isShaderMaterial||n.isRawShaderMaterial)&&!0!==n.clipping||(_.clippingPlanes=b.uniform),ez(n,d),// store the light setup it was created for
a.needsLights=ej(n),a.lightsStateVersion=u,a.needsLights&&(// wire up the material to this renderer's lighting state
_.ambientLightColor.value=s.state.ambient,_.lightProbe.value=s.state.probe,_.directionalLights.value=s.state.directional,_.directionalLightShadows.value=s.state.directionalShadow,_.spotLights.value=s.state.spot,_.spotLightShadows.value=s.state.spotShadow,_.rectAreaLights.value=s.state.rectArea,_.ltc_1.value=s.state.rectAreaLTC1,_.ltc_2.value=s.state.rectAreaLTC2,_.pointLights.value=s.state.point,_.pointLightShadows.value=s.state.pointShadow,_.hemisphereLights.value=s.state.hemi,_.directionalShadowMap.value=s.state.directionalShadowMap,_.directionalShadowMatrix.value=s.state.directionalShadowMatrix,_.spotShadowMap.value=s.state.spotShadowMap,_.spotLightMatrix.value=s.state.spotLightMatrix,_.spotLightMap.value=s.state.spotLightMap,_.pointShadowMap.value=s.state.pointShadowMap,_.pointShadowMatrix.value=s.state.pointShadowMatrix);let y=g.getUniforms(),v=$d5b33d7c30034067$var$WebGLUniforms.seqWithValue(y.seq,_);return a.currentProgram=g,a.uniformsList=v,g}function ez(n,r){let i=l.get(n);i.outputColorSpace=r.outputColorSpace,i.instancing=r.instancing,i.instancingColor=r.instancingColor,i.skinning=r.skinning,i.morphTargets=r.morphTargets,i.morphNormals=r.morphNormals,i.morphColors=r.morphColors,i.morphTargetsCount=r.morphTargetsCount,i.numClippingPlanes=r.numClippingPlanes,i.numIntersection=r.numClipIntersection,i.vertexAlphas=r.vertexAlphas,i.vertexTangents=r.vertexTangents,i.toneMapping=r.toneMapping}function eV(n,r,i,o,d){!0!==r.isScene&&(r=e_),u.resetTextureUnits();let p=r.fog,f=o.isMeshStandardMaterial?r.environment:null,m=null===q?H.outputColorSpace:!0===q.isXRRenderTarget?q.texture.colorSpace:$d5b33d7c30034067$export$42429b3acfb233a4,_=(o.isMeshStandardMaterial?h:c).get(o.envMap||f),y=!0===o.vertexColors&&!!i.attributes.color&&4===i.attributes.color.itemSize,v=!!i.attributes.tangent&&(!!o.normalMap||o.anisotropy>0),x=!!i.morphAttributes.position,T=!!i.morphAttributes.normal,S=!!i.morphAttributes.color,E=$d5b33d7c30034067$export$9fcb6b4294603b2;o.toneMapped&&(null===q||!0===q.isXRRenderTarget)&&(E=H.toneMapping);let A=i.morphAttributes.position||i.morphAttributes.normal||i.morphAttributes.color,I=void 0!==A?A.length:0,P=l.get(o),O=V.state.lights;if(!0===eh&&(!0===ed||n!==K)){let r=n===K&&o.id===Y;// we might want to call this function with some ClippingGroup
// object instead of the material, once it becomes feasible
// (#8465, #8379)
b.setState(o,n,r)}//
let R=!1;o.version===P.__version?P.needsLights&&P.lightsStateVersion!==O.state.version?R=!0:P.outputColorSpace!==m?R=!0:d.isInstancedMesh&&!1===P.instancing?R=!0:d.isInstancedMesh||!0!==P.instancing?d.isSkinnedMesh&&!1===P.skinning?R=!0:d.isSkinnedMesh||!0!==P.skinning?d.isInstancedMesh&&!0===P.instancingColor&&null===d.instanceColor?R=!0:d.isInstancedMesh&&!1===P.instancingColor&&null!==d.instanceColor?R=!0:P.envMap!==_?R=!0:!0===o.fog&&P.fog!==p?R=!0:void 0!==P.numClippingPlanes&&(P.numClippingPlanes!==b.numPlanes||P.numIntersection!==b.numIntersection)?R=!0:P.vertexAlphas!==y?R=!0:P.vertexTangents!==v?R=!0:P.morphTargets!==x?R=!0:P.morphNormals!==T?R=!0:P.morphColors!==S?R=!0:P.toneMapping!==E?R=!0:!0===a.isWebGL2&&P.morphTargetsCount!==I&&(R=!0):R=!0:R=!0:(R=!0,P.__version=o.version);//
let C=P.currentProgram;!0===R&&(C=eB(o,r,d));let L=!1,D=!1,N=!1,k=C.getUniforms(),U=P.uniforms;if(s.useProgram(C.program)&&(L=!0,D=!0,N=!0),o.id!==Y&&(Y=o.id,D=!0),L||K!==n){// common camera uniforms
k.setValue(eb,"projectionMatrix",n.projectionMatrix),k.setValue(eb,"viewMatrix",n.matrixWorldInverse);let r=k.map.cameraPosition;void 0!==r&&r.setValue(eb,eg.setFromMatrixPosition(n.matrixWorld)),a.logarithmicDepthBuffer&&k.setValue(eb,"logDepthBufFC",2/(Math.log(n.far+1)/Math.LN2)),(o.isMeshPhongMaterial||o.isMeshToonMaterial||o.isMeshLambertMaterial||o.isMeshBasicMaterial||o.isMeshStandardMaterial||o.isShaderMaterial)&&k.setValue(eb,"isOrthographic",!0===n.isOrthographicCamera),K!==n&&(K=n,// lighting uniforms depend on the camera so enforce an update
// now, in case this material supports lights - or later, when
// the next material that does gets activated:
D=!0,N=!0)}// skinning and morph target uniforms must be set even if material didn't change
// auto-setting of texture unit for bone and morph texture must go before other textures
// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
if(d.isSkinnedMesh){k.setOptional(eb,d,"bindMatrix"),k.setOptional(eb,d,"bindMatrixInverse");let n=d.skeleton;n&&(a.floatVertexTextures?(null===n.boneTexture&&n.computeBoneTexture(),k.setValue(eb,"boneTexture",n.boneTexture,u),k.setValue(eb,"boneTextureSize",n.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}let F=i.morphAttributes;// UBOs
if((void 0!==F.position||void 0!==F.normal||void 0!==F.color&&!0===a.isWebGL2)&&w.update(d,i,C),(D||P.receiveShadow!==d.receiveShadow)&&(P.receiveShadow=d.receiveShadow,k.setValue(eb,"receiveShadow",d.receiveShadow)),o.isMeshGouraudMaterial&&null!==o.envMap&&(U.envMap.value=_,U.flipEnvMap.value=_.isCubeTexture&&!1===_.isRenderTargetTexture?-1:1),D&&(k.setValue(eb,"toneMappingExposure",H.toneMappingExposure),P.needsLights&&// note: all lighting uniforms are always set correctly
// they simply reference the renderer's state for their
// values
//
// use the current material's .needsUpdate flags to set
// the GL state when required
eG(U,N),p&&!0===o.fog&&g.refreshFogUniforms(U,p),g.refreshMaterialUniforms(U,o,ei,er,ep),$d5b33d7c30034067$var$WebGLUniforms.upload(eb,P.uniformsList,U,u)),o.isShaderMaterial&&!0===o.uniformsNeedUpdate&&($d5b33d7c30034067$var$WebGLUniforms.upload(eb,P.uniformsList,U,u),o.uniformsNeedUpdate=!1),o.isSpriteMaterial&&k.setValue(eb,"center",d.center),// common matrices
k.setValue(eb,"modelViewMatrix",d.modelViewMatrix),k.setValue(eb,"normalMatrix",d.normalMatrix),k.setValue(eb,"modelMatrix",d.matrixWorld),o.isShaderMaterial||o.isRawShaderMaterial){let n=o.uniformsGroups;for(let r=0,i=n.length;r<i;r++)if(a.isWebGL2){let i=n[r];M.update(i,C),M.bind(i,C)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return C}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
function eG(n,r){n.ambientLightColor.needsUpdate=r,n.lightProbe.needsUpdate=r,n.directionalLights.needsUpdate=r,n.directionalLightShadows.needsUpdate=r,n.pointLights.needsUpdate=r,n.pointLightShadows.needsUpdate=r,n.spotLights.needsUpdate=r,n.spotLightShadows.needsUpdate=r,n.rectAreaLights.needsUpdate=r,n.hemisphereLights.needsUpdate=r}function ej(n){return n.isMeshLambertMaterial||n.isMeshToonMaterial||n.isMeshPhongMaterial||n.isMeshStandardMaterial||n.isShadowMaterial||n.isShaderMaterial&&!0===n.lights}eL.setAnimationLoop(eO),"undefined"!=typeof self&&eL.setContext(self),this.setAnimationLoop=function(n){eP=n,ew.setAnimationLoop(n),null===n?eL.stop():eL.start()},ew.addEventListener("sessionstart",eR),ew.addEventListener("sessionend",eC),// Rendering
this.render=function(n,r){if(void 0!==r&&!0!==r.isCamera){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(!0===$)return;!0===n.matrixWorldAutoUpdate&&n.updateMatrixWorld(),null===r.parent&&!0===r.matrixWorldAutoUpdate&&r.updateMatrixWorld(),!0===ew.enabled&&!0===ew.isPresenting&&(!0===ew.cameraAutoUpdate&&ew.updateCamera(r),r=ew.getCamera()),!0===n.isScene&&n.onBeforeRender(H,n,r,q),(V=y.get(n,j.length)).init(),j.push(V),ef.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),ec.setFromProjectionMatrix(ef),ed=this.localClippingEnabled,eh=b.init(this.clippingPlanes,ed),(z=_.get(n,G.length)).init(),G.push(z),eD(n,r,0,H.sortObjects),z.finish(),!0===H.sortObjects&&z.sort(ea,es),//
this.info.render.frame++,!0===eh&&b.beginShadows();let i=V.state.shadowsArray;if(v.render(i,n,r),!0===eh&&b.endShadows(),!0===this.info.autoReset&&this.info.reset(),//
x.render(z,n),// render scene
V.setupLights(H._useLegacyLights),r.isArrayCamera){let i=r.cameras;for(let r=0,a=i.length;r<a;r++){let a=i[r];eN(z,n,a,a.viewport)}}else eN(z,n,r);null!==q&&(// resolve multisample renderbuffers to a single-sample texture if necessary
u.updateMultisampleRenderTarget(q),// Generate mipmap if we're using any kind of mipmap filtering
u.updateRenderTargetMipmap(q)),!0===n.isScene&&n.onAfterRender(H,n,r),// _gl.finish();
A.resetDefaultState(),Y=-1,K=null,j.pop(),V=j.length>0?j[j.length-1]:null,G.pop(),z=G.length>0?G[G.length-1]:null},this.getActiveCubeFace=function(){return W},this.getActiveMipmapLevel=function(){return X},this.getRenderTarget=function(){return q},this.setRenderTargetTextures=function(n,r,a){l.get(n.texture).__webglTexture=r,l.get(n.depthTexture).__webglTexture=a;let s=l.get(n);s.__hasExternalTextures=!0,s.__hasExternalTextures&&(s.__autoAllocateDepthBuffer=void 0===a,s.__autoAllocateDepthBuffer||!0!==i.has("WEBGL_multisampled_render_to_texture")||(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),s.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(n,r){let i=l.get(n);i.__webglFramebuffer=r,i.__useDefaultFramebuffer=void 0===r},this.setRenderTarget=function(n,r=0,i=0){q=n,W=r,X=i;let o=!0,c=null,h=!1,d=!1;if(n){let p=l.get(n);void 0!==p.__useDefaultFramebuffer?(// We need to make sure to rebind the framebuffer.
s.bindFramebuffer(eb.FRAMEBUFFER,null),o=!1):void 0===p.__webglFramebuffer?u.setupRenderTarget(n):p.__hasExternalTextures&&u.rebindTextures(n,l.get(n.texture).__webglTexture,l.get(n.depthTexture).__webglTexture);let f=n.texture;(f.isData3DTexture||f.isDataArrayTexture||f.isCompressedArrayTexture)&&(d=!0);let m=l.get(n).__webglFramebuffer;n.isWebGLCubeRenderTarget?(c=Array.isArray(m[r])?m[r][i]:m[r],h=!0):c=a.isWebGL2&&n.samples>0&&!1===u.useMultisampledRTT(n)?l.get(n).__webglMultisampledFramebuffer:Array.isArray(m)?m[i]:m,Z.copy(n.viewport),J.copy(n.scissor),Q=n.scissorTest}else Z.copy(eo).multiplyScalar(ei).floor(),J.copy(el).multiplyScalar(ei).floor(),Q=eu;let p=s.bindFramebuffer(eb.FRAMEBUFFER,c);if(p&&a.drawBuffers&&o&&s.drawBuffers(n,c),s.viewport(Z),s.scissor(J),s.setScissorTest(Q),h){let a=l.get(n.texture);eb.framebufferTexture2D(eb.FRAMEBUFFER,eb.COLOR_ATTACHMENT0,eb.TEXTURE_CUBE_MAP_POSITIVE_X+r,a.__webglTexture,i)}else if(d){let a=l.get(n.texture),s=r||0;eb.framebufferTextureLayer(eb.FRAMEBUFFER,eb.COLOR_ATTACHMENT0,a.__webglTexture,i||0,s)}Y=-1},this.readRenderTargetPixels=function(n,r,o,u,c,h,d){if(!(n&&n.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let p=l.get(n).__webglFramebuffer;if(n.isWebGLCubeRenderTarget&&void 0!==d&&(p=p[d]),p){s.bindFramebuffer(eb.FRAMEBUFFER,p);try{let s=n.texture,l=s.format,d=s.type;if(l!==$d5b33d7c30034067$export$3f8bb04b555a363c&&E.convert(l)!==eb.getParameter(eb.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}let p=d===$d5b33d7c30034067$export$2697304443f382bc&&(i.has("EXT_color_buffer_half_float")||a.isWebGL2&&i.has("EXT_color_buffer_float"));if(d!==$d5b33d7c30034067$export$2e8ce08d3f6f5e10&&E.convert(d)!==eb.getParameter(eb.IMPLEMENTATION_COLOR_READ_TYPE)&&// Edge and Chrome Mac < 52 (#9513)
!(d===$d5b33d7c30034067$export$f6d331659b644596&&(a.isWebGL2||i.has("OES_texture_float")||i.has("WEBGL_color_buffer_float")))&&// Chrome Mac >= 52 and Firefox
!p){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
r>=0&&r<=n.width-u&&o>=0&&o<=n.height-c&&eb.readPixels(r,o,u,c,E.convert(l),E.convert(d),h)}finally{// restore framebuffer of current render target if necessary
let n=null!==q?l.get(q).__webglFramebuffer:null;s.bindFramebuffer(eb.FRAMEBUFFER,n)}}},this.copyFramebufferToTexture=function(n,r,i=0){let a=Math.pow(2,-i),o=Math.floor(r.image.width*a),l=Math.floor(r.image.height*a);u.setTexture2D(r,0),eb.copyTexSubImage2D(eb.TEXTURE_2D,i,0,0,n.x,n.y,o,l),s.unbindTexture()},this.copyTextureToTexture=function(n,r,i,a=0){let o=r.image.width,l=r.image.height,c=E.convert(i.format),h=E.convert(i.type);u.setTexture2D(i,0),// As another texture upload may have changed pixelStorei
// parameters, make sure they are correct for the dstTexture
eb.pixelStorei(eb.UNPACK_FLIP_Y_WEBGL,i.flipY),eb.pixelStorei(eb.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i.premultiplyAlpha),eb.pixelStorei(eb.UNPACK_ALIGNMENT,i.unpackAlignment),r.isDataTexture?eb.texSubImage2D(eb.TEXTURE_2D,a,n.x,n.y,o,l,c,h,r.image.data):r.isCompressedTexture?eb.compressedTexSubImage2D(eb.TEXTURE_2D,a,n.x,n.y,r.mipmaps[0].width,r.mipmaps[0].height,c,r.mipmaps[0].data):eb.texSubImage2D(eb.TEXTURE_2D,a,n.x,n.y,c,h,r.image),0===a&&i.generateMipmaps&&eb.generateMipmap(eb.TEXTURE_2D),s.unbindTexture()},this.copyTextureToTexture3D=function(n,r,i,a,o=0){let l;if(H.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}let c=n.max.x-n.min.x+1,h=n.max.y-n.min.y+1,d=n.max.z-n.min.z+1,p=E.convert(a.format),f=E.convert(a.type);if(a.isData3DTexture)u.setTexture3D(a,0),l=eb.TEXTURE_3D;else if(a.isDataArrayTexture)u.setTexture2DArray(a,0),l=eb.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}eb.pixelStorei(eb.UNPACK_FLIP_Y_WEBGL,a.flipY),eb.pixelStorei(eb.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultiplyAlpha),eb.pixelStorei(eb.UNPACK_ALIGNMENT,a.unpackAlignment);let m=eb.getParameter(eb.UNPACK_ROW_LENGTH),g=eb.getParameter(eb.UNPACK_IMAGE_HEIGHT),_=eb.getParameter(eb.UNPACK_SKIP_PIXELS),y=eb.getParameter(eb.UNPACK_SKIP_ROWS),b=eb.getParameter(eb.UNPACK_SKIP_IMAGES),v=i.isCompressedTexture?i.mipmaps[0]:i.image;eb.pixelStorei(eb.UNPACK_ROW_LENGTH,v.width),eb.pixelStorei(eb.UNPACK_IMAGE_HEIGHT,v.height),eb.pixelStorei(eb.UNPACK_SKIP_PIXELS,n.min.x),eb.pixelStorei(eb.UNPACK_SKIP_ROWS,n.min.y),eb.pixelStorei(eb.UNPACK_SKIP_IMAGES,n.min.z),i.isDataTexture||i.isData3DTexture?eb.texSubImage3D(l,o,r.x,r.y,r.z,c,h,d,p,f,v.data):i.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),eb.compressedTexSubImage3D(l,o,r.x,r.y,r.z,c,h,d,p,v.data)):eb.texSubImage3D(l,o,r.x,r.y,r.z,c,h,d,p,f,v),eb.pixelStorei(eb.UNPACK_ROW_LENGTH,m),eb.pixelStorei(eb.UNPACK_IMAGE_HEIGHT,g),eb.pixelStorei(eb.UNPACK_SKIP_PIXELS,_),eb.pixelStorei(eb.UNPACK_SKIP_ROWS,y),eb.pixelStorei(eb.UNPACK_SKIP_IMAGES,b),0===o&&a.generateMipmaps&&eb.generateMipmap(l),s.unbindTexture()},this.initTexture=function(n){n.isCubeTexture?u.setTextureCube(n,0):n.isData3DTexture?u.setTexture3D(n,0):n.isDataArrayTexture||n.isCompressedArrayTexture?u.setTexture2DArray(n,0):u.setTexture2D(n,0),s.unbindTexture()},this.resetState=function(){W=0,X=0,q=null,s.reset(),A.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return $d5b33d7c30034067$export$5a0e9190d10875d3}get physicallyCorrectLights(){return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights}set physicallyCorrectLights(n){console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!n}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===$d5b33d7c30034067$export$561f394b24edfcaa?$d5b33d7c30034067$export$f32388edbb32674:$d5b33d7c30034067$export$7207336e4151a112}set outputEncoding(n){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=n===$d5b33d7c30034067$export$f32388edbb32674?$d5b33d7c30034067$export$561f394b24edfcaa:$d5b33d7c30034067$export$42429b3acfb233a4}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(n){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=n}}class $d5b33d7c30034067$export$a2f65229194348f9 extends $d5b33d7c30034067$export$f6cc00ef28d7cf97{}$d5b33d7c30034067$export$a2f65229194348f9.prototype.isWebGL1Renderer=!0;class $d5b33d7c30034067$export$6f1519f023b8d0f6{constructor(n,r=25e-5){this.isFogExp2=!0,this.name="",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(n),this.density=r}clone(){return new $d5b33d7c30034067$export$6f1519f023b8d0f6(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class $d5b33d7c30034067$export$3c890837b09508d4{constructor(n,r=1,i=1e3){this.isFog=!0,this.name="",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(n),this.near=r,this.far=i}clone(){return new $d5b33d7c30034067$export$3c890837b09508d4(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class $d5b33d7c30034067$export$38af1803e3442a7f extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(n,r){return super.copy(n,r),null!==n.background&&(this.background=n.background.clone()),null!==n.environment&&(this.environment=n.environment.clone()),null!==n.fog&&(this.fog=n.fog.clone()),this.backgroundBlurriness=n.backgroundBlurriness,this.backgroundIntensity=n.backgroundIntensity,null!==n.overrideMaterial&&(this.overrideMaterial=n.overrideMaterial.clone()),this.matrixAutoUpdate=n.matrixAutoUpdate,this}toJSON(n){let r=super.toJSON(n);return null!==this.fog&&(r.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(r.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(r.object.backgroundIntensity=this.backgroundIntensity),r}}class $d5b33d7c30034067$export$3d5cd879f108f53f{constructor(n,r){this.isInterleavedBuffer=!0,this.array=n,this.stride=r,this.count=void 0!==n?n.length/r:0,this.usage=$d5b33d7c30034067$export$763e8360f4d7f77d,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=$d5b33d7c30034067$var$generateUUID()}onUploadCallback(){}set needsUpdate(n){!0===n&&this.version++}setUsage(n){return this.usage=n,this}copy(n){return this.array=new n.array.constructor(n.array),this.count=n.count,this.stride=n.stride,this.usage=n.usage,this}copyAt(n,r,i){n*=this.stride,i*=r.stride;for(let a=0,s=this.stride;a<s;a++)this.array[n+a]=r.array[i+a];return this}set(n,r=0){return this.array.set(n,r),this}clone(n){void 0===n.arrayBuffers&&(n.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=$d5b33d7c30034067$var$generateUUID()),void 0===n.arrayBuffers[this.array.buffer._uuid]&&(n.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);let r=new this.array.constructor(n.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(r,this.stride);return i.setUsage(this.usage),i}onUpload(n){return this.onUploadCallback=n,this}toJSON(n){//
return void 0===n.arrayBuffers&&(n.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=$d5b33d7c30034067$var$generateUUID()),void 0===n.arrayBuffers[this.array.buffer._uuid]&&(n.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const $d5b33d7c30034067$var$_vector$5=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$920b6d07334599c7{constructor(n,r,i,a=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=n,this.itemSize=r,this.offset=i,this.normalized=a}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(n){this.data.needsUpdate=n}applyMatrix4(n){for(let r=0,i=this.data.count;r<i;r++)$d5b33d7c30034067$var$_vector$5.fromBufferAttribute(this,r),$d5b33d7c30034067$var$_vector$5.applyMatrix4(n),this.setXYZ(r,$d5b33d7c30034067$var$_vector$5.x,$d5b33d7c30034067$var$_vector$5.y,$d5b33d7c30034067$var$_vector$5.z);return this}applyNormalMatrix(n){for(let r=0,i=this.count;r<i;r++)$d5b33d7c30034067$var$_vector$5.fromBufferAttribute(this,r),$d5b33d7c30034067$var$_vector$5.applyNormalMatrix(n),this.setXYZ(r,$d5b33d7c30034067$var$_vector$5.x,$d5b33d7c30034067$var$_vector$5.y,$d5b33d7c30034067$var$_vector$5.z);return this}transformDirection(n){for(let r=0,i=this.count;r<i;r++)$d5b33d7c30034067$var$_vector$5.fromBufferAttribute(this,r),$d5b33d7c30034067$var$_vector$5.transformDirection(n),this.setXYZ(r,$d5b33d7c30034067$var$_vector$5.x,$d5b33d7c30034067$var$_vector$5.y,$d5b33d7c30034067$var$_vector$5.z);return this}setX(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.data.array[n*this.data.stride+this.offset]=r,this}setY(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.data.array[n*this.data.stride+this.offset+1]=r,this}setZ(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.data.array[n*this.data.stride+this.offset+2]=r,this}setW(n,r){return this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array)),this.data.array[n*this.data.stride+this.offset+3]=r,this}getX(n){let r=this.data.array[n*this.data.stride+this.offset];return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}getY(n){let r=this.data.array[n*this.data.stride+this.offset+1];return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}getZ(n){let r=this.data.array[n*this.data.stride+this.offset+2];return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}getW(n){let r=this.data.array[n*this.data.stride+this.offset+3];return this.normalized&&(r=$d5b33d7c30034067$var$denormalize(r,this.array)),r}setXY(n,r,i){return n=n*this.data.stride+this.offset,this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array),i=$d5b33d7c30034067$var$normalize(i,this.array)),this.data.array[n+0]=r,this.data.array[n+1]=i,this}setXYZ(n,r,i,a){return n=n*this.data.stride+this.offset,this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array),i=$d5b33d7c30034067$var$normalize(i,this.array),a=$d5b33d7c30034067$var$normalize(a,this.array)),this.data.array[n+0]=r,this.data.array[n+1]=i,this.data.array[n+2]=a,this}setXYZW(n,r,i,a,s){return n=n*this.data.stride+this.offset,this.normalized&&(r=$d5b33d7c30034067$var$normalize(r,this.array),i=$d5b33d7c30034067$var$normalize(i,this.array),a=$d5b33d7c30034067$var$normalize(a,this.array),s=$d5b33d7c30034067$var$normalize(s,this.array)),this.data.array[n+0]=r,this.data.array[n+1]=i,this.data.array[n+2]=a,this.data.array[n+3]=s,this}clone(n){if(void 0!==n)return void 0===n.interleavedBuffers&&(n.interleavedBuffers={}),void 0===n.interleavedBuffers[this.data.uuid]&&(n.interleavedBuffers[this.data.uuid]=this.data.clone(n)),new $d5b33d7c30034067$export$920b6d07334599c7(n.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized);{console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");let n=[];for(let r=0;r<this.count;r++){let i=r*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)n.push(this.data.array[i+r])}return new $d5b33d7c30034067$export$8dea267bd6bde117(new this.array.constructor(n),this.itemSize,this.normalized)}}toJSON(n){if(void 0!==n)return void 0===n.interleavedBuffers&&(n.interleavedBuffers={}),void 0===n.interleavedBuffers[this.data.uuid]&&(n.interleavedBuffers[this.data.uuid]=this.data.toJSON(n)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized};{console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");let n=[];for(let r=0;r<this.count;r++){let i=r*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)n.push(this.data.array[i+r])}// de-interleave data and save it as an ordinary buffer attribute for now
return{itemSize:this.itemSize,type:this.array.constructor.name,array:n,normalized:this.normalized}}}}class $d5b33d7c30034067$export$5ec7dd1c6994bf8e extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(n)}copy(n){return super.copy(n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.rotation=n.rotation,this.sizeAttenuation=n.sizeAttenuation,this.fog=n.fog,this}}const $d5b33d7c30034067$var$_intersectPoint=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_worldScale=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_mvPosition=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_alignedPosition=/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1,$d5b33d7c30034067$var$_rotatedPosition=/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1,$d5b33d7c30034067$var$_viewWorldMatrix=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_vA=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vB=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_vC=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_uvA=/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1,$d5b33d7c30034067$var$_uvB=/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1,$d5b33d7c30034067$var$_uvC=/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1;class $d5b33d7c30034067$export$3075603db8e6204c extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(n){if(super(),this.isSprite=!0,this.type="Sprite",void 0===$d5b33d7c30034067$var$_geometry){$d5b33d7c30034067$var$_geometry=new $d5b33d7c30034067$export$b7be63a67df8959;let n=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),r=new $d5b33d7c30034067$export$3d5cd879f108f53f(n,5);$d5b33d7c30034067$var$_geometry.setIndex([0,1,2,0,2,3]),$d5b33d7c30034067$var$_geometry.setAttribute("position",new $d5b33d7c30034067$export$920b6d07334599c7(r,3,0,!1)),$d5b33d7c30034067$var$_geometry.setAttribute("uv",new $d5b33d7c30034067$export$920b6d07334599c7(r,2,3,!1))}this.geometry=$d5b33d7c30034067$var$_geometry,this.material=void 0!==n?n:new $d5b33d7c30034067$export$5ec7dd1c6994bf8e,this.center=new $d5b33d7c30034067$export$c977b3e384af9ae1(.5,.5)}raycast(n,r){let i,a;null===n.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),$d5b33d7c30034067$var$_worldScale.setFromMatrixScale(this.matrixWorld),$d5b33d7c30034067$var$_viewWorldMatrix.copy(n.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(n.camera.matrixWorldInverse,this.matrixWorld),$d5b33d7c30034067$var$_mvPosition.setFromMatrixPosition(this.modelViewMatrix),n.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&$d5b33d7c30034067$var$_worldScale.multiplyScalar(-$d5b33d7c30034067$var$_mvPosition.z);let s=this.material.rotation;0!==s&&(a=Math.cos(s),i=Math.sin(s));let o=this.center;$d5b33d7c30034067$var$transformVertex($d5b33d7c30034067$var$_vA.set(-.5,-.5,0),$d5b33d7c30034067$var$_mvPosition,o,$d5b33d7c30034067$var$_worldScale,i,a),$d5b33d7c30034067$var$transformVertex($d5b33d7c30034067$var$_vB.set(.5,-.5,0),$d5b33d7c30034067$var$_mvPosition,o,$d5b33d7c30034067$var$_worldScale,i,a),$d5b33d7c30034067$var$transformVertex($d5b33d7c30034067$var$_vC.set(.5,.5,0),$d5b33d7c30034067$var$_mvPosition,o,$d5b33d7c30034067$var$_worldScale,i,a),$d5b33d7c30034067$var$_uvA.set(0,0),$d5b33d7c30034067$var$_uvB.set(1,0),$d5b33d7c30034067$var$_uvC.set(1,1);// check first triangle
let l=n.ray.intersectTriangle($d5b33d7c30034067$var$_vA,$d5b33d7c30034067$var$_vB,$d5b33d7c30034067$var$_vC,!1,$d5b33d7c30034067$var$_intersectPoint);if(null===l&&(// check second triangle
$d5b33d7c30034067$var$transformVertex($d5b33d7c30034067$var$_vB.set(-.5,.5,0),$d5b33d7c30034067$var$_mvPosition,o,$d5b33d7c30034067$var$_worldScale,i,a),$d5b33d7c30034067$var$_uvB.set(0,1),null===(l=n.ray.intersectTriangle($d5b33d7c30034067$var$_vA,$d5b33d7c30034067$var$_vC,$d5b33d7c30034067$var$_vB,!1,$d5b33d7c30034067$var$_intersectPoint))))return;let u=n.ray.origin.distanceTo($d5b33d7c30034067$var$_intersectPoint);u<n.near||u>n.far||r.push({distance:u,point:$d5b33d7c30034067$var$_intersectPoint.clone(),uv:$d5b33d7c30034067$export$5a465592bfe74b48.getInterpolation($d5b33d7c30034067$var$_intersectPoint,$d5b33d7c30034067$var$_vA,$d5b33d7c30034067$var$_vB,$d5b33d7c30034067$var$_vC,$d5b33d7c30034067$var$_uvA,$d5b33d7c30034067$var$_uvB,$d5b33d7c30034067$var$_uvC,new $d5b33d7c30034067$export$c977b3e384af9ae1),face:null,object:this})}copy(n,r){return super.copy(n,r),void 0!==n.center&&this.center.copy(n.center),this.material=n.material,this}}function $d5b33d7c30034067$var$transformVertex(n,r,i,a,s,o){// compute position in camera space
$d5b33d7c30034067$var$_alignedPosition.subVectors(n,i).addScalar(.5).multiply(a),void 0!==s?($d5b33d7c30034067$var$_rotatedPosition.x=o*$d5b33d7c30034067$var$_alignedPosition.x-s*$d5b33d7c30034067$var$_alignedPosition.y,$d5b33d7c30034067$var$_rotatedPosition.y=s*$d5b33d7c30034067$var$_alignedPosition.x+o*$d5b33d7c30034067$var$_alignedPosition.y):$d5b33d7c30034067$var$_rotatedPosition.copy($d5b33d7c30034067$var$_alignedPosition),n.copy(r),n.x+=$d5b33d7c30034067$var$_rotatedPosition.x,n.y+=$d5b33d7c30034067$var$_rotatedPosition.y,// transform to world space
n.applyMatrix4($d5b33d7c30034067$var$_viewWorldMatrix)}const $d5b33d7c30034067$var$_v1$2=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_v2$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$112e7237be0c5f30 extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(n){super.copy(n,!1);let r=n.levels;for(let n=0,i=r.length;n<i;n++){let i=r[n];this.addLevel(i.object.clone(),i.distance,i.hysteresis)}return this.autoUpdate=n.autoUpdate,this}addLevel(n,r=0,i=0){let a;r=Math.abs(r);let s=this.levels;for(a=0;a<s.length&&!(r<s[a].distance);a++);return s.splice(a,0,{distance:r,hysteresis:i,object:n}),this.add(n),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(n){let r=this.levels;if(r.length>0){let i,a;for(i=1,a=r.length;i<a;i++){let a=r[i].distance;if(r[i].object.visible&&(a-=a*r[i].hysteresis),n<a)break}return r[i-1].object}return null}raycast(n,r){let i=this.levels;if(i.length>0){$d5b33d7c30034067$var$_v1$2.setFromMatrixPosition(this.matrixWorld);let i=n.ray.origin.distanceTo($d5b33d7c30034067$var$_v1$2);this.getObjectForDistance(i).raycast(n,r)}}update(n){let r=this.levels;if(r.length>1){let i,a;$d5b33d7c30034067$var$_v1$2.setFromMatrixPosition(n.matrixWorld),$d5b33d7c30034067$var$_v2$1.setFromMatrixPosition(this.matrixWorld);let s=$d5b33d7c30034067$var$_v1$2.distanceTo($d5b33d7c30034067$var$_v2$1)/n.zoom;for(i=1,r[0].object.visible=!0,a=r.length;i<a;i++){let n=r[i].distance;if(r[i].object.visible&&(n-=n*r[i].hysteresis),s>=n)r[i-1].object.visible=!1,r[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<a;i++)r[i].object.visible=!1}}toJSON(n){let r=super.toJSON(n);!1===this.autoUpdate&&(r.object.autoUpdate=!1),r.object.levels=[];let i=this.levels;for(let n=0,a=i.length;n<a;n++){let a=i[n];r.object.levels.push({object:a.object.uuid,distance:a.distance,hysteresis:a.hysteresis})}return r}}const $d5b33d7c30034067$var$_basePosition=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_skinIndex=/*@__PURE__*/new $d5b33d7c30034067$export$fa7daccca11cdbe3,$d5b33d7c30034067$var$_skinWeight=/*@__PURE__*/new $d5b33d7c30034067$export$fa7daccca11cdbe3,$d5b33d7c30034067$var$_vector3=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_matrix4=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_vertex=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_sphere$3=/*@__PURE__*/new $d5b33d7c30034067$export$805e8b72413ccaba,$d5b33d7c30034067$var$_inverseMatrix$2=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_ray$2=/*@__PURE__*/new $d5b33d7c30034067$export$a186db52eed6d40e;class $d5b33d7c30034067$export$b303577035157ecf extends $d5b33d7c30034067$export$e176487c05830cc5{constructor(n,r){super(n,r),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new $d5b33d7c30034067$export$2ae72fc923e5eb5,this.bindMatrixInverse=new $d5b33d7c30034067$export$2ae72fc923e5eb5,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){let n=this.geometry;null===this.boundingBox&&(this.boundingBox=new $d5b33d7c30034067$export$6f7d5a9418ab2aa3),this.boundingBox.makeEmpty();let r=n.getAttribute("position");for(let n=0;n<r.count;n++)$d5b33d7c30034067$var$_vertex.fromBufferAttribute(r,n),this.applyBoneTransform(n,$d5b33d7c30034067$var$_vertex),this.boundingBox.expandByPoint($d5b33d7c30034067$var$_vertex)}computeBoundingSphere(){let n=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new $d5b33d7c30034067$export$805e8b72413ccaba),this.boundingSphere.makeEmpty();let r=n.getAttribute("position");for(let n=0;n<r.count;n++)$d5b33d7c30034067$var$_vertex.fromBufferAttribute(r,n),this.applyBoneTransform(n,$d5b33d7c30034067$var$_vertex),this.boundingSphere.expandByPoint($d5b33d7c30034067$var$_vertex)}copy(n,r){return super.copy(n,r),this.bindMode=n.bindMode,this.bindMatrix.copy(n.bindMatrix),this.bindMatrixInverse.copy(n.bindMatrixInverse),this.skeleton=n.skeleton,null!==n.boundingBox&&(this.boundingBox=n.boundingBox.clone()),null!==n.boundingSphere&&(this.boundingSphere=n.boundingSphere.clone()),this}raycast(n,r){let i=this.material,a=this.matrixWorld;if(void 0!==i&&(null===this.boundingSphere&&this.computeBoundingSphere(),$d5b33d7c30034067$var$_sphere$3.copy(this.boundingSphere),$d5b33d7c30034067$var$_sphere$3.applyMatrix4(a),!1!==n.ray.intersectsSphere($d5b33d7c30034067$var$_sphere$3))){// test with bounding box in local space
if(// convert ray to local space of skinned mesh
$d5b33d7c30034067$var$_inverseMatrix$2.copy(a).invert(),$d5b33d7c30034067$var$_ray$2.copy(n.ray).applyMatrix4($d5b33d7c30034067$var$_inverseMatrix$2),null!==this.boundingBox&&!1===$d5b33d7c30034067$var$_ray$2.intersectsBox(this.boundingBox))return;// test for intersections with geometry
this._computeIntersections(n,r,$d5b33d7c30034067$var$_ray$2)}}getVertexPosition(n,r){return super.getVertexPosition(n,r),this.applyBoneTransform(n,r),r}bind(n,r){this.skeleton=n,void 0===r&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),r=this.matrixWorld),this.bindMatrix.copy(r),this.bindMatrixInverse.copy(r).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){let n=new $d5b33d7c30034067$export$fa7daccca11cdbe3,r=this.geometry.attributes.skinWeight;for(let i=0,a=r.count;i<a;i++){n.fromBufferAttribute(r,i);let a=1/n.manhattanLength();a!==1/0?n.multiplyScalar(a):n.set(1,0,0,0),r.setXYZW(i,n.x,n.y,n.z,n.w)}}updateMatrixWorld(n){super.updateMatrixWorld(n),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(n,r){let i=this.skeleton,a=this.geometry;$d5b33d7c30034067$var$_skinIndex.fromBufferAttribute(a.attributes.skinIndex,n),$d5b33d7c30034067$var$_skinWeight.fromBufferAttribute(a.attributes.skinWeight,n),$d5b33d7c30034067$var$_basePosition.copy(r).applyMatrix4(this.bindMatrix),r.set(0,0,0);for(let n=0;n<4;n++){let a=$d5b33d7c30034067$var$_skinWeight.getComponent(n);if(0!==a){let s=$d5b33d7c30034067$var$_skinIndex.getComponent(n);$d5b33d7c30034067$var$_matrix4.multiplyMatrices(i.bones[s].matrixWorld,i.boneInverses[s]),r.addScaledVector($d5b33d7c30034067$var$_vector3.copy($d5b33d7c30034067$var$_basePosition).applyMatrix4($d5b33d7c30034067$var$_matrix4),a)}}return r.applyMatrix4(this.bindMatrixInverse)}boneTransform(n,r){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(n,r)}}class $d5b33d7c30034067$export$b127726e56765aa4 extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(){super(),this.isBone=!0,this.type="Bone"}}class $d5b33d7c30034067$export$b691f601014eabe1 extends $d5b33d7c30034067$export$5431306cf43de24a{constructor(n=null,r=1,i=1,a,s,o,l,u,c=$d5b33d7c30034067$export$727aa5ec3fe39bf0,h=$d5b33d7c30034067$export$727aa5ec3fe39bf0,d,p){super(null,o,l,u,c,h,a,s,d,p),this.isDataTexture=!0,this.image={data:n,width:r,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const $d5b33d7c30034067$var$_offsetMatrix=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_identityMatrix=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5;class $d5b33d7c30034067$export$8f31e4c4a37b8e9c{constructor(n=[],r=[]){this.uuid=$d5b33d7c30034067$var$generateUUID(),this.bones=n.slice(0),this.boneInverses=r,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.init()}init(){let n=this.bones,r=this.boneInverses;// calculate inverse bone matrices if necessary
if(this.boneMatrices=new Float32Array(16*n.length),0===r.length)this.calculateInverses();else if(n.length!==r.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,r=this.bones.length;n<r;n++)this.boneInverses.push(new $d5b33d7c30034067$export$2ae72fc923e5eb5)}}calculateInverses(){this.boneInverses.length=0;for(let n=0,r=this.bones.length;n<r;n++){let r=new $d5b33d7c30034067$export$2ae72fc923e5eb5;this.bones[n]&&r.copy(this.bones[n].matrixWorld).invert(),this.boneInverses.push(r)}}pose(){// recover the bind-time world matrices
for(let n=0,r=this.bones.length;n<r;n++){let r=this.bones[n];r&&r.matrixWorld.copy(this.boneInverses[n]).invert()}// compute the local matrices, positions, rotations and scales
for(let n=0,r=this.bones.length;n<r;n++){let r=this.bones[n];r&&(r.parent&&r.parent.isBone?(r.matrix.copy(r.parent.matrixWorld).invert(),r.matrix.multiply(r.matrixWorld)):r.matrix.copy(r.matrixWorld),r.matrix.decompose(r.position,r.quaternion,r.scale))}}update(){let n=this.bones,r=this.boneInverses,i=this.boneMatrices,a=this.boneTexture;// flatten bone matrices to array
for(let a=0,s=n.length;a<s;a++){// compute the offset between the current and the original transform
let s=n[a]?n[a].matrixWorld:$d5b33d7c30034067$var$_identityMatrix;$d5b33d7c30034067$var$_offsetMatrix.multiplyMatrices(s,r[a]),$d5b33d7c30034067$var$_offsetMatrix.toArray(i,16*a)}null!==a&&(a.needsUpdate=!0)}clone(){return new $d5b33d7c30034067$export$8f31e4c4a37b8e9c(this.bones,this.boneInverses)}computeBoneTexture(){// layout (1 matrix = 4 pixels)
//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
let n=Math.sqrt(4*this.bones.length);// 4 pixels needed for 1 matrix
n=Math.max(n=$d5b33d7c30034067$var$ceilPowerOfTwo(n),4);let r=new Float32Array(n*n*4);// 4 floats per RGBA pixel
r.set(this.boneMatrices);let i=new $d5b33d7c30034067$export$b691f601014eabe1(r,n,n,$d5b33d7c30034067$export$3f8bb04b555a363c,$d5b33d7c30034067$export$f6d331659b644596);return i.needsUpdate=!0,this.boneMatrices=r,this.boneTexture=i,this.boneTextureSize=n,this}getBoneByName(n){for(let r=0,i=this.bones.length;r<i;r++){let i=this.bones[r];if(i.name===n)return i}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(n,r){this.uuid=n.uuid;for(let i=0,a=n.bones.length;i<a;i++){let a=n.bones[i],s=r[a];void 0===s&&(console.warn("THREE.Skeleton: No bone found with UUID:",a),s=new $d5b33d7c30034067$export$b127726e56765aa4),this.bones.push(s),this.boneInverses.push(new $d5b33d7c30034067$export$2ae72fc923e5eb5().fromArray(n.boneInverses[i]))}return this.init(),this}toJSON(){let n={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};n.uuid=this.uuid;let r=this.bones,i=this.boneInverses;for(let a=0,s=r.length;a<s;a++){let s=r[a];n.bones.push(s.uuid);let o=i[a];n.boneInverses.push(o.toArray())}return n}}class $d5b33d7c30034067$export$32ea87a8b54d744a extends $d5b33d7c30034067$export$8dea267bd6bde117{constructor(n,r,i,a=1){super(n,r,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=a}copy(n){return super.copy(n),this.meshPerAttribute=n.meshPerAttribute,this}toJSON(){let n=super.toJSON();return n.meshPerAttribute=this.meshPerAttribute,n.isInstancedBufferAttribute=!0,n}}const $d5b33d7c30034067$var$_instanceLocalMatrix=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_instanceWorldMatrix=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_instanceIntersects=[],$d5b33d7c30034067$var$_box3=/*@__PURE__*/new $d5b33d7c30034067$export$6f7d5a9418ab2aa3,$d5b33d7c30034067$var$_identity=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_mesh=/*@__PURE__*/new $d5b33d7c30034067$export$e176487c05830cc5,$d5b33d7c30034067$var$_sphere$2=/*@__PURE__*/new $d5b33d7c30034067$export$805e8b72413ccaba;class $d5b33d7c30034067$export$f3c979c331175ad7 extends $d5b33d7c30034067$export$e176487c05830cc5{constructor(n,r,i){super(n,r),this.isInstancedMesh=!0,this.instanceMatrix=new $d5b33d7c30034067$export$32ea87a8b54d744a(new Float32Array(16*i),16),this.instanceColor=null,this.count=i,this.boundingBox=null,this.boundingSphere=null;for(let n=0;n<i;n++)this.setMatrixAt(n,$d5b33d7c30034067$var$_identity)}computeBoundingBox(){let n=this.geometry,r=this.count;null===this.boundingBox&&(this.boundingBox=new $d5b33d7c30034067$export$6f7d5a9418ab2aa3),null===n.boundingBox&&n.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<r;i++)this.getMatrixAt(i,$d5b33d7c30034067$var$_instanceLocalMatrix),$d5b33d7c30034067$var$_box3.copy(n.boundingBox).applyMatrix4($d5b33d7c30034067$var$_instanceLocalMatrix),this.boundingBox.union($d5b33d7c30034067$var$_box3)}computeBoundingSphere(){let n=this.geometry,r=this.count;null===this.boundingSphere&&(this.boundingSphere=new $d5b33d7c30034067$export$805e8b72413ccaba),null===n.boundingSphere&&n.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<r;i++)this.getMatrixAt(i,$d5b33d7c30034067$var$_instanceLocalMatrix),$d5b33d7c30034067$var$_sphere$2.copy(n.boundingSphere).applyMatrix4($d5b33d7c30034067$var$_instanceLocalMatrix),this.boundingSphere.union($d5b33d7c30034067$var$_sphere$2)}copy(n,r){return super.copy(n,r),this.instanceMatrix.copy(n.instanceMatrix),null!==n.instanceColor&&(this.instanceColor=n.instanceColor.clone()),this.count=n.count,null!==n.boundingBox&&(this.boundingBox=n.boundingBox.clone()),null!==n.boundingSphere&&(this.boundingSphere=n.boundingSphere.clone()),this}getColorAt(n,r){r.fromArray(this.instanceColor.array,3*n)}getMatrixAt(n,r){r.fromArray(this.instanceMatrix.array,16*n)}raycast(n,r){let i=this.matrixWorld,a=this.count;if($d5b33d7c30034067$var$_mesh.geometry=this.geometry,$d5b33d7c30034067$var$_mesh.material=this.material,void 0!==$d5b33d7c30034067$var$_mesh.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),$d5b33d7c30034067$var$_sphere$2.copy(this.boundingSphere),$d5b33d7c30034067$var$_sphere$2.applyMatrix4(i),!1!==n.ray.intersectsSphere($d5b33d7c30034067$var$_sphere$2)))// now test each instance
for(let s=0;s<a;s++){// calculate the world matrix for each instance
this.getMatrixAt(s,$d5b33d7c30034067$var$_instanceLocalMatrix),$d5b33d7c30034067$var$_instanceWorldMatrix.multiplyMatrices(i,$d5b33d7c30034067$var$_instanceLocalMatrix),// the mesh represents this single instance
$d5b33d7c30034067$var$_mesh.matrixWorld=$d5b33d7c30034067$var$_instanceWorldMatrix,$d5b33d7c30034067$var$_mesh.raycast(n,$d5b33d7c30034067$var$_instanceIntersects);// process the result of raycast
for(let n=0,i=$d5b33d7c30034067$var$_instanceIntersects.length;n<i;n++){let i=$d5b33d7c30034067$var$_instanceIntersects[n];i.instanceId=s,i.object=this,r.push(i)}$d5b33d7c30034067$var$_instanceIntersects.length=0}}setColorAt(n,r){null===this.instanceColor&&(this.instanceColor=new $d5b33d7c30034067$export$32ea87a8b54d744a(new Float32Array(3*this.instanceMatrix.count),3)),r.toArray(this.instanceColor.array,3*n)}setMatrixAt(n,r){r.toArray(this.instanceMatrix.array,16*n)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class $d5b33d7c30034067$export$fbaaa33907730a0c extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(n)}copy(n){return super.copy(n),this.color.copy(n.color),this.map=n.map,this.linewidth=n.linewidth,this.linecap=n.linecap,this.linejoin=n.linejoin,this.fog=n.fog,this}}const $d5b33d7c30034067$var$_start$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_end$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_inverseMatrix$1=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_ray$1=/*@__PURE__*/new $d5b33d7c30034067$export$a186db52eed6d40e,$d5b33d7c30034067$var$_sphere$1=/*@__PURE__*/new $d5b33d7c30034067$export$805e8b72413ccaba;class $d5b33d7c30034067$export$17d680238e50603e extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(n=new $d5b33d7c30034067$export$b7be63a67df8959,r=new $d5b33d7c30034067$export$fbaaa33907730a0c){super(),this.isLine=!0,this.type="Line",this.geometry=n,this.material=r,this.updateMorphTargets()}copy(n,r){return super.copy(n,r),this.material=Array.isArray(n.material)?n.material.slice():n.material,this.geometry=n.geometry,this}computeLineDistances(){let n=this.geometry;// we assume non-indexed geometry
if(null===n.index){let r=n.attributes.position,i=[0];for(let n=1,a=r.count;n<a;n++)$d5b33d7c30034067$var$_start$1.fromBufferAttribute(r,n-1),$d5b33d7c30034067$var$_end$1.fromBufferAttribute(r,n),i[n]=i[n-1],i[n]+=$d5b33d7c30034067$var$_start$1.distanceTo($d5b33d7c30034067$var$_end$1);n.setAttribute("lineDistance",new $d5b33d7c30034067$export$cbe7a62641830ebd(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(n,r){let i=this.geometry,a=this.matrixWorld,s=n.params.Line.threshold,o=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),$d5b33d7c30034067$var$_sphere$1.copy(i.boundingSphere),$d5b33d7c30034067$var$_sphere$1.applyMatrix4(a),$d5b33d7c30034067$var$_sphere$1.radius+=s,!1===n.ray.intersectsSphere($d5b33d7c30034067$var$_sphere$1))return;//
$d5b33d7c30034067$var$_inverseMatrix$1.copy(a).invert(),$d5b33d7c30034067$var$_ray$1.copy(n.ray).applyMatrix4($d5b33d7c30034067$var$_inverseMatrix$1);let l=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=l*l,c=new $d5b33d7c30034067$export$64b5c384219d3699,h=new $d5b33d7c30034067$export$64b5c384219d3699,d=new $d5b33d7c30034067$export$64b5c384219d3699,p=new $d5b33d7c30034067$export$64b5c384219d3699,f=this.isLineSegments?2:1,m=i.index,g=i.attributes,_=g.position;if(null!==m){let i=Math.max(0,o.start),a=Math.min(m.count,o.start+o.count);for(let s=i,o=a-1;s<o;s+=f){let i=m.getX(s),a=m.getX(s+1);c.fromBufferAttribute(_,i),h.fromBufferAttribute(_,a);let o=$d5b33d7c30034067$var$_ray$1.distanceSqToSegment(c,h,p,d);if(o>u)continue;p.applyMatrix4(this.matrixWorld);let l=n.ray.origin.distanceTo(p);l<n.near||l>n.far||r.push({distance:l,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:d.clone().applyMatrix4(this.matrixWorld),index:s,face:null,faceIndex:null,object:this})}}else{let i=Math.max(0,o.start),a=Math.min(_.count,o.start+o.count);for(let s=i,o=a-1;s<o;s+=f){c.fromBufferAttribute(_,s),h.fromBufferAttribute(_,s+1);let i=$d5b33d7c30034067$var$_ray$1.distanceSqToSegment(c,h,p,d);if(i>u)continue;p.applyMatrix4(this.matrixWorld);let a=n.ray.origin.distanceTo(p);a<n.near||a>n.far||r.push({distance:a,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:d.clone().applyMatrix4(this.matrixWorld),index:s,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){let n=this.geometry,r=n.morphAttributes,i=Object.keys(r);if(i.length>0){let n=r[i[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,i=n.length;r<i;r++){let i=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=r}}}}}const $d5b33d7c30034067$var$_start=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_end=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$ff1ed10fedfdd604 extends $d5b33d7c30034067$export$17d680238e50603e{constructor(n,r){super(n,r),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){let n=this.geometry;// we assume non-indexed geometry
if(null===n.index){let r=n.attributes.position,i=[];for(let n=0,a=r.count;n<a;n+=2)$d5b33d7c30034067$var$_start.fromBufferAttribute(r,n),$d5b33d7c30034067$var$_end.fromBufferAttribute(r,n+1),i[n]=0===n?0:i[n-1],i[n+1]=i[n]+$d5b33d7c30034067$var$_start.distanceTo($d5b33d7c30034067$var$_end);n.setAttribute("lineDistance",new $d5b33d7c30034067$export$cbe7a62641830ebd(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class $d5b33d7c30034067$export$f85a24d745e4f17d extends $d5b33d7c30034067$export$17d680238e50603e{constructor(n,r){super(n,r),this.isLineLoop=!0,this.type="LineLoop"}}class $d5b33d7c30034067$export$a178c45366ce5d6b extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(n)}copy(n){return super.copy(n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.size=n.size,this.sizeAttenuation=n.sizeAttenuation,this.fog=n.fog,this}}const $d5b33d7c30034067$var$_inverseMatrix=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_ray=/*@__PURE__*/new $d5b33d7c30034067$export$a186db52eed6d40e,$d5b33d7c30034067$var$_sphere=/*@__PURE__*/new $d5b33d7c30034067$export$805e8b72413ccaba,$d5b33d7c30034067$var$_position$2=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$1c787534cb11aa3e extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(n=new $d5b33d7c30034067$export$b7be63a67df8959,r=new $d5b33d7c30034067$export$a178c45366ce5d6b){super(),this.isPoints=!0,this.type="Points",this.geometry=n,this.material=r,this.updateMorphTargets()}copy(n,r){return super.copy(n,r),this.material=Array.isArray(n.material)?n.material.slice():n.material,this.geometry=n.geometry,this}raycast(n,r){let i=this.geometry,a=this.matrixWorld,s=n.params.Points.threshold,o=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),$d5b33d7c30034067$var$_sphere.copy(i.boundingSphere),$d5b33d7c30034067$var$_sphere.applyMatrix4(a),$d5b33d7c30034067$var$_sphere.radius+=s,!1===n.ray.intersectsSphere($d5b33d7c30034067$var$_sphere))return;//
$d5b33d7c30034067$var$_inverseMatrix.copy(a).invert(),$d5b33d7c30034067$var$_ray.copy(n.ray).applyMatrix4($d5b33d7c30034067$var$_inverseMatrix);let l=s/((this.scale.x+this.scale.y+this.scale.z)/3),u=l*l,c=i.index,h=i.attributes,d=h.position;if(null!==c){let i=Math.max(0,o.start),s=Math.min(c.count,o.start+o.count);for(let o=i,l=s;o<l;o++){let i=c.getX(o);$d5b33d7c30034067$var$_position$2.fromBufferAttribute(d,i),$d5b33d7c30034067$var$testPoint($d5b33d7c30034067$var$_position$2,i,u,a,n,r,this)}}else{let i=Math.max(0,o.start),s=Math.min(d.count,o.start+o.count);for(let o=i,l=s;o<l;o++)$d5b33d7c30034067$var$_position$2.fromBufferAttribute(d,o),$d5b33d7c30034067$var$testPoint($d5b33d7c30034067$var$_position$2,o,u,a,n,r,this)}}updateMorphTargets(){let n=this.geometry,r=n.morphAttributes,i=Object.keys(r);if(i.length>0){let n=r[i[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,i=n.length;r<i;r++){let i=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=r}}}}}function $d5b33d7c30034067$var$testPoint(n,r,i,a,s,o,l){let u=$d5b33d7c30034067$var$_ray.distanceSqToPoint(n);if(u<i){let i=new $d5b33d7c30034067$export$64b5c384219d3699;$d5b33d7c30034067$var$_ray.closestPointToPoint(n,i),i.applyMatrix4(a);let c=s.ray.origin.distanceTo(i);if(c<s.near||c>s.far)return;o.push({distance:c,distanceToRay:Math.sqrt(u),point:i,index:r,face:null,object:l})}}class $d5b33d7c30034067$export$6e09d1edf8d5a25c extends $d5b33d7c30034067$export$5431306cf43de24a{constructor(n,r,i,a,s,o,l,u,c){super(n,r,i,a,s,o,l,u,c),this.isVideoTexture=!0,this.minFilter=void 0!==o?o:$d5b33d7c30034067$export$8a72f490b25c56c8,this.magFilter=void 0!==s?s:$d5b33d7c30034067$export$8a72f490b25c56c8,this.generateMipmaps=!1;let h=this;function d(){h.needsUpdate=!0,n.requestVideoFrameCallback(d)}"requestVideoFrameCallback"in n&&n.requestVideoFrameCallback(d)}clone(){return new this.constructor(this.image).copy(this)}update(){let n=this.image,r="requestVideoFrameCallback"in n;!1===r&&n.readyState>=n.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class $d5b33d7c30034067$export$9270d786f73ce6fe extends $d5b33d7c30034067$export$5431306cf43de24a{constructor(n,r){super({width:n,height:r}),this.isFramebufferTexture=!0,this.magFilter=$d5b33d7c30034067$export$727aa5ec3fe39bf0,this.minFilter=$d5b33d7c30034067$export$727aa5ec3fe39bf0,this.generateMipmaps=!1,this.needsUpdate=!0}}class $d5b33d7c30034067$export$3466bac9141a5cc4 extends $d5b33d7c30034067$export$5431306cf43de24a{constructor(n,r,i,a,s,o,l,u,c,h,d,p){super(null,o,l,u,c,h,a,s,d,p),this.isCompressedTexture=!0,this.image={width:r,height:i},this.mipmaps=n,// no flipping for cube textures
// (also flipping doesn't work for compressed textures )
this.flipY=!1,// can't generate mipmaps for compressed textures
// mips must be embedded in DDS files
this.generateMipmaps=!1}}class $d5b33d7c30034067$export$5fe6b8e34b274fcb extends $d5b33d7c30034067$export$3466bac9141a5cc4{constructor(n,r,i,a,s,o){super(n,r,i,s,o),this.isCompressedArrayTexture=!0,this.image.depth=a,this.wrapR=$d5b33d7c30034067$export$9d9334239a5a5e06}}class $d5b33d7c30034067$export$d80173634de65bff extends $d5b33d7c30034067$export$3466bac9141a5cc4{constructor(n,r,i){super(void 0,n[0].width,n[0].height,r,i,$d5b33d7c30034067$export$8759762a6477f2c4),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=n}}class $d5b33d7c30034067$export$f7189e49152d1c13 extends $d5b33d7c30034067$export$5431306cf43de24a{constructor(n,r,i,a,s,o,l,u,c){super(n,r,i,a,s,o,l,u,c),this.isCanvasTexture=!0,this.needsUpdate=!0}}/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/class $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(){this.type="Curve",this.arcLengthDivisions=200}// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]
getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}// Get point at relative position in curve according to arc length
// - u [0 .. 1]
getPointAt(n,r){let i=this.getUtoTmapping(n);return this.getPoint(i,r)}// Get sequence of points using getPoint( t )
getPoints(n=5){let r=[];for(let i=0;i<=n;i++)r.push(this.getPoint(i/n));return r}// Get sequence of points using getPointAt( u )
getSpacedPoints(n=5){let r=[];for(let i=0;i<=n;i++)r.push(this.getPointAt(i/n));return r}// Get total curve arc length
getLength(){let n=this.getLengths();return n[n.length-1]}// Get list of cumulative segment lengths
getLengths(n=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===n+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;let r=[],i,a=this.getPoint(0),s=0;r.push(0);for(let o=1;o<=n;o++)r.push(s+=(i=this.getPoint(o/n)).distanceTo(a)),a=i;return this.cacheArcLengths=r,r;// { sums: cache, sum: sum }; Sum is in the last element.
}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
getUtoTmapping(n,r){let i;let a=this.getLengths(),s=0,o=a.length;i=r||n*a[o-1];// binary search for the index with largest value smaller than target u distance
let l=0,u=o-1,c;for(;l<=u;)if((c=a[s=Math.floor(l+(u-l)/2)]-i)<0)l=s+1;else if(c>0)u=s-1;else{u=s;break;// DONE
}if(a[s=u]===i)return s/(o-1);// we could get finer grain at lengths, or use simple interpolation between two points
let h=a[s],d=a[s+1],p=d-h,f=(i-h)/p,m=(s+f)/(o-1);return m}// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation
getTangent(n,r){let i=1e-4,a=n-i,s=n+i;a<0&&(a=0),s>1&&(s=1);let o=this.getPoint(a),l=this.getPoint(s),u=r||(o.isVector2?new $d5b33d7c30034067$export$c977b3e384af9ae1:new $d5b33d7c30034067$export$64b5c384219d3699);return u.copy(l).sub(o).normalize(),u}getTangentAt(n,r){let i=this.getUtoTmapping(n);return this.getTangent(i,r)}computeFrenetFrames(n,r){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
let i=new $d5b33d7c30034067$export$64b5c384219d3699,a=[],s=[],o=[],l=new $d5b33d7c30034067$export$64b5c384219d3699,u=new $d5b33d7c30034067$export$2ae72fc923e5eb5;// compute the tangent vectors for each segment on the curve
for(let r=0;r<=n;r++){let i=r/n;a[r]=this.getTangentAt(i,new $d5b33d7c30034067$export$64b5c384219d3699)}// select an initial normal vector perpendicular to the first tangent vector,
// and in the direction of the minimum tangent xyz component
s[0]=new $d5b33d7c30034067$export$64b5c384219d3699,o[0]=new $d5b33d7c30034067$export$64b5c384219d3699;let c=Number.MAX_VALUE,h=Math.abs(a[0].x),d=Math.abs(a[0].y),p=Math.abs(a[0].z);h<=c&&(c=h,i.set(1,0,0)),d<=c&&(c=d,i.set(0,1,0)),p<=c&&i.set(0,0,1),l.crossVectors(a[0],i).normalize(),s[0].crossVectors(a[0],l),o[0].crossVectors(a[0],s[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
for(let r=1;r<=n;r++){if(s[r]=s[r-1].clone(),o[r]=o[r-1].clone(),l.crossVectors(a[r-1],a[r]),l.length()>Number.EPSILON){l.normalize();let n=Math.acos($d5b33d7c30034067$var$clamp(a[r-1].dot(a[r]),-1,1));// clamp for floating pt errors
s[r].applyMatrix4(u.makeRotationAxis(l,n))}o[r].crossVectors(a[r],s[r])}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
if(!0===r){let r=Math.acos($d5b33d7c30034067$var$clamp(s[0].dot(s[n]),-1,1));r/=n,a[0].dot(l.crossVectors(s[0],s[n]))>0&&(r=-r);for(let i=1;i<=n;i++)// twist a little...
s[i].applyMatrix4(u.makeRotationAxis(a[i],r*i)),o[i].crossVectors(a[i],s[i])}return{tangents:a,normals:s,binormals:o}}clone(){return new this.constructor().copy(this)}copy(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}toJSON(){let n={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return n.arcLengthDivisions=this.arcLengthDivisions,n.type=this.type,n}fromJSON(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}}class $d5b33d7c30034067$export$3f87a931616cde04 extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(n=0,r=0,i=1,a=1,s=0,o=2*Math.PI,l=!1,u=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=n,this.aY=r,this.xRadius=i,this.yRadius=a,this.aStartAngle=s,this.aEndAngle=o,this.aClockwise=l,this.aRotation=u}getPoint(n,r){let i=r||new $d5b33d7c30034067$export$c977b3e384af9ae1,a=2*Math.PI,s=this.aEndAngle-this.aStartAngle,o=Math.abs(s)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI
for(;s<0;)s+=a;for(;s>a;)s-=a;s<Number.EPSILON&&(s=o?0:a),!0!==this.aClockwise||o||(s===a?s=-a:s-=a);let l=this.aStartAngle+n*s,u=this.aX+this.xRadius*Math.cos(l),c=this.aY+this.yRadius*Math.sin(l);if(0!==this.aRotation){let n=Math.cos(this.aRotation),r=Math.sin(this.aRotation),i=u-this.aX,a=c-this.aY;// Rotate the point about the center of the ellipse.
u=i*n-a*r+this.aX,c=i*r+a*n+this.aY}return i.set(u,c)}copy(n){return super.copy(n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this}toJSON(){let n=super.toJSON();return n.aX=this.aX,n.aY=this.aY,n.xRadius=this.xRadius,n.yRadius=this.yRadius,n.aStartAngle=this.aStartAngle,n.aEndAngle=this.aEndAngle,n.aClockwise=this.aClockwise,n.aRotation=this.aRotation,n}fromJSON(n){return super.fromJSON(n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this}}class $d5b33d7c30034067$export$b1eedc9aab6300e8 extends $d5b33d7c30034067$export$3f87a931616cde04{constructor(n,r,i,a,s,o){super(n,r,i,i,a,s,o),this.isArcCurve=!0,this.type="ArcCurve"}}/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 *//*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/function $d5b33d7c30034067$var$CubicPoly(){let n=0,r=0,i=0,a=0;/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */function s(s,o,l,u){n=s,r=l,i=-3*s+3*o-2*l-u,a=2*s-2*o+l+u}return{initCatmullRom:function(n,r,i,a,o){s(r,i,o*(i-n),o*(a-r))},initNonuniformCatmullRom:function(n,r,i,a,o,l,u){// compute tangents when parameterized in [t1,t2]
let c=(r-n)/o-(i-n)/(o+l)+(i-r)/l,h=(i-r)/l-(a-r)/(l+u)+(a-i)/u;s(r,i,// rescale tangents for parametrization in [0,1]
c*=l,h*=l)},calc:function(s){let o=s*s,l=o*s;return n+r*s+i*o+a*l}}}//
const $d5b33d7c30034067$var$tmp=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$px=/*@__PURE__*/new $d5b33d7c30034067$var$CubicPoly,$d5b33d7c30034067$var$py=/*@__PURE__*/new $d5b33d7c30034067$var$CubicPoly,$d5b33d7c30034067$var$pz=/*@__PURE__*/new $d5b33d7c30034067$var$CubicPoly;class $d5b33d7c30034067$export$b9146b27c24b744c extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(n=[],r=!1,i="centripetal",a=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=n,this.closed=r,this.curveType=i,this.tension=a}getPoint(n,r=new $d5b33d7c30034067$export$64b5c384219d3699){let i,a;let s=r,o=this.points,l=o.length,u=(l-(this.closed?0:1))*n,c=Math.floor(u),h=u-c;this.closed?c+=c>0?0:(Math.floor(Math.abs(c)/l)+1)*l:0===h&&c===l-1&&(c=l-2,h=1),this.closed||c>0?i=o[(c-1)%l]:(// extrapolate first point
$d5b33d7c30034067$var$tmp.subVectors(o[0],o[1]).add(o[0]),i=$d5b33d7c30034067$var$tmp);let d=o[c%l],p=o[(c+1)%l];if(this.closed||c+2<l?a=o[(c+2)%l]:(// extrapolate last point
$d5b33d7c30034067$var$tmp.subVectors(o[l-1],o[l-2]).add(o[l-1]),a=$d5b33d7c30034067$var$tmp),"centripetal"===this.curveType||"chordal"===this.curveType){// init Centripetal / Chordal Catmull-Rom
let n="chordal"===this.curveType?.5:.25,r=Math.pow(i.distanceToSquared(d),n),s=Math.pow(d.distanceToSquared(p),n),o=Math.pow(p.distanceToSquared(a),n);s<1e-4&&(s=1),r<1e-4&&(r=s),o<1e-4&&(o=s),$d5b33d7c30034067$var$px.initNonuniformCatmullRom(i.x,d.x,p.x,a.x,r,s,o),$d5b33d7c30034067$var$py.initNonuniformCatmullRom(i.y,d.y,p.y,a.y,r,s,o),$d5b33d7c30034067$var$pz.initNonuniformCatmullRom(i.z,d.z,p.z,a.z,r,s,o)}else"catmullrom"===this.curveType&&($d5b33d7c30034067$var$px.initCatmullRom(i.x,d.x,p.x,a.x,this.tension),$d5b33d7c30034067$var$py.initCatmullRom(i.y,d.y,p.y,a.y,this.tension),$d5b33d7c30034067$var$pz.initCatmullRom(i.z,d.z,p.z,a.z,this.tension));return s.set($d5b33d7c30034067$var$px.calc(h),$d5b33d7c30034067$var$py.calc(h),$d5b33d7c30034067$var$pz.calc(h)),s}copy(n){super.copy(n),this.points=[];for(let r=0,i=n.points.length;r<i;r++){let i=n.points[r];this.points.push(i.clone())}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this}toJSON(){let n=super.toJSON();n.points=[];for(let r=0,i=this.points.length;r<i;r++){let i=this.points[r];n.points.push(i.toArray())}return n.closed=this.closed,n.curveType=this.curveType,n.tension=this.tension,n}fromJSON(n){super.fromJSON(n),this.points=[];for(let r=0,i=n.points.length;r<i;r++){let i=n.points[r];this.points.push(new $d5b33d7c30034067$export$64b5c384219d3699().fromArray(i))}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this}}/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */function $d5b33d7c30034067$var$CatmullRom(n,r,i,a,s){let o=(a-r)*.5,l=(s-i)*.5,u=n*n,c=n*u;return(2*i-2*a+o+l)*c+(-3*i+3*a-2*o-l)*u+o*n+i}//
function $d5b33d7c30034067$var$QuadraticBezierP0(n,r){let i=1-n;return i*i*r}function $d5b33d7c30034067$var$QuadraticBezierP1(n,r){return 2*(1-n)*n*r}function $d5b33d7c30034067$var$QuadraticBezierP2(n,r){return n*n*r}function $d5b33d7c30034067$var$QuadraticBezier(n,r,i,a){return $d5b33d7c30034067$var$QuadraticBezierP0(n,r)+$d5b33d7c30034067$var$QuadraticBezierP1(n,i)+$d5b33d7c30034067$var$QuadraticBezierP2(n,a)}//
function $d5b33d7c30034067$var$CubicBezierP0(n,r){let i=1-n;return i*i*i*r}function $d5b33d7c30034067$var$CubicBezierP1(n,r){let i=1-n;return 3*i*i*n*r}function $d5b33d7c30034067$var$CubicBezierP2(n,r){return 3*(1-n)*n*n*r}function $d5b33d7c30034067$var$CubicBezierP3(n,r){return n*n*n*r}function $d5b33d7c30034067$var$CubicBezier(n,r,i,a,s){return $d5b33d7c30034067$var$CubicBezierP0(n,r)+$d5b33d7c30034067$var$CubicBezierP1(n,i)+$d5b33d7c30034067$var$CubicBezierP2(n,a)+$d5b33d7c30034067$var$CubicBezierP3(n,s)}class $d5b33d7c30034067$export$e36650d36468bb39 extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(n=new $d5b33d7c30034067$export$c977b3e384af9ae1,r=new $d5b33d7c30034067$export$c977b3e384af9ae1,i=new $d5b33d7c30034067$export$c977b3e384af9ae1,a=new $d5b33d7c30034067$export$c977b3e384af9ae1){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=n,this.v1=r,this.v2=i,this.v3=a}getPoint(n,r=new $d5b33d7c30034067$export$c977b3e384af9ae1){let i=r,a=this.v0,s=this.v1,o=this.v2,l=this.v3;return i.set($d5b33d7c30034067$var$CubicBezier(n,a.x,s.x,o.x,l.x),$d5b33d7c30034067$var$CubicBezier(n,a.y,s.y,o.y,l.y)),i}copy(n){return super.copy(n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this}toJSON(){let n=super.toJSON();return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n}fromJSON(n){return super.fromJSON(n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this}}class $d5b33d7c30034067$export$13d5f1c9525f246c extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(n=new $d5b33d7c30034067$export$64b5c384219d3699,r=new $d5b33d7c30034067$export$64b5c384219d3699,i=new $d5b33d7c30034067$export$64b5c384219d3699,a=new $d5b33d7c30034067$export$64b5c384219d3699){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=n,this.v1=r,this.v2=i,this.v3=a}getPoint(n,r=new $d5b33d7c30034067$export$64b5c384219d3699){let i=r,a=this.v0,s=this.v1,o=this.v2,l=this.v3;return i.set($d5b33d7c30034067$var$CubicBezier(n,a.x,s.x,o.x,l.x),$d5b33d7c30034067$var$CubicBezier(n,a.y,s.y,o.y,l.y),$d5b33d7c30034067$var$CubicBezier(n,a.z,s.z,o.z,l.z)),i}copy(n){return super.copy(n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this}toJSON(){let n=super.toJSON();return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n}fromJSON(n){return super.fromJSON(n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this}}class $d5b33d7c30034067$export$ab2e07e76531a47e extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(n=new $d5b33d7c30034067$export$c977b3e384af9ae1,r=new $d5b33d7c30034067$export$c977b3e384af9ae1){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=n,this.v2=r}getPoint(n,r=new $d5b33d7c30034067$export$c977b3e384af9ae1){let i=r;return 1===n?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(n).add(this.v1)),i}// Line curve is linear, so we can overwrite default getPointAt
getPointAt(n,r){return this.getPoint(n,r)}getTangent(n,r=new $d5b33d7c30034067$export$c977b3e384af9ae1){return r.subVectors(this.v2,this.v1).normalize()}getTangentAt(n,r){return this.getTangent(n,r)}copy(n){return super.copy(n),this.v1.copy(n.v1),this.v2.copy(n.v2),this}toJSON(){let n=super.toJSON();return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}fromJSON(n){return super.fromJSON(n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}class $d5b33d7c30034067$export$1fdfd9d9cf487600 extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(n=new $d5b33d7c30034067$export$64b5c384219d3699,r=new $d5b33d7c30034067$export$64b5c384219d3699){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=n,this.v2=r}getPoint(n,r=new $d5b33d7c30034067$export$64b5c384219d3699){let i=r;return 1===n?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(n).add(this.v1)),i}// Line curve is linear, so we can overwrite default getPointAt
getPointAt(n,r){return this.getPoint(n,r)}getTangent(n,r=new $d5b33d7c30034067$export$64b5c384219d3699){return r.subVectors(this.v2,this.v1).normalize()}getTangentAt(n,r){return this.getTangent(n,r)}copy(n){return super.copy(n),this.v1.copy(n.v1),this.v2.copy(n.v2),this}toJSON(){let n=super.toJSON();return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}fromJSON(n){return super.fromJSON(n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}class $d5b33d7c30034067$export$5938c4ee491a43ad extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(n=new $d5b33d7c30034067$export$c977b3e384af9ae1,r=new $d5b33d7c30034067$export$c977b3e384af9ae1,i=new $d5b33d7c30034067$export$c977b3e384af9ae1){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=n,this.v1=r,this.v2=i}getPoint(n,r=new $d5b33d7c30034067$export$c977b3e384af9ae1){let i=r,a=this.v0,s=this.v1,o=this.v2;return i.set($d5b33d7c30034067$var$QuadraticBezier(n,a.x,s.x,o.x),$d5b33d7c30034067$var$QuadraticBezier(n,a.y,s.y,o.y)),i}copy(n){return super.copy(n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this}toJSON(){let n=super.toJSON();return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}fromJSON(n){return super.fromJSON(n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}class $d5b33d7c30034067$export$bf3f4c7e459f90fc extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(n=new $d5b33d7c30034067$export$64b5c384219d3699,r=new $d5b33d7c30034067$export$64b5c384219d3699,i=new $d5b33d7c30034067$export$64b5c384219d3699){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=n,this.v1=r,this.v2=i}getPoint(n,r=new $d5b33d7c30034067$export$64b5c384219d3699){let i=r,a=this.v0,s=this.v1,o=this.v2;return i.set($d5b33d7c30034067$var$QuadraticBezier(n,a.x,s.x,o.x),$d5b33d7c30034067$var$QuadraticBezier(n,a.y,s.y,o.y),$d5b33d7c30034067$var$QuadraticBezier(n,a.z,s.z,o.z)),i}copy(n){return super.copy(n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this}toJSON(){let n=super.toJSON();return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}fromJSON(n){return super.fromJSON(n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}class $d5b33d7c30034067$export$d3bdd77da77afc1b extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(n=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=n}getPoint(n,r=new $d5b33d7c30034067$export$c977b3e384af9ae1){let i=r,a=this.points,s=(a.length-1)*n,o=Math.floor(s),l=s-o,u=a[0===o?o:o-1],c=a[o],h=a[o>a.length-2?a.length-1:o+1],d=a[o>a.length-3?a.length-1:o+2];return i.set($d5b33d7c30034067$var$CatmullRom(l,u.x,c.x,h.x,d.x),$d5b33d7c30034067$var$CatmullRom(l,u.y,c.y,h.y,d.y)),i}copy(n){super.copy(n),this.points=[];for(let r=0,i=n.points.length;r<i;r++){let i=n.points[r];this.points.push(i.clone())}return this}toJSON(){let n=super.toJSON();n.points=[];for(let r=0,i=this.points.length;r<i;r++){let i=this.points[r];n.points.push(i.toArray())}return n}fromJSON(n){super.fromJSON(n),this.points=[];for(let r=0,i=n.points.length;r<i;r++){let i=n.points[r];this.points.push(new $d5b33d7c30034067$export$c977b3e384af9ae1().fromArray(i))}return this}}var $d5b33d7c30034067$var$Curves=/*#__PURE__*/Object.freeze({__proto__:null,ArcCurve:$d5b33d7c30034067$export$b1eedc9aab6300e8,CatmullRomCurve3:$d5b33d7c30034067$export$b9146b27c24b744c,CubicBezierCurve:$d5b33d7c30034067$export$e36650d36468bb39,CubicBezierCurve3:$d5b33d7c30034067$export$13d5f1c9525f246c,EllipseCurve:$d5b33d7c30034067$export$3f87a931616cde04,LineCurve:$d5b33d7c30034067$export$ab2e07e76531a47e,LineCurve3:$d5b33d7c30034067$export$1fdfd9d9cf487600,QuadraticBezierCurve:$d5b33d7c30034067$export$5938c4ee491a43ad,QuadraticBezierCurve3:$d5b33d7c30034067$export$bf3f4c7e459f90fc,SplineCurve:$d5b33d7c30034067$export$d3bdd77da77afc1b});/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/class $d5b33d7c30034067$export$4aaf9b66af1bbf2c extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(n){this.curves.push(n)}closePath(){// Add a line curve if start and end of lines are not connected
let n=this.curves[0].getPoint(0),r=this.curves[this.curves.length-1].getPoint(1);n.equals(r)||this.curves.push(new $d5b33d7c30034067$export$ab2e07e76531a47e(r,n))}// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:
// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')
getPoint(n,r){let i=n*this.getLength(),a=this.getCurveLengths(),s=0;// To think about boundaries points.
for(;s<a.length;){if(a[s]>=i){let n=a[s]-i,o=this.curves[s],l=o.getLength(),u=0===l?0:1-n/l;return o.getPointAt(u,r)}s++}return null;// loop where sum != 0, sum > d , sum+1 <d
}// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength
getLength(){let n=this.getCurveLengths();return n[n.length-1]}// cacheLengths must be recalculated.
updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.
getCurveLengths(){// We use cache values if curves and cache array are same length
if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;// Get length of sub-curve
// Push sums into cached array
let n=[],r=0;for(let i=0,a=this.curves.length;i<a;i++)n.push(r+=this.curves[i].getLength());return this.cacheLengths=n,n}getSpacedPoints(n=40){let r=[];for(let i=0;i<=n;i++)r.push(this.getPoint(i/n));return this.autoClose&&r.push(r[0]),r}getPoints(n=12){let r;let i=[];for(let a=0,s=this.curves;a<s.length;a++){let o=s[a],l=o.isEllipseCurve?2*n:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?n*o.points.length:n,u=o.getPoints(l);for(let n=0;n<u.length;n++){let a=u[n];r&&r.equals(a)||(i.push(a),r=a);// ensures no consecutive points are duplicates
}}return this.autoClose&&i.length>1&&!i[i.length-1].equals(i[0])&&i.push(i[0]),i}copy(n){super.copy(n),this.curves=[];for(let r=0,i=n.curves.length;r<i;r++){let i=n.curves[r];this.curves.push(i.clone())}return this.autoClose=n.autoClose,this}toJSON(){let n=super.toJSON();n.autoClose=this.autoClose,n.curves=[];for(let r=0,i=this.curves.length;r<i;r++){let i=this.curves[r];n.curves.push(i.toJSON())}return n}fromJSON(n){super.fromJSON(n),this.autoClose=n.autoClose,this.curves=[];for(let r=0,i=n.curves.length;r<i;r++){let i=n.curves[r];this.curves.push(new $d5b33d7c30034067$var$Curves[i.type]().fromJSON(i))}return this}}class $d5b33d7c30034067$export$4b2950bdac9b6ee9 extends $d5b33d7c30034067$export$4aaf9b66af1bbf2c{constructor(n){super(),this.type="Path",this.currentPoint=new $d5b33d7c30034067$export$c977b3e384af9ae1,n&&this.setFromPoints(n)}setFromPoints(n){this.moveTo(n[0].x,n[0].y);for(let r=1,i=n.length;r<i;r++)this.lineTo(n[r].x,n[r].y);return this}moveTo(n,r){return this.currentPoint.set(n,r),this}lineTo(n,r){let i=new $d5b33d7c30034067$export$ab2e07e76531a47e(this.currentPoint.clone(),new $d5b33d7c30034067$export$c977b3e384af9ae1(n,r));return this.curves.push(i),this.currentPoint.set(n,r),this}quadraticCurveTo(n,r,i,a){let s=new $d5b33d7c30034067$export$5938c4ee491a43ad(this.currentPoint.clone(),new $d5b33d7c30034067$export$c977b3e384af9ae1(n,r),new $d5b33d7c30034067$export$c977b3e384af9ae1(i,a));return this.curves.push(s),this.currentPoint.set(i,a),this}bezierCurveTo(n,r,i,a,s,o){let l=new $d5b33d7c30034067$export$e36650d36468bb39(this.currentPoint.clone(),new $d5b33d7c30034067$export$c977b3e384af9ae1(n,r),new $d5b33d7c30034067$export$c977b3e384af9ae1(i,a),new $d5b33d7c30034067$export$c977b3e384af9ae1(s,o));return this.curves.push(l),this.currentPoint.set(s,o),this}splineThru(n/*Array of Vector*/){let r=[this.currentPoint.clone()].concat(n),i=new $d5b33d7c30034067$export$d3bdd77da77afc1b(r);return this.curves.push(i),this.currentPoint.copy(n[n.length-1]),this}arc(n,r,i,a,s,o){let l=this.currentPoint.x,u=this.currentPoint.y;return this.absarc(n+l,r+u,i,a,s,o),this}absarc(n,r,i,a,s,o){return this.absellipse(n,r,i,i,a,s,o),this}ellipse(n,r,i,a,s,o,l,u){let c=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(n+c,r+h,i,a,s,o,l,u),this}absellipse(n,r,i,a,s,o,l,u){let c=new $d5b33d7c30034067$export$3f87a931616cde04(n,r,i,a,s,o,l,u);if(this.curves.length>0){// if a previous curve is present, attempt to join
let n=c.getPoint(0);n.equals(this.currentPoint)||this.lineTo(n.x,n.y)}this.curves.push(c);let h=c.getPoint(1);return this.currentPoint.copy(h),this}copy(n){return super.copy(n),this.currentPoint.copy(n.currentPoint),this}toJSON(){let n=super.toJSON();return n.currentPoint=this.currentPoint.toArray(),n}fromJSON(n){return super.fromJSON(n),this.currentPoint.fromArray(n.currentPoint),this}}class $d5b33d7c30034067$export$6d839803fcd1882c extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=[new $d5b33d7c30034067$export$c977b3e384af9ae1(0,-.5),new $d5b33d7c30034067$export$c977b3e384af9ae1(.5,0),new $d5b33d7c30034067$export$c977b3e384af9ae1(0,.5)],r=12,i=0,a=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:n,segments:r,phiStart:i,phiLength:a},r=Math.floor(r),// clamp phiLength so it's in range of [ 0, 2PI ]
a=$d5b33d7c30034067$var$clamp(a,0,2*Math.PI);// buffers
let s=[],o=[],l=[],u=[],c=[],h=1/r,d=new $d5b33d7c30034067$export$64b5c384219d3699,p=new $d5b33d7c30034067$export$c977b3e384af9ae1,f=new $d5b33d7c30034067$export$64b5c384219d3699,m=new $d5b33d7c30034067$export$64b5c384219d3699,g=new $d5b33d7c30034067$export$64b5c384219d3699,_=0,y=0;// pre-compute normals for initial "meridian"
for(let r=0;r<=n.length-1;r++)switch(r){case 0:_=n[r+1].x-n[r].x,y=n[r+1].y-n[r].y,f.x=1*y,f.y=-_,f.z=0*y,g.copy(f),f.normalize(),u.push(f.x,f.y,f.z);break;case n.length-1:u.push(g.x,g.y,g.z);break;default:_=n[r+1].x-n[r].x,y=n[r+1].y-n[r].y,f.x=1*y,f.y=-_,f.z=0*y,m.copy(f),f.x+=g.x,f.y+=g.y,f.z+=g.z,f.normalize(),u.push(f.x,f.y,f.z),g.copy(m)}// generate vertices, uvs and normals
for(let s=0;s<=r;s++){let f=i+s*h*a,m=Math.sin(f),g=Math.cos(f);for(let i=0;i<=n.length-1;i++){// vertex
d.x=n[i].x*m,d.y=n[i].y,d.z=n[i].x*g,o.push(d.x,d.y,d.z),// uv
p.x=s/r,p.y=i/(n.length-1),l.push(p.x,p.y);// normal
let a=u[3*i+0]*m,h=u[3*i+1],f=u[3*i+0]*g;c.push(a,h,f)}}// indices
for(let i=0;i<r;i++)for(let r=0;r<n.length-1;r++){let a=r+i*n.length,o=a,l=a+n.length,u=a+n.length+1,c=a+1;// faces
s.push(o,l,c),s.push(u,c,l)}// build geometry
this.setIndex(s),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(o,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(l,2)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(c,3))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}static fromJSON(n){return new $d5b33d7c30034067$export$6d839803fcd1882c(n.points,n.segments,n.phiStart,n.phiLength)}}class $d5b33d7c30034067$export$41680e8551036033 extends $d5b33d7c30034067$export$6d839803fcd1882c{constructor(n=1,r=1,i=4,a=8){let s=new $d5b33d7c30034067$export$4b2950bdac9b6ee9;s.absarc(0,-r/2,n,1.5*Math.PI,0),s.absarc(0,r/2,n,0,.5*Math.PI),super(s.getPoints(i),a),this.type="CapsuleGeometry",this.parameters={radius:n,length:r,capSegments:i,radialSegments:a}}static fromJSON(n){return new $d5b33d7c30034067$export$41680e8551036033(n.radius,n.length,n.capSegments,n.radialSegments)}}class $d5b33d7c30034067$export$d5c0e8d607467193 extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=1,r=32,i=0,a=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:n,segments:r,thetaStart:i,thetaLength:a},r=Math.max(3,r);// buffers
let s=[],o=[],l=[],u=[],c=new $d5b33d7c30034067$export$64b5c384219d3699,h=new $d5b33d7c30034067$export$c977b3e384af9ae1;// center point
o.push(0,0,0),l.push(0,0,1),u.push(.5,.5);for(let s=0,d=3;s<=r;s++,d+=3){let p=i+s/r*a;// vertex
c.x=n*Math.cos(p),c.y=n*Math.sin(p),o.push(c.x,c.y,c.z),// normal
l.push(0,0,1),// uvs
h.x=(o[d]/n+1)/2,h.y=(o[d+1]/n+1)/2,u.push(h.x,h.y)}// indices
for(let n=1;n<=r;n++)s.push(n,n+1,0);// build geometry
this.setIndex(s),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(o,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(l,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(u,2))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}static fromJSON(n){return new $d5b33d7c30034067$export$d5c0e8d607467193(n.radius,n.segments,n.thetaStart,n.thetaLength)}}class $d5b33d7c30034067$export$68f745719dbe5198 extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=1,r=1,i=1,a=32,s=1,o=!1,l=0,u=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:n,radiusBottom:r,height:i,radialSegments:a,heightSegments:s,openEnded:o,thetaStart:l,thetaLength:u};let c=this;a=Math.floor(a),s=Math.floor(s);// buffers
let h=[],d=[],p=[],f=[],m=0,g=[],_=i/2,y=0;function b(i){// save the index of the first center vertex
let s=m,o=new $d5b33d7c30034067$export$c977b3e384af9ae1,g=new $d5b33d7c30034067$export$64b5c384219d3699,b=0,v=!0===i?n:r,x=!0===i?1:-1;// first we generate the center vertex data of the cap.
// because the geometry needs one set of uvs per face,
// we must generate a center vertex per face/segment
for(let n=1;n<=a;n++)// vertex
d.push(0,_*x,0),// normal
p.push(0,x,0),// uv
f.push(.5,.5),// increase index
m++;// save the index of the last center vertex
let w=m;// now we generate the surrounding vertices, normals and uvs
for(let n=0;n<=a;n++){let r=n/a,i=r*u+l,s=Math.cos(i),c=Math.sin(i);// vertex
g.x=v*c,g.y=_*x,g.z=v*s,d.push(g.x,g.y,g.z),// normal
p.push(0,x,0),// uv
o.x=.5*s+.5,o.y=.5*c*x+.5,f.push(o.x,o.y),// increase index
m++}// generate indices
for(let n=0;n<a;n++){let r=s+n,a=w+n;!0===i?h.push(a,a+1,r):h.push(a+1,a,r),b+=3}// add a group to the geometry. this will ensure multi material support
c.addGroup(y,b,!0===i?1:2),// calculate new start value for groups
y+=b}// generate geometry
(function(){let o=new $d5b33d7c30034067$export$64b5c384219d3699,b=new $d5b33d7c30034067$export$64b5c384219d3699,v=0,x=(r-n)/i;// generate vertices, normals and uvs
for(let c=0;c<=s;c++){let h=[],y=c/s,v=y*(r-n)+n;for(let n=0;n<=a;n++){let r=n/a,s=r*u+l,c=Math.sin(s),g=Math.cos(s);// vertex
b.x=v*c,b.y=-y*i+_,b.z=v*g,d.push(b.x,b.y,b.z),// normal
o.set(c,x,g).normalize(),p.push(o.x,o.y,o.z),// uv
f.push(r,1-y),// save index of vertex in respective row
h.push(m++)}// now save vertices of the row in our index array
g.push(h)}// generate indices
for(let n=0;n<a;n++)for(let r=0;r<s;r++){// we use the index array to access the correct indices
let i=g[r][n],a=g[r+1][n],s=g[r+1][n+1],o=g[r][n+1];// faces
h.push(i,a,o),h.push(a,s,o),// update group counter
v+=6}// add a group to the geometry. this will ensure multi material support
c.addGroup(y,v,0),// calculate new start value for groups
y+=v})(),!1===o&&(n>0&&b(!0),r>0&&b(!1)),// build geometry
this.setIndex(h),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(d,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(p,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(f,2))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}static fromJSON(n){return new $d5b33d7c30034067$export$68f745719dbe5198(n.radiusTop,n.radiusBottom,n.height,n.radialSegments,n.heightSegments,n.openEnded,n.thetaStart,n.thetaLength)}}class $d5b33d7c30034067$export$a7a48974f285c9b3 extends $d5b33d7c30034067$export$68f745719dbe5198{constructor(n=1,r=1,i=32,a=1,s=!1,o=0,l=2*Math.PI){super(0,n,r,i,a,s,o,l),this.type="ConeGeometry",this.parameters={radius:n,height:r,radialSegments:i,heightSegments:a,openEnded:s,thetaStart:o,thetaLength:l}}static fromJSON(n){return new $d5b33d7c30034067$export$a7a48974f285c9b3(n.radius,n.height,n.radialSegments,n.heightSegments,n.openEnded,n.thetaStart,n.thetaLength)}}class $d5b33d7c30034067$export$60e57a7d3f20ff65 extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=[],r=[],i=1,a=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:n,indices:r,radius:i,detail:a};// default buffer data
let s=[],o=[];function l(n,r,i,a){let s=a+1,o=[];// construct all of the vertices for this subdivision
for(let a=0;a<=s;a++){o[a]=[];let l=n.clone().lerp(i,a/s),u=r.clone().lerp(i,a/s),c=s-a;for(let n=0;n<=c;n++)0===n&&a===s?o[a][n]=l:o[a][n]=l.clone().lerp(u,n/c)}// construct all of the faces
for(let n=0;n<s;n++)for(let r=0;r<2*(s-n)-1;r++){let i=Math.floor(r/2);r%2==0?(d(o[n][i+1]),d(o[n+1][i]),d(o[n][i])):(d(o[n][i+1]),d(o[n+1][i+1]),d(o[n+1][i]))}}function u(n){let r=new $d5b33d7c30034067$export$64b5c384219d3699;// iterate over the entire buffer and apply the radius to each vertex
for(let i=0;i<s.length;i+=3)r.x=s[i+0],r.y=s[i+1],r.z=s[i+2],r.normalize().multiplyScalar(n),s[i+0]=r.x,s[i+1]=r.y,s[i+2]=r.z}function c(){let n=new $d5b33d7c30034067$export$64b5c384219d3699;for(let r=0;r<s.length;r+=3){n.x=s[r+0],n.y=s[r+1],n.z=s[r+2];let i=g(n)/2/Math.PI+.5,a=_(n)/Math.PI+.5;o.push(i,1-a)}f(),h()}function h(){// handle case when face straddles the seam, see #3269
for(let n=0;n<o.length;n+=6){// uv data of a single face
let r=o[n+0],i=o[n+2],a=o[n+4],s=Math.max(r,i,a),l=Math.min(r,i,a);// 0.9 is somewhat arbitrary
s>.9&&l<.1&&(r<.2&&(o[n+0]+=1),i<.2&&(o[n+2]+=1),a<.2&&(o[n+4]+=1))}}function d(n){s.push(n.x,n.y,n.z)}function p(r,i){let a=3*r;i.x=n[a+0],i.y=n[a+1],i.z=n[a+2]}function f(){let n=new $d5b33d7c30034067$export$64b5c384219d3699,r=new $d5b33d7c30034067$export$64b5c384219d3699,i=new $d5b33d7c30034067$export$64b5c384219d3699,a=new $d5b33d7c30034067$export$64b5c384219d3699,l=new $d5b33d7c30034067$export$c977b3e384af9ae1,u=new $d5b33d7c30034067$export$c977b3e384af9ae1,c=new $d5b33d7c30034067$export$c977b3e384af9ae1;for(let h=0,d=0;h<s.length;h+=9,d+=6){n.set(s[h+0],s[h+1],s[h+2]),r.set(s[h+3],s[h+4],s[h+5]),i.set(s[h+6],s[h+7],s[h+8]),l.set(o[d+0],o[d+1]),u.set(o[d+2],o[d+3]),c.set(o[d+4],o[d+5]),a.copy(n).add(r).add(i).divideScalar(3);let p=g(a);m(l,d+0,n,p),m(u,d+2,r,p),m(c,d+4,i,p)}}function m(n,r,i,a){a<0&&1===n.x&&(o[r]=n.x-1),0===i.x&&0===i.z&&(o[r]=a/2/Math.PI+.5)}// Angle around the Y axis, counter-clockwise when looking from above.
function g(n){return Math.atan2(n.z,-n.x)}// Angle above the XZ plane.
function _(n){return Math.atan2(-n.y,Math.sqrt(n.x*n.x+n.z*n.z))}// the subdivision creates the vertex buffer data
// helper functions
(function(n){let i=new $d5b33d7c30034067$export$64b5c384219d3699,a=new $d5b33d7c30034067$export$64b5c384219d3699,s=new $d5b33d7c30034067$export$64b5c384219d3699;// iterate over all faces and apply a subdivision with the given detail value
for(let o=0;o<r.length;o+=3)// get the vertices of the face
p(r[o+0],i),p(r[o+1],a),p(r[o+2],s),// perform subdivision
l(i,a,s,n)})(a),// all vertices should lie on a conceptual sphere with a given radius
u(i),// finally, create the uv data
c(),// build non-indexed geometry
this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(s,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(s.slice(),3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(o,2)),0===a?this.computeVertexNormals():this.normalizeNormals()}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}static fromJSON(n){return new $d5b33d7c30034067$export$60e57a7d3f20ff65(n.vertices,n.indices,n.radius,n.details)}}class $d5b33d7c30034067$export$c0babfeb8708fc9c extends $d5b33d7c30034067$export$60e57a7d3f20ff65{constructor(n=1,r=0){let i=(1+Math.sqrt(5))/2,a=1/i,s=[// (1, 1, 1)
-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,// (0, 1/, )
0,-a,-i,0,-a,i,0,a,-i,0,a,i,// (1/, , 0)
-a,-i,0,-a,i,0,a,-i,0,a,i,0,// (, 0, 1/)
-i,0,-a,i,0,-a,-i,0,a,i,0,a],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(s,o,n,r),this.type="DodecahedronGeometry",this.parameters={radius:n,detail:r}}static fromJSON(n){return new $d5b33d7c30034067$export$c0babfeb8708fc9c(n.radius,n.detail)}}const $d5b33d7c30034067$var$_v0=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_v1$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_normal=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_triangle=/*@__PURE__*/new $d5b33d7c30034067$export$5a465592bfe74b48;class $d5b33d7c30034067$export$4730b1542707547f extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=null,r=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:n,thresholdAngle:r},null!==n){let i=4,a=Math.pow(10,i),s=Math.cos($d5b33d7c30034067$var$DEG2RAD*r),o=n.getIndex(),l=n.getAttribute("position"),u=o?o.count:l.count,c=[0,0,0],h=["a","b","c"],d=[,,,],p={},f=[];for(let n=0;n<u;n+=3){o?(c[0]=o.getX(n),c[1]=o.getX(n+1),c[2]=o.getX(n+2)):(c[0]=n,c[1]=n+1,c[2]=n+2);let{a:r,b:i,c:u}=$d5b33d7c30034067$var$_triangle;// skip degenerate triangles
if(r.fromBufferAttribute(l,c[0]),i.fromBufferAttribute(l,c[1]),u.fromBufferAttribute(l,c[2]),$d5b33d7c30034067$var$_triangle.getNormal($d5b33d7c30034067$var$_normal),// create hashes for the edge from the vertices
d[0]=`${Math.round(r.x*a)},${Math.round(r.y*a)},${Math.round(r.z*a)}`,d[1]=`${Math.round(i.x*a)},${Math.round(i.y*a)},${Math.round(i.z*a)}`,d[2]=`${Math.round(u.x*a)},${Math.round(u.y*a)},${Math.round(u.z*a)}`,d[0]!==d[1]&&d[1]!==d[2]&&d[2]!==d[0])// iterate over every edge
for(let n=0;n<3;n++){// get the first and next vertex making up the edge
let r=(n+1)%3,i=d[n],a=d[r],o=$d5b33d7c30034067$var$_triangle[h[n]],l=$d5b33d7c30034067$var$_triangle[h[r]],u=`${i}_${a}`,m=`${a}_${i}`;m in p&&p[m]?($d5b33d7c30034067$var$_normal.dot(p[m].normal)<=s&&(f.push(o.x,o.y,o.z),f.push(l.x,l.y,l.z)),p[m]=null):u in p||(p[u]={index0:c[n],index1:c[r],normal:$d5b33d7c30034067$var$_normal.clone()})}}// iterate over all remaining, unmatched edges and add them to the vertex array
for(let n in p)if(p[n]){let{index0:r,index1:i}=p[n];$d5b33d7c30034067$var$_v0.fromBufferAttribute(l,r),$d5b33d7c30034067$var$_v1$1.fromBufferAttribute(l,i),f.push($d5b33d7c30034067$var$_v0.x,$d5b33d7c30034067$var$_v0.y,$d5b33d7c30034067$var$_v0.z),f.push($d5b33d7c30034067$var$_v1$1.x,$d5b33d7c30034067$var$_v1$1.y,$d5b33d7c30034067$var$_v1$1.z)}this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(f,3))}}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}}class $d5b33d7c30034067$export$6428a7f2611ef1fa extends $d5b33d7c30034067$export$4b2950bdac9b6ee9{constructor(n){super(n),this.uuid=$d5b33d7c30034067$var$generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(n){let r=[];for(let i=0,a=this.holes.length;i<a;i++)r[i]=this.holes[i].getPoints(n);return r}// get points of shape and holes (keypoints based on segments parameter)
extractPoints(n){return{shape:this.getPoints(n),holes:this.getPointsHoles(n)}}copy(n){super.copy(n),this.holes=[];for(let r=0,i=n.holes.length;r<i;r++){let i=n.holes[r];this.holes.push(i.clone())}return this}toJSON(){let n=super.toJSON();n.uuid=this.uuid,n.holes=[];for(let r=0,i=this.holes.length;r<i;r++){let i=this.holes[r];n.holes.push(i.toJSON())}return n}fromJSON(n){super.fromJSON(n),this.uuid=n.uuid,this.holes=[];for(let r=0,i=n.holes.length;r<i;r++){let i=n.holes[r];this.holes.push(new $d5b33d7c30034067$export$4b2950bdac9b6ee9().fromJSON(i))}return this}}/**
 * Port from https://github.com/mapbox/earcut (v2.2.4)
 */const $d5b33d7c30034067$var$Earcut={triangulate:function(n,r,i=2){let a,s,o,l,u,c,h;let d=r&&r.length,p=d?r[0]*i:n.length,f=$d5b33d7c30034067$var$linkedList(n,0,p,i,!0),m=[];if(!f||f.next===f.prev)return m;// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(d&&(f=$d5b33d7c30034067$var$eliminateHoles(n,r,f,i)),n.length>80*i){a=o=n[0],s=l=n[1];for(let r=i;r<p;r+=i)u=n[r],c=n[r+1],u<a&&(a=u),c<s&&(s=c),u>o&&(o=u),c>l&&(l=c);h=0!==// minX, minY and invSize are later used to transform coords into integers for z-order calculation
(h=Math.max(o-a,l-s))?32767/h:0}return $d5b33d7c30034067$var$earcutLinked(f,m,i,a,s,h,0),m}};// create a circular doubly linked list from polygon points in the specified winding order
function $d5b33d7c30034067$var$linkedList(n,r,i,a,s){let o,l;if(s===$d5b33d7c30034067$var$signedArea(n,r,i,a)>0)for(o=r;o<i;o+=a)l=$d5b33d7c30034067$var$insertNode(o,n[o],n[o+1],l);else for(o=i-a;o>=r;o-=a)l=$d5b33d7c30034067$var$insertNode(o,n[o],n[o+1],l);return l&&$d5b33d7c30034067$var$equals(l,l.next)&&($d5b33d7c30034067$var$removeNode(l),l=l.next),l}// eliminate colinear or duplicate points
function $d5b33d7c30034067$var$filterPoints(n,r){if(!n)return n;r||(r=n);let i=n,a;do if(a=!1,!i.steiner&&($d5b33d7c30034067$var$equals(i,i.next)||0===$d5b33d7c30034067$var$area(i.prev,i,i.next))){if($d5b33d7c30034067$var$removeNode(i),(i=r=i.prev)===i.next)break;a=!0}else i=i.next;while(a||i!==r)return r}// main ear slicing loop which triangulates a polygon (given as a linked list)
function $d5b33d7c30034067$var$earcutLinked(n,r,i,a,s,o,l){if(!n)return;// interlink polygon nodes in z-order
!l&&o&&$d5b33d7c30034067$var$indexCurve(n,a,s,o);let u=n,c,h;// iterate through ears, slicing them one by one
for(;n.prev!==n.next;){if(c=n.prev,h=n.next,o?$d5b33d7c30034067$var$isEarHashed(n,a,s,o):$d5b33d7c30034067$var$isEar(n)){// cut off the triangle
r.push(c.i/i|0),r.push(n.i/i|0),r.push(h.i/i|0),$d5b33d7c30034067$var$removeNode(n),// skipping the next vertex leads to less sliver triangles
n=h.next,u=h.next;continue}// if we looped through the whole remaining polygon and can't find any more ears
if((n=h)===u){// try filtering points and slicing again
l?1===l?$d5b33d7c30034067$var$earcutLinked(n=$d5b33d7c30034067$var$cureLocalIntersections($d5b33d7c30034067$var$filterPoints(n),r,i),r,i,a,s,o,2):2===l&&$d5b33d7c30034067$var$splitEarcut(n,r,i,a,s,o):$d5b33d7c30034067$var$earcutLinked($d5b33d7c30034067$var$filterPoints(n),r,i,a,s,o,1);break}}}// check whether a polygon node forms a valid ear with adjacent nodes
function $d5b33d7c30034067$var$isEar(n){let r=n.prev,i=n,a=n.next;if($d5b33d7c30034067$var$area(r,i,a)>=0)return!1;// reflex, can't be an ear
// now make sure we don't have other points inside the potential ear
let s=r.x,o=i.x,l=a.x,u=r.y,c=i.y,h=a.y,d=s<o?s<l?s:l:o<l?o:l,p=u<c?u<h?u:h:c<h?c:h,f=s>o?s>l?s:l:o>l?o:l,m=u>c?u>h?u:h:c>h?c:h,g=a.next;for(;g!==r;){if(g.x>=d&&g.x<=f&&g.y>=p&&g.y<=m&&$d5b33d7c30034067$var$pointInTriangle(s,u,o,c,l,h,g.x,g.y)&&$d5b33d7c30034067$var$area(g.prev,g,g.next)>=0)return!1;g=g.next}return!0}function $d5b33d7c30034067$var$isEarHashed(n,r,i,a){let s=n.prev,o=n,l=n.next;if($d5b33d7c30034067$var$area(s,o,l)>=0)return!1;// reflex, can't be an ear
let u=s.x,c=o.x,h=l.x,d=s.y,p=o.y,f=l.y,m=u<c?u<h?u:h:c<h?c:h,g=d<p?d<f?d:f:p<f?p:f,_=u>c?u>h?u:h:c>h?c:h,y=d>p?d>f?d:f:p>f?p:f,b=$d5b33d7c30034067$var$zOrder(m,g,r,i,a),v=$d5b33d7c30034067$var$zOrder(_,y,r,i,a),x=n.prevZ,w=n.nextZ;// look for points inside the triangle in both directions
for(;x&&x.z>=b&&w&&w.z<=v;){if(x.x>=m&&x.x<=_&&x.y>=g&&x.y<=y&&x!==s&&x!==l&&$d5b33d7c30034067$var$pointInTriangle(u,d,c,p,h,f,x.x,x.y)&&$d5b33d7c30034067$var$area(x.prev,x,x.next)>=0||(x=x.prevZ,w.x>=m&&w.x<=_&&w.y>=g&&w.y<=y&&w!==s&&w!==l&&$d5b33d7c30034067$var$pointInTriangle(u,d,c,p,h,f,w.x,w.y)&&$d5b33d7c30034067$var$area(w.prev,w,w.next)>=0))return!1;w=w.nextZ}// look for remaining points in decreasing z-order
for(;x&&x.z>=b;){if(x.x>=m&&x.x<=_&&x.y>=g&&x.y<=y&&x!==s&&x!==l&&$d5b33d7c30034067$var$pointInTriangle(u,d,c,p,h,f,x.x,x.y)&&$d5b33d7c30034067$var$area(x.prev,x,x.next)>=0)return!1;x=x.prevZ}// look for remaining points in increasing z-order
for(;w&&w.z<=v;){if(w.x>=m&&w.x<=_&&w.y>=g&&w.y<=y&&w!==s&&w!==l&&$d5b33d7c30034067$var$pointInTriangle(u,d,c,p,h,f,w.x,w.y)&&$d5b33d7c30034067$var$area(w.prev,w,w.next)>=0)return!1;w=w.nextZ}return!0}// go through all polygon nodes and cure small local self-intersections
function $d5b33d7c30034067$var$cureLocalIntersections(n,r,i){let a=n;do{let s=a.prev,o=a.next.next;!$d5b33d7c30034067$var$equals(s,o)&&$d5b33d7c30034067$var$intersects(s,a,a.next,o)&&$d5b33d7c30034067$var$locallyInside(s,o)&&$d5b33d7c30034067$var$locallyInside(o,s)&&(r.push(s.i/i|0),r.push(a.i/i|0),r.push(o.i/i|0),// remove two nodes involved
$d5b33d7c30034067$var$removeNode(a),$d5b33d7c30034067$var$removeNode(a.next),a=n=o),a=a.next}while(a!==n)return $d5b33d7c30034067$var$filterPoints(a)}// try splitting polygon into two and triangulate them independently
function $d5b33d7c30034067$var$splitEarcut(n,r,i,a,s,o){// look for a valid diagonal that divides the polygon into two
let l=n;do{let n=l.next.next;for(;n!==l.prev;){if(l.i!==n.i&&$d5b33d7c30034067$var$isValidDiagonal(l,n)){// split the polygon in two by the diagonal
let u=$d5b33d7c30034067$var$splitPolygon(l,n);// filter colinear points around the cuts
l=$d5b33d7c30034067$var$filterPoints(l,l.next),u=$d5b33d7c30034067$var$filterPoints(u,u.next),// run earcut on each half
$d5b33d7c30034067$var$earcutLinked(l,r,i,a,s,o,0),$d5b33d7c30034067$var$earcutLinked(u,r,i,a,s,o,0);return}n=n.next}l=l.next}while(l!==n)}// link every hole into the outer loop, producing a single-ring polygon without holes
function $d5b33d7c30034067$var$eliminateHoles(n,r,i,a){let s,o,l,u,c;let h=[];for(s=0,o=r.length;s<o;s++)l=r[s]*a,u=s<o-1?r[s+1]*a:n.length,(c=$d5b33d7c30034067$var$linkedList(n,l,u,a,!1))===c.next&&(c.steiner=!0),h.push($d5b33d7c30034067$var$getLeftmost(c));// process holes from left to right
for(h.sort($d5b33d7c30034067$var$compareX),s=0;s<h.length;s++)i=$d5b33d7c30034067$var$eliminateHole(h[s],i);return i}function $d5b33d7c30034067$var$compareX(n,r){return n.x-r.x}// find a bridge between vertices that connects hole with an outer ring and link it
function $d5b33d7c30034067$var$eliminateHole(n,r){let i=$d5b33d7c30034067$var$findHoleBridge(n,r);if(!i)return r;let a=$d5b33d7c30034067$var$splitPolygon(i,n);return(// filter collinear points around the cuts
$d5b33d7c30034067$var$filterPoints(a,a.next),$d5b33d7c30034067$var$filterPoints(i,i.next))}// David Eberly's algorithm for finding a bridge between hole and outer polygon
function $d5b33d7c30034067$var$findHoleBridge(n,r){let i=r,a=-1/0,s,o=n.x,l=n.y;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(l<=i.y&&l>=i.next.y&&i.next.y!==i.y){let n=i.x+(l-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(n<=o&&n>a&&(a=n,s=i.x<i.next.x?i:i.next,n===o))return s;// hole touches outer segment; pick leftmost endpoint
}i=i.next}while(i!==r)if(!s)return null;// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
let u=s,c=s.x,h=s.y,d=1/0,p;i=s;do o>=i.x&&i.x>=c&&o!==i.x&&$d5b33d7c30034067$var$pointInTriangle(l<h?o:a,l,c,h,l<h?a:o,l,i.x,i.y)&&(p=Math.abs(l-i.y)/(o-i.x),$d5b33d7c30034067$var$locallyInside(i,n)&&(p<d||p===d&&(i.x>s.x||i.x===s.x&&$d5b33d7c30034067$var$sectorContainsSector(s,i)))&&(s=i,d=p)),i=i.next;while(i!==u)return s}// whether sector in vertex m contains sector in vertex p in the same coordinates
function $d5b33d7c30034067$var$sectorContainsSector(n,r){return 0>$d5b33d7c30034067$var$area(n.prev,n,r.prev)&&0>$d5b33d7c30034067$var$area(r.next,n,n.next)}// interlink polygon nodes in z-order
function $d5b33d7c30034067$var$indexCurve(n,r,i,a){let s=n;do 0===s.z&&(s.z=$d5b33d7c30034067$var$zOrder(s.x,s.y,r,i,a)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==n)s.prevZ.nextZ=null,s.prevZ=null,$d5b33d7c30034067$var$sortLinked(s)}// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function $d5b33d7c30034067$var$sortLinked(n){let r,i,a,s,o,l,u,c,h=1;do{for(i=n,n=null,o=null,l=0;i;){for(l++,a=i,u=0,r=0;r<h&&(u++,a=a.nextZ);r++);for(c=h;u>0||c>0&&a;)0!==u&&(0===c||!a||i.z<=a.z)?(s=i,i=i.nextZ,u--):(s=a,a=a.nextZ,c--),o?o.nextZ=s:n=s,s.prevZ=o,o=s;i=a}o.nextZ=null,h*=2}while(l>1)return n}// z-order of a point given coords and inverse of the longer side of data bbox
function $d5b33d7c30034067$var$zOrder(n,r,i,a,s){return(n=((n=((n=((n=(// coords are transformed into non-negative 15-bit integer range
(n=(n-i)*s|0)|n<<8)&16711935)|n<<4)&252645135)|n<<2)&858993459)|n<<1)&1431655765)|(r=((r=((r=((r=((r=(r-a)*s|0)|r<<8)&16711935)|r<<4)&252645135)|r<<2)&858993459)|r<<1)&1431655765)<<1}// find the leftmost node of a polygon ring
function $d5b33d7c30034067$var$getLeftmost(n){let r=n,i=n;do(r.x<i.x||r.x===i.x&&r.y<i.y)&&(i=r),r=r.next;while(r!==n)return i}// check if a point lies within a convex triangle
function $d5b33d7c30034067$var$pointInTriangle(n,r,i,a,s,o,l,u){return(s-l)*(r-u)>=(n-l)*(o-u)&&(n-l)*(a-u)>=(i-l)*(r-u)&&(i-l)*(o-u)>=(s-l)*(a-u)}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function $d5b33d7c30034067$var$isValidDiagonal(n,r){return n.next.i!==r.i&&n.prev.i!==r.i&&!$d5b33d7c30034067$var$intersectsPolygon(n,r)&&// dones't intersect other edges
($d5b33d7c30034067$var$locallyInside(n,r)&&$d5b33d7c30034067$var$locallyInside(r,n)&&$d5b33d7c30034067$var$middleInside(n,r)&&// locally visible
($d5b33d7c30034067$var$area(n.prev,n,r.prev)||$d5b33d7c30034067$var$area(n,r.prev,r))||// does not create opposite-facing sectors
$d5b33d7c30034067$var$equals(n,r)&&$d5b33d7c30034067$var$area(n.prev,n,n.next)>0&&$d5b33d7c30034067$var$area(r.prev,r,r.next)>0);// special zero-length case
}// signed area of a triangle
function $d5b33d7c30034067$var$area(n,r,i){return(r.y-n.y)*(i.x-r.x)-(r.x-n.x)*(i.y-r.y)}// check if two points are equal
function $d5b33d7c30034067$var$equals(n,r){return n.x===r.x&&n.y===r.y}// check if two segments intersect
function $d5b33d7c30034067$var$intersects(n,r,i,a){let s=$d5b33d7c30034067$var$sign($d5b33d7c30034067$var$area(n,r,i)),o=$d5b33d7c30034067$var$sign($d5b33d7c30034067$var$area(n,r,a)),l=$d5b33d7c30034067$var$sign($d5b33d7c30034067$var$area(i,a,n)),u=$d5b33d7c30034067$var$sign($d5b33d7c30034067$var$area(i,a,r));return!!(s!==o&&l!==u||0===s&&$d5b33d7c30034067$var$onSegment(n,i,r)||0===o&&$d5b33d7c30034067$var$onSegment(n,a,r)||0===l&&$d5b33d7c30034067$var$onSegment(i,n,a)||0===u&&$d5b33d7c30034067$var$onSegment(i,r,a))}// for collinear points p, q, r, check if point q lies on segment pr
function $d5b33d7c30034067$var$onSegment(n,r,i){return r.x<=Math.max(n.x,i.x)&&r.x>=Math.min(n.x,i.x)&&r.y<=Math.max(n.y,i.y)&&r.y>=Math.min(n.y,i.y)}function $d5b33d7c30034067$var$sign(n){return n>0?1:n<0?-1:0}// check if a polygon diagonal intersects any polygon segments
function $d5b33d7c30034067$var$intersectsPolygon(n,r){let i=n;do{if(i.i!==n.i&&i.next.i!==n.i&&i.i!==r.i&&i.next.i!==r.i&&$d5b33d7c30034067$var$intersects(i,i.next,n,r))return!0;i=i.next}while(i!==n)return!1}// check if a polygon diagonal is locally inside the polygon
function $d5b33d7c30034067$var$locallyInside(n,r){return 0>$d5b33d7c30034067$var$area(n.prev,n,n.next)?$d5b33d7c30034067$var$area(n,r,n.next)>=0&&$d5b33d7c30034067$var$area(n,n.prev,r)>=0:0>$d5b33d7c30034067$var$area(n,r,n.prev)||0>$d5b33d7c30034067$var$area(n,n.next,r)}// check if the middle point of a polygon diagonal is inside the polygon
function $d5b33d7c30034067$var$middleInside(n,r){let i=n,a=!1,s=(n.x+r.x)/2,o=(n.y+r.y)/2;do i.y>o!=i.next.y>o&&i.next.y!==i.y&&s<(i.next.x-i.x)*(o-i.y)/(i.next.y-i.y)+i.x&&(a=!a),i=i.next;while(i!==n)return a}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function $d5b33d7c30034067$var$splitPolygon(n,r){let i=new $d5b33d7c30034067$var$Node(n.i,n.x,n.y),a=new $d5b33d7c30034067$var$Node(r.i,r.x,r.y),s=n.next,o=r.prev;return n.next=r,r.prev=n,i.next=s,s.prev=i,a.next=i,i.prev=a,o.next=a,a.prev=o,a}// create a node and optionally link it with previous one (in a circular doubly linked list)
function $d5b33d7c30034067$var$insertNode(n,r,i,a){let s=new $d5b33d7c30034067$var$Node(n,r,i);return a?(s.next=a.next,s.prev=a,a.next.prev=s,a.next=s):(s.prev=s,s.next=s),s}function $d5b33d7c30034067$var$removeNode(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function $d5b33d7c30034067$var$Node(n,r,i){// vertex index in coordinates array
this.i=n,// vertex coordinates
this.x=r,this.y=i,// previous and next vertex nodes in a polygon ring
this.prev=null,this.next=null,// z-order curve value
this.z=0,// previous and next nodes in z-order
this.prevZ=null,this.nextZ=null,// indicates whether this is a steiner point
this.steiner=!1}function $d5b33d7c30034067$var$signedArea(n,r,i,a){let s=0;for(let o=r,l=i-a;o<i;o+=a)s+=(n[l]-n[o])*(n[o+1]+n[l+1]),l=o;return s}class $d5b33d7c30034067$export$96bdf6d9c66d7ba8{// calculate area of the contour polygon
static area(n){let r=n.length,i=0;for(let a=r-1,s=0;s<r;a=s++)i+=n[a].x*n[s].y-n[s].x*n[a].y;return .5*i}static isClockWise(n){return 0>$d5b33d7c30034067$export$96bdf6d9c66d7ba8.area(n)}static triangulateShape(n,r){let i=[],a=[],s=[];// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
$d5b33d7c30034067$var$removeDupEndPts(n),$d5b33d7c30034067$var$addContour(i,n);//
let o=n.length;r.forEach($d5b33d7c30034067$var$removeDupEndPts);for(let n=0;n<r.length;n++)a.push(o),o+=r[n].length,$d5b33d7c30034067$var$addContour(i,r[n]);//
let l=$d5b33d7c30034067$var$Earcut.triangulate(i,a);//
for(let n=0;n<l.length;n+=3)s.push(l.slice(n,n+3));return s}}function $d5b33d7c30034067$var$removeDupEndPts(n){let r=n.length;r>2&&n[r-1].equals(n[0])&&n.pop()}function $d5b33d7c30034067$var$addContour(n,r){for(let i=0;i<r.length;i++)n.push(r[i].x),n.push(r[i].y)}/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */class $d5b33d7c30034067$export$598697a1efa63ca7 extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=new $d5b33d7c30034067$export$6428a7f2611ef1fa([new $d5b33d7c30034067$export$c977b3e384af9ae1(.5,.5),new $d5b33d7c30034067$export$c977b3e384af9ae1(-.5,.5),new $d5b33d7c30034067$export$c977b3e384af9ae1(-.5,-.5),new $d5b33d7c30034067$export$c977b3e384af9ae1(.5,-.5)]),r={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:n,options:r},n=Array.isArray(n)?n:[n];let i=this,a=[],s=[];for(let r=0,i=n.length;r<i;r++){let i=n[r];o(i)}// functions
function o(n){let o,l,u,c;let h=[],d=void 0!==r.curveSegments?r.curveSegments:12,p=void 0!==r.steps?r.steps:1,f=void 0!==r.depth?r.depth:1,m=void 0===r.bevelEnabled||r.bevelEnabled,g=void 0!==r.bevelThickness?r.bevelThickness:.2,_=void 0!==r.bevelSize?r.bevelSize:g-.1,y=void 0!==r.bevelOffset?r.bevelOffset:0,b=void 0!==r.bevelSegments?r.bevelSegments:3,v=r.extrudePath,x=void 0!==r.UVGenerator?r.UVGenerator:$d5b33d7c30034067$var$WorldUVGenerator,w,T=!1;v&&(w=v.getSpacedPoints(p),T=!0,m=!1,// SETUP TNB variables
// TODO1 - have a .isClosed in spline?
o=v.computeFrenetFrames(p,!1),// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
l=new $d5b33d7c30034067$export$64b5c384219d3699,u=new $d5b33d7c30034067$export$64b5c384219d3699,c=new $d5b33d7c30034067$export$64b5c384219d3699),m||(b=0,g=0,_=0,y=0);// Variables initialization
let S=n.extractPoints(d),E=S.shape,A=S.holes,M=!$d5b33d7c30034067$export$96bdf6d9c66d7ba8.isClockWise(E);if(M){E=E.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
for(let n=0,r=A.length;n<r;n++){let r=A[n];$d5b33d7c30034067$export$96bdf6d9c66d7ba8.isClockWise(r)&&(A[n]=r.reverse())}}let I=$d5b33d7c30034067$export$96bdf6d9c66d7ba8.triangulateShape(E,A),P=E;for(let n=0,r=A.length;n<r;n++){let r=A[n];E=E.concat(r)}function O(n,r,i){return r||console.error("THREE.ExtrudeGeometry: vec does not exist"),n.clone().addScaledVector(r,i)}let R=E.length,C=I.length;// Find directions for point movement
function L(n,r,i){let a,s,o;// good reading for geometry algorithms (here: line-line intersection)
// http://geomalgorithms.com/a05-_intersect-1.html
let l=n.x-r.x,u=n.y-r.y,c=i.x-n.x,h=i.y-n.y,d=l*l+u*u,p=l*h-u*c;if(Math.abs(p)>Number.EPSILON){// not collinear
// length of vectors for normalizing
let p=Math.sqrt(d),f=Math.sqrt(c*c+h*h),m=r.x-u/p,g=r.y+l/p,_=i.x-h/f,y=i.y+c/f,b=((_-m)*h-(y-g)*c)/(l*h-u*c);// vector from inPt to intersection point
a=m+l*b-n.x,s=g+u*b-n.y;// Don't normalize!, otherwise sharp corners become ugly
//  but prevent crazy spikes
let v=a*a+s*s;if(v<=2)return new $d5b33d7c30034067$export$c977b3e384af9ae1(a,s);o=Math.sqrt(v/2)}else{// handle special case of collinear edges
let n=!1;// assumes: opposite
l>Number.EPSILON?c>Number.EPSILON&&(n=!0):l<-Number.EPSILON?c<-Number.EPSILON&&(n=!0):Math.sign(u)===Math.sign(h)&&(n=!0),n?(// console.log("Warning: lines are a straight sequence");
a=-u,s=l,o=Math.sqrt(d)):(// console.log("Warning: lines are a straight spike");
a=l,s=u,o=Math.sqrt(d/2))}return new $d5b33d7c30034067$export$c977b3e384af9ae1(a/o,s/o)}let D=[];for(let n=0,r=P.length,i=r-1,a=n+1;n<r;n++,i++,a++)i===r&&(i=0),a===r&&(a=0),//  (j)---(i)---(k)
// console.log('i,j,k', i, j , k)
D[n]=L(P[n],P[i],P[a]);let N=[],k,U=D.concat();for(let n=0,r=A.length;n<r;n++){let r=A[n];k=[];for(let n=0,i=r.length,a=i-1,s=n+1;n<i;n++,a++,s++)a===i&&(a=0),s===i&&(s=0),//  (j)---(i)---(k)
k[n]=L(r[n],r[a],r[s]);N.push(k),U=U.concat(k)}// Loop bevelSegments, 1 for the front, 1 for the back
for(let n=0;n<b;n++){//for ( b = bevelSegments; b > 0; b -- ) {
let r=n/b,i=g*Math.cos(r*Math.PI/2),a=_*Math.sin(r*Math.PI/2)+y;// contract shape
for(let n=0,r=P.length;n<r;n++){let r=O(P[n],D[n],a);V(r.x,r.y,-i)}// expand holes
for(let n=0,r=A.length;n<r;n++){let r=A[n];k=N[n];for(let n=0,s=r.length;n<s;n++){let s=O(r[n],k[n],a);V(s.x,s.y,-i)}}}let F=_+y;// Back facing vertices
for(let n=0;n<R;n++){let r=m?O(E[n],U[n],F):E[n];T?(// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
u.copy(o.normals[0]).multiplyScalar(r.x),l.copy(o.binormals[0]).multiplyScalar(r.y),c.copy(w[0]).add(u).add(l),V(c.x,c.y,c.z)):V(r.x,r.y,0)}// Add stepped vertices...
// Including front facing vertices
for(let n=1;n<=p;n++)for(let r=0;r<R;r++){let i=m?O(E[r],U[r],F):E[r];T?(// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
u.copy(o.normals[n]).multiplyScalar(i.x),l.copy(o.binormals[n]).multiplyScalar(i.y),c.copy(w[n]).add(u).add(l),V(c.x,c.y,c.z)):V(i.x,i.y,f/p*n)}// Add bevel segments planes
//for ( b = 1; b <= bevelSegments; b ++ ) {
for(let n=b-1;n>=0;n--){let r=n/b,i=g*Math.cos(r*Math.PI/2),a=_*Math.sin(r*Math.PI/2)+y;// contract shape
for(let n=0,r=P.length;n<r;n++){let r=O(P[n],D[n],a);V(r.x,r.y,f+i)}// expand holes
for(let n=0,r=A.length;n<r;n++){let r=A[n];k=N[n];for(let n=0,s=r.length;n<s;n++){let s=O(r[n],k[n],a);T?V(s.x,s.y+w[p-1].y,w[p-1].x+i):V(s.x,s.y,f+i)}}}// Create faces for the z-sides of the shape
function B(){let n=a.length/3,r=0;z(P,0),r+=P.length;for(let n=0,i=A.length;n<i;n++){let i=A[n];z(i,r),//, true
r+=i.length}i.addGroup(n,a.length/3-n,1)}function z(n,r){let i=n.length;for(;--i>=0;){let a=i,s=i-1;s<0&&(s=n.length-1);//console.log('b', i,j, i-1, k,vertices.length);
for(let n=0,i=p+2*b;n<i;n++){let i=R*n,o=R*(n+1),l=r+a+i,u=r+s+i,c=r+s+o,h=r+a+o;j(l,u,c,h)}}}function V(n,r,i){h.push(n),h.push(r),h.push(i)}function G(n,r,s){H(n),H(r),H(s);let o=a.length/3,l=x.generateTopUV(i,a,o-3,o-2,o-1);$(l[0]),$(l[1]),$(l[2])}function j(n,r,s,o){H(n),H(r),H(o),H(r),H(s),H(o);let l=a.length/3,u=x.generateSideWallUV(i,a,l-6,l-3,l-2,l-1);$(u[0]),$(u[1]),$(u[3]),$(u[1]),$(u[2]),$(u[3])}function H(n){a.push(h[3*n+0]),a.push(h[3*n+1]),a.push(h[3*n+2])}function $(n){s.push(n.x),s.push(n.y)}/* Faces */// Top and bottom faces
/////  Internal functions
(function(){let n=a.length/3;if(m){let n=0,r=0*R;// steps + 1
// Bottom faces
for(let n=0;n<C;n++){let i=I[n];G(i[2]+r,i[1]+r,i[0]+r)}r=R*(n=p+2*b);// Top faces
for(let n=0;n<C;n++){let i=I[n];G(i[0]+r,i[1]+r,i[2]+r)}}else{// Bottom faces
for(let n=0;n<C;n++){let r=I[n];G(r[2],r[1],r[0])}// Top faces
for(let n=0;n<C;n++){let r=I[n];G(r[0]+R*p,r[1]+R*p,r[2]+R*p)}}i.addGroup(n,a.length/3-n,0)})(),// Sides faces
B()}// build geometry
this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(a,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(s,2)),this.computeVertexNormals()}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}toJSON(){let n=super.toJSON(),r=this.parameters.shapes,i=this.parameters.options;return $d5b33d7c30034067$var$toJSON$1(r,i,n)}static fromJSON(n,r){let i=[];for(let a=0,s=n.shapes.length;a<s;a++){let s=r[n.shapes[a]];i.push(s)}let a=n.options.extrudePath;return void 0!==a&&(n.options.extrudePath=new $d5b33d7c30034067$var$Curves[a.type]().fromJSON(a)),new $d5b33d7c30034067$export$598697a1efa63ca7(i,n.options)}}const $d5b33d7c30034067$var$WorldUVGenerator={generateTopUV:function(n,r,i,a,s){let o=r[3*i],l=r[3*i+1],u=r[3*a],c=r[3*a+1],h=r[3*s],d=r[3*s+1];return[new $d5b33d7c30034067$export$c977b3e384af9ae1(o,l),new $d5b33d7c30034067$export$c977b3e384af9ae1(u,c),new $d5b33d7c30034067$export$c977b3e384af9ae1(h,d)]},generateSideWallUV:function(n,r,i,a,s,o){let l=r[3*i],u=r[3*i+1],c=r[3*i+2],h=r[3*a],d=r[3*a+1],p=r[3*a+2],f=r[3*s],m=r[3*s+1],g=r[3*s+2],_=r[3*o],y=r[3*o+1],b=r[3*o+2];return Math.abs(u-d)<Math.abs(l-h)?[new $d5b33d7c30034067$export$c977b3e384af9ae1(l,1-c),new $d5b33d7c30034067$export$c977b3e384af9ae1(h,1-p),new $d5b33d7c30034067$export$c977b3e384af9ae1(f,1-g),new $d5b33d7c30034067$export$c977b3e384af9ae1(_,1-b)]:[new $d5b33d7c30034067$export$c977b3e384af9ae1(u,1-c),new $d5b33d7c30034067$export$c977b3e384af9ae1(d,1-p),new $d5b33d7c30034067$export$c977b3e384af9ae1(m,1-g),new $d5b33d7c30034067$export$c977b3e384af9ae1(y,1-b)]}};function $d5b33d7c30034067$var$toJSON$1(n,r,i){if(i.shapes=[],Array.isArray(n))for(let r=0,a=n.length;r<a;r++){let a=n[r];i.shapes.push(a.uuid)}else i.shapes.push(n.uuid);return i.options=Object.assign({},r),void 0!==r.extrudePath&&(i.options.extrudePath=r.extrudePath.toJSON()),i}class $d5b33d7c30034067$export$9567cc828c9535da extends $d5b33d7c30034067$export$60e57a7d3f20ff65{constructor(n=1,r=0){let i=(1+Math.sqrt(5))/2,a=[-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(a,s,n,r),this.type="IcosahedronGeometry",this.parameters={radius:n,detail:r}}static fromJSON(n){return new $d5b33d7c30034067$export$9567cc828c9535da(n.radius,n.detail)}}class $d5b33d7c30034067$export$1954e2b809fe361e extends $d5b33d7c30034067$export$60e57a7d3f20ff65{constructor(n=1,r=0){let i=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],a=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(i,a,n,r),this.type="OctahedronGeometry",this.parameters={radius:n,detail:r}}static fromJSON(n){return new $d5b33d7c30034067$export$1954e2b809fe361e(n.radius,n.detail)}}class $d5b33d7c30034067$export$68cb731f50f614af extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=.5,r=1,i=32,a=1,s=0,o=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:n,outerRadius:r,thetaSegments:i,phiSegments:a,thetaStart:s,thetaLength:o},i=Math.max(3,i),a=Math.max(1,a);// buffers
let l=[],u=[],c=[],h=[],d=n,p=(r-n)/a,f=new $d5b33d7c30034067$export$64b5c384219d3699,m=new $d5b33d7c30034067$export$c977b3e384af9ae1;// generate vertices, normals and uvs
for(let n=0;n<=a;n++){for(let n=0;n<=i;n++){// values are generate from the inside of the ring to the outside
let a=s+n/i*o;// vertex
f.x=d*Math.cos(a),f.y=d*Math.sin(a),u.push(f.x,f.y,f.z),// normal
c.push(0,0,1),// uv
m.x=(f.x/r+1)/2,m.y=(f.y/r+1)/2,h.push(m.x,m.y)}// increase the radius for next row of vertices
d+=p}// indices
for(let n=0;n<a;n++){let r=n*(i+1);for(let n=0;n<i;n++){let a=n+r,s=a,o=a+i+1,u=a+i+2,c=a+1;// faces
l.push(s,o,c),l.push(o,u,c)}}// build geometry
this.setIndex(l),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(u,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(c,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(h,2))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}static fromJSON(n){return new $d5b33d7c30034067$export$68cb731f50f614af(n.innerRadius,n.outerRadius,n.thetaSegments,n.phiSegments,n.thetaStart,n.thetaLength)}}class $d5b33d7c30034067$export$57a29a1c803e9065 extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=new $d5b33d7c30034067$export$6428a7f2611ef1fa([new $d5b33d7c30034067$export$c977b3e384af9ae1(0,.5),new $d5b33d7c30034067$export$c977b3e384af9ae1(-.5,-.5),new $d5b33d7c30034067$export$c977b3e384af9ae1(.5,-.5)]),r=12){super(),this.type="ShapeGeometry",this.parameters={shapes:n,curveSegments:r};// buffers
let i=[],a=[],s=[],o=[],l=0,u=0;// allow single and array values for "shapes" parameter
if(!1===Array.isArray(n))c(n);else for(let r=0;r<n.length;r++)c(n[r]),this.addGroup(l,u,r),l+=u,u=0;// helper functions
function c(n){let l=a.length/3,c=n.extractPoints(r),h=c.shape,d=c.holes;// check direction of vertices
!1===$d5b33d7c30034067$export$96bdf6d9c66d7ba8.isClockWise(h)&&(h=h.reverse());for(let n=0,r=d.length;n<r;n++){let r=d[n];!0===$d5b33d7c30034067$export$96bdf6d9c66d7ba8.isClockWise(r)&&(d[n]=r.reverse())}let p=$d5b33d7c30034067$export$96bdf6d9c66d7ba8.triangulateShape(h,d);// join vertices of inner and outer paths to a single array
for(let n=0,r=d.length;n<r;n++){let r=d[n];h=h.concat(r)}// vertices, normals, uvs
for(let n=0,r=h.length;n<r;n++){let r=h[n];a.push(r.x,r.y,0),s.push(0,0,1),o.push(r.x,r.y)}// indices
for(let n=0,r=p.length;n<r;n++){let r=p[n],a=r[0]+l,s=r[1]+l,o=r[2]+l;i.push(a,s,o),u+=3}}// build geometry
this.setIndex(i),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(a,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(s,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(o,2))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}toJSON(){let n=super.toJSON(),r=this.parameters.shapes;return $d5b33d7c30034067$var$toJSON(r,n)}static fromJSON(n,r){let i=[];for(let a=0,s=n.shapes.length;a<s;a++){let s=r[n.shapes[a]];i.push(s)}return new $d5b33d7c30034067$export$57a29a1c803e9065(i,n.curveSegments)}}function $d5b33d7c30034067$var$toJSON(n,r){if(r.shapes=[],Array.isArray(n))for(let i=0,a=n.length;i<a;i++){let a=n[i];r.shapes.push(a.uuid)}else r.shapes.push(n.uuid);return r}class $d5b33d7c30034067$export$1b417fc3b307a251 extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=1,r=32,i=16,a=0,s=2*Math.PI,o=0,l=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:n,widthSegments:r,heightSegments:i,phiStart:a,phiLength:s,thetaStart:o,thetaLength:l},r=Math.max(3,Math.floor(r)),i=Math.max(2,Math.floor(i));let u=Math.min(o+l,Math.PI),c=0,h=[],d=new $d5b33d7c30034067$export$64b5c384219d3699,p=new $d5b33d7c30034067$export$64b5c384219d3699,f=[],m=[],g=[],_=[];// generate vertices, normals and uvs
for(let f=0;f<=i;f++){let y=[],b=f/i,v=0;0===f&&0===o?v=.5/r:f===i&&u===Math.PI&&(v=-.5/r);for(let i=0;i<=r;i++){let u=i/r;// vertex
d.x=-n*Math.cos(a+u*s)*Math.sin(o+b*l),d.y=n*Math.cos(o+b*l),d.z=n*Math.sin(a+u*s)*Math.sin(o+b*l),m.push(d.x,d.y,d.z),// normal
p.copy(d).normalize(),g.push(p.x,p.y,p.z),// uv
_.push(u+v,1-b),y.push(c++)}h.push(y)}// indices
for(let n=0;n<i;n++)for(let a=0;a<r;a++){let r=h[n][a+1],s=h[n][a],l=h[n+1][a],c=h[n+1][a+1];(0!==n||o>0)&&f.push(r,s,c),(n!==i-1||u<Math.PI)&&f.push(s,l,c)}// build geometry
this.setIndex(f),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(m,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(g,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(_,2))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}static fromJSON(n){return new $d5b33d7c30034067$export$1b417fc3b307a251(n.radius,n.widthSegments,n.heightSegments,n.phiStart,n.phiLength,n.thetaStart,n.thetaLength)}}class $d5b33d7c30034067$export$fb3f7adc68bd6e02 extends $d5b33d7c30034067$export$60e57a7d3f20ff65{constructor(n=1,r=0){let i=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],a=[2,1,0,0,3,2,1,3,0,2,3,1];super(i,a,n,r),this.type="TetrahedronGeometry",this.parameters={radius:n,detail:r}}static fromJSON(n){return new $d5b33d7c30034067$export$fb3f7adc68bd6e02(n.radius,n.detail)}}class $d5b33d7c30034067$export$a2312a2a1fa56495 extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=1,r=.4,i=12,a=48,s=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:n,tube:r,radialSegments:i,tubularSegments:a,arc:s},i=Math.floor(i),a=Math.floor(a);// buffers
let o=[],l=[],u=[],c=[],h=new $d5b33d7c30034067$export$64b5c384219d3699,d=new $d5b33d7c30034067$export$64b5c384219d3699,p=new $d5b33d7c30034067$export$64b5c384219d3699;// generate vertices, normals and uvs
for(let o=0;o<=i;o++)for(let f=0;f<=a;f++){let m=f/a*s,g=o/i*Math.PI*2;// vertex
d.x=(n+r*Math.cos(g))*Math.cos(m),d.y=(n+r*Math.cos(g))*Math.sin(m),d.z=r*Math.sin(g),l.push(d.x,d.y,d.z),// normal
h.x=n*Math.cos(m),h.y=n*Math.sin(m),p.subVectors(d,h).normalize(),u.push(p.x,p.y,p.z),// uv
c.push(f/a),c.push(o/i)}// generate indices
for(let n=1;n<=i;n++)for(let r=1;r<=a;r++){// indices
let i=(a+1)*n+r-1,s=(a+1)*(n-1)+r-1,l=(a+1)*(n-1)+r,u=(a+1)*n+r;// faces
o.push(i,s,u),o.push(s,l,u)}// build geometry
this.setIndex(o),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(l,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(u,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(c,2))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}static fromJSON(n){return new $d5b33d7c30034067$export$a2312a2a1fa56495(n.radius,n.tube,n.radialSegments,n.tubularSegments,n.arc)}}class $d5b33d7c30034067$export$77e9bfadfb9ab8c8 extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=1,r=.4,i=64,a=8,s=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:n,tube:r,tubularSegments:i,radialSegments:a,p:s,q:o},i=Math.floor(i),a=Math.floor(a);// buffers
let l=[],u=[],c=[],h=[],d=new $d5b33d7c30034067$export$64b5c384219d3699,p=new $d5b33d7c30034067$export$64b5c384219d3699,f=new $d5b33d7c30034067$export$64b5c384219d3699,m=new $d5b33d7c30034067$export$64b5c384219d3699,g=new $d5b33d7c30034067$export$64b5c384219d3699,_=new $d5b33d7c30034067$export$64b5c384219d3699,y=new $d5b33d7c30034067$export$64b5c384219d3699;// generate vertices, normals and uvs
for(let l=0;l<=i;++l){// the radian "u" is used to calculate the position on the torus curve of the current tubular segment
let v=l/i*s*Math.PI*2;// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
b(v,s,o,n,f),b(v+.01,s,o,n,m),// calculate orthonormal basis
_.subVectors(m,f),y.addVectors(m,f),g.crossVectors(_,y),y.crossVectors(g,_),// normalize B, N. T can be ignored, we don't use it
g.normalize(),y.normalize();for(let n=0;n<=a;++n){// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
let s=n/a*Math.PI*2,o=-r*Math.cos(s),m=r*Math.sin(s);// now calculate the final vertex position.
// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve
d.x=f.x+(o*y.x+m*g.x),d.y=f.y+(o*y.y+m*g.y),d.z=f.z+(o*y.z+m*g.z),u.push(d.x,d.y,d.z),// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
p.subVectors(d,f).normalize(),c.push(p.x,p.y,p.z),// uv
h.push(l/i),h.push(n/a)}}// generate indices
for(let n=1;n<=i;n++)for(let r=1;r<=a;r++){// indices
let i=(a+1)*(n-1)+(r-1),s=(a+1)*n+(r-1),o=(a+1)*n+r,u=(a+1)*(n-1)+r;// faces
l.push(i,s,u),l.push(s,o,u)}// this function calculates the current position on the torus curve
function b(n,r,i,a,s){let o=Math.cos(n),l=Math.sin(n),u=i/r*n,c=Math.cos(u);s.x=a*(2+c)*.5*o,s.y=a*(2+c)*l*.5,s.z=a*Math.sin(u)*.5}// build geometry
this.setIndex(l),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(u,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(c,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(h,2))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}static fromJSON(n){return new $d5b33d7c30034067$export$77e9bfadfb9ab8c8(n.radius,n.tube,n.tubularSegments,n.radialSegments,n.p,n.q)}}class $d5b33d7c30034067$export$7897d9d48904490c extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=new $d5b33d7c30034067$export$bf3f4c7e459f90fc(new $d5b33d7c30034067$export$64b5c384219d3699(-1,-1,0),new $d5b33d7c30034067$export$64b5c384219d3699(-1,1,0),new $d5b33d7c30034067$export$64b5c384219d3699(1,1,0)),r=64,i=1,a=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:n,tubularSegments:r,radius:i,radialSegments:a,closed:s};let o=n.computeFrenetFrames(r,s);// expose internals
this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;// helper variables
let l=new $d5b33d7c30034067$export$64b5c384219d3699,u=new $d5b33d7c30034067$export$64b5c384219d3699,c=new $d5b33d7c30034067$export$c977b3e384af9ae1,h=new $d5b33d7c30034067$export$64b5c384219d3699,d=[],p=[],f=[],m=[];function g(s){// we use getPointAt to sample evenly distributed points from the given path
h=n.getPointAt(s/r,h);// retrieve corresponding normal and binormal
let c=o.normals[s],f=o.binormals[s];// generate normals and vertices for the current segment
for(let n=0;n<=a;n++){let r=n/a*Math.PI*2,s=Math.sin(r),o=-Math.cos(r);// normal
u.x=o*c.x+s*f.x,u.y=o*c.y+s*f.y,u.z=o*c.z+s*f.z,u.normalize(),p.push(u.x,u.y,u.z),// vertex
l.x=h.x+i*u.x,l.y=h.y+i*u.y,l.z=h.z+i*u.z,d.push(l.x,l.y,l.z)}}function _(){for(let n=1;n<=r;n++)for(let r=1;r<=a;r++){let i=(a+1)*(n-1)+(r-1),s=(a+1)*n+(r-1),o=(a+1)*n+r,l=(a+1)*(n-1)+r;// faces
m.push(i,s,l),m.push(s,o,l)}}function y(){for(let n=0;n<=r;n++)for(let i=0;i<=a;i++)c.x=n/r,c.y=i/a,f.push(c.x,c.y)}// create buffer data
// functions
(function(){for(let n=0;n<r;n++)g(n);// if the geometry is not closed, generate the last row of vertices and normals
// at the regular position on the given path
//
// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
g(!1===s?r:0),// uvs are generated in a separate function.
// this makes it easy compute correct values for closed geometries
y(),// finally create faces
_()})(),// build geometry
this.setIndex(m),this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(d,3)),this.setAttribute("normal",new $d5b33d7c30034067$export$cbe7a62641830ebd(p,3)),this.setAttribute("uv",new $d5b33d7c30034067$export$cbe7a62641830ebd(f,2))}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}toJSON(){let n=super.toJSON();return n.path=this.parameters.path.toJSON(),n}static fromJSON(n){// This only works for built-in curves (e.g. CatmullRomCurve3).
// User defined curves or instances of CurvePath will not be deserialized.
return new $d5b33d7c30034067$export$7897d9d48904490c(new $d5b33d7c30034067$var$Curves[n.path.type]().fromJSON(n.path),n.tubularSegments,n.radius,n.radialSegments,n.closed)}}class $d5b33d7c30034067$export$4b739da06d24892b extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(n=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:n},null!==n){// buffer
let r=[],i=new Set,a=new $d5b33d7c30034067$export$64b5c384219d3699,s=new $d5b33d7c30034067$export$64b5c384219d3699;if(null!==n.index){// indexed BufferGeometry
let o=n.attributes.position,l=n.index,u=n.groups;0===u.length&&(u=[{start:0,count:l.count,materialIndex:0}]);// create a data structure that contains all edges without duplicates
for(let n=0,c=u.length;n<c;++n){let c=u[n],h=c.start,d=c.count;for(let n=h,u=h+d;n<u;n+=3)for(let u=0;u<3;u++){let c=l.getX(n+u),h=l.getX(n+(u+1)%3);a.fromBufferAttribute(o,c),s.fromBufferAttribute(o,h),!0===$d5b33d7c30034067$var$isUniqueEdge(a,s,i)&&(r.push(a.x,a.y,a.z),r.push(s.x,s.y,s.z))}}}else{// non-indexed BufferGeometry
let o=n.attributes.position;for(let n=0,l=o.count/3;n<l;n++)for(let l=0;l<3;l++){// three edges per triangle, an edge is represented as (index1, index2)
// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
let u=3*n+l,c=3*n+(l+1)%3;a.fromBufferAttribute(o,u),s.fromBufferAttribute(o,c),!0===$d5b33d7c30034067$var$isUniqueEdge(a,s,i)&&(r.push(a.x,a.y,a.z),r.push(s.x,s.y,s.z))}}// build geometry
this.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(r,3))}}copy(n){return super.copy(n),this.parameters=Object.assign({},n.parameters),this}}function $d5b33d7c30034067$var$isUniqueEdge(n,r,i){let a=`${n.x},${n.y},${n.z}-${r.x},${r.y},${r.z}`,s=`${r.x},${r.y},${r.z}-${n.x},${n.y},${n.z}`;return!0!==i.has(a)&&!0!==i.has(s)&&(i.add(a),i.add(s),!0)}var $d5b33d7c30034067$var$Geometries=/*#__PURE__*/Object.freeze({__proto__:null,BoxGeometry:$d5b33d7c30034067$export$33e43285f7406bd5,CapsuleGeometry:$d5b33d7c30034067$export$41680e8551036033,CircleGeometry:$d5b33d7c30034067$export$d5c0e8d607467193,ConeGeometry:$d5b33d7c30034067$export$a7a48974f285c9b3,CylinderGeometry:$d5b33d7c30034067$export$68f745719dbe5198,DodecahedronGeometry:$d5b33d7c30034067$export$c0babfeb8708fc9c,EdgesGeometry:$d5b33d7c30034067$export$4730b1542707547f,ExtrudeGeometry:$d5b33d7c30034067$export$598697a1efa63ca7,IcosahedronGeometry:$d5b33d7c30034067$export$9567cc828c9535da,LatheGeometry:$d5b33d7c30034067$export$6d839803fcd1882c,OctahedronGeometry:$d5b33d7c30034067$export$1954e2b809fe361e,PlaneGeometry:$d5b33d7c30034067$export$967d831af31f69ce,PolyhedronGeometry:$d5b33d7c30034067$export$60e57a7d3f20ff65,RingGeometry:$d5b33d7c30034067$export$68cb731f50f614af,ShapeGeometry:$d5b33d7c30034067$export$57a29a1c803e9065,SphereGeometry:$d5b33d7c30034067$export$1b417fc3b307a251,TetrahedronGeometry:$d5b33d7c30034067$export$fb3f7adc68bd6e02,TorusGeometry:$d5b33d7c30034067$export$a2312a2a1fa56495,TorusKnotGeometry:$d5b33d7c30034067$export$77e9bfadfb9ab8c8,TubeGeometry:$d5b33d7c30034067$export$7897d9d48904490c,WireframeGeometry:$d5b33d7c30034067$export$4b739da06d24892b});class $d5b33d7c30034067$export$e8564da406055a3 extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(0),this.transparent=!0,this.fog=!0,this.setValues(n)}copy(n){return super.copy(n),this.color.copy(n.color),this.fog=n.fog,this}}class $d5b33d7c30034067$export$21c421a2e1df9d22 extends $d5b33d7c30034067$export$83c7d75d550a8b0d{constructor(n){super(n),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class $d5b33d7c30034067$export$f2980790215acccd extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new $d5b33d7c30034067$export$892596cec99bc70e(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$d5b33d7c30034067$export$2852a58ebdac27b8,this.normalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(n)}copy(n){return super.copy(n),this.defines={STANDARD:""},this.color.copy(n.color),this.roughness=n.roughness,this.metalness=n.metalness,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.roughnessMap=n.roughnessMap,this.metalnessMap=n.metalnessMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.envMapIntensity=n.envMapIntensity,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}class $d5b33d7c30034067$export$28d04986c4269c9f extends $d5b33d7c30034067$export$f2980790215acccd{constructor(n){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return $d5b33d7c30034067$var$clamp(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(n){this.ior=(1+.4*n)/(1-.4*n)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new $d5b33d7c30034067$export$892596cec99bc70e(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new $d5b33d7c30034067$export$892596cec99bc70e(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new $d5b33d7c30034067$export$892596cec99bc70e(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(n)}get anisotropy(){return this._anisotropy}set anisotropy(n){this._anisotropy>0!=n>0&&this.version++,this._anisotropy=n}get clearcoat(){return this._clearcoat}set clearcoat(n){this._clearcoat>0!=n>0&&this.version++,this._clearcoat=n}get iridescence(){return this._iridescence}set iridescence(n){this._iridescence>0!=n>0&&this.version++,this._iridescence=n}get sheen(){return this._sheen}set sheen(n){this._sheen>0!=n>0&&this.version++,this._sheen=n}get transmission(){return this._transmission}set transmission(n){this._transmission>0!=n>0&&this.version++,this._transmission=n}copy(n){return super.copy(n),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=n.anisotropy,this.anisotropyRotation=n.anisotropyRotation,this.anisotropyMap=n.anisotropyMap,this.clearcoat=n.clearcoat,this.clearcoatMap=n.clearcoatMap,this.clearcoatRoughness=n.clearcoatRoughness,this.clearcoatRoughnessMap=n.clearcoatRoughnessMap,this.clearcoatNormalMap=n.clearcoatNormalMap,this.clearcoatNormalScale.copy(n.clearcoatNormalScale),this.ior=n.ior,this.iridescence=n.iridescence,this.iridescenceMap=n.iridescenceMap,this.iridescenceIOR=n.iridescenceIOR,this.iridescenceThicknessRange=[...n.iridescenceThicknessRange],this.iridescenceThicknessMap=n.iridescenceThicknessMap,this.sheen=n.sheen,this.sheenColor.copy(n.sheenColor),this.sheenColorMap=n.sheenColorMap,this.sheenRoughness=n.sheenRoughness,this.sheenRoughnessMap=n.sheenRoughnessMap,this.transmission=n.transmission,this.transmissionMap=n.transmissionMap,this.thickness=n.thickness,this.thicknessMap=n.thicknessMap,this.attenuationDistance=n.attenuationDistance,this.attenuationColor.copy(n.attenuationColor),this.specularIntensity=n.specularIntensity,this.specularIntensityMap=n.specularIntensityMap,this.specularColor.copy(n.specularColor),this.specularColorMap=n.specularColorMap,this}}class $d5b33d7c30034067$export$24c72f71cbaf0678 extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(16777215),this.specular=new $d5b33d7c30034067$export$892596cec99bc70e(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new $d5b33d7c30034067$export$892596cec99bc70e(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$d5b33d7c30034067$export$2852a58ebdac27b8,this.normalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=$d5b33d7c30034067$export$e50ac29801f1774d,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(n)}copy(n){return super.copy(n),this.color.copy(n.color),this.specular.copy(n.specular),this.shininess=n.shininess,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}class $d5b33d7c30034067$export$df893cf97e765622 extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new $d5b33d7c30034067$export$892596cec99bc70e(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$d5b33d7c30034067$export$2852a58ebdac27b8,this.normalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(n)}copy(n){return super.copy(n),this.color.copy(n.color),this.map=n.map,this.gradientMap=n.gradientMap,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.fog=n.fog,this}}class $d5b33d7c30034067$export$bfe8c0a091f41ae7 extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$d5b33d7c30034067$export$2852a58ebdac27b8,this.normalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(n)}copy(n){return super.copy(n),this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.flatShading=n.flatShading,this}}class $d5b33d7c30034067$export$5023a9a8114806b8 extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new $d5b33d7c30034067$export$892596cec99bc70e(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$d5b33d7c30034067$export$2852a58ebdac27b8,this.normalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=$d5b33d7c30034067$export$e50ac29801f1774d,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(n)}copy(n){return super.copy(n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}class $d5b33d7c30034067$export$6f5fef6235ec12ee extends $d5b33d7c30034067$export$a2d8b23205c25948{constructor(n){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=$d5b33d7c30034067$export$2852a58ebdac27b8,this.normalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(n)}copy(n){return super.copy(n),this.defines={MATCAP:""},this.color.copy(n.color),this.matcap=n.matcap,this.map=n.map,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.flatShading=n.flatShading,this.fog=n.fog,this}}class $d5b33d7c30034067$export$327886a3efaeaebe extends $d5b33d7c30034067$export$fbaaa33907730a0c{constructor(n){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(n)}copy(n){return super.copy(n),this.scale=n.scale,this.dashSize=n.dashSize,this.gapSize=n.gapSize,this}}// same as Array.prototype.slice, but also works on typed arrays
function $d5b33d7c30034067$var$arraySlice(n,r,i){return $d5b33d7c30034067$var$isTypedArray(n)?new n.constructor(n.subarray(r,void 0!==i?i:n.length)):n.slice(r,i)}// converts an array to a specific type
function $d5b33d7c30034067$var$convertArray(n,r,i){return n&&// let 'undefined' and 'null' pass
(i||n.constructor!==r)?"number"==typeof r.BYTES_PER_ELEMENT?new r(n):Array.prototype.slice.call(n):n}function $d5b33d7c30034067$var$isTypedArray(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}// returns an array by which times and values can be sorted
function $d5b33d7c30034067$var$getKeyframeOrder(n){function r(r,i){return n[r]-n[i]}let i=n.length,a=Array(i);for(let n=0;n!==i;++n)a[n]=n;return a.sort(r),a}// uses the array previously returned by 'getKeyframeOrder' to sort data
function $d5b33d7c30034067$var$sortedArray(n,r,i){let a=n.length,s=new n.constructor(a);for(let o=0,l=0;l!==a;++o){let a=i[o]*r;for(let i=0;i!==r;++i)s[l++]=n[a+i]}return s}// function for parsing AOS keyframe formats
function $d5b33d7c30034067$var$flattenJSON(n,r,i,a){let s=1,o=n[0];for(;void 0!==o&&void 0===o[a];)o=n[s++];if(void 0===o)return;// no data
let l=o[a];if(void 0!==l){if(Array.isArray(l))do void 0!==(l=o[a])&&(r.push(o.time),i.push.apply(i,l)),o=n[s++];while(void 0!==o)else if(void 0!==l.toArray)do void 0!==(l=o[a])&&(r.push(o.time),l.toArray(i,i.length)),o=n[s++];while(void 0!==o)else do void 0!==(l=o[a])&&(r.push(o.time),i.push(l)),o=n[s++];while(void 0!==o)}// no data
}function $d5b33d7c30034067$var$subclip(n,r,i,a,s=30){let o=n.clone();o.name=r;let l=[];for(let n=0;n<o.tracks.length;++n){let r=o.tracks[n],u=r.getValueSize(),c=[],h=[];for(let n=0;n<r.times.length;++n){let o=r.times[n]*s;if(!(o<i)&&!(o>=a)){c.push(r.times[n]);for(let i=0;i<u;++i)h.push(r.values[n*u+i])}}0!==c.length&&(r.times=$d5b33d7c30034067$var$convertArray(c,r.times.constructor),r.values=$d5b33d7c30034067$var$convertArray(h,r.values.constructor),l.push(r))}o.tracks=l;// find minimum .times value across all tracks in the trimmed clip
let u=1/0;for(let n=0;n<o.tracks.length;++n)u>o.tracks[n].times[0]&&(u=o.tracks[n].times[0]);// shift all tracks such that clip begins at t=0
for(let n=0;n<o.tracks.length;++n)o.tracks[n].shift(-1*u);return o.resetDuration(),o}function $d5b33d7c30034067$var$makeClipAdditive(n,r=0,i=n,a=30){a<=0&&(a=30);let s=i.tracks.length,o=r/a;// Make each track's values relative to the values at the reference frame
for(let r=0;r<s;++r){let a;let s=i.tracks[r],l=s.ValueTypeName;// Skip this track if it's non-numeric
if("bool"===l||"string"===l)continue;// Find the track in the target clip whose name and type matches the reference track
let u=n.tracks.find(function(n){return n.name===s.name&&n.ValueTypeName===l});if(void 0===u)continue;let c=0,h=s.getValueSize();s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=h/3);let d=0,p=u.getValueSize();u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);let f=s.times.length-1;// Find the value to subtract out of the track
if(o<=s.times[0]){// Reference frame is earlier than the first keyframe, so just use the first keyframe
let n=c,r=h-c;a=$d5b33d7c30034067$var$arraySlice(s.values,n,r)}else if(o>=s.times[f]){// Reference frame is after the last keyframe, so just use the last keyframe
let n=f*h+c,r=n+h-c;a=$d5b33d7c30034067$var$arraySlice(s.values,n,r)}else{// Interpolate to the reference value
let n=s.createInterpolant(),r=c,i=h-c;n.evaluate(o),a=$d5b33d7c30034067$var$arraySlice(n.resultBuffer,r,i)}// Conjugate the quaternion
if("quaternion"===l){let n=new $d5b33d7c30034067$export$23d6a54f0bbc85a3().fromArray(a).normalize().conjugate();n.toArray(a)}// Subtract the reference value from all of the track values
let m=u.times.length;for(let n=0;n<m;++n){let r=n*p+d;if("quaternion"===l)$d5b33d7c30034067$export$23d6a54f0bbc85a3.multiplyQuaternionsFlat(u.values,r,a,0,u.values,r);else{let n=p-2*d;// Subtract each value for all other numeric track types
for(let i=0;i<n;++i)u.values[r+i]-=a[i]}}}return n.blendMode=$d5b33d7c30034067$export$d875e029ef558d3,n}const $d5b33d7c30034067$export$7ee8caa573e71ad1={arraySlice:$d5b33d7c30034067$var$arraySlice,convertArray:$d5b33d7c30034067$var$convertArray,isTypedArray:$d5b33d7c30034067$var$isTypedArray,getKeyframeOrder:$d5b33d7c30034067$var$getKeyframeOrder,sortedArray:$d5b33d7c30034067$var$sortedArray,flattenJSON:$d5b33d7c30034067$var$flattenJSON,subclip:$d5b33d7c30034067$var$subclip,makeClipAdditive:$d5b33d7c30034067$var$makeClipAdditive};/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */class $d5b33d7c30034067$export$b558baee9c0f72d3{constructor(n,r,i,a){this.parameterPositions=n,this._cachedIndex=0,this.resultBuffer=void 0!==a?a:new r.constructor(i),this.sampleValues=r,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(n){let r=this.parameterPositions,i=this._cachedIndex,a=r[i],s=r[i-1];t:{n:{let o;r:{//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
i:if(!(n<a)){for(let o=i+2;;){if(void 0===a){if(n<s)break i;return(// after end
i=r.length,this._cachedIndex=i,this.copySampleValue_(i-1))}if(i===o)break;// this loop
if(s=a,n<(a=r[++i]))break n}// prepare binary search on the right side of the index
o=r.length;break r}//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
if(!(n>=s)){// looping?
let l=r[1];n<l&&(i=2,s=l);// linear reverse scan
for(let o=i-2;;){if(void 0===s)return(// before start
this._cachedIndex=0,this.copySampleValue_(0));if(i===o)break;// this loop
if(a=s,n>=(s=r[--i-1]))break n}// prepare binary search on the left side of the index
o=i,i=0;break r}break t}// linear scan
// binary search
for(;i<o;){let a=i+o>>>1;n<r[a]?o=a:i=a+1}// check boundary cases, again
if(a=r[i],void 0===(s=r[i-1]))return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===a)return i=r.length,this._cachedIndex=i,this.copySampleValue_(i-1)}// seek
this._cachedIndex=i,this.intervalChanged_(i,s,a)}// validate_interval
return this.interpolate_(i,s,n,a)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(n){// copies a sample value to the result buffer
let r=this.resultBuffer,i=this.sampleValues,a=this.valueSize,s=n*a;for(let n=0;n!==a;++n)r[n]=i[s+n];return r}// Template methods for derived classes:
interpolate_(){throw Error("call to abstract method");// implementations shall return this.resultBuffer
}intervalChanged_(){// empty
}}/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */class $d5b33d7c30034067$export$3646682e7a3959 extends $d5b33d7c30034067$export$b558baee9c0f72d3{constructor(n,r,i,a){super(n,r,i,a),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:$d5b33d7c30034067$export$7f795934b84ab523,endingEnd:$d5b33d7c30034067$export$7f795934b84ab523}}intervalChanged_(n,r,i){let a=this.parameterPositions,s=n-2,o=n+1,l=a[s],u=a[o];if(void 0===l)switch(this.getSettings_().endingStart){case $d5b33d7c30034067$export$24a4ccb5099273b5:// f'(t0) = 0
s=n,l=2*r-i;break;case $d5b33d7c30034067$export$8e8c3ecdcd8e1fee:// use the other end of the curve
s=a.length-2,l=r+a[s]-a[s+1];break;default:// f''(t0) = 0 a.k.a. Natural Spline
s=n,l=i}if(void 0===u)switch(this.getSettings_().endingEnd){case $d5b33d7c30034067$export$24a4ccb5099273b5:// f'(tN) = 0
o=n,u=2*i-r;break;case $d5b33d7c30034067$export$8e8c3ecdcd8e1fee:// use the other end of the curve
o=1,u=i+a[1]-a[0];break;default:// f''(tN) = 0, a.k.a. Natural Spline
o=n-1,u=r}let c=(i-r)*.5,h=this.valueSize;this._weightPrev=c/(r-l),this._weightNext=c/(u-i),this._offsetPrev=s*h,this._offsetNext=o*h}interpolate_(n,r,i,a){let s=this.resultBuffer,o=this.sampleValues,l=this.valueSize,u=n*l,c=u-l,h=this._offsetPrev,d=this._offsetNext,p=this._weightPrev,f=this._weightNext,m=(i-r)/(a-r),g=m*m,_=g*m,y=-p*_+2*p*g-p*m,b=(1+p)*_+(-1.5-2*p)*g+(-.5+p)*m+1,v=(-1-f)*_+(1.5+f)*g+.5*m,x=f*_-f*g;// combine data linearly
for(let n=0;n!==l;++n)s[n]=y*o[h+n]+b*o[c+n]+v*o[u+n]+x*o[d+n];return s}}class $d5b33d7c30034067$export$a8e6009059f51e1a extends $d5b33d7c30034067$export$b558baee9c0f72d3{constructor(n,r,i,a){super(n,r,i,a)}interpolate_(n,r,i,a){let s=this.resultBuffer,o=this.sampleValues,l=this.valueSize,u=n*l,c=u-l,h=(i-r)/(a-r),d=1-h;for(let n=0;n!==l;++n)s[n]=o[c+n]*d+o[u+n]*h;return s}}/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */class $d5b33d7c30034067$export$fb9758ef7ef8d5cc extends $d5b33d7c30034067$export$b558baee9c0f72d3{constructor(n,r,i,a){super(n,r,i,a)}interpolate_(n/*, t0, t, t1 */){return this.copySampleValue_(n-1)}}class $d5b33d7c30034067$export$b0e479f45b7006d6{constructor(n,r,i,a){if(void 0===n)throw Error("THREE.KeyframeTrack: track name is undefined");if(void 0===r||0===r.length)throw Error("THREE.KeyframeTrack: no keyframes in track named "+n);this.name=n,this.times=$d5b33d7c30034067$var$convertArray(r,this.TimeBufferType),this.values=$d5b33d7c30034067$var$convertArray(i,this.ValueBufferType),this.setInterpolation(a||this.DefaultInterpolation)}// Serialization (in static context, because of constructor invocation
// and automatic invocation of .toJSON):
static toJSON(n){let r;let i=n.constructor;// derived classes can define a static toJSON method
if(i.toJSON!==this.toJSON)r=i.toJSON(n);else{// by default, we assume the data can be serialized as-is
r={name:n.name,times:$d5b33d7c30034067$var$convertArray(n.times,Array),values:$d5b33d7c30034067$var$convertArray(n.values,Array)};let i=n.getInterpolation();i!==n.DefaultInterpolation&&(r.interpolation=i)}return r.type=n.ValueTypeName,r}InterpolantFactoryMethodDiscrete(n){return new $d5b33d7c30034067$export$fb9758ef7ef8d5cc(this.times,this.values,this.getValueSize(),n)}InterpolantFactoryMethodLinear(n){return new $d5b33d7c30034067$export$a8e6009059f51e1a(this.times,this.values,this.getValueSize(),n)}InterpolantFactoryMethodSmooth(n){return new $d5b33d7c30034067$export$3646682e7a3959(this.times,this.values,this.getValueSize(),n)}setInterpolation(n){let r;switch(n){case $d5b33d7c30034067$export$995b32462a65e855:r=this.InterpolantFactoryMethodDiscrete;break;case $d5b33d7c30034067$export$30fac1aace31cf4d:r=this.InterpolantFactoryMethodLinear;break;case $d5b33d7c30034067$export$198b11ff4c72bb30:r=this.InterpolantFactoryMethodSmooth}if(void 0===r){let r="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){// fall back to default, unless the default itself is messed up
if(n!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw Error(r);// fatal, in this case
}return console.warn("THREE.KeyframeTrack:",r),this}return this.createInterpolant=r,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return $d5b33d7c30034067$export$995b32462a65e855;case this.InterpolantFactoryMethodLinear:return $d5b33d7c30034067$export$30fac1aace31cf4d;case this.InterpolantFactoryMethodSmooth:return $d5b33d7c30034067$export$198b11ff4c72bb30}}getValueSize(){return this.values.length/this.times.length}// move all keyframes either forwards or backwards in time
shift(n){if(0!==n){let r=this.times;for(let i=0,a=r.length;i!==a;++i)r[i]+=n}return this}// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
scale(n){if(1!==n){let r=this.times;for(let i=0,a=r.length;i!==a;++i)r[i]*=n}return this}// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
trim(n,r){let i=this.times,a=i.length,s=0,o=a-1;for(;s!==a&&i[s]<n;)++s;for(;-1!==o&&i[o]>r;)--o;if(++o,0!==s||o!==a){s>=o&&(s=(o=Math.max(o,1))-1);let n=this.getValueSize();this.times=$d5b33d7c30034067$var$arraySlice(i,s,o),this.values=$d5b33d7c30034067$var$arraySlice(this.values,s*n,o*n)}return this}// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
validate(){let n=!0,r=this.getValueSize();r-Math.floor(r)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),n=!1);let i=this.times,a=this.values,s=i.length;0===s&&(console.error("THREE.KeyframeTrack: Track is empty.",this),n=!1);let o=null;for(let r=0;r!==s;r++){let a=i[r];if("number"==typeof a&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,r,a),n=!1;break}if(null!==o&&o>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,r,a,o),n=!1;break}o=a}if(void 0!==a&&$d5b33d7c30034067$var$isTypedArray(a))for(let r=0,i=a.length;r!==i;++r){let i=a[r];if(isNaN(i)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,r,i),n=!1;break}}return n}// removes equivalent sequential keys as common in morph target sequences
// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
optimize(){// times or values may be shared with other tracks, so overwriting is unsafe
let n=$d5b33d7c30034067$var$arraySlice(this.times),r=$d5b33d7c30034067$var$arraySlice(this.values),i=this.getValueSize(),a=this.getInterpolation()===$d5b33d7c30034067$export$198b11ff4c72bb30,s=n.length-1,o=1;for(let l=1;l<s;++l){let s=!1,u=n[l],c=n[l+1];// remove adjacent keyframes scheduled at the same time
if(u!==c&&(1!==l||u!==n[0])){if(a)s=!0;else{// remove unnecessary keyframes same as their neighbors
let n=l*i,a=n-i,o=n+i;for(let l=0;l!==i;++l){let i=r[n+l];if(i!==r[a+l]||i!==r[o+l]){s=!0;break}}}}// in-place compaction
if(s){if(l!==o){n[o]=n[l];let a=l*i,s=o*i;for(let n=0;n!==i;++n)r[s+n]=r[a+n]}++o}}// flush last keyframe (compaction looks ahead)
if(s>0){n[o]=n[s];for(let n=s*i,a=o*i,l=0;l!==i;++l)r[a+l]=r[n+l];++o}return o!==n.length?(this.times=$d5b33d7c30034067$var$arraySlice(n,0,o),this.values=$d5b33d7c30034067$var$arraySlice(r,0,o*i)):(this.times=n,this.values=r),this}clone(){let n=$d5b33d7c30034067$var$arraySlice(this.times,0),r=$d5b33d7c30034067$var$arraySlice(this.values,0),i=this.constructor,a=new i(this.name,n,r);return(// Interpolant argument to constructor is not saved, so copy the factory method directly.
a.createInterpolant=this.createInterpolant,a)}}$d5b33d7c30034067$export$b0e479f45b7006d6.prototype.TimeBufferType=Float32Array,$d5b33d7c30034067$export$b0e479f45b7006d6.prototype.ValueBufferType=Float32Array,$d5b33d7c30034067$export$b0e479f45b7006d6.prototype.DefaultInterpolation=$d5b33d7c30034067$export$30fac1aace31cf4d;/**
 * A Track of Boolean keyframe values.
 */class $d5b33d7c30034067$export$d3a344b98cf0b775 extends $d5b33d7c30034067$export$b0e479f45b7006d6{}$d5b33d7c30034067$export$d3a344b98cf0b775.prototype.ValueTypeName="bool",$d5b33d7c30034067$export$d3a344b98cf0b775.prototype.ValueBufferType=Array,$d5b33d7c30034067$export$d3a344b98cf0b775.prototype.DefaultInterpolation=$d5b33d7c30034067$export$995b32462a65e855,$d5b33d7c30034067$export$d3a344b98cf0b775.prototype.InterpolantFactoryMethodLinear=void 0,$d5b33d7c30034067$export$d3a344b98cf0b775.prototype.InterpolantFactoryMethodSmooth=void 0;/**
 * A Track of keyframe values that represent color.
 */class $d5b33d7c30034067$export$83444c5d885347d8 extends $d5b33d7c30034067$export$b0e479f45b7006d6{}$d5b33d7c30034067$export$83444c5d885347d8.prototype.ValueTypeName="color";/**
 * A Track of numeric keyframe values.
 */class $d5b33d7c30034067$export$d45f0d1a4d9a9314 extends $d5b33d7c30034067$export$b0e479f45b7006d6{}$d5b33d7c30034067$export$d45f0d1a4d9a9314.prototype.ValueTypeName="number";/**
 * Spherical linear unit quaternion interpolant.
 */class $d5b33d7c30034067$export$2db1cfb7923d931e extends $d5b33d7c30034067$export$b558baee9c0f72d3{constructor(n,r,i,a){super(n,r,i,a)}interpolate_(n,r,i,a){let s=this.resultBuffer,o=this.sampleValues,l=this.valueSize,u=(i-r)/(a-r),c=n*l;for(let n=c+l;c!==n;c+=4)$d5b33d7c30034067$export$23d6a54f0bbc85a3.slerpFlat(s,0,o,c-l,o,c,u);return s}}/**
 * A Track of quaternion keyframe values.
 */class $d5b33d7c30034067$export$b8043f12b5aafbd7 extends $d5b33d7c30034067$export$b0e479f45b7006d6{InterpolantFactoryMethodLinear(n){return new $d5b33d7c30034067$export$2db1cfb7923d931e(this.times,this.values,this.getValueSize(),n)}}$d5b33d7c30034067$export$b8043f12b5aafbd7.prototype.ValueTypeName="quaternion",// ValueBufferType is inherited
$d5b33d7c30034067$export$b8043f12b5aafbd7.prototype.DefaultInterpolation=$d5b33d7c30034067$export$30fac1aace31cf4d,$d5b33d7c30034067$export$b8043f12b5aafbd7.prototype.InterpolantFactoryMethodSmooth=void 0;/**
 * A Track that interpolates Strings
 */class $d5b33d7c30034067$export$6ce41d4f3a8df9cd extends $d5b33d7c30034067$export$b0e479f45b7006d6{}$d5b33d7c30034067$export$6ce41d4f3a8df9cd.prototype.ValueTypeName="string",$d5b33d7c30034067$export$6ce41d4f3a8df9cd.prototype.ValueBufferType=Array,$d5b33d7c30034067$export$6ce41d4f3a8df9cd.prototype.DefaultInterpolation=$d5b33d7c30034067$export$995b32462a65e855,$d5b33d7c30034067$export$6ce41d4f3a8df9cd.prototype.InterpolantFactoryMethodLinear=void 0,$d5b33d7c30034067$export$6ce41d4f3a8df9cd.prototype.InterpolantFactoryMethodSmooth=void 0;/**
 * A Track of vectored keyframe values.
 */class $d5b33d7c30034067$export$5ce2dcb4cc9f2bff extends $d5b33d7c30034067$export$b0e479f45b7006d6{}$d5b33d7c30034067$export$5ce2dcb4cc9f2bff.prototype.ValueTypeName="vector";class $d5b33d7c30034067$export$d942c706bf23829c{constructor(n,r=-1,i,a=$d5b33d7c30034067$export$bcfbbdcf8de7f8cd){this.name=n,this.tracks=i,this.duration=r,this.blendMode=a,this.uuid=$d5b33d7c30034067$var$generateUUID(),this.duration<0&&this.resetDuration()}static parse(n){let r=[],i=n.tracks,a=1/(n.fps||1);for(let n=0,s=i.length;n!==s;++n)r.push($d5b33d7c30034067$var$parseKeyframeTrack(i[n]).scale(a));let s=new this(n.name,n.duration,r,n.blendMode);return s.uuid=n.uuid,s}static toJSON(n){let r=[],i=n.tracks,a={name:n.name,duration:n.duration,tracks:r,uuid:n.uuid,blendMode:n.blendMode};for(let n=0,a=i.length;n!==a;++n)r.push($d5b33d7c30034067$export$b0e479f45b7006d6.toJSON(i[n]));return a}static CreateFromMorphTargetSequence(n,r,i,a){let s=r.length,o=[];for(let n=0;n<s;n++){let l=[],u=[];l.push((n+s-1)%s,n,(n+1)%s),u.push(0,1,0);let c=$d5b33d7c30034067$var$getKeyframeOrder(l);l=$d5b33d7c30034067$var$sortedArray(l,1,c),u=$d5b33d7c30034067$var$sortedArray(u,1,c),a||0!==l[0]||(l.push(s),u.push(u[0])),o.push(new $d5b33d7c30034067$export$d45f0d1a4d9a9314(".morphTargetInfluences["+r[n].name+"]",l,u).scale(1/i))}return new this(n,-1,o)}static findByName(n,r){let i=n;if(!Array.isArray(n)){let r=n;i=r.geometry&&r.geometry.animations||r.animations}for(let n=0;n<i.length;n++)if(i[n].name===r)return i[n];return null}static CreateClipsFromMorphTargetSequences(n,r,i){let a={},s=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
// patterns like Walk_001, Walk_002, Run_001, Run_002
for(let r=0,i=n.length;r<i;r++){let i=n[r],o=i.name.match(s);if(o&&o.length>1){let n=o[1],r=a[n];r||(a[n]=r=[]),r.push(i)}}let o=[];for(let n in a)o.push(this.CreateFromMorphTargetSequence(n,a[n],r,i));return o}// parse the animation.hierarchy format
static parseAnimation(n,r){if(!n)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;let i=function(n,r,i,a,s){// only return track if there are actually keys.
if(0!==i.length){let o=[],l=[];$d5b33d7c30034067$var$flattenJSON(i,o,l,a),0!==o.length&&s.push(new n(r,o,l))}},a=[],s=n.name||"default",o=n.fps||30,l=n.blendMode,u=n.length||-1,c=n.hierarchy||[];for(let n=0;n<c.length;n++){let s=c[n].keys;// skip empty tracks
if(s&&0!==s.length){// process morph targets
if(s[0].morphTargets){let n;// figure out all morph targets used in this track
let r={};for(n=0;n<s.length;n++)if(s[n].morphTargets)for(let i=0;i<s[n].morphTargets.length;i++)r[s[n].morphTargets[i]]=-1;// create a track for each morph target with all zero
// morphTargetInfluences except for the keys in which
// the morphTarget is named.
for(let i in r){let r=[],o=[];for(let a=0;a!==s[n].morphTargets.length;++a){let a=s[n];r.push(a.time),o.push(a.morphTarget===i?1:0)}a.push(new $d5b33d7c30034067$export$d45f0d1a4d9a9314(".morphTargetInfluence["+i+"]",r,o))}u=r.length*o}else{// ...assume skeletal animation
let o=".bones["+r[n].name+"]";i($d5b33d7c30034067$export$5ce2dcb4cc9f2bff,o+".position",s,"pos",a),i($d5b33d7c30034067$export$b8043f12b5aafbd7,o+".quaternion",s,"rot",a),i($d5b33d7c30034067$export$5ce2dcb4cc9f2bff,o+".scale",s,"scl",a)}}}if(0===a.length)return null;let h=new this(s,u,a,l);return h}resetDuration(){let n=this.tracks,r=0;for(let i=0,a=n.length;i!==a;++i){let n=this.tracks[i];r=Math.max(r,n.times[n.times.length-1])}return this.duration=r,this}trim(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].trim(0,this.duration);return this}validate(){let n=!0;for(let r=0;r<this.tracks.length;r++)n=n&&this.tracks[r].validate();return n}optimize(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].optimize();return this}clone(){let n=[];for(let r=0;r<this.tracks.length;r++)n.push(this.tracks[r].clone());return new this.constructor(this.name,this.duration,n,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function $d5b33d7c30034067$var$getTrackTypeForValueTypeName(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return $d5b33d7c30034067$export$d45f0d1a4d9a9314;case"vector":case"vector2":case"vector3":case"vector4":return $d5b33d7c30034067$export$5ce2dcb4cc9f2bff;case"color":return $d5b33d7c30034067$export$83444c5d885347d8;case"quaternion":return $d5b33d7c30034067$export$b8043f12b5aafbd7;case"bool":case"boolean":return $d5b33d7c30034067$export$d3a344b98cf0b775;case"string":return $d5b33d7c30034067$export$6ce41d4f3a8df9cd}throw Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function $d5b33d7c30034067$var$parseKeyframeTrack(n){if(void 0===n.type)throw Error("THREE.KeyframeTrack: track type undefined, can not parse");let r=$d5b33d7c30034067$var$getTrackTypeForValueTypeName(n.type);if(void 0===n.times){let r=[],i=[];$d5b33d7c30034067$var$flattenJSON(n.keys,r,i,"value"),n.times=r,n.values=i}return(// derived classes can define a static parse method
void 0!==r.parse?r.parse(n):new r(n.name,n.times,n.values,n.interpolation))}const $d5b33d7c30034067$export$94affb487e701bf2={enabled:!1,files:{},add:function(n,r){!1!==this.enabled&&// console.log( 'THREE.Cache', 'Adding key:', key );
(this.files[n]=r)},get:function(n){if(!1!==this.enabled)// console.log( 'THREE.Cache', 'Checking key:', key );
return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class $d5b33d7c30034067$export$99cc795e99919eed{constructor(n,r,i){let a;let s=this,o=!1,l=0,u=0,c=[];// Refer to #5689 for the reason why we don't set .onStart
// in the constructor
this.onStart=void 0,this.onLoad=n,this.onProgress=r,this.onError=i,this.itemStart=function(n){u++,!1===o&&void 0!==s.onStart&&s.onStart(n,l,u),o=!0},this.itemEnd=function(n){l++,void 0!==s.onProgress&&s.onProgress(n,l,u),l===u&&(o=!1,void 0!==s.onLoad&&s.onLoad())},this.itemError=function(n){void 0!==s.onError&&s.onError(n)},this.resolveURL=function(n){return a?a(n):n},this.setURLModifier=function(n){return a=n,this},this.addHandler=function(n,r){return c.push(n,r),this},this.removeHandler=function(n){let r=c.indexOf(n);return -1!==r&&c.splice(r,2),this},this.getHandler=function(n){for(let r=0,i=c.length;r<i;r+=2){let i=c[r],a=c[r+1];if(i.global&&(i.lastIndex=0),i.test(n))return a}return null}}}const $d5b33d7c30034067$export$b033c3f9a95c6a16=/*@__PURE__*/new $d5b33d7c30034067$export$99cc795e99919eed;class $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){this.manager=void 0!==n?n:$d5b33d7c30034067$export$b033c3f9a95c6a16,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(n,r){let i=this;return new Promise(function(a,s){i.load(n,a,r,s)})}parse(){}setCrossOrigin(n){return this.crossOrigin=n,this}setWithCredentials(n){return this.withCredentials=n,this}setPath(n){return this.path=n,this}setResourcePath(n){return this.resourcePath=n,this}setRequestHeader(n){return this.requestHeader=n,this}}$d5b33d7c30034067$export$3b0d6d7590275603.DEFAULT_MATERIAL_NAME="__DEFAULT";const $d5b33d7c30034067$var$loading={};class $d5b33d7c30034067$var$HttpError extends Error{constructor(n,r){super(n),this.response=r}}class $d5b33d7c30034067$export$98435a25b5cf7b2b extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){void 0===n&&(n=""),void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);let s=$d5b33d7c30034067$export$94affb487e701bf2.get(n);if(void 0!==s)return this.manager.itemStart(n),setTimeout(()=>{r&&r(s),this.manager.itemEnd(n)},0),s;// Check if request is duplicate
if(void 0!==$d5b33d7c30034067$var$loading[n]){$d5b33d7c30034067$var$loading[n].push({onLoad:r,onProgress:i,onError:a});return}// Initialise array for duplicate requests
$d5b33d7c30034067$var$loading[n]=[],$d5b33d7c30034067$var$loading[n].push({onLoad:r,onProgress:i,onError:a});// create request
let o=new Request(n,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),l=this.mimeType,u=this.responseType;// start the fetch
fetch(o).then(r=>{if(200===r.status||0===r.status){// Workaround: Checking if response.body === undefined for Alipay browser #23548
if(0===r.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===r.body||void 0===r.body.getReader)return r;let i=$d5b33d7c30034067$var$loading[n],a=r.body.getReader(),s=r.headers.get("Content-Length")||r.headers.get("X-File-Size"),o=s?parseInt(s):0,l=0!==o,u=0,c=new ReadableStream({start(n){r();function r(){a.read().then(({done:a,value:s})=>{if(a)n.close();else{u+=s.byteLength;let a=new ProgressEvent("progress",{lengthComputable:l,loaded:u,total:o});for(let n=0,r=i.length;n<r;n++){let r=i[n];r.onProgress&&r.onProgress(a)}n.enqueue(s),r()}})}}});return new Response(c)}throw new $d5b33d7c30034067$var$HttpError(`fetch for "${r.url}" responded with ${r.status}: ${r.statusText}`,r)}).then(n=>{switch(u){case"arraybuffer":return n.arrayBuffer();case"blob":return n.blob();case"document":return n.text().then(n=>{let r=new DOMParser;return r.parseFromString(n,l)});case"json":return n.json();default:if(void 0===l)return n.text();{// sniff encoding
let r=/charset="?([^;"\s]*)"?/i,i=r.exec(l),a=i&&i[1]?i[1].toLowerCase():void 0,s=new TextDecoder(a);return n.arrayBuffer().then(n=>s.decode(n))}}}).then(r=>{// Add to cache only on HTTP success, so that we do not cache
// error response bodies as proper responses to requests.
$d5b33d7c30034067$export$94affb487e701bf2.add(n,r);let i=$d5b33d7c30034067$var$loading[n];delete $d5b33d7c30034067$var$loading[n];for(let n=0,a=i.length;n<a;n++){let a=i[n];a.onLoad&&a.onLoad(r)}}).catch(r=>{// Abort errors and other errors are handled the same
let i=$d5b33d7c30034067$var$loading[n];if(void 0===i)throw(// When onLoad was called and url was deleted in `loading`
this.manager.itemError(n),r);delete $d5b33d7c30034067$var$loading[n];for(let n=0,a=i.length;n<a;n++){let a=i[n];a.onError&&a.onError(r)}this.manager.itemError(n)}).finally(()=>{this.manager.itemEnd(n)}),this.manager.itemStart(n)}setResponseType(n){return this.responseType=n,this}setMimeType(n){return this.mimeType=n,this}}class $d5b33d7c30034067$export$29711c7e14f61db extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){let s=this,o=new $d5b33d7c30034067$export$98435a25b5cf7b2b(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(n,function(i){try{r(s.parse(JSON.parse(i)))}catch(r){a?a(r):console.error(r),s.manager.itemError(n)}},i,a)}parse(n){let r=[];for(let i=0;i<n.length;i++){let a=$d5b33d7c30034067$export$d942c706bf23829c.parse(n[i]);r.push(a)}return r}}/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */class $d5b33d7c30034067$export$bd73ce947a280350 extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){let s=this,o=[],l=new $d5b33d7c30034067$export$3466bac9141a5cc4,u=new $d5b33d7c30034067$export$98435a25b5cf7b2b(this.manager);u.setPath(this.path),u.setResponseType("arraybuffer"),u.setRequestHeader(this.requestHeader),u.setWithCredentials(s.withCredentials);let c=0;function h(h){u.load(n[h],function(n){let i=s.parse(n,!0);o[h]={width:i.width,height:i.height,format:i.format,mipmaps:i.mipmaps},6===(c+=1)&&(1===i.mipmapCount&&(l.minFilter=$d5b33d7c30034067$export$8a72f490b25c56c8),l.image=o,l.format=i.format,l.needsUpdate=!0,r&&r(l))},i,a)}if(Array.isArray(n))for(let r=0,i=n.length;r<i;++r)h(r);else u.load(n,function(n){let i=s.parse(n,!0);if(i.isCubemap){let n=i.mipmaps.length/i.mipmapCount;for(let r=0;r<n;r++){o[r]={mipmaps:[]};for(let n=0;n<i.mipmapCount;n++)o[r].mipmaps.push(i.mipmaps[r*i.mipmapCount+n]),o[r].format=i.format,o[r].width=i.width,o[r].height=i.height}l.image=o}else l.image.width=i.width,l.image.height=i.height,l.mipmaps=i.mipmaps;1===i.mipmapCount&&(l.minFilter=$d5b33d7c30034067$export$8a72f490b25c56c8),l.format=i.format,l.needsUpdate=!0,r&&r(l)},i,a);return l}}class $d5b33d7c30034067$export$8905ce1c7a2464a1 extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);let s=this,o=$d5b33d7c30034067$export$94affb487e701bf2.get(n);if(void 0!==o)return s.manager.itemStart(n),setTimeout(function(){r&&r(o),s.manager.itemEnd(n)},0),o;let l=$d5b33d7c30034067$var$createElementNS("img");function u(){h(),$d5b33d7c30034067$export$94affb487e701bf2.add(n,this),r&&r(this),s.manager.itemEnd(n)}function c(r){h(),a&&a(r),s.manager.itemError(n),s.manager.itemEnd(n)}function h(){l.removeEventListener("load",u,!1),l.removeEventListener("error",c,!1)}return l.addEventListener("load",u,!1),l.addEventListener("error",c,!1),"data:"!==n.slice(0,5)&&void 0!==this.crossOrigin&&(l.crossOrigin=this.crossOrigin),s.manager.itemStart(n),l.src=n,l}}class $d5b33d7c30034067$export$2ec114afc2cf6308 extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){let s=new $d5b33d7c30034067$export$ee2e5a18258a4049;s.colorSpace=$d5b33d7c30034067$export$561f394b24edfcaa;let o=new $d5b33d7c30034067$export$8905ce1c7a2464a1(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let l=0;function u(i){o.load(n[i],function(n){s.images[i]=n,6==++l&&(s.needsUpdate=!0,r&&r(s))},void 0,a)}for(let r=0;r<n.length;++r)u(r);return s}}/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */class $d5b33d7c30034067$export$792d8a18f2c55855 extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){let s=this,o=new $d5b33d7c30034067$export$b691f601014eabe1,l=new $d5b33d7c30034067$export$98435a25b5cf7b2b(this.manager);return l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setPath(this.path),l.setWithCredentials(s.withCredentials),l.load(n,function(n){let i;try{i=s.parse(n)}catch(n){if(void 0!==a)a(n);else{console.error(n);return}}void 0!==i.image?o.image=i.image:void 0!==i.data&&(o.image.width=i.width,o.image.height=i.height,o.image.data=i.data),o.wrapS=void 0!==i.wrapS?i.wrapS:$d5b33d7c30034067$export$9d9334239a5a5e06,o.wrapT=void 0!==i.wrapT?i.wrapT:$d5b33d7c30034067$export$9d9334239a5a5e06,o.magFilter=void 0!==i.magFilter?i.magFilter:$d5b33d7c30034067$export$8a72f490b25c56c8,o.minFilter=void 0!==i.minFilter?i.minFilter:$d5b33d7c30034067$export$8a72f490b25c56c8,o.anisotropy=void 0!==i.anisotropy?i.anisotropy:1,void 0!==i.colorSpace?o.colorSpace=i.colorSpace:void 0!==i.encoding&&(o.encoding=i.encoding),void 0!==i.flipY&&(o.flipY=i.flipY),void 0!==i.format&&(o.format=i.format),void 0!==i.type&&(o.type=i.type),void 0!==i.mipmaps&&(o.mipmaps=i.mipmaps,o.minFilter=$d5b33d7c30034067$export$5d8599b6a933fb1b),1===i.mipmapCount&&(o.minFilter=$d5b33d7c30034067$export$8a72f490b25c56c8),void 0!==i.generateMipmaps&&(o.generateMipmaps=i.generateMipmaps),o.needsUpdate=!0,r&&r(o,i)},i,a),o}}class $d5b33d7c30034067$export$fd1bfc71f64c538c extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){let s=new $d5b33d7c30034067$export$5431306cf43de24a,o=new $d5b33d7c30034067$export$8905ce1c7a2464a1(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(n,function(n){s.image=n,s.needsUpdate=!0,void 0!==r&&r(s)},i,a),s}}class $d5b33d7c30034067$export$6ecadb6ed240d696 extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(n,r=1){super(),this.isLight=!0,this.type="Light",this.color=new $d5b33d7c30034067$export$892596cec99bc70e(n),this.intensity=r}dispose(){// Empty here in base class; some subclasses override.
}copy(n,r){return super.copy(n,r),this.color.copy(n.color),this.intensity=n.intensity,this}toJSON(n){let r=super.toJSON(n);return r.object.color=this.color.getHex(),r.object.intensity=this.intensity,void 0!==this.groundColor&&(r.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(r.object.distance=this.distance),void 0!==this.angle&&(r.object.angle=this.angle),void 0!==this.decay&&(r.object.decay=this.decay),void 0!==this.penumbra&&(r.object.penumbra=this.penumbra),void 0!==this.shadow&&(r.object.shadow=this.shadow.toJSON()),r}}class $d5b33d7c30034067$export$8d474f55edbb9624 extends $d5b33d7c30034067$export$6ecadb6ed240d696{constructor(n,r,i){super(n,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy($d5b33d7c30034067$export$e4dd07dff30cc924.DEFAULT_UP),this.updateMatrix(),this.groundColor=new $d5b33d7c30034067$export$892596cec99bc70e(r)}copy(n,r){return super.copy(n,r),this.groundColor.copy(n.groundColor),this}}const $d5b33d7c30034067$var$_projScreenMatrix$1=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_lightPositionWorld$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_lookTarget$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$var$LightShadow{constructor(n){this.camera=n,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new $d5b33d7c30034067$export$c977b3e384af9ae1(512,512),this.map=null,this.mapPass=null,this.matrix=new $d5b33d7c30034067$export$2ae72fc923e5eb5,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new $d5b33d7c30034067$export$35efe6f4c85463d2,this._frameExtents=new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1),this._viewportCount=1,this._viewports=[new $d5b33d7c30034067$export$fa7daccca11cdbe3(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(n){let r=this.camera,i=this.matrix;$d5b33d7c30034067$var$_lightPositionWorld$1.setFromMatrixPosition(n.matrixWorld),r.position.copy($d5b33d7c30034067$var$_lightPositionWorld$1),$d5b33d7c30034067$var$_lookTarget$1.setFromMatrixPosition(n.target.matrixWorld),r.lookAt($d5b33d7c30034067$var$_lookTarget$1),r.updateMatrixWorld(),$d5b33d7c30034067$var$_projScreenMatrix$1.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),this._frustum.setFromProjectionMatrix($d5b33d7c30034067$var$_projScreenMatrix$1),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply($d5b33d7c30034067$var$_projScreenMatrix$1)}getViewport(n){return this._viewports[n]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(n){return this.camera=n.camera.clone(),this.bias=n.bias,this.radius=n.radius,this.mapSize.copy(n.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){let n={};return 0!==this.bias&&(n.bias=this.bias),0!==this.normalBias&&(n.normalBias=this.normalBias),1!==this.radius&&(n.radius=this.radius),(512!==this.mapSize.x||512!==this.mapSize.y)&&(n.mapSize=this.mapSize.toArray()),n.camera=this.camera.toJSON(!1).object,delete n.camera.matrix,n}}class $d5b33d7c30034067$var$SpotLightShadow extends $d5b33d7c30034067$var$LightShadow{constructor(){super(new $d5b33d7c30034067$export$74e4ae24825f68d7(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(n){let r=this.camera,i=2*$d5b33d7c30034067$var$RAD2DEG*n.angle*this.focus,a=this.mapSize.width/this.mapSize.height,s=n.distance||r.far;(i!==r.fov||a!==r.aspect||s!==r.far)&&(r.fov=i,r.aspect=a,r.far=s,r.updateProjectionMatrix()),super.updateMatrices(n)}copy(n){return super.copy(n),this.focus=n.focus,this}}class $d5b33d7c30034067$export$81495cbb73897362 extends $d5b33d7c30034067$export$6ecadb6ed240d696{constructor(n,r,i=0,a=Math.PI/3,s=0,o=2){super(n,r),this.isSpotLight=!0,this.type="SpotLight",this.position.copy($d5b33d7c30034067$export$e4dd07dff30cc924.DEFAULT_UP),this.updateMatrix(),this.target=new $d5b33d7c30034067$export$e4dd07dff30cc924,this.distance=i,this.angle=a,this.penumbra=s,this.decay=o,this.map=null,this.shadow=new $d5b33d7c30034067$var$SpotLightShadow}get power(){// compute the light's luminous power (in lumens) from its intensity (in candela)
// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
return this.intensity*Math.PI}set power(n){// set the light's intensity (in candela) from the desired luminous power (in lumens)
this.intensity=n/Math.PI}dispose(){this.shadow.dispose()}copy(n,r){return super.copy(n,r),this.distance=n.distance,this.angle=n.angle,this.penumbra=n.penumbra,this.decay=n.decay,this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}}const $d5b33d7c30034067$var$_projScreenMatrix=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_lightPositionWorld=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_lookTarget=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$var$PointLightShadow extends $d5b33d7c30034067$var$LightShadow{constructor(){super(new $d5b33d7c30034067$export$74e4ae24825f68d7(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new $d5b33d7c30034067$export$c977b3e384af9ae1(4,2),this._viewportCount=6,this._viewports=[// These viewports map a cube-map onto a 2D texture with the
// following orientation:
//
//  xzXZ
//   y Y
//
// X - Positive x direction
// x - Negative x direction
// Y - Positive y direction
// y - Negative y direction
// Z - Positive z direction
// z - Negative z direction
// positive X
new $d5b33d7c30034067$export$fa7daccca11cdbe3(2,1,1,1),// negative X
new $d5b33d7c30034067$export$fa7daccca11cdbe3(0,1,1,1),// positive Z
new $d5b33d7c30034067$export$fa7daccca11cdbe3(3,1,1,1),// negative Z
new $d5b33d7c30034067$export$fa7daccca11cdbe3(1,1,1,1),// positive Y
new $d5b33d7c30034067$export$fa7daccca11cdbe3(3,0,1,1),// negative Y
new $d5b33d7c30034067$export$fa7daccca11cdbe3(1,0,1,1)],this._cubeDirections=[new $d5b33d7c30034067$export$64b5c384219d3699(1,0,0),new $d5b33d7c30034067$export$64b5c384219d3699(-1,0,0),new $d5b33d7c30034067$export$64b5c384219d3699(0,0,1),new $d5b33d7c30034067$export$64b5c384219d3699(0,0,-1),new $d5b33d7c30034067$export$64b5c384219d3699(0,1,0),new $d5b33d7c30034067$export$64b5c384219d3699(0,-1,0)],this._cubeUps=[new $d5b33d7c30034067$export$64b5c384219d3699(0,1,0),new $d5b33d7c30034067$export$64b5c384219d3699(0,1,0),new $d5b33d7c30034067$export$64b5c384219d3699(0,1,0),new $d5b33d7c30034067$export$64b5c384219d3699(0,1,0),new $d5b33d7c30034067$export$64b5c384219d3699(0,0,1),new $d5b33d7c30034067$export$64b5c384219d3699(0,0,-1)]}updateMatrices(n,r=0){let i=this.camera,a=this.matrix,s=n.distance||i.far;s!==i.far&&(i.far=s,i.updateProjectionMatrix()),$d5b33d7c30034067$var$_lightPositionWorld.setFromMatrixPosition(n.matrixWorld),i.position.copy($d5b33d7c30034067$var$_lightPositionWorld),$d5b33d7c30034067$var$_lookTarget.copy(i.position),$d5b33d7c30034067$var$_lookTarget.add(this._cubeDirections[r]),i.up.copy(this._cubeUps[r]),i.lookAt($d5b33d7c30034067$var$_lookTarget),i.updateMatrixWorld(),a.makeTranslation(-$d5b33d7c30034067$var$_lightPositionWorld.x,-$d5b33d7c30034067$var$_lightPositionWorld.y,-$d5b33d7c30034067$var$_lightPositionWorld.z),$d5b33d7c30034067$var$_projScreenMatrix.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix($d5b33d7c30034067$var$_projScreenMatrix)}}class $d5b33d7c30034067$export$4c9c1cb3f0b6f455 extends $d5b33d7c30034067$export$6ecadb6ed240d696{constructor(n,r,i=0,a=2){super(n,r),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=a,this.shadow=new $d5b33d7c30034067$var$PointLightShadow}get power(){// compute the light's luminous power (in lumens) from its intensity (in candela)
// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
return 4*this.intensity*Math.PI}set power(n){// set the light's intensity (in candela) from the desired luminous power (in lumens)
this.intensity=n/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(n,r){return super.copy(n,r),this.distance=n.distance,this.decay=n.decay,this.shadow=n.shadow.clone(),this}}class $d5b33d7c30034067$var$DirectionalLightShadow extends $d5b33d7c30034067$var$LightShadow{constructor(){super(new $d5b33d7c30034067$export$9ebf355ee4ed261b(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class $d5b33d7c30034067$export$3fea33cc9972c868 extends $d5b33d7c30034067$export$6ecadb6ed240d696{constructor(n,r){super(n,r),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy($d5b33d7c30034067$export$e4dd07dff30cc924.DEFAULT_UP),this.updateMatrix(),this.target=new $d5b33d7c30034067$export$e4dd07dff30cc924,this.shadow=new $d5b33d7c30034067$var$DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(n){return super.copy(n),this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}}class $d5b33d7c30034067$export$af279bfef9ec2c96 extends $d5b33d7c30034067$export$6ecadb6ed240d696{constructor(n,r){super(n,r),this.isAmbientLight=!0,this.type="AmbientLight"}}class $d5b33d7c30034067$export$61db2d908bbd2429 extends $d5b33d7c30034067$export$6ecadb6ed240d696{constructor(n,r,i=10,a=10){super(n,r),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=a}get power(){// compute the light's luminous power (in lumens) from its intensity (in nits)
return this.intensity*this.width*this.height*Math.PI}set power(n){// set the light's intensity (in nits) from the desired luminous power (in lumens)
this.intensity=n/(this.width*this.height*Math.PI)}copy(n){return super.copy(n),this.width=n.width,this.height=n.height,this}toJSON(n){let r=super.toJSON(n);return r.object.width=this.width,r.object.height=this.height,r}}/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */// 3-band SH defined by 9 coefficients
class $d5b33d7c30034067$export$ba61ce607e1f405a{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let n=0;n<9;n++)this.coefficients.push(new $d5b33d7c30034067$export$64b5c384219d3699)}set(n){for(let r=0;r<9;r++)this.coefficients[r].copy(n[r]);return this}zero(){for(let n=0;n<9;n++)this.coefficients[n].set(0,0,0);return this}// get the radiance in the direction of the normal
// target is a Vector3
getAt(n,r){// normal is assumed to be unit length
let i=n.x,a=n.y,s=n.z,o=this.coefficients;return(// band 0
r.copy(o[0]).multiplyScalar(.282095),// band 1
r.addScaledVector(o[1],.488603*a),r.addScaledVector(o[2],.488603*s),r.addScaledVector(o[3],.488603*i),// band 2
r.addScaledVector(o[4],1.092548*(i*a)),r.addScaledVector(o[5],1.092548*(a*s)),r.addScaledVector(o[6],.315392*(3*s*s-1)),r.addScaledVector(o[7],1.092548*(i*s)),r.addScaledVector(o[8],.546274*(i*i-a*a)),r)}// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
// target is a Vector3
// https://graphics.stanford.edu/papers/envmap/envmap.pdf
getIrradianceAt(n,r){// normal is assumed to be unit length
let i=n.x,a=n.y,s=n.z,o=this.coefficients;return(// band 0
r.copy(o[0]).multiplyScalar(.886227),// band 1
r.addScaledVector(o[1],1.023328*a),r.addScaledVector(o[2],1.023328*s),r.addScaledVector(o[3],1.023328*i),// band 2
r.addScaledVector(o[4],.858086*i*a),r.addScaledVector(o[5],.858086*a*s),r.addScaledVector(o[6],.743125*s*s-.247708),r.addScaledVector(o[7],.858086*i*s),r.addScaledVector(o[8],.429043*(i*i-a*a)),r)}add(n){for(let r=0;r<9;r++)this.coefficients[r].add(n.coefficients[r]);return this}addScaledSH(n,r){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(n.coefficients[i],r);return this}scale(n){for(let r=0;r<9;r++)this.coefficients[r].multiplyScalar(n);return this}lerp(n,r){for(let i=0;i<9;i++)this.coefficients[i].lerp(n.coefficients[i],r);return this}equals(n){for(let r=0;r<9;r++)if(!this.coefficients[r].equals(n.coefficients[r]))return!1;return!0}copy(n){return this.set(n.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(n,r=0){let i=this.coefficients;for(let a=0;a<9;a++)i[a].fromArray(n,r+3*a);return this}toArray(n=[],r=0){let i=this.coefficients;for(let a=0;a<9;a++)i[a].toArray(n,r+3*a);return n}// evaluate the basis functions
// shBasis is an Array[ 9 ]
static getBasisAt(n,r){// normal is assumed to be unit length
let i=n.x,a=n.y,s=n.z;// band 0
r[0]=.282095,// band 1
r[1]=.488603*a,r[2]=.488603*s,r[3]=.488603*i,// band 2
r[4]=1.092548*i*a,r[5]=1.092548*a*s,r[6]=.315392*(3*s*s-1),r[7]=1.092548*i*s,r[8]=.546274*(i*i-a*a)}}class $d5b33d7c30034067$export$e7ef036e309b38d2 extends $d5b33d7c30034067$export$6ecadb6ed240d696{constructor(n=new $d5b33d7c30034067$export$ba61ce607e1f405a,r=1){super(void 0,r),this.isLightProbe=!0,this.sh=n}copy(n){return super.copy(n),this.sh.copy(n.sh),this}fromJSON(n){return this.intensity=n.intensity,this.sh.fromArray(n.sh),this}toJSON(n){let r=super.toJSON(n);return r.object.sh=this.sh.toArray(),r}}class $d5b33d7c30034067$export$3bd6d323353dcf96 extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n),this.textures={}}load(n,r,i,a){let s=this,o=new $d5b33d7c30034067$export$98435a25b5cf7b2b(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(n,function(i){try{r(s.parse(JSON.parse(i)))}catch(r){a?a(r):console.error(r),s.manager.itemError(n)}},i,a)}parse(n){let r=this.textures;function i(n){return void 0===r[n]&&console.warn("THREE.MaterialLoader: Undefined texture",n),r[n]}let a=$d5b33d7c30034067$export$3bd6d323353dcf96.createMaterialFromType(n.type);// Shader Material
if(void 0!==n.uuid&&(a.uuid=n.uuid),void 0!==n.name&&(a.name=n.name),void 0!==n.color&&void 0!==a.color&&a.color.setHex(n.color),void 0!==n.roughness&&(a.roughness=n.roughness),void 0!==n.metalness&&(a.metalness=n.metalness),void 0!==n.sheen&&(a.sheen=n.sheen),void 0!==n.sheenColor&&(a.sheenColor=new $d5b33d7c30034067$export$892596cec99bc70e().setHex(n.sheenColor)),void 0!==n.sheenRoughness&&(a.sheenRoughness=n.sheenRoughness),void 0!==n.emissive&&void 0!==a.emissive&&a.emissive.setHex(n.emissive),void 0!==n.specular&&void 0!==a.specular&&a.specular.setHex(n.specular),void 0!==n.specularIntensity&&(a.specularIntensity=n.specularIntensity),void 0!==n.specularColor&&void 0!==a.specularColor&&a.specularColor.setHex(n.specularColor),void 0!==n.shininess&&(a.shininess=n.shininess),void 0!==n.clearcoat&&(a.clearcoat=n.clearcoat),void 0!==n.clearcoatRoughness&&(a.clearcoatRoughness=n.clearcoatRoughness),void 0!==n.iridescence&&(a.iridescence=n.iridescence),void 0!==n.iridescenceIOR&&(a.iridescenceIOR=n.iridescenceIOR),void 0!==n.iridescenceThicknessRange&&(a.iridescenceThicknessRange=n.iridescenceThicknessRange),void 0!==n.transmission&&(a.transmission=n.transmission),void 0!==n.thickness&&(a.thickness=n.thickness),void 0!==n.attenuationDistance&&(a.attenuationDistance=n.attenuationDistance),void 0!==n.attenuationColor&&void 0!==a.attenuationColor&&a.attenuationColor.setHex(n.attenuationColor),void 0!==n.anisotropy&&(a.anisotropy=n.anisotropy),void 0!==n.anisotropyRotation&&(a.anisotropyRotation=n.anisotropyRotation),void 0!==n.fog&&(a.fog=n.fog),void 0!==n.flatShading&&(a.flatShading=n.flatShading),void 0!==n.blending&&(a.blending=n.blending),void 0!==n.combine&&(a.combine=n.combine),void 0!==n.side&&(a.side=n.side),void 0!==n.shadowSide&&(a.shadowSide=n.shadowSide),void 0!==n.opacity&&(a.opacity=n.opacity),void 0!==n.transparent&&(a.transparent=n.transparent),void 0!==n.alphaTest&&(a.alphaTest=n.alphaTest),void 0!==n.alphaHash&&(a.alphaHash=n.alphaHash),void 0!==n.depthTest&&(a.depthTest=n.depthTest),void 0!==n.depthWrite&&(a.depthWrite=n.depthWrite),void 0!==n.colorWrite&&(a.colorWrite=n.colorWrite),void 0!==n.stencilWrite&&(a.stencilWrite=n.stencilWrite),void 0!==n.stencilWriteMask&&(a.stencilWriteMask=n.stencilWriteMask),void 0!==n.stencilFunc&&(a.stencilFunc=n.stencilFunc),void 0!==n.stencilRef&&(a.stencilRef=n.stencilRef),void 0!==n.stencilFuncMask&&(a.stencilFuncMask=n.stencilFuncMask),void 0!==n.stencilFail&&(a.stencilFail=n.stencilFail),void 0!==n.stencilZFail&&(a.stencilZFail=n.stencilZFail),void 0!==n.stencilZPass&&(a.stencilZPass=n.stencilZPass),void 0!==n.wireframe&&(a.wireframe=n.wireframe),void 0!==n.wireframeLinewidth&&(a.wireframeLinewidth=n.wireframeLinewidth),void 0!==n.wireframeLinecap&&(a.wireframeLinecap=n.wireframeLinecap),void 0!==n.wireframeLinejoin&&(a.wireframeLinejoin=n.wireframeLinejoin),void 0!==n.rotation&&(a.rotation=n.rotation),1!==n.linewidth&&(a.linewidth=n.linewidth),void 0!==n.dashSize&&(a.dashSize=n.dashSize),void 0!==n.gapSize&&(a.gapSize=n.gapSize),void 0!==n.scale&&(a.scale=n.scale),void 0!==n.polygonOffset&&(a.polygonOffset=n.polygonOffset),void 0!==n.polygonOffsetFactor&&(a.polygonOffsetFactor=n.polygonOffsetFactor),void 0!==n.polygonOffsetUnits&&(a.polygonOffsetUnits=n.polygonOffsetUnits),void 0!==n.dithering&&(a.dithering=n.dithering),void 0!==n.alphaToCoverage&&(a.alphaToCoverage=n.alphaToCoverage),void 0!==n.premultipliedAlpha&&(a.premultipliedAlpha=n.premultipliedAlpha),void 0!==n.forceSinglePass&&(a.forceSinglePass=n.forceSinglePass),void 0!==n.visible&&(a.visible=n.visible),void 0!==n.toneMapped&&(a.toneMapped=n.toneMapped),void 0!==n.userData&&(a.userData=n.userData),void 0!==n.vertexColors&&("number"==typeof n.vertexColors?a.vertexColors=n.vertexColors>0:a.vertexColors=n.vertexColors),void 0!==n.uniforms)for(let r in n.uniforms){let s=n.uniforms[r];switch(a.uniforms[r]={},s.type){case"t":a.uniforms[r].value=i(s.value);break;case"c":a.uniforms[r].value=new $d5b33d7c30034067$export$892596cec99bc70e().setHex(s.value);break;case"v2":a.uniforms[r].value=new $d5b33d7c30034067$export$c977b3e384af9ae1().fromArray(s.value);break;case"v3":a.uniforms[r].value=new $d5b33d7c30034067$export$64b5c384219d3699().fromArray(s.value);break;case"v4":a.uniforms[r].value=new $d5b33d7c30034067$export$fa7daccca11cdbe3().fromArray(s.value);break;case"m3":a.uniforms[r].value=new $d5b33d7c30034067$export$8ff26dafa08918().fromArray(s.value);break;case"m4":a.uniforms[r].value=new $d5b33d7c30034067$export$2ae72fc923e5eb5().fromArray(s.value);break;default:a.uniforms[r].value=s.value}}if(void 0!==n.defines&&(a.defines=n.defines),void 0!==n.vertexShader&&(a.vertexShader=n.vertexShader),void 0!==n.fragmentShader&&(a.fragmentShader=n.fragmentShader),void 0!==n.glslVersion&&(a.glslVersion=n.glslVersion),void 0!==n.extensions)for(let r in n.extensions)a.extensions[r]=n.extensions[r];if(void 0!==n.lights&&(a.lights=n.lights),void 0!==n.clipping&&(a.clipping=n.clipping),void 0!==n.size&&(a.size=n.size),void 0!==n.sizeAttenuation&&(a.sizeAttenuation=n.sizeAttenuation),void 0!==n.map&&(a.map=i(n.map)),void 0!==n.matcap&&(a.matcap=i(n.matcap)),void 0!==n.alphaMap&&(a.alphaMap=i(n.alphaMap)),void 0!==n.bumpMap&&(a.bumpMap=i(n.bumpMap)),void 0!==n.bumpScale&&(a.bumpScale=n.bumpScale),void 0!==n.normalMap&&(a.normalMap=i(n.normalMap)),void 0!==n.normalMapType&&(a.normalMapType=n.normalMapType),void 0!==n.normalScale){let r=n.normalScale;!1===Array.isArray(r)&&(r=[r,r]),a.normalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1().fromArray(r)}return void 0!==n.displacementMap&&(a.displacementMap=i(n.displacementMap)),void 0!==n.displacementScale&&(a.displacementScale=n.displacementScale),void 0!==n.displacementBias&&(a.displacementBias=n.displacementBias),void 0!==n.roughnessMap&&(a.roughnessMap=i(n.roughnessMap)),void 0!==n.metalnessMap&&(a.metalnessMap=i(n.metalnessMap)),void 0!==n.emissiveMap&&(a.emissiveMap=i(n.emissiveMap)),void 0!==n.emissiveIntensity&&(a.emissiveIntensity=n.emissiveIntensity),void 0!==n.specularMap&&(a.specularMap=i(n.specularMap)),void 0!==n.specularIntensityMap&&(a.specularIntensityMap=i(n.specularIntensityMap)),void 0!==n.specularColorMap&&(a.specularColorMap=i(n.specularColorMap)),void 0!==n.envMap&&(a.envMap=i(n.envMap)),void 0!==n.envMapIntensity&&(a.envMapIntensity=n.envMapIntensity),void 0!==n.reflectivity&&(a.reflectivity=n.reflectivity),void 0!==n.refractionRatio&&(a.refractionRatio=n.refractionRatio),void 0!==n.lightMap&&(a.lightMap=i(n.lightMap)),void 0!==n.lightMapIntensity&&(a.lightMapIntensity=n.lightMapIntensity),void 0!==n.aoMap&&(a.aoMap=i(n.aoMap)),void 0!==n.aoMapIntensity&&(a.aoMapIntensity=n.aoMapIntensity),void 0!==n.gradientMap&&(a.gradientMap=i(n.gradientMap)),void 0!==n.clearcoatMap&&(a.clearcoatMap=i(n.clearcoatMap)),void 0!==n.clearcoatRoughnessMap&&(a.clearcoatRoughnessMap=i(n.clearcoatRoughnessMap)),void 0!==n.clearcoatNormalMap&&(a.clearcoatNormalMap=i(n.clearcoatNormalMap)),void 0!==n.clearcoatNormalScale&&(a.clearcoatNormalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1().fromArray(n.clearcoatNormalScale)),void 0!==n.iridescenceMap&&(a.iridescenceMap=i(n.iridescenceMap)),void 0!==n.iridescenceThicknessMap&&(a.iridescenceThicknessMap=i(n.iridescenceThicknessMap)),void 0!==n.transmissionMap&&(a.transmissionMap=i(n.transmissionMap)),void 0!==n.thicknessMap&&(a.thicknessMap=i(n.thicknessMap)),void 0!==n.anisotropyMap&&(a.anisotropyMap=i(n.anisotropyMap)),void 0!==n.sheenColorMap&&(a.sheenColorMap=i(n.sheenColorMap)),void 0!==n.sheenRoughnessMap&&(a.sheenRoughnessMap=i(n.sheenRoughnessMap)),a}setTextures(n){return this.textures=n,this}static createMaterialFromType(n){let r={ShadowMaterial:$d5b33d7c30034067$export$e8564da406055a3,SpriteMaterial:$d5b33d7c30034067$export$5ec7dd1c6994bf8e,RawShaderMaterial:$d5b33d7c30034067$export$21c421a2e1df9d22,ShaderMaterial:$d5b33d7c30034067$export$83c7d75d550a8b0d,PointsMaterial:$d5b33d7c30034067$export$a178c45366ce5d6b,MeshPhysicalMaterial:$d5b33d7c30034067$export$28d04986c4269c9f,MeshStandardMaterial:$d5b33d7c30034067$export$f2980790215acccd,MeshPhongMaterial:$d5b33d7c30034067$export$24c72f71cbaf0678,MeshToonMaterial:$d5b33d7c30034067$export$df893cf97e765622,MeshNormalMaterial:$d5b33d7c30034067$export$bfe8c0a091f41ae7,MeshLambertMaterial:$d5b33d7c30034067$export$5023a9a8114806b8,MeshDepthMaterial:$d5b33d7c30034067$export$2698c22ec13825db,MeshDistanceMaterial:$d5b33d7c30034067$export$33e187ed002f2a19,MeshBasicMaterial:$d5b33d7c30034067$export$55cbcc9b622fe1f5,MeshMatcapMaterial:$d5b33d7c30034067$export$6f5fef6235ec12ee,LineDashedMaterial:$d5b33d7c30034067$export$327886a3efaeaebe,LineBasicMaterial:$d5b33d7c30034067$export$fbaaa33907730a0c,Material:$d5b33d7c30034067$export$a2d8b23205c25948};return new r[n]}}class $d5b33d7c30034067$export$b5d2dc08d867e41a{static decodeText(n){if("undefined"!=typeof TextDecoder)return new TextDecoder().decode(n);// Avoid the String.fromCharCode.apply(null, array) shortcut, which
// throws a "maximum call stack size exceeded" error for large arrays.
let r="";for(let i=0,a=n.length;i<a;i++)r+=String.fromCharCode(n[i]);try{// merges multi-byte utf-8 characters.
return decodeURIComponent(escape(r))}catch(n){return r}}static extractUrlBase(n){let r=n.lastIndexOf("/");return -1===r?"./":n.slice(0,r+1)}static resolveURL(n,r){return(// Invalid URL
"string"!=typeof n||""===n?"":(/^https?:\/\//i.test(r)&&/^\//.test(n)&&(r=r.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(n)||/^data:.*,.*$/i.test(n)||/^blob:.*$/i.test(n))?n:r+n)}}class $d5b33d7c30034067$export$231f009cbe414146 extends $d5b33d7c30034067$export$b7be63a67df8959{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(n){return super.copy(n),this.instanceCount=n.instanceCount,this}toJSON(){let n=super.toJSON();return n.instanceCount=this.instanceCount,n.isInstancedBufferGeometry=!0,n}}class $d5b33d7c30034067$export$dc275bb96327833a extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){let s=this,o=new $d5b33d7c30034067$export$98435a25b5cf7b2b(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(n,function(i){try{r(s.parse(JSON.parse(i)))}catch(r){a?a(r):console.error(r),s.manager.itemError(n)}},i,a)}parse(n){let r={},i={};function a(n,i){if(void 0!==r[i])return r[i];let a=n.interleavedBuffers,o=a[i],l=s(n,o.buffer),u=$d5b33d7c30034067$var$getTypedArray(o.type,l),c=new $d5b33d7c30034067$export$3d5cd879f108f53f(u,o.stride);return c.uuid=o.uuid,r[i]=c,c}function s(n,r){if(void 0!==i[r])return i[r];let a=n.arrayBuffers,s=a[r],o=new Uint32Array(s).buffer;return i[r]=o,o}let o=n.isInstancedBufferGeometry?new $d5b33d7c30034067$export$231f009cbe414146:new $d5b33d7c30034067$export$b7be63a67df8959,l=n.data.index;if(void 0!==l){let n=$d5b33d7c30034067$var$getTypedArray(l.type,l.array);o.setIndex(new $d5b33d7c30034067$export$8dea267bd6bde117(n,1))}let u=n.data.attributes;for(let r in u){let i;let s=u[r];if(s.isInterleavedBufferAttribute){let r=a(n.data,s.data);i=new $d5b33d7c30034067$export$920b6d07334599c7(r,s.itemSize,s.offset,s.normalized)}else{let n=$d5b33d7c30034067$var$getTypedArray(s.type,s.array),r=s.isInstancedBufferAttribute?$d5b33d7c30034067$export$32ea87a8b54d744a:$d5b33d7c30034067$export$8dea267bd6bde117;i=new r(n,s.itemSize,s.normalized)}void 0!==s.name&&(i.name=s.name),void 0!==s.usage&&i.setUsage(s.usage),void 0!==s.updateRange&&(i.updateRange.offset=s.updateRange.offset,i.updateRange.count=s.updateRange.count),o.setAttribute(r,i)}let c=n.data.morphAttributes;if(c)for(let r in c){let i=c[r],s=[];for(let r=0,o=i.length;r<o;r++){let o;let l=i[r];if(l.isInterleavedBufferAttribute){let r=a(n.data,l.data);o=new $d5b33d7c30034067$export$920b6d07334599c7(r,l.itemSize,l.offset,l.normalized)}else{let n=$d5b33d7c30034067$var$getTypedArray(l.type,l.array);o=new $d5b33d7c30034067$export$8dea267bd6bde117(n,l.itemSize,l.normalized)}void 0!==l.name&&(o.name=l.name),s.push(o)}o.morphAttributes[r]=s}let h=n.data.morphTargetsRelative;h&&(o.morphTargetsRelative=!0);let d=n.data.groups||n.data.drawcalls||n.data.offsets;if(void 0!==d)for(let n=0,r=d.length;n!==r;++n){let r=d[n];o.addGroup(r.start,r.count,r.materialIndex)}let p=n.data.boundingSphere;if(void 0!==p){let n=new $d5b33d7c30034067$export$64b5c384219d3699;void 0!==p.center&&n.fromArray(p.center),o.boundingSphere=new $d5b33d7c30034067$export$805e8b72413ccaba(n,p.radius)}return n.name&&(o.name=n.name),n.userData&&(o.userData=n.userData),o}}class $d5b33d7c30034067$export$40110c8505c5ad19 extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){let s=this,o=""===this.path?$d5b33d7c30034067$export$b5d2dc08d867e41a.extractUrlBase(n):this.path;this.resourcePath=this.resourcePath||o;let l=new $d5b33d7c30034067$export$98435a25b5cf7b2b(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(n,function(i){let o=null;try{o=JSON.parse(i)}catch(r){void 0!==a&&a(r),console.error("THREE:ObjectLoader: Can't parse "+n+".",r.message);return}let l=o.metadata;if(void 0===l||void 0===l.type||"geometry"===l.type.toLowerCase()){void 0!==a&&a(Error("THREE.ObjectLoader: Can't load "+n)),console.error("THREE.ObjectLoader: Can't load "+n);return}s.parse(o,r)},i,a)}async loadAsync(n,r){let i=this,a=""===this.path?$d5b33d7c30034067$export$b5d2dc08d867e41a.extractUrlBase(n):this.path;this.resourcePath=this.resourcePath||a;let s=new $d5b33d7c30034067$export$98435a25b5cf7b2b(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials);let o=await s.loadAsync(n,r),l=JSON.parse(o),u=l.metadata;if(void 0===u||void 0===u.type||"geometry"===u.type.toLowerCase())throw Error("THREE.ObjectLoader: Can't load "+n);return await i.parseAsync(l)}parse(n,r){let i=this.parseAnimations(n.animations),a=this.parseShapes(n.shapes),s=this.parseGeometries(n.geometries,a),o=this.parseImages(n.images,function(){void 0!==r&&r(c)}),l=this.parseTextures(n.textures,o),u=this.parseMaterials(n.materials,l),c=this.parseObject(n.object,s,u,l,i),h=this.parseSkeletons(n.skeletons,c);//
if(this.bindSkeletons(c,h),void 0!==r){let n=!1;for(let r in o)if(o[r].data instanceof HTMLImageElement){n=!0;break}!1===n&&r(c)}return c}async parseAsync(n){let r=this.parseAnimations(n.animations),i=this.parseShapes(n.shapes),a=this.parseGeometries(n.geometries,i),s=await this.parseImagesAsync(n.images),o=this.parseTextures(n.textures,s),l=this.parseMaterials(n.materials,o),u=this.parseObject(n.object,a,l,o,r),c=this.parseSkeletons(n.skeletons,u);return this.bindSkeletons(u,c),u}parseShapes(n){let r={};if(void 0!==n)for(let i=0,a=n.length;i<a;i++){let a=new $d5b33d7c30034067$export$6428a7f2611ef1fa().fromJSON(n[i]);r[a.uuid]=a}return r}parseSkeletons(n,r){let i={},a={};// create skeletons
if(// generate bone lookup table
r.traverse(function(n){n.isBone&&(a[n.uuid]=n)}),void 0!==n)for(let r=0,s=n.length;r<s;r++){let s=new $d5b33d7c30034067$export$8f31e4c4a37b8e9c().fromJSON(n[r],a);i[s.uuid]=s}return i}parseGeometries(n,r){let i={};if(void 0!==n){let a=new $d5b33d7c30034067$export$dc275bb96327833a;for(let s=0,o=n.length;s<o;s++){let o;let l=n[s];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":o=a.parse(l);break;default:l.type in $d5b33d7c30034067$var$Geometries?o=$d5b33d7c30034067$var$Geometries[l.type].fromJSON(l,r):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}o.uuid=l.uuid,void 0!==l.name&&(o.name=l.name),void 0!==l.userData&&(o.userData=l.userData),i[l.uuid]=o}}return i}parseMaterials(n,r){let i={},a={};// MultiMaterial
if(void 0!==n){let s=new $d5b33d7c30034067$export$3bd6d323353dcf96;s.setTextures(r);for(let r=0,o=n.length;r<o;r++){let o=n[r];void 0===i[o.uuid]&&(i[o.uuid]=s.parse(o)),a[o.uuid]=i[o.uuid]}}return a}parseAnimations(n){let r={};if(void 0!==n)for(let i=0;i<n.length;i++){let a=n[i],s=$d5b33d7c30034067$export$d942c706bf23829c.parse(a);r[s.uuid]=s}return r}parseImages(n,r){let i;let a=this,s={};function o(n){return a.manager.itemStart(n),i.load(n,function(){a.manager.itemEnd(n)},void 0,function(){a.manager.itemError(n),a.manager.itemEnd(n)})}function l(n){if("string"==typeof n){let r=n,i=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(r)?r:a.resourcePath+r;return o(i)}return n.data?{data:$d5b33d7c30034067$var$getTypedArray(n.type,n.data),width:n.width,height:n.height}:null}if(void 0!==n&&n.length>0){let a=new $d5b33d7c30034067$export$99cc795e99919eed(r);(i=new $d5b33d7c30034067$export$8905ce1c7a2464a1(a)).setCrossOrigin(this.crossOrigin);for(let r=0,i=n.length;r<i;r++){let i=n[r],a=i.url;if(Array.isArray(a)){// load array of images e.g CubeTexture
let n=[];for(let r=0,i=a.length;r<i;r++){let i=a[r],s=l(i);null!==s&&(s instanceof HTMLImageElement?n.push(s):n.push(new $d5b33d7c30034067$export$b691f601014eabe1(s.data,s.width,s.height)))}s[i.uuid]=new $d5b33d7c30034067$export$1d2df86270c81ecb(n)}else{// load single image
let n=l(i.url);s[i.uuid]=new $d5b33d7c30034067$export$1d2df86270c81ecb(n)}}}return s}async parseImagesAsync(n){let r;let i=this,a={};async function s(n){if("string"==typeof n){let a=n,s=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:i.resourcePath+a;return await r.loadAsync(s)}return n.data?{data:$d5b33d7c30034067$var$getTypedArray(n.type,n.data),width:n.width,height:n.height}:null}if(void 0!==n&&n.length>0){(r=new $d5b33d7c30034067$export$8905ce1c7a2464a1(this.manager)).setCrossOrigin(this.crossOrigin);for(let r=0,i=n.length;r<i;r++){let i=n[r],o=i.url;if(Array.isArray(o)){// load array of images e.g CubeTexture
let n=[];for(let r=0,i=o.length;r<i;r++){let i=o[r],a=await s(i);null!==a&&(a instanceof HTMLImageElement?n.push(a):n.push(new $d5b33d7c30034067$export$b691f601014eabe1(a.data,a.width,a.height)))}a[i.uuid]=new $d5b33d7c30034067$export$1d2df86270c81ecb(n)}else{// load single image
let n=await s(i.url);a[i.uuid]=new $d5b33d7c30034067$export$1d2df86270c81ecb(n)}}}return a}parseTextures(n,r){function i(n,r){return"number"==typeof n?n:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",n),r[n])}let a={};if(void 0!==n)for(let s=0,o=n.length;s<o;s++){let o;let l=n[s];void 0===l.image&&console.warn('THREE.ObjectLoader: No "image" specified for',l.uuid),void 0===r[l.image]&&console.warn("THREE.ObjectLoader: Undefined image",l.image);let u=r[l.image],c=u.data;Array.isArray(c)?(o=new $d5b33d7c30034067$export$ee2e5a18258a4049,6===c.length&&(o.needsUpdate=!0)):(o=c&&c.data?new $d5b33d7c30034067$export$b691f601014eabe1:new $d5b33d7c30034067$export$5431306cf43de24a,c&&(o.needsUpdate=!0)),o.source=u,o.uuid=l.uuid,void 0!==l.name&&(o.name=l.name),void 0!==l.mapping&&(o.mapping=i(l.mapping,$d5b33d7c30034067$var$TEXTURE_MAPPING)),void 0!==l.channel&&(o.channel=l.channel),void 0!==l.offset&&o.offset.fromArray(l.offset),void 0!==l.repeat&&o.repeat.fromArray(l.repeat),void 0!==l.center&&o.center.fromArray(l.center),void 0!==l.rotation&&(o.rotation=l.rotation),void 0!==l.wrap&&(o.wrapS=i(l.wrap[0],$d5b33d7c30034067$var$TEXTURE_WRAPPING),o.wrapT=i(l.wrap[1],$d5b33d7c30034067$var$TEXTURE_WRAPPING)),void 0!==l.format&&(o.format=l.format),void 0!==l.internalFormat&&(o.internalFormat=l.internalFormat),void 0!==l.type&&(o.type=l.type),void 0!==l.colorSpace&&(o.colorSpace=l.colorSpace),void 0!==l.encoding&&(o.encoding=l.encoding),void 0!==l.minFilter&&(o.minFilter=i(l.minFilter,$d5b33d7c30034067$var$TEXTURE_FILTER)),void 0!==l.magFilter&&(o.magFilter=i(l.magFilter,$d5b33d7c30034067$var$TEXTURE_FILTER)),void 0!==l.anisotropy&&(o.anisotropy=l.anisotropy),void 0!==l.flipY&&(o.flipY=l.flipY),void 0!==l.generateMipmaps&&(o.generateMipmaps=l.generateMipmaps),void 0!==l.premultiplyAlpha&&(o.premultiplyAlpha=l.premultiplyAlpha),void 0!==l.unpackAlignment&&(o.unpackAlignment=l.unpackAlignment),void 0!==l.compareFunction&&(o.compareFunction=l.compareFunction),void 0!==l.userData&&(o.userData=l.userData),a[l.uuid]=o}return a}parseObject(n,r,i,a,s){let o,l,u;function c(n){return void 0===r[n]&&console.warn("THREE.ObjectLoader: Undefined geometry",n),r[n]}function h(n){if(void 0!==n){if(Array.isArray(n)){let r=[];for(let a=0,s=n.length;a<s;a++){let s=n[a];void 0===i[s]&&console.warn("THREE.ObjectLoader: Undefined material",s),r.push(i[s])}return r}return void 0===i[n]&&console.warn("THREE.ObjectLoader: Undefined material",n),i[n]}}function d(n){return void 0===a[n]&&console.warn("THREE.ObjectLoader: Undefined texture",n),a[n]}switch(n.type){case"Scene":o=new $d5b33d7c30034067$export$38af1803e3442a7f,void 0!==n.background&&(Number.isInteger(n.background)?o.background=new $d5b33d7c30034067$export$892596cec99bc70e(n.background):o.background=d(n.background)),void 0!==n.environment&&(o.environment=d(n.environment)),void 0!==n.fog&&("Fog"===n.fog.type?o.fog=new $d5b33d7c30034067$export$3c890837b09508d4(n.fog.color,n.fog.near,n.fog.far):"FogExp2"===n.fog.type&&(o.fog=new $d5b33d7c30034067$export$6f1519f023b8d0f6(n.fog.color,n.fog.density))),void 0!==n.backgroundBlurriness&&(o.backgroundBlurriness=n.backgroundBlurriness),void 0!==n.backgroundIntensity&&(o.backgroundIntensity=n.backgroundIntensity);break;case"PerspectiveCamera":o=new $d5b33d7c30034067$export$74e4ae24825f68d7(n.fov,n.aspect,n.near,n.far),void 0!==n.focus&&(o.focus=n.focus),void 0!==n.zoom&&(o.zoom=n.zoom),void 0!==n.filmGauge&&(o.filmGauge=n.filmGauge),void 0!==n.filmOffset&&(o.filmOffset=n.filmOffset),void 0!==n.view&&(o.view=Object.assign({},n.view));break;case"OrthographicCamera":o=new $d5b33d7c30034067$export$9ebf355ee4ed261b(n.left,n.right,n.top,n.bottom,n.near,n.far),void 0!==n.zoom&&(o.zoom=n.zoom),void 0!==n.view&&(o.view=Object.assign({},n.view));break;case"AmbientLight":o=new $d5b33d7c30034067$export$af279bfef9ec2c96(n.color,n.intensity);break;case"DirectionalLight":o=new $d5b33d7c30034067$export$3fea33cc9972c868(n.color,n.intensity);break;case"PointLight":o=new $d5b33d7c30034067$export$4c9c1cb3f0b6f455(n.color,n.intensity,n.distance,n.decay);break;case"RectAreaLight":o=new $d5b33d7c30034067$export$61db2d908bbd2429(n.color,n.intensity,n.width,n.height);break;case"SpotLight":o=new $d5b33d7c30034067$export$81495cbb73897362(n.color,n.intensity,n.distance,n.angle,n.penumbra,n.decay);break;case"HemisphereLight":o=new $d5b33d7c30034067$export$8d474f55edbb9624(n.color,n.groundColor,n.intensity);break;case"LightProbe":o=new $d5b33d7c30034067$export$e7ef036e309b38d2().fromJSON(n);break;case"SkinnedMesh":l=c(n.geometry),u=h(n.material),o=new $d5b33d7c30034067$export$b303577035157ecf(l,u),void 0!==n.bindMode&&(o.bindMode=n.bindMode),void 0!==n.bindMatrix&&o.bindMatrix.fromArray(n.bindMatrix),void 0!==n.skeleton&&(o.skeleton=n.skeleton);break;case"Mesh":l=c(n.geometry),u=h(n.material),o=new $d5b33d7c30034067$export$e176487c05830cc5(l,u);break;case"InstancedMesh":l=c(n.geometry),u=h(n.material);let p=n.count,f=n.instanceMatrix,m=n.instanceColor;(o=new $d5b33d7c30034067$export$f3c979c331175ad7(l,u,p)).instanceMatrix=new $d5b33d7c30034067$export$32ea87a8b54d744a(new Float32Array(f.array),16),void 0!==m&&(o.instanceColor=new $d5b33d7c30034067$export$32ea87a8b54d744a(new Float32Array(m.array),m.itemSize));break;case"LOD":o=new $d5b33d7c30034067$export$112e7237be0c5f30;break;case"Line":o=new $d5b33d7c30034067$export$17d680238e50603e(c(n.geometry),h(n.material));break;case"LineLoop":o=new $d5b33d7c30034067$export$f85a24d745e4f17d(c(n.geometry),h(n.material));break;case"LineSegments":o=new $d5b33d7c30034067$export$ff1ed10fedfdd604(c(n.geometry),h(n.material));break;case"PointCloud":case"Points":o=new $d5b33d7c30034067$export$1c787534cb11aa3e(c(n.geometry),h(n.material));break;case"Sprite":o=new $d5b33d7c30034067$export$3075603db8e6204c(h(n.material));break;case"Group":o=new $d5b33d7c30034067$export$eb2fcfdbd7ba97d4;break;case"Bone":o=new $d5b33d7c30034067$export$b127726e56765aa4;break;default:o=new $d5b33d7c30034067$export$e4dd07dff30cc924}if(o.uuid=n.uuid,void 0!==n.name&&(o.name=n.name),void 0!==n.matrix?(o.matrix.fromArray(n.matrix),void 0!==n.matrixAutoUpdate&&(o.matrixAutoUpdate=n.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(void 0!==n.position&&o.position.fromArray(n.position),void 0!==n.rotation&&o.rotation.fromArray(n.rotation),void 0!==n.quaternion&&o.quaternion.fromArray(n.quaternion),void 0!==n.scale&&o.scale.fromArray(n.scale)),void 0!==n.up&&o.up.fromArray(n.up),void 0!==n.castShadow&&(o.castShadow=n.castShadow),void 0!==n.receiveShadow&&(o.receiveShadow=n.receiveShadow),n.shadow&&(void 0!==n.shadow.bias&&(o.shadow.bias=n.shadow.bias),void 0!==n.shadow.normalBias&&(o.shadow.normalBias=n.shadow.normalBias),void 0!==n.shadow.radius&&(o.shadow.radius=n.shadow.radius),void 0!==n.shadow.mapSize&&o.shadow.mapSize.fromArray(n.shadow.mapSize),void 0!==n.shadow.camera&&(o.shadow.camera=this.parseObject(n.shadow.camera))),void 0!==n.visible&&(o.visible=n.visible),void 0!==n.frustumCulled&&(o.frustumCulled=n.frustumCulled),void 0!==n.renderOrder&&(o.renderOrder=n.renderOrder),void 0!==n.userData&&(o.userData=n.userData),void 0!==n.layers&&(o.layers.mask=n.layers),void 0!==n.children){let l=n.children;for(let n=0;n<l.length;n++)o.add(this.parseObject(l[n],r,i,a,s))}if(void 0!==n.animations){let r=n.animations;for(let n=0;n<r.length;n++){let i=r[n];o.animations.push(s[i])}}if("LOD"===n.type){void 0!==n.autoUpdate&&(o.autoUpdate=n.autoUpdate);let r=n.levels;for(let n=0;n<r.length;n++){let i=r[n],a=o.getObjectByProperty("uuid",i.object);void 0!==a&&o.addLevel(a,i.distance,i.hysteresis)}}return o}bindSkeletons(n,r){0!==Object.keys(r).length&&n.traverse(function(n){if(!0===n.isSkinnedMesh&&void 0!==n.skeleton){let i=r[n.skeleton];void 0===i?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(i,n.bindMatrix)}})}}const $d5b33d7c30034067$var$TEXTURE_MAPPING={UVMapping:$d5b33d7c30034067$export$1beec6768cbb3d2d,CubeReflectionMapping:$d5b33d7c30034067$export$8759762a6477f2c4,CubeRefractionMapping:$d5b33d7c30034067$export$dc59f8aed047f61d,EquirectangularReflectionMapping:$d5b33d7c30034067$export$d64030b316d3b087,EquirectangularRefractionMapping:$d5b33d7c30034067$export$ee99d97d46898098,CubeUVReflectionMapping:$d5b33d7c30034067$export$dbf3e70ff37af79},$d5b33d7c30034067$var$TEXTURE_WRAPPING={RepeatWrapping:$d5b33d7c30034067$export$533346c8e8dac0f5,ClampToEdgeWrapping:$d5b33d7c30034067$export$9d9334239a5a5e06,MirroredRepeatWrapping:$d5b33d7c30034067$export$c7e7c00b14f51a4f},$d5b33d7c30034067$var$TEXTURE_FILTER={NearestFilter:$d5b33d7c30034067$export$727aa5ec3fe39bf0,NearestMipmapNearestFilter:$d5b33d7c30034067$export$d129e38cf6feaa8c,NearestMipmapLinearFilter:$d5b33d7c30034067$export$d2327c1afe5bfdf2,LinearFilter:$d5b33d7c30034067$export$8a72f490b25c56c8,LinearMipmapNearestFilter:$d5b33d7c30034067$export$19a719f377145a13,LinearMipmapLinearFilter:$d5b33d7c30034067$export$5d8599b6a933fb1b};class $d5b33d7c30034067$export$52286b55c4a9b51f extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n),this.isImageBitmapLoader=!0,"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(n){return this.options=n,this}load(n,r,i,a){void 0===n&&(n=""),void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);let s=this,o=$d5b33d7c30034067$export$94affb487e701bf2.get(n);if(void 0!==o)return s.manager.itemStart(n),setTimeout(function(){r&&r(o),s.manager.itemEnd(n)},0),o;let l={};l.credentials="anonymous"===this.crossOrigin?"same-origin":"include",l.headers=this.requestHeader,fetch(n,l).then(function(n){return n.blob()}).then(function(n){return createImageBitmap(n,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(i){$d5b33d7c30034067$export$94affb487e701bf2.add(n,i),r&&r(i),s.manager.itemEnd(n)}).catch(function(r){a&&a(r),s.manager.itemError(n),s.manager.itemEnd(n)}),s.manager.itemStart(n)}}class $d5b33d7c30034067$export$fcbc63750ec2a81f{static getContext(){return void 0===$d5b33d7c30034067$var$_context&&($d5b33d7c30034067$var$_context=new(window.AudioContext||window.webkitAudioContext)),$d5b33d7c30034067$var$_context}static setContext(n){$d5b33d7c30034067$var$_context=n}}class $d5b33d7c30034067$export$d8d5fccfbf47714e extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){let s=this,o=new $d5b33d7c30034067$export$98435a25b5cf7b2b(this.manager);function l(r){a?a(r):console.error(r),s.manager.itemError(n)}o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(n,function(n){try{// Create a copy of the buffer. The `decodeAudioData` method
// detaches the buffer when complete, preventing reuse.
let i=n.slice(0),a=$d5b33d7c30034067$export$fcbc63750ec2a81f.getContext();a.decodeAudioData(i,function(n){r(n)},l)}catch(n){l(n)}},i,a)}}class $d5b33d7c30034067$export$2f22dadc8bc42820 extends $d5b33d7c30034067$export$e7ef036e309b38d2{constructor(n,r,i=1){super(void 0,i),this.isHemisphereLightProbe=!0;let a=new $d5b33d7c30034067$export$892596cec99bc70e().set(n),s=new $d5b33d7c30034067$export$892596cec99bc70e().set(r),o=new $d5b33d7c30034067$export$64b5c384219d3699(a.r,a.g,a.b),l=new $d5b33d7c30034067$export$64b5c384219d3699(s.r,s.g,s.b),u=Math.sqrt(Math.PI),c=u*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(l).multiplyScalar(u),this.sh.coefficients[1].copy(o).sub(l).multiplyScalar(c)}}class $d5b33d7c30034067$export$afe310a21c86023d extends $d5b33d7c30034067$export$e7ef036e309b38d2{constructor(n,r=1){super(void 0,r),this.isAmbientLightProbe=!0;let i=new $d5b33d7c30034067$export$892596cec99bc70e().set(n);// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
this.sh.coefficients[0].set(i.r,i.g,i.b).multiplyScalar(2*Math.sqrt(Math.PI))}}const $d5b33d7c30034067$var$_eyeRight=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_eyeLeft=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_projectionMatrix=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5;class $d5b33d7c30034067$export$bc7f73a1065bee0c{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new $d5b33d7c30034067$export$74e4ae24825f68d7,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new $d5b33d7c30034067$export$74e4ae24825f68d7,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(n){let r=this._cache,i=r.focus!==n.focus||r.fov!==n.fov||r.aspect!==n.aspect*this.aspect||r.near!==n.near||r.far!==n.far||r.zoom!==n.zoom||r.eyeSep!==this.eyeSep;if(i){let i,a;r.focus=n.focus,r.fov=n.fov,r.aspect=n.aspect*this.aspect,r.near=n.near,r.far=n.far,r.zoom=n.zoom,r.eyeSep=this.eyeSep,// Off-axis stereoscopic effect based on
// http://paulbourke.net/stereographics/stereorender/
$d5b33d7c30034067$var$_projectionMatrix.copy(n.projectionMatrix);let s=r.eyeSep/2,o=s*r.near/r.focus,l=r.near*Math.tan($d5b33d7c30034067$var$DEG2RAD*r.fov*.5)/r.zoom;// translate xOffset
$d5b33d7c30034067$var$_eyeLeft.elements[12]=-s,$d5b33d7c30034067$var$_eyeRight.elements[12]=s,// for left eye
i=-l*r.aspect+o,a=l*r.aspect+o,$d5b33d7c30034067$var$_projectionMatrix.elements[0]=2*r.near/(a-i),$d5b33d7c30034067$var$_projectionMatrix.elements[8]=(a+i)/(a-i),this.cameraL.projectionMatrix.copy($d5b33d7c30034067$var$_projectionMatrix),// for right eye
i=-l*r.aspect-o,a=l*r.aspect-o,$d5b33d7c30034067$var$_projectionMatrix.elements[0]=2*r.near/(a-i),$d5b33d7c30034067$var$_projectionMatrix.elements[8]=(a+i)/(a-i),this.cameraR.projectionMatrix.copy($d5b33d7c30034067$var$_projectionMatrix)}this.cameraL.matrixWorld.copy(n.matrixWorld).multiply($d5b33d7c30034067$var$_eyeLeft),this.cameraR.matrixWorld.copy(n.matrixWorld).multiply($d5b33d7c30034067$var$_eyeRight)}}class $d5b33d7c30034067$export$9735c82c4bae3302{constructor(n=!0){this.autoStart=n,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=$d5b33d7c30034067$var$now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let n=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){let r=$d5b33d7c30034067$var$now();n=(r-this.oldTime)/1e3,this.oldTime=r,this.elapsedTime+=n}return n}}function $d5b33d7c30034067$var$now(){return("undefined"==typeof performance?Date:performance).now();// see #10732
}const $d5b33d7c30034067$var$_position$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_quaternion$1=/*@__PURE__*/new $d5b33d7c30034067$export$23d6a54f0bbc85a3,$d5b33d7c30034067$var$_scale$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_orientation$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$8a1b810c6fde8951 extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(){super(),this.type="AudioListener",this.context=$d5b33d7c30034067$export$fcbc63750ec2a81f.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,// private
this._clock=new $d5b33d7c30034067$export$9735c82c4bae3302}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(n){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=n,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(n){return this.gain.gain.setTargetAtTime(n,this.context.currentTime,.01),this}updateMatrixWorld(n){super.updateMatrixWorld(n);let r=this.context.listener,i=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose($d5b33d7c30034067$var$_position$1,$d5b33d7c30034067$var$_quaternion$1,$d5b33d7c30034067$var$_scale$1),$d5b33d7c30034067$var$_orientation$1.set(0,0,-1).applyQuaternion($d5b33d7c30034067$var$_quaternion$1),r.positionX){// code path for Chrome (see #14393)
let n=this.context.currentTime+this.timeDelta;r.positionX.linearRampToValueAtTime($d5b33d7c30034067$var$_position$1.x,n),r.positionY.linearRampToValueAtTime($d5b33d7c30034067$var$_position$1.y,n),r.positionZ.linearRampToValueAtTime($d5b33d7c30034067$var$_position$1.z,n),r.forwardX.linearRampToValueAtTime($d5b33d7c30034067$var$_orientation$1.x,n),r.forwardY.linearRampToValueAtTime($d5b33d7c30034067$var$_orientation$1.y,n),r.forwardZ.linearRampToValueAtTime($d5b33d7c30034067$var$_orientation$1.z,n),r.upX.linearRampToValueAtTime(i.x,n),r.upY.linearRampToValueAtTime(i.y,n),r.upZ.linearRampToValueAtTime(i.z,n)}else r.setPosition($d5b33d7c30034067$var$_position$1.x,$d5b33d7c30034067$var$_position$1.y,$d5b33d7c30034067$var$_position$1.z),r.setOrientation($d5b33d7c30034067$var$_orientation$1.x,$d5b33d7c30034067$var$_orientation$1.y,$d5b33d7c30034067$var$_orientation$1.z,i.x,i.y,i.z)}}class $d5b33d7c30034067$export$153755f98d9861de extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(n){super(),this.type="Audio",this.listener=n,this.context=n.context,this.gain=this.context.createGain(),this.gain.connect(n.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(n){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=n,this.connect(),this}setMediaElementSource(n){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(n),this.connect(),this}setMediaStreamSource(n){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(n),this.connect(),this}setBuffer(n){return this.buffer=n,this.sourceType="buffer",this.autoplay&&this.play(),this}play(n=0){if(!0===this.isPlaying){console.warn("THREE.Audio: Audio is already playing.");return}if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+n;let r=this.context.createBufferSource();return r.buffer=this.buffer,r.loop=this.loop,r.loopStart=this.loopStart,r.loopEnd=this.loopEnd,r.onended=this.onEnded.bind(this),r.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=r,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return!0===this.isPlaying&&(// update current progress
this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,null!==this.source&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let n=1,r=this.filters.length;n<r;n++)this.filters[n-1].connect(this.filters[n]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(!1!==this._connected){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let n=1,r=this.filters.length;n<r;n++)this.filters[n-1].disconnect(this.filters[n]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(n){return n||(n=[]),!0===this._connected?(this.disconnect(),this.filters=n.slice(),this.connect()):this.filters=n.slice(),this}setDetune(n){if(this.detune=n,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this;// only set detune when available
}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(n){return this.setFilters(n?[n]:[])}setPlaybackRate(n){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=n,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(n){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=n,!0===this.isPlaying&&(this.source.loop=this.loop),this}setLoopStart(n){return this.loopStart=n,this}setLoopEnd(n){return this.loopEnd=n,this}getVolume(){return this.gain.gain.value}setVolume(n){return this.gain.gain.setTargetAtTime(n,this.context.currentTime,.01),this}}const $d5b33d7c30034067$var$_position=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_quaternion=/*@__PURE__*/new $d5b33d7c30034067$export$23d6a54f0bbc85a3,$d5b33d7c30034067$var$_scale=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_orientation=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$4b3e397ef1832507 extends $d5b33d7c30034067$export$153755f98d9861de{constructor(n){super(n),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(n){return this.panner.refDistance=n,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(n){return this.panner.rolloffFactor=n,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(n){return this.panner.distanceModel=n,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(n){return this.panner.maxDistance=n,this}setDirectionalCone(n,r,i){return this.panner.coneInnerAngle=n,this.panner.coneOuterAngle=r,this.panner.coneOuterGain=i,this}updateMatrixWorld(n){if(super.updateMatrixWorld(n),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose($d5b33d7c30034067$var$_position,$d5b33d7c30034067$var$_quaternion,$d5b33d7c30034067$var$_scale),$d5b33d7c30034067$var$_orientation.set(0,0,1).applyQuaternion($d5b33d7c30034067$var$_quaternion);let r=this.panner;if(r.positionX){// code path for Chrome and Firefox (see #14393)
let n=this.context.currentTime+this.listener.timeDelta;r.positionX.linearRampToValueAtTime($d5b33d7c30034067$var$_position.x,n),r.positionY.linearRampToValueAtTime($d5b33d7c30034067$var$_position.y,n),r.positionZ.linearRampToValueAtTime($d5b33d7c30034067$var$_position.z,n),r.orientationX.linearRampToValueAtTime($d5b33d7c30034067$var$_orientation.x,n),r.orientationY.linearRampToValueAtTime($d5b33d7c30034067$var$_orientation.y,n),r.orientationZ.linearRampToValueAtTime($d5b33d7c30034067$var$_orientation.z,n)}else r.setPosition($d5b33d7c30034067$var$_position.x,$d5b33d7c30034067$var$_position.y,$d5b33d7c30034067$var$_position.z),r.setOrientation($d5b33d7c30034067$var$_orientation.x,$d5b33d7c30034067$var$_orientation.y,$d5b33d7c30034067$var$_orientation.z)}}class $d5b33d7c30034067$export$d47da1ef3d382827{constructor(n,r=2048){this.analyser=n.context.createAnalyser(),this.analyser.fftSize=r,this.data=new Uint8Array(this.analyser.frequencyBinCount),n.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let n=0,r=this.getFrequencyData();for(let i=0;i<r.length;i++)n+=r[i];return n/r.length}}class $d5b33d7c30034067$export$dfe0af1ca1acb78a{constructor(n,r,i){let a,s,o;// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
//
// interpolators can use .buffer as their .result
// the data then goes to 'incoming'
//
// 'accu0' and 'accu1' are used frame-interleaved for
// the cumulative result and are compared to detect
// changes
//
// 'orig' stores the original state of the property
//
// 'add' is used for additive cumulative results
//
// 'work' is optional and is only present for quaternion types. It is used
// to store intermediate quaternion multiplication results
switch(this.binding=n,this.valueSize=i,r){case"quaternion":a=this._slerp,s=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*i),this._workIndex=5;break;case"string":case"bool":a=this._select,// Use the regular mix function and for additive on these types,
// additive is not relevant for non-numeric types
s=this._select,o=this._setAdditiveIdentityOther,this.buffer=Array(5*i);break;default:a=this._lerp,s=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*i)}this._mixBufferRegion=a,this._mixBufferRegionAdditive=s,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}// accumulate data in the 'incoming' region into 'accu<i>'
accumulate(n,r){// note: happily accumulating nothing when weight = 0, the caller knows
// the weight and shouldn't have made the call in the first place
let i=this.buffer,a=this.valueSize,s=n*a+a,o=this.cumulativeWeight;if(0===o){// accuN := incoming * weight
for(let n=0;n!==a;++n)i[s+n]=i[n];o=r}else{// accuN := accuN + incoming * weight
o+=r;let n=r/o;this._mixBufferRegion(i,s,0,n,a)}this.cumulativeWeight=o}// accumulate data in the 'incoming' region into 'add'
accumulateAdditive(n){let r=this.buffer,i=this.valueSize,a=i*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),// add := add + incoming * weight
this._mixBufferRegionAdditive(r,a,0,n,i),this.cumulativeWeightAdditive+=n}// apply the state of 'accu<i>' to the binding when accus differ
apply(n){let r=this.valueSize,i=this.buffer,a=n*r+r,s=this.cumulativeWeight,o=this.cumulativeWeightAdditive,l=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){// accuN := accuN + original * ( 1 - cumulativeWeight )
let n=r*this._origIndex;this._mixBufferRegion(i,a,n,1-s,r)}o>0&&this._mixBufferRegionAdditive(i,a,this._addIndex*r,1,r);for(let n=r,s=r+r;n!==s;++n)if(i[n]!==i[n+r]){// value has changed -> update scene graph
l.setValue(i,a);break}}// remember the state of the bound property and copy it to both accus
saveOriginalState(){let n=this.binding,r=this.buffer,i=this.valueSize,a=i*this._origIndex;n.getValue(r,a);// accu[0..1] := orig -- initially detect changes against the original
for(let n=i,s=a;n!==s;++n)r[n]=r[a+n%i];// Add to identity for additive
this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}// apply the state previously taken via 'saveOriginalState' to the binding
restoreOriginalState(){let n=3*this.valueSize;this.binding.setValue(this.buffer,n)}_setAdditiveIdentityNumeric(){let n=this._addIndex*this.valueSize,r=n+this.valueSize;for(let i=n;i<r;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){let n=this._origIndex*this.valueSize,r=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[r+i]=this.buffer[n+i]}// mix functions
_select(n,r,i,a,s){if(a>=.5)for(let a=0;a!==s;++a)n[r+a]=n[i+a]}_slerp(n,r,i,a){$d5b33d7c30034067$export$23d6a54f0bbc85a3.slerpFlat(n,r,n,r,n,i,a)}_slerpAdditive(n,r,i,a,s){let o=this._workIndex*s;// Store result in intermediate buffer offset
$d5b33d7c30034067$export$23d6a54f0bbc85a3.multiplyQuaternionsFlat(n,o,n,r,n,i),// Slerp to the intermediate result
$d5b33d7c30034067$export$23d6a54f0bbc85a3.slerpFlat(n,r,n,r,n,o,a)}_lerp(n,r,i,a,s){let o=1-a;for(let l=0;l!==s;++l){let s=r+l;n[s]=n[s]*o+n[i+l]*a}}_lerpAdditive(n,r,i,a,s){for(let o=0;o!==s;++o){let s=r+o;n[s]=n[s]+n[i+o]*a}}}// Characters [].:/ are reserved for track binding syntax.
const $d5b33d7c30034067$var$_RESERVED_CHARS_RE="\\[\\]\\.:\\/",$d5b33d7c30034067$var$_reservedRe=RegExp("["+$d5b33d7c30034067$var$_RESERVED_CHARS_RE+"]","g"),$d5b33d7c30034067$var$_wordChar="[^"+$d5b33d7c30034067$var$_RESERVED_CHARS_RE+"]",$d5b33d7c30034067$var$_wordCharOrDot="[^"+$d5b33d7c30034067$var$_RESERVED_CHARS_RE.replace("\\.","")+"]",$d5b33d7c30034067$var$_directoryRe=/*@__PURE__*//((?:WC+[\/:])*)/.source.replace("WC",$d5b33d7c30034067$var$_wordChar),$d5b33d7c30034067$var$_nodeRe=/*@__PURE__*//(WCOD+)?/.source.replace("WCOD",$d5b33d7c30034067$var$_wordCharOrDot),$d5b33d7c30034067$var$_objectRe=/*@__PURE__*//(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",$d5b33d7c30034067$var$_wordChar),$d5b33d7c30034067$var$_propertyRe=/*@__PURE__*//\.(WC+)(?:\[(.+)\])?/.source.replace("WC",$d5b33d7c30034067$var$_wordChar),$d5b33d7c30034067$var$_trackRe=RegExp("^"+$d5b33d7c30034067$var$_directoryRe+$d5b33d7c30034067$var$_nodeRe+$d5b33d7c30034067$var$_objectRe+$d5b33d7c30034067$var$_propertyRe+"$"),$d5b33d7c30034067$var$_supportedObjectNames=["material","materials","bones","map"];class $d5b33d7c30034067$var$Composite{constructor(n,r,i){let a=i||$d5b33d7c30034067$export$7bf70fcf9f891893.parseTrackName(r);this._targetGroup=n,this._bindings=n.subscribe_(r,a)}getValue(n,r){this.bind();// bind all binding
let i=this._targetGroup.nCachedObjects_,a=this._bindings[i];// and only call .getValue on the first
void 0!==a&&a.getValue(n,r)}setValue(n,r){let i=this._bindings;for(let a=this._targetGroup.nCachedObjects_,s=i.length;a!==s;++a)i[a].setValue(n,r)}bind(){let n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=n.length;r!==i;++r)n[r].bind()}unbind(){let n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=n.length;r!==i;++r)n[r].unbind()}}// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class $d5b33d7c30034067$export$7bf70fcf9f891893{constructor(n,r,i){this.path=r,this.parsedPath=i||$d5b33d7c30034067$export$7bf70fcf9f891893.parseTrackName(r),this.node=$d5b33d7c30034067$export$7bf70fcf9f891893.findNode(n,this.parsedPath.nodeName),this.rootNode=n,// initial state of these methods that calls 'bind'
this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(n,r,i){return n&&n.isAnimationObjectGroup?new $d5b33d7c30034067$export$7bf70fcf9f891893.Composite(n,r,i):new $d5b33d7c30034067$export$7bf70fcf9f891893(n,r,i)}/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */static sanitizeNodeName(n){return n.replace(/\s/g,"_").replace($d5b33d7c30034067$var$_reservedRe,"")}static parseTrackName(n){let r=$d5b33d7c30034067$var$_trackRe.exec(n);if(null===r)throw Error("PropertyBinding: Cannot parse trackName: "+n);let i={// directoryName: matches[ 1 ], // (tschw) currently unused
nodeName:r[2],objectName:r[3],objectIndex:r[4],propertyName:r[5],propertyIndex:r[6]},a=i.nodeName&&i.nodeName.lastIndexOf(".");if(void 0!==a&&-1!==a){let n=i.nodeName.substring(a+1);// Object names must be checked against an allowlist. Otherwise, there
// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
// 'bar' could be the objectName, or part of a nodeName (which can
// include '.' characters).
-1!==$d5b33d7c30034067$var$_supportedObjectNames.indexOf(n)&&(i.nodeName=i.nodeName.substring(0,a),i.objectName=n)}if(null===i.propertyName||0===i.propertyName.length)throw Error("PropertyBinding: can not parse propertyName from trackName: "+n);return i}static findNode(n,r){if(void 0===r||""===r||"."===r||-1===r||r===n.name||r===n.uuid)return n;// search into skeleton bones.
if(n.skeleton){let i=n.skeleton.getBoneByName(r);if(void 0!==i)return i}// search into node subtree.
if(n.children){let i=function(n){for(let a=0;a<n.length;a++){let s=n[a];if(s.name===r||s.uuid===r)return s;let o=i(s.children);if(o)return o}return null},a=i(n.children);if(a)return a}return null}// these are used to "bind" a nonexistent property
_getValue_unavailable(){}_setValue_unavailable(){}// Getters
_getValue_direct(n,r){n[r]=this.targetObject[this.propertyName]}_getValue_array(n,r){let i=this.resolvedProperty;for(let a=0,s=i.length;a!==s;++a)n[r++]=i[a]}_getValue_arrayElement(n,r){n[r]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(n,r){this.resolvedProperty.toArray(n,r)}// Direct
_setValue_direct(n,r){this.targetObject[this.propertyName]=n[r]}_setValue_direct_setNeedsUpdate(n,r){this.targetObject[this.propertyName]=n[r],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(n,r){this.targetObject[this.propertyName]=n[r],this.targetObject.matrixWorldNeedsUpdate=!0}// EntireArray
_setValue_array(n,r){let i=this.resolvedProperty;for(let a=0,s=i.length;a!==s;++a)i[a]=n[r++]}_setValue_array_setNeedsUpdate(n,r){let i=this.resolvedProperty;for(let a=0,s=i.length;a!==s;++a)i[a]=n[r++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(n,r){let i=this.resolvedProperty;for(let a=0,s=i.length;a!==s;++a)i[a]=n[r++];this.targetObject.matrixWorldNeedsUpdate=!0}// ArrayElement
_setValue_arrayElement(n,r){this.resolvedProperty[this.propertyIndex]=n[r]}_setValue_arrayElement_setNeedsUpdate(n,r){this.resolvedProperty[this.propertyIndex]=n[r],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(n,r){this.resolvedProperty[this.propertyIndex]=n[r],this.targetObject.matrixWorldNeedsUpdate=!0}// HasToFromArray
_setValue_fromArray(n,r){this.resolvedProperty.fromArray(n,r)}_setValue_fromArray_setNeedsUpdate(n,r){this.resolvedProperty.fromArray(n,r),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(n,r){this.resolvedProperty.fromArray(n,r),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(n,r){this.bind(),this.getValue(n,r)}_setValue_unbound(n,r){this.bind(),this.setValue(n,r)}// create getter / setter pair for a property in the scene graph
bind(){let n=this.node,r=this.parsedPath,i=r.objectName,a=r.propertyName,s=r.propertyIndex;// ensure there is a value node
if(n||(n=$d5b33d7c30034067$export$7bf70fcf9f891893.findNode(this.rootNode,r.nodeName),this.node=n),// set fail state so we can just 'return' on error
this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!n){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(i){let a=r.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
switch(i){case"materials":if(!n.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!n.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}n=n.material.materials;break;case"bones":if(!n.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}// potential future optimization: skip this if propertyIndex is already an integer
// and convert the integer string to a true integer.
n=n.skeleton.bones;// support resolving morphTarget names into indices.
for(let r=0;r<n.length;r++)if(n[r].name===a){a=r;break}break;case"map":if("map"in n){n=n.map;break}if(!n.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!n.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}n=n.material.map;break;default:if(void 0===n[i]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}n=n[i]}if(void 0!==a){if(void 0===n[a]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,n);return}n=n[a]}}// resolve property
let o=n[a];if(void 0===o){let i=r.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+i+"."+a+" but it wasn't found.",n);return}// determine versioning scheme
let l=this.Versioning.None;this.targetObject=n,void 0!==n.needsUpdate?l=this.Versioning.NeedsUpdate:void 0!==n.matrixWorldNeedsUpdate&&(l=this.Versioning.MatrixWorldNeedsUpdate);// determine how the property gets bound
let u=this.BindingType.Direct;if(void 0!==s){// access a sub element of the property array (only primitives are supported right now)
if("morphTargetInfluences"===a){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
// support resolving morphTarget names into indices.
if(!n.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!n.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}void 0!==n.morphTargetDictionary[s]&&(s=n.morphTargetDictionary[s])}u=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=s}else void 0!==o.fromArray&&void 0!==o.toArray?(// must use copy for Object3D.Euler/Quaternion
u=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(u=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=a;// select getter / setter
this.getValue=this.GetterByBindingType[u],this.setValue=this.SetterByBindingTypeAndVersioning[u][l]}unbind(){this.node=null,// back to the prototype version of getValue / setValue
// note: avoiding to mutate the shape of 'this' via 'delete'
this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}$d5b33d7c30034067$export$7bf70fcf9f891893.Composite=$d5b33d7c30034067$var$Composite,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},$d5b33d7c30034067$export$7bf70fcf9f891893.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},$d5b33d7c30034067$export$7bf70fcf9f891893.prototype.GetterByBindingType=[$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._getValue_direct,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._getValue_array,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._getValue_arrayElement,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._getValue_toArray],$d5b33d7c30034067$export$7bf70fcf9f891893.prototype.SetterByBindingTypeAndVersioning=[[// Direct
$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_direct,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_direct_setNeedsUpdate,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[// EntireArray
$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_array,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_array_setNeedsUpdate,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_array_setMatrixWorldNeedsUpdate],[// ArrayElement
$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_arrayElement,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_arrayElement_setNeedsUpdate,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[// HasToFromArray
$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_fromArray,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_fromArray_setNeedsUpdate,$d5b33d7c30034067$export$7bf70fcf9f891893.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */class $d5b33d7c30034067$export$30619c2afd3f34db{constructor(){this.isAnimationObjectGroup=!0,this.uuid=$d5b33d7c30034067$var$generateUUID(),// cached objects followed by the active ones
this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;// note: read by PropertyBinding.Composite
let n={};this._indicesByUUID=n;for(let r=0,i=arguments.length;r!==i;++r)n[arguments[r].uuid]=r;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};let r=this;this.stats={objects:{get total(){return r._objects.length},get inUse(){return this.total-r.nCachedObjects_}},get bindingsPerObject(){return r._bindings.length}}}add(){let n=this._objects,r=this._indicesByUUID,i=this._paths,a=this._parsedPaths,s=this._bindings,o=s.length,l,u=n.length,c=this.nCachedObjects_;for(let h=0,d=arguments.length;h!==d;++h){let d=arguments[h],p=d.uuid,f=r[p];if(void 0===f){// unknown object -> add it to the ACTIVE region
f=u++,r[p]=f,n.push(d);// accounting is done, now do the same for all bindings
for(let n=0,r=o;n!==r;++n)s[n].push(new $d5b33d7c30034067$export$7bf70fcf9f891893(d,i[n],a[n]))}else if(f<c){l=n[f];// move existing object to the ACTIVE region
let u=--c,h=n[u];r[h.uuid]=f,n[f]=h,r[p]=u,n[u]=d;// accounting is done, now do the same for all bindings
for(let n=0,r=o;n!==r;++n){let r=s[n],o=r[u],l=r[f];r[f]=o,void 0===l&&// for objects that are cached, the binding may
// or may not exist
(l=new $d5b33d7c30034067$export$7bf70fcf9f891893(d,i[n],a[n])),r[u]=l}}else n[f]!==l&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");// else the object is already where we want it to be
}// for arguments
this.nCachedObjects_=c}remove(){let n=this._objects,r=this._indicesByUUID,i=this._bindings,a=i.length,s=this.nCachedObjects_;for(let o=0,l=arguments.length;o!==l;++o){let l=arguments[o],u=l.uuid,c=r[u];if(void 0!==c&&c>=s){// move existing object into the CACHED region
let o=s++,h=n[o];r[h.uuid]=c,n[c]=h,r[u]=o,n[o]=l;// accounting is done, now do the same for all bindings
for(let n=0,r=a;n!==r;++n){let r=i[n],a=r[o],s=r[c];r[c]=a,r[o]=s}}}// for arguments
this.nCachedObjects_=s}// remove & forget
uncache(){let n=this._objects,r=this._indicesByUUID,i=this._bindings,a=i.length,s=this.nCachedObjects_,o=n.length;for(let l=0,u=arguments.length;l!==u;++l){let u=arguments[l],c=u.uuid,h=r[c];if(void 0!==h){if(delete r[c],h<s){// object is cached, shrink the CACHED region
let l=--s,u=n[l],c=--o,d=n[c];// last cached object takes this object's place
r[u.uuid]=h,n[h]=u,// last object goes to the activated slot and pop
r[d.uuid]=l,n[l]=d,n.pop();// accounting is done, now do the same for all bindings
for(let n=0,r=a;n!==r;++n){let r=i[n],a=r[l],s=r[c];r[h]=a,r[l]=s,r.pop()}}else{// object is active, just swap with the last and pop
let s=--o,l=n[s];s>0&&(r[l.uuid]=h),n[h]=l,n.pop();// accounting is done, now do the same for all bindings
for(let n=0,r=a;n!==r;++n){let r=i[n];r[h]=r[s],r.pop()}}// cached or active
}// if object is known
}// for arguments
this.nCachedObjects_=s}// Internal interface used by befriended PropertyBinding.Composite:
subscribe_(n,r){// returns an array of bindings for the given path that is changed
// according to the contained objects in the group
let i=this._bindingsIndicesByPath,a=i[n],s=this._bindings;if(void 0!==a)return s[a];let o=this._paths,l=this._parsedPaths,u=this._objects,c=u.length,h=this.nCachedObjects_,d=Array(c);a=s.length,i[n]=a,o.push(n),l.push(r),s.push(d);for(let i=h,a=u.length;i!==a;++i){let a=u[i];d[i]=new $d5b33d7c30034067$export$7bf70fcf9f891893(a,n,r)}return d}unsubscribe_(n){// tells the group to forget about a property path and no longer
// update the array previously obtained with 'subscribe_'
let r=this._bindingsIndicesByPath,i=r[n];if(void 0!==i){let a=this._paths,s=this._parsedPaths,o=this._bindings,l=o.length-1,u=o[l],c=n[l];r[c]=i,o[i]=u,o.pop(),s[i]=s[l],s.pop(),a[i]=a[l],a.pop()}}}class $d5b33d7c30034067$export$6946940a69e799e{constructor(n,r,i=null,a=r.blendMode){this._mixer=n,this._clip=r,this._localRoot=i,this.blendMode=a;let s=r.tracks,o=s.length,l=Array(o),u={endingStart:$d5b33d7c30034067$export$7f795934b84ab523,endingEnd:$d5b33d7c30034067$export$7f795934b84ab523};for(let n=0;n!==o;++n){let r=s[n].createInterpolant(null);l[n]=r,r.settings=u}this._interpolantSettings=u,this._interpolants=l,// inside: PropertyMixer (managed by the mixer)
this._propertyBindings=Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=$d5b33d7c30034067$export$dfaf4422ce096e29,this._loopCount=-1,// global mixer time when the action is to be started
// it's set back to 'null' upon start of the action
this._startTime=null,// scaled local time of the action
// gets clamped or wrapped to 0..clip.duration according to loop
this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}// State & Scheduling
play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}// return true when play has been called
isScheduled(){return this._mixer._isActiveAction(this)}startAt(n){return this._startTime=n,this}setLoop(n,r){return this.loop=n,this.repetitions=r,this}// Weight
// set the weight stopping any scheduled fading
// although .enabled = false yields an effective weight of zero, this
// method does *not* change .enabled, because it would be confusing
setEffectiveWeight(n){return this.weight=n,// note: same logic as when updated at runtime
this._effectiveWeight=this.enabled?n:0,this.stopFading()}// return the weight considering fading and .enabled
getEffectiveWeight(){return this._effectiveWeight}fadeIn(n){return this._scheduleFading(n,0,1)}fadeOut(n){return this._scheduleFading(n,1,0)}crossFadeFrom(n,r,i){if(n.fadeOut(r),this.fadeIn(r),i){let i=this._clip.duration,a=n._clip.duration,s=a/i,o=i/a;n.warp(1,s,r),this.warp(o,1,r)}return this}crossFadeTo(n,r,i){return n.crossFadeFrom(this,r,i)}stopFading(){let n=this._weightInterpolant;return null!==n&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(n)),this}// Time Scale Control
// set the time scale stopping any scheduled warping
// although .paused = true yields an effective time scale of zero, this
// method does *not* change .paused, because it would be confusing
setEffectiveTimeScale(n){return this.timeScale=n,this._effectiveTimeScale=this.paused?0:n,this.stopWarping()}// return the time scale considering warping and .paused
getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(n){return this.timeScale=this._clip.duration/n,this.stopWarping()}syncWith(n){return this.time=n.time,this.timeScale=n.timeScale,this.stopWarping()}halt(n){return this.warp(this._effectiveTimeScale,0,n)}warp(n,r,i){let a=this._mixer,s=a.time,o=this.timeScale,l=this._timeScaleInterpolant;null===l&&(l=a._lendControlInterpolant(),this._timeScaleInterpolant=l);let u=l.parameterPositions,c=l.sampleValues;return u[0]=s,u[1]=s+i,c[0]=n/o,c[1]=r/o,this}stopWarping(){let n=this._timeScaleInterpolant;return null!==n&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(n)),this}// Object Accessors
getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}// Interna
_update(n,r,i,a){// called by the mixer
if(!this.enabled){// call ._updateWeight() to update ._effectiveWeight
this._updateWeight(n);return}let s=this._startTime;if(null!==s){// check for scheduled start of action
let a=(n-s)*i;a<0||0===i?r=0:(this._startTime=null,r=i*a)}// apply time scale and advance time
r*=this._updateTimeScale(n);let o=this._updateTime(r),l=this._updateWeight(n);if(l>0){let n=this._interpolants,r=this._propertyBindings;if(this.blendMode===$d5b33d7c30034067$export$d875e029ef558d3)for(let i=0,a=n.length;i!==a;++i)n[i].evaluate(o),r[i].accumulateAdditive(l);else for(let i=0,s=n.length;i!==s;++i)n[i].evaluate(o),r[i].accumulate(a,l)}}_updateWeight(n){let r=0;if(this.enabled){r=this.weight;let i=this._weightInterpolant;if(null!==i){let a=i.evaluate(n)[0];r*=a,n>i.parameterPositions[1]&&(this.stopFading(),0===a&&(this.enabled=!1))}}return this._effectiveWeight=r,r}_updateTimeScale(n){let r=0;if(!this.paused){r=this.timeScale;let i=this._timeScaleInterpolant;if(null!==i){let a=i.evaluate(n)[0];r*=a,n>i.parameterPositions[1]&&(this.stopWarping(),0===r?this.paused=!0:this.timeScale=r)}}return this._effectiveTimeScale=r,r}_updateTime(n){let r=this._clip.duration,i=this.loop,a=this.time+n,s=this._loopCount,o=i===$d5b33d7c30034067$export$f8f6f2041b78e210;if(0===n)return -1===s?a:o&&(1&s)==1?r-a:a;if(i===$d5b33d7c30034067$export$d62fdc9d1b1cccad){-1===s&&(// just started
this._loopCount=0,this._setEndings(!0,!0,!1));a:{if(a>=r)a=r;else if(a<0)a=0;else{this.time=a;break a}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=a,this._mixer.dispatchEvent({type:"finished",action:this,direction:n<0?-1:1})}}else{if(-1===s&&(n>=0?(s=0,this._setEndings(!0,0===this.repetitions,o)):// transition through zero counts as a repetition,
// so leave loopCount at -1
this._setEndings(0===this.repetitions,!0,o)),a>=r||a<0){// wrap around
let i=Math.floor(a/r);// signed
a-=r*i,s+=Math.abs(i);let l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,a=n>0?r:0,this.time=a,this._mixer.dispatchEvent({type:"finished",action:this,direction:n>0?1:-1});else{// keep running
if(1===l){// entering the last round
let r=n<0;this._setEndings(r,!r,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=a,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=a;if(o&&(1&s)==1)return r-a}return a}_setEndings(n,r,i){let a=this._interpolantSettings;i?(a.endingStart=$d5b33d7c30034067$export$24a4ccb5099273b5,a.endingEnd=$d5b33d7c30034067$export$24a4ccb5099273b5):(n?a.endingStart=this.zeroSlopeAtStart?$d5b33d7c30034067$export$24a4ccb5099273b5:$d5b33d7c30034067$export$7f795934b84ab523:a.endingStart=$d5b33d7c30034067$export$8e8c3ecdcd8e1fee,r?a.endingEnd=this.zeroSlopeAtEnd?$d5b33d7c30034067$export$24a4ccb5099273b5:$d5b33d7c30034067$export$7f795934b84ab523:a.endingEnd=$d5b33d7c30034067$export$8e8c3ecdcd8e1fee)}_scheduleFading(n,r,i){let a=this._mixer,s=a.time,o=this._weightInterpolant;null===o&&(o=a._lendControlInterpolant(),this._weightInterpolant=o);let l=o.parameterPositions,u=o.sampleValues;return l[0]=s,u[0]=r,l[1]=s+n,u[1]=i,this}}const $d5b33d7c30034067$var$_controlInterpolantsResultBuffer=new Float32Array(1);class $d5b33d7c30034067$export$fbd77e5aefaa0102 extends $d5b33d7c30034067$export$ec8b666c5fe2c75a{constructor(n){super(),this._root=n,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(n,r){let i=n._localRoot||this._root,a=n._clip.tracks,s=a.length,o=n._propertyBindings,l=n._interpolants,u=i.uuid,c=this._bindingsByRootAndName,h=c[u];void 0===h&&(h={},c[u]=h);for(let n=0;n!==s;++n){let s=a[n],c=s.name,d=h[c];if(void 0!==d)++d.referenceCount,o[n]=d;else{if(void 0!==(d=o[n])){// existing binding, make sure the cache knows
null===d._cacheIndex&&(++d.referenceCount,this._addInactiveBinding(d,u,c));continue}let a=r&&r._propertyBindings[n].binding.parsedPath;d=new $d5b33d7c30034067$export$dfe0af1ca1acb78a($d5b33d7c30034067$export$7bf70fcf9f891893.create(i,c,a),s.ValueTypeName,s.getValueSize()),++d.referenceCount,this._addInactiveBinding(d,u,c),o[n]=d}l[n].resultBuffer=d.buffer}}_activateAction(n){if(!this._isActiveAction(n)){if(null===n._cacheIndex){// this action has been forgotten by the cache, but the user
// appears to be still using it -> rebind
let r=(n._localRoot||this._root).uuid,i=n._clip.uuid,a=this._actionsByClip[i];this._bindAction(n,a&&a.knownActions[0]),this._addInactiveAction(n,i,r)}let r=n._propertyBindings;// increment reference counts / sort out state
for(let n=0,i=r.length;n!==i;++n){let i=r[n];0==i.useCount++&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(n)}}_deactivateAction(n){if(this._isActiveAction(n)){let r=n._propertyBindings;// decrement reference counts / sort out state
for(let n=0,i=r.length;n!==i;++n){let i=r[n];0==--i.useCount&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(n)}}// Memory manager
_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},// inside:
// {
// 	knownActions: Array< AnimationAction > - used as prototypes
// 	actionByRoot: AnimationAction - lookup
// }
this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;let n=this;this.stats={actions:{get total(){return n._actions.length},get inUse(){return n._nActiveActions}},bindings:{get total(){return n._bindings.length},get inUse(){return n._nActiveBindings}},controlInterpolants:{get total(){return n._controlInterpolants.length},get inUse(){return n._nActiveControlInterpolants}}}}// Memory management for AnimationAction objects
_isActiveAction(n){let r=n._cacheIndex;return null!==r&&r<this._nActiveActions}_addInactiveAction(n,r,i){let a=this._actions,s=this._actionsByClip,o=s[r];if(void 0===o)o={knownActions:[n],actionByRoot:{}},n._byClipCacheIndex=0,s[r]=o;else{let r=o.knownActions;n._byClipCacheIndex=r.length,r.push(n)}n._cacheIndex=a.length,a.push(n),o.actionByRoot[i]=n}_removeInactiveAction(n){let r=this._actions,i=r[r.length-1],a=n._cacheIndex;i._cacheIndex=a,r[a]=i,r.pop(),n._cacheIndex=null;let s=n._clip.uuid,o=this._actionsByClip,l=o[s],u=l.knownActions,c=u[u.length-1],h=n._byClipCacheIndex;c._byClipCacheIndex=h,u[h]=c,u.pop(),n._byClipCacheIndex=null;let d=l.actionByRoot,p=(n._localRoot||this._root).uuid;delete d[p],0===u.length&&delete o[s],this._removeInactiveBindingsForAction(n)}_removeInactiveBindingsForAction(n){let r=n._propertyBindings;for(let n=0,i=r.length;n!==i;++n){let i=r[n];0==--i.referenceCount&&this._removeInactiveBinding(i)}}_lendAction(n){// [ active actions |  inactive actions  ]
// [  active actions >| inactive actions ]
//                 s        a
//                  <-swap->
//                 a        s
let r=this._actions,i=n._cacheIndex,a=this._nActiveActions++,s=r[a];n._cacheIndex=a,r[a]=n,s._cacheIndex=i,r[i]=s}_takeBackAction(n){// [  active actions  | inactive actions ]
// [ active actions |< inactive actions  ]
//        a        s
//         <-swap->
//        s        a
let r=this._actions,i=n._cacheIndex,a=--this._nActiveActions,s=r[a];n._cacheIndex=a,r[a]=n,s._cacheIndex=i,r[i]=s}// Memory management for PropertyMixer objects
_addInactiveBinding(n,r,i){let a=this._bindingsByRootAndName,s=this._bindings,o=a[r];void 0===o&&(o={},a[r]=o),o[i]=n,n._cacheIndex=s.length,s.push(n)}_removeInactiveBinding(n){let r=this._bindings,i=n.binding,a=i.rootNode.uuid,s=i.path,o=this._bindingsByRootAndName,l=o[a],u=r[r.length-1],c=n._cacheIndex;u._cacheIndex=c,r[c]=u,r.pop(),delete l[s],0===Object.keys(l).length&&delete o[a]}_lendBinding(n){let r=this._bindings,i=n._cacheIndex,a=this._nActiveBindings++,s=r[a];n._cacheIndex=a,r[a]=n,s._cacheIndex=i,r[i]=s}_takeBackBinding(n){let r=this._bindings,i=n._cacheIndex,a=--this._nActiveBindings,s=r[a];n._cacheIndex=a,r[a]=n,s._cacheIndex=i,r[i]=s}// Memory management of Interpolants for weight and time scale
_lendControlInterpolant(){let n=this._controlInterpolants,r=this._nActiveControlInterpolants++,i=n[r];return void 0===i&&((i=new $d5b33d7c30034067$export$a8e6009059f51e1a(new Float32Array(2),new Float32Array(2),1,$d5b33d7c30034067$var$_controlInterpolantsResultBuffer)).__cacheIndex=r,n[r]=i),i}_takeBackControlInterpolant(n){let r=this._controlInterpolants,i=n.__cacheIndex,a=--this._nActiveControlInterpolants,s=r[a];n.__cacheIndex=a,r[a]=n,s.__cacheIndex=i,r[i]=s}// return an action for a clip optionally using a custom root target
// object (this method allocates a lot of dynamic memory in case a
// previously unknown clip/root combination is specified)
clipAction(n,r,i){let a=r||this._root,s=a.uuid,o="string"==typeof n?$d5b33d7c30034067$export$d942c706bf23829c.findByName(a,n):n,l=null!==o?o.uuid:n,u=this._actionsByClip[l],c=null;if(void 0===i&&(i=null!==o?o.blendMode:$d5b33d7c30034067$export$bcfbbdcf8de7f8cd),void 0!==u){let n=u.actionByRoot[s];if(void 0!==n&&n.blendMode===i)return n;// we know the clip, so we don't have to parse all
// the bindings again but can just copy
c=u.knownActions[0],null===o&&(o=c._clip)}// clip must be known when specified via string
if(null===o)return null;// allocate all resources required to run it
let h=new $d5b33d7c30034067$export$6946940a69e799e(this,o,r,i);return this._bindAction(h,c),// and make the action known to the memory manager
this._addInactiveAction(h,l,s),h}// get an existing action
existingAction(n,r){let i=r||this._root,a=i.uuid,s="string"==typeof n?$d5b33d7c30034067$export$d942c706bf23829c.findByName(i,n):n,o=s?s.uuid:n,l=this._actionsByClip[o];return void 0!==l&&l.actionByRoot[a]||null}// deactivates all previously scheduled actions
stopAllAction(){let n=this._actions,r=this._nActiveActions;for(let i=r-1;i>=0;--i)n[i].stop();return this}// advance the time and update apply the animation
update(n){n*=this.timeScale;let r=this._actions,i=this._nActiveActions,a=this.time+=n,s=Math.sign(n),o=this._accuIndex^=1;// run active actions
for(let l=0;l!==i;++l){let i=r[l];i._update(a,n,s,o)}// update scene graph
let l=this._bindings,u=this._nActiveBindings;for(let n=0;n!==u;++n)l[n].apply(o);return this}// Allows you to seek to a specific time in an animation.
setTime(n){this.time=0;// Zero out time attribute for AnimationMixer object;
for(let n=0;n<this._actions.length;n++)this._actions[n].time=0;// Zero out time attribute for all associated AnimationAction objects.
return this.update(n);// Update used to set exact time. Returns "this" AnimationMixer object.
}// return this mixer's root target object
getRoot(){return this._root}// free all resources specific to a particular clip
uncacheClip(n){let r=this._actions,i=n.uuid,a=this._actionsByClip,s=a[i];if(void 0!==s){// note: just calling _removeInactiveAction would mess up the
// iteration state and also require updating the state we can
// just throw away
let n=s.knownActions;for(let i=0,a=n.length;i!==a;++i){let a=n[i];this._deactivateAction(a);let s=a._cacheIndex,o=r[r.length-1];a._cacheIndex=null,a._byClipCacheIndex=null,o._cacheIndex=s,r[s]=o,r.pop(),this._removeInactiveBindingsForAction(a)}delete a[i]}}// free all resources specific to a particular root target object
uncacheRoot(n){let r=n.uuid,i=this._actionsByClip;for(let n in i){let a=i[n].actionByRoot,s=a[r];void 0!==s&&(this._deactivateAction(s),this._removeInactiveAction(s))}let a=this._bindingsByRootAndName,s=a[r];if(void 0!==s)for(let n in s){let r=s[n];r.restoreOriginalState(),this._removeInactiveBinding(r)}}// remove a targeted clip from the cache
uncacheAction(n,r){let i=this.existingAction(n,r);null!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}}class $d5b33d7c30034067$export$2947cebfe91c02f8{constructor(n){this.value=n}clone(){return new $d5b33d7c30034067$export$2947cebfe91c02f8(void 0===this.value.clone?this.value:this.value.clone())}}let $d5b33d7c30034067$var$_id=0;class $d5b33d7c30034067$export$c412d5ffe1f79209 extends $d5b33d7c30034067$export$ec8b666c5fe2c75a{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:$d5b33d7c30034067$var$_id++}),this.name="",this.usage=$d5b33d7c30034067$export$763e8360f4d7f77d,this.uniforms=[]}add(n){return this.uniforms.push(n),this}remove(n){let r=this.uniforms.indexOf(n);return -1!==r&&this.uniforms.splice(r,1),this}setName(n){return this.name=n,this}setUsage(n){return this.usage=n,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(n){this.name=n.name,this.usage=n.usage;let r=n.uniforms;this.uniforms.length=0;for(let n=0,i=r.length;n<i;n++)this.uniforms.push(r[n].clone());return this}clone(){return new this.constructor().copy(this)}}class $d5b33d7c30034067$export$25ec0e1af1389358 extends $d5b33d7c30034067$export$3d5cd879f108f53f{constructor(n,r,i=1){super(n,r),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=i}copy(n){return super.copy(n),this.meshPerAttribute=n.meshPerAttribute,this}clone(n){let r=super.clone(n);return r.meshPerAttribute=this.meshPerAttribute,r}toJSON(n){let r=super.toJSON(n);return r.isInstancedInterleavedBuffer=!0,r.meshPerAttribute=this.meshPerAttribute,r}}class $d5b33d7c30034067$export$6b7339ae8dbddf73{constructor(n,r,i,a,s){this.isGLBufferAttribute=!0,this.name="",this.buffer=n,this.type=r,this.itemSize=i,this.elementSize=a,this.count=s,this.version=0}set needsUpdate(n){!0===n&&this.version++}setBuffer(n){return this.buffer=n,this}setType(n,r){return this.type=n,this.elementSize=r,this}setItemSize(n){return this.itemSize=n,this}setCount(n){return this.count=n,this}}class $d5b33d7c30034067$export$8b7aaceff00bd2f{constructor(n,r,i=0,a=1/0){this.ray=new $d5b33d7c30034067$export$a186db52eed6d40e(n,r),// direction is assumed to be normalized (for accurate distance calculations)
this.near=i,this.far=a,this.camera=null,this.layers=new $d5b33d7c30034067$export$89312ce47c0ca777,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(n,r){// direction is assumed to be normalized (for accurate distance calculations)
this.ray.set(n,r)}setFromCamera(n,r){r.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(r.matrixWorld),this.ray.direction.set(n.x,n.y,.5).unproject(r).sub(this.ray.origin).normalize(),this.camera=r):r.isOrthographicCamera?(this.ray.origin.set(n.x,n.y,(r.near+r.far)/(r.near-r.far)).unproject(r),this.ray.direction.set(0,0,-1).transformDirection(r.matrixWorld),this.camera=r):console.error("THREE.Raycaster: Unsupported camera type: "+r.type)}intersectObject(n,r=!0,i=[]){return $d5b33d7c30034067$var$intersectObject(n,this,i,r),i.sort($d5b33d7c30034067$var$ascSort),i}intersectObjects(n,r=!0,i=[]){for(let a=0,s=n.length;a<s;a++)$d5b33d7c30034067$var$intersectObject(n[a],this,i,r);return i.sort($d5b33d7c30034067$var$ascSort),i}}function $d5b33d7c30034067$var$ascSort(n,r){return n.distance-r.distance}function $d5b33d7c30034067$var$intersectObject(n,r,i,a){if(n.layers.test(r.layers)&&n.raycast(r,i),!0===a){let a=n.children;for(let n=0,s=a.length;n<s;n++)$d5b33d7c30034067$var$intersectObject(a[n],r,i,!0)}}/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */class $d5b33d7c30034067$export$d712cd887b4a00f7{constructor(n=1,r=0,i=0){return this.radius=n,this.phi=r,this.theta=i,this}set(n,r,i){return this.radius=n,this.phi=r,this.theta=i,this}copy(n){return this.radius=n.radius,this.phi=n.phi,this.theta=n.theta,this}// restrict phi to be between EPS and PI-EPS
makeSafe(){let n=1e-6;return this.phi=Math.max(n,Math.min(Math.PI-n,this.phi)),this}setFromVector3(n){return this.setFromCartesianCoords(n.x,n.y,n.z)}setFromCartesianCoords(n,r,i){return this.radius=Math.sqrt(n*n+r*r+i*i),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(n,i),this.phi=Math.acos($d5b33d7c30034067$var$clamp(r/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */class $d5b33d7c30034067$export$287165bb2177f4fd{constructor(n=1,r=0,i=0){return this.radius=n,this.theta=r,this.y=i,this}set(n,r,i){return this.radius=n,this.theta=r,this.y=i,this}copy(n){return this.radius=n.radius,this.theta=n.theta,this.y=n.y,this}setFromVector3(n){return this.setFromCartesianCoords(n.x,n.y,n.z)}setFromCartesianCoords(n,r,i){return this.radius=Math.sqrt(n*n+i*i),this.theta=Math.atan2(n,i),this.y=r,this}clone(){return new this.constructor().copy(this)}}const $d5b33d7c30034067$var$_vector$4=/*@__PURE__*/new $d5b33d7c30034067$export$c977b3e384af9ae1;class $d5b33d7c30034067$export$60f553fa130f08b0{constructor(n=new $d5b33d7c30034067$export$c977b3e384af9ae1(1/0,1/0),r=new $d5b33d7c30034067$export$c977b3e384af9ae1(-1/0,-1/0)){this.isBox2=!0,this.min=n,this.max=r}set(n,r){return this.min.copy(n),this.max.copy(r),this}setFromPoints(n){this.makeEmpty();for(let r=0,i=n.length;r<i;r++)this.expandByPoint(n[r]);return this}setFromCenterAndSize(n,r){let i=$d5b33d7c30034067$var$_vector$4.copy(r).multiplyScalar(.5);return this.min.copy(n).sub(i),this.max.copy(n).add(i),this}clone(){return new this.constructor().copy(this)}copy(n){return this.min.copy(n.min),this.max.copy(n.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(n){return this.isEmpty()?n.set(0,0):n.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(n){return this.isEmpty()?n.set(0,0):n.subVectors(this.max,this.min)}expandByPoint(n){return this.min.min(n),this.max.max(n),this}expandByVector(n){return this.min.sub(n),this.max.add(n),this}expandByScalar(n){return this.min.addScalar(-n),this.max.addScalar(n),this}containsPoint(n){return!(n.x<this.min.x)&&!(n.x>this.max.x)&&!(n.y<this.min.y)&&!(n.y>this.max.y)}containsBox(n){return this.min.x<=n.min.x&&n.max.x<=this.max.x&&this.min.y<=n.min.y&&n.max.y<=this.max.y}getParameter(n,r){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
return r.set((n.x-this.min.x)/(this.max.x-this.min.x),(n.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(n){// using 4 splitting planes to rule out intersections
return!(n.max.x<this.min.x)&&!(n.min.x>this.max.x)&&!(n.max.y<this.min.y)&&!(n.min.y>this.max.y)}clampPoint(n,r){return r.copy(n).clamp(this.min,this.max)}distanceToPoint(n){return this.clampPoint(n,$d5b33d7c30034067$var$_vector$4).distanceTo(n)}intersect(n){return this.min.max(n.min),this.max.min(n.max),this.isEmpty()&&this.makeEmpty(),this}union(n){return this.min.min(n.min),this.max.max(n.max),this}translate(n){return this.min.add(n),this.max.add(n),this}equals(n){return n.min.equals(this.min)&&n.max.equals(this.max)}}const $d5b33d7c30034067$var$_startP=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_startEnd=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$e0ba6359f1954fd3{constructor(n=new $d5b33d7c30034067$export$64b5c384219d3699,r=new $d5b33d7c30034067$export$64b5c384219d3699){this.start=n,this.end=r}set(n,r){return this.start.copy(n),this.end.copy(r),this}copy(n){return this.start.copy(n.start),this.end.copy(n.end),this}getCenter(n){return n.addVectors(this.start,this.end).multiplyScalar(.5)}delta(n){return n.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(n,r){return this.delta(r).multiplyScalar(n).add(this.start)}closestPointToPointParameter(n,r){$d5b33d7c30034067$var$_startP.subVectors(n,this.start),$d5b33d7c30034067$var$_startEnd.subVectors(this.end,this.start);let i=$d5b33d7c30034067$var$_startEnd.dot($d5b33d7c30034067$var$_startEnd),a=$d5b33d7c30034067$var$_startEnd.dot($d5b33d7c30034067$var$_startP),s=a/i;return r&&(s=$d5b33d7c30034067$var$clamp(s,0,1)),s}closestPointToPoint(n,r,i){let a=this.closestPointToPointParameter(n,r);return this.delta(i).multiplyScalar(a).add(this.start)}applyMatrix4(n){return this.start.applyMatrix4(n),this.end.applyMatrix4(n),this}equals(n){return n.start.equals(this.start)&&n.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const $d5b33d7c30034067$var$_vector$3=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$4b14638ffdd81e68 extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(n,r){super(),this.light=n,this.matrix=n.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,this.type="SpotLightHelper";let i=new $d5b33d7c30034067$export$b7be63a67df8959,a=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let n=0,r=1,i=32;n<i;n++,r++){let s=n/i*Math.PI*2,o=r/i*Math.PI*2;a.push(Math.cos(s),Math.sin(s),1,Math.cos(o),Math.sin(o),1)}i.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(a,3));let s=new $d5b33d7c30034067$export$fbaaa33907730a0c({fog:!1,toneMapped:!1});this.cone=new $d5b33d7c30034067$export$ff1ed10fedfdd604(i,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);let n=this.light.distance?this.light.distance:1e3,r=n*Math.tan(this.light.angle);this.cone.scale.set(r,r,n),$d5b33d7c30034067$var$_vector$3.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt($d5b33d7c30034067$var$_vector$3),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const $d5b33d7c30034067$var$_vector$2=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_boneMatrix=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5,$d5b33d7c30034067$var$_matrixWorldInv=/*@__PURE__*/new $d5b33d7c30034067$export$2ae72fc923e5eb5;class $d5b33d7c30034067$export$5277df3c9e732259 extends $d5b33d7c30034067$export$ff1ed10fedfdd604{constructor(n){let r=$d5b33d7c30034067$var$getBoneList(n),i=new $d5b33d7c30034067$export$b7be63a67df8959,a=[],s=[],o=new $d5b33d7c30034067$export$892596cec99bc70e(0,0,1),l=new $d5b33d7c30034067$export$892596cec99bc70e(0,1,0);for(let n=0;n<r.length;n++){let i=r[n];i.parent&&i.parent.isBone&&(a.push(0,0,0),a.push(0,0,0),s.push(o.r,o.g,o.b),s.push(l.r,l.g,l.b))}i.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(a,3)),i.setAttribute("color",new $d5b33d7c30034067$export$cbe7a62641830ebd(s,3));let u=new $d5b33d7c30034067$export$fbaaa33907730a0c({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,u),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=n,this.bones=r,this.matrix=n.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(n){let r=this.bones,i=this.geometry,a=i.getAttribute("position");$d5b33d7c30034067$var$_matrixWorldInv.copy(this.root.matrixWorld).invert();for(let n=0,i=0;n<r.length;n++){let s=r[n];s.parent&&s.parent.isBone&&($d5b33d7c30034067$var$_boneMatrix.multiplyMatrices($d5b33d7c30034067$var$_matrixWorldInv,s.matrixWorld),$d5b33d7c30034067$var$_vector$2.setFromMatrixPosition($d5b33d7c30034067$var$_boneMatrix),a.setXYZ(i,$d5b33d7c30034067$var$_vector$2.x,$d5b33d7c30034067$var$_vector$2.y,$d5b33d7c30034067$var$_vector$2.z),$d5b33d7c30034067$var$_boneMatrix.multiplyMatrices($d5b33d7c30034067$var$_matrixWorldInv,s.parent.matrixWorld),$d5b33d7c30034067$var$_vector$2.setFromMatrixPosition($d5b33d7c30034067$var$_boneMatrix),a.setXYZ(i+1,$d5b33d7c30034067$var$_vector$2.x,$d5b33d7c30034067$var$_vector$2.y,$d5b33d7c30034067$var$_vector$2.z),i+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(n)}dispose(){this.geometry.dispose(),this.material.dispose()}}function $d5b33d7c30034067$var$getBoneList(n){let r=[];!0===n.isBone&&r.push(n);for(let i=0;i<n.children.length;i++)r.push.apply(r,$d5b33d7c30034067$var$getBoneList(n.children[i]));return r}class $d5b33d7c30034067$export$9a9291685b9e4023 extends $d5b33d7c30034067$export$e176487c05830cc5{constructor(n,r,i){let a=new $d5b33d7c30034067$export$1b417fc3b307a251(r,4,2),s=new $d5b33d7c30034067$export$55cbcc9b622fe1f5({wireframe:!0,fog:!1,toneMapped:!1});super(a,s),this.light=n,this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update();/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color);/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/}}const $d5b33d7c30034067$var$_vector$1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_color1=/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e,$d5b33d7c30034067$var$_color2=/*@__PURE__*/new $d5b33d7c30034067$export$892596cec99bc70e;class $d5b33d7c30034067$export$8dca15f13f4f8172 extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(n,r,i){super(),this.light=n,this.matrix=n.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="HemisphereLightHelper";let a=new $d5b33d7c30034067$export$1954e2b809fe361e(r);a.rotateY(.5*Math.PI),this.material=new $d5b33d7c30034067$export$55cbcc9b622fe1f5({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);let s=a.getAttribute("position"),o=new Float32Array(3*s.count);a.setAttribute("color",new $d5b33d7c30034067$export$8dea267bd6bde117(o,3)),this.add(new $d5b33d7c30034067$export$e176487c05830cc5(a,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){let n=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{let r=n.geometry.getAttribute("color");$d5b33d7c30034067$var$_color1.copy(this.light.color),$d5b33d7c30034067$var$_color2.copy(this.light.groundColor);for(let n=0,i=r.count;n<i;n++){let a=n<i/2?$d5b33d7c30034067$var$_color1:$d5b33d7c30034067$var$_color2;r.setXYZ(n,a.r,a.g,a.b)}r.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),n.lookAt($d5b33d7c30034067$var$_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate())}}class $d5b33d7c30034067$export$3875d39926561055 extends $d5b33d7c30034067$export$ff1ed10fedfdd604{constructor(n=10,r=10,i=4473924,a=8947848){i=new $d5b33d7c30034067$export$892596cec99bc70e(i),a=new $d5b33d7c30034067$export$892596cec99bc70e(a);let s=r/2,o=n/r,l=n/2,u=[],c=[];for(let n=0,h=0,d=-l;n<=r;n++,d+=o){u.push(-l,0,d,l,0,d),u.push(d,0,-l,d,0,l);let r=n===s?i:a;r.toArray(c,h),h+=3,r.toArray(c,h),h+=3,r.toArray(c,h),h+=3,r.toArray(c,h),h+=3}let h=new $d5b33d7c30034067$export$b7be63a67df8959;h.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(u,3)),h.setAttribute("color",new $d5b33d7c30034067$export$cbe7a62641830ebd(c,3));let d=new $d5b33d7c30034067$export$fbaaa33907730a0c({vertexColors:!0,toneMapped:!1});super(h,d),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class $d5b33d7c30034067$export$361430a10f533cd3 extends $d5b33d7c30034067$export$ff1ed10fedfdd604{constructor(n=10,r=16,i=8,a=64,s=4473924,o=8947848){s=new $d5b33d7c30034067$export$892596cec99bc70e(s),o=new $d5b33d7c30034067$export$892596cec99bc70e(o);let l=[],u=[];// create the sectors
if(r>1)for(let i=0;i<r;i++){let a=i/r*(2*Math.PI),c=Math.sin(a)*n,h=Math.cos(a)*n;l.push(0,0,0),l.push(c,0,h);let d=1&i?s:o;u.push(d.r,d.g,d.b),u.push(d.r,d.g,d.b)}// create the rings
for(let r=0;r<i;r++){let c=1&r?s:o,h=n-n/i*r;for(let n=0;n<a;n++){// first vertex
let r=n/a*(2*Math.PI),i=Math.sin(r)*h,s=Math.cos(r)*h;l.push(i,0,s),u.push(c.r,c.g,c.b),i=Math.sin(// second vertex
r=(n+1)/a*(2*Math.PI))*h,s=Math.cos(r)*h,l.push(i,0,s),u.push(c.r,c.g,c.b)}}let c=new $d5b33d7c30034067$export$b7be63a67df8959;c.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(l,3)),c.setAttribute("color",new $d5b33d7c30034067$export$cbe7a62641830ebd(u,3));let h=new $d5b33d7c30034067$export$fbaaa33907730a0c({vertexColors:!0,toneMapped:!1});super(c,h),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const $d5b33d7c30034067$var$_v1=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_v2=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_v3=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$f8e434dc14203e7d extends $d5b33d7c30034067$export$e4dd07dff30cc924{constructor(n,r,i){super(),this.light=n,this.matrix=n.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="DirectionalLightHelper",void 0===r&&(r=1);let a=new $d5b33d7c30034067$export$b7be63a67df8959;a.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd([-r,r,0,r,r,0,r,-r,0,-r,-r,0,-r,r,0],3));let s=new $d5b33d7c30034067$export$fbaaa33907730a0c({fog:!1,toneMapped:!1});this.lightPlane=new $d5b33d7c30034067$export$17d680238e50603e(a,s),this.add(this.lightPlane),(a=new $d5b33d7c30034067$export$b7be63a67df8959).setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd([0,0,0,0,0,1],3)),this.targetLine=new $d5b33d7c30034067$export$17d680238e50603e(a,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),$d5b33d7c30034067$var$_v1.setFromMatrixPosition(this.light.matrixWorld),$d5b33d7c30034067$var$_v2.setFromMatrixPosition(this.light.target.matrixWorld),$d5b33d7c30034067$var$_v3.subVectors($d5b33d7c30034067$var$_v2,$d5b33d7c30034067$var$_v1),this.lightPlane.lookAt($d5b33d7c30034067$var$_v2),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt($d5b33d7c30034067$var$_v2),this.targetLine.scale.z=$d5b33d7c30034067$var$_v3.length()}}const $d5b33d7c30034067$var$_vector=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699,$d5b33d7c30034067$var$_camera=/*@__PURE__*/new $d5b33d7c30034067$export$79f141de891a5fed;/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
 */class $d5b33d7c30034067$export$ed8e93f853cd795 extends $d5b33d7c30034067$export$ff1ed10fedfdd604{constructor(n){let r=new $d5b33d7c30034067$export$b7be63a67df8959,i=new $d5b33d7c30034067$export$fbaaa33907730a0c({color:16777215,vertexColors:!0,toneMapped:!1}),a=[],s=[],o={};function l(n,r){u(n),u(r)}function u(n){a.push(0,0,0),s.push(0,0,0),void 0===o[n]&&(o[n]=[]),o[n].push(a.length/3-1)}// near
l("n1","n2"),l("n2","n4"),l("n4","n3"),l("n3","n1"),// far
l("f1","f2"),l("f2","f4"),l("f4","f3"),l("f3","f1"),// sides
l("n1","f1"),l("n2","f2"),l("n3","f3"),l("n4","f4"),// cone
l("p","n1"),l("p","n2"),l("p","n3"),l("p","n4"),// up
l("u1","u2"),l("u2","u3"),l("u3","u1"),// target
l("c","t"),l("p","c"),// cross
l("cn1","cn2"),l("cn3","cn4"),l("cf1","cf2"),l("cf3","cf4"),r.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(a,3)),r.setAttribute("color",new $d5b33d7c30034067$export$cbe7a62641830ebd(s,3)),super(r,i),this.type="CameraHelper",this.camera=n,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=n.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();// colors
let c=new $d5b33d7c30034067$export$892596cec99bc70e(16755200),h=new $d5b33d7c30034067$export$892596cec99bc70e(16711680),d=new $d5b33d7c30034067$export$892596cec99bc70e(43775),p=new $d5b33d7c30034067$export$892596cec99bc70e(16777215),f=new $d5b33d7c30034067$export$892596cec99bc70e(3355443);this.setColors(c,h,d,p,f)}setColors(n,r,i,a,s){let o=this.geometry,l=o.getAttribute("color");// near
l.setXYZ(0,n.r,n.g,n.b),l.setXYZ(1,n.r,n.g,n.b),l.setXYZ(2,n.r,n.g,n.b),l.setXYZ(3,n.r,n.g,n.b),l.setXYZ(4,n.r,n.g,n.b),l.setXYZ(5,n.r,n.g,n.b),l.setXYZ(6,n.r,n.g,n.b),l.setXYZ(7,n.r,n.g,n.b),// far
l.setXYZ(8,n.r,n.g,n.b),l.setXYZ(9,n.r,n.g,n.b),l.setXYZ(10,n.r,n.g,n.b),l.setXYZ(11,n.r,n.g,n.b),l.setXYZ(12,n.r,n.g,n.b),l.setXYZ(13,n.r,n.g,n.b),l.setXYZ(14,n.r,n.g,n.b),l.setXYZ(15,n.r,n.g,n.b),// sides
l.setXYZ(16,n.r,n.g,n.b),l.setXYZ(17,n.r,n.g,n.b),l.setXYZ(18,n.r,n.g,n.b),l.setXYZ(19,n.r,n.g,n.b),l.setXYZ(20,n.r,n.g,n.b),l.setXYZ(21,n.r,n.g,n.b),l.setXYZ(22,n.r,n.g,n.b),l.setXYZ(23,n.r,n.g,n.b),// cone
l.setXYZ(24,r.r,r.g,r.b),l.setXYZ(25,r.r,r.g,r.b),l.setXYZ(26,r.r,r.g,r.b),l.setXYZ(27,r.r,r.g,r.b),l.setXYZ(28,r.r,r.g,r.b),l.setXYZ(29,r.r,r.g,r.b),l.setXYZ(30,r.r,r.g,r.b),l.setXYZ(31,r.r,r.g,r.b),// up
l.setXYZ(32,i.r,i.g,i.b),l.setXYZ(33,i.r,i.g,i.b),l.setXYZ(34,i.r,i.g,i.b),l.setXYZ(35,i.r,i.g,i.b),l.setXYZ(36,i.r,i.g,i.b),l.setXYZ(37,i.r,i.g,i.b),// target
l.setXYZ(38,a.r,a.g,a.b),l.setXYZ(39,a.r,a.g,a.b),l.setXYZ(40,s.r,s.g,s.b),l.setXYZ(41,s.r,s.g,s.b),// cross
l.setXYZ(42,s.r,s.g,s.b),l.setXYZ(43,s.r,s.g,s.b),l.setXYZ(44,s.r,s.g,s.b),l.setXYZ(45,s.r,s.g,s.b),l.setXYZ(46,s.r,s.g,s.b),l.setXYZ(47,s.r,s.g,s.b),l.setXYZ(48,s.r,s.g,s.b),l.setXYZ(49,s.r,s.g,s.b),l.needsUpdate=!0}update(){let n=this.geometry,r=this.pointMap,i=1,a=1;// we need just camera projection matrix inverse
// world matrix must be identity
$d5b33d7c30034067$var$_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),// center / target
$d5b33d7c30034067$var$setPoint("c",r,n,$d5b33d7c30034067$var$_camera,0,0,-1),$d5b33d7c30034067$var$setPoint("t",r,n,$d5b33d7c30034067$var$_camera,0,0,1),// near
$d5b33d7c30034067$var$setPoint("n1",r,n,$d5b33d7c30034067$var$_camera,-i,-a,-1),$d5b33d7c30034067$var$setPoint("n2",r,n,$d5b33d7c30034067$var$_camera,i,-a,-1),$d5b33d7c30034067$var$setPoint("n3",r,n,$d5b33d7c30034067$var$_camera,-i,a,-1),$d5b33d7c30034067$var$setPoint("n4",r,n,$d5b33d7c30034067$var$_camera,i,a,-1),// far
$d5b33d7c30034067$var$setPoint("f1",r,n,$d5b33d7c30034067$var$_camera,-i,-a,1),$d5b33d7c30034067$var$setPoint("f2",r,n,$d5b33d7c30034067$var$_camera,i,-a,1),$d5b33d7c30034067$var$setPoint("f3",r,n,$d5b33d7c30034067$var$_camera,-i,a,1),$d5b33d7c30034067$var$setPoint("f4",r,n,$d5b33d7c30034067$var$_camera,i,a,1),// up
$d5b33d7c30034067$var$setPoint("u1",r,n,$d5b33d7c30034067$var$_camera,.7*i,1.1*a,-1),$d5b33d7c30034067$var$setPoint("u2",r,n,$d5b33d7c30034067$var$_camera,-(.7*i),1.1*a,-1),$d5b33d7c30034067$var$setPoint("u3",r,n,$d5b33d7c30034067$var$_camera,0,2*a,-1),// cross
$d5b33d7c30034067$var$setPoint("cf1",r,n,$d5b33d7c30034067$var$_camera,-i,0,1),$d5b33d7c30034067$var$setPoint("cf2",r,n,$d5b33d7c30034067$var$_camera,i,0,1),$d5b33d7c30034067$var$setPoint("cf3",r,n,$d5b33d7c30034067$var$_camera,0,-a,1),$d5b33d7c30034067$var$setPoint("cf4",r,n,$d5b33d7c30034067$var$_camera,0,a,1),$d5b33d7c30034067$var$setPoint("cn1",r,n,$d5b33d7c30034067$var$_camera,-i,0,-1),$d5b33d7c30034067$var$setPoint("cn2",r,n,$d5b33d7c30034067$var$_camera,i,0,-1),$d5b33d7c30034067$var$setPoint("cn3",r,n,$d5b33d7c30034067$var$_camera,0,-a,-1),$d5b33d7c30034067$var$setPoint("cn4",r,n,$d5b33d7c30034067$var$_camera,0,a,-1),n.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function $d5b33d7c30034067$var$setPoint(n,r,i,a,s,o,l){$d5b33d7c30034067$var$_vector.set(s,o,l).unproject(a);let u=r[n];if(void 0!==u){let n=i.getAttribute("position");for(let r=0,i=u.length;r<i;r++)n.setXYZ(u[r],$d5b33d7c30034067$var$_vector.x,$d5b33d7c30034067$var$_vector.y,$d5b33d7c30034067$var$_vector.z)}}const $d5b33d7c30034067$var$_box=/*@__PURE__*/new $d5b33d7c30034067$export$6f7d5a9418ab2aa3;class $d5b33d7c30034067$export$38a664cc862a6a9d extends $d5b33d7c30034067$export$ff1ed10fedfdd604{constructor(n,r=16776960){let i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),a=new Float32Array(24),s=new $d5b33d7c30034067$export$b7be63a67df8959;s.setIndex(new $d5b33d7c30034067$export$8dea267bd6bde117(i,1)),s.setAttribute("position",new $d5b33d7c30034067$export$8dea267bd6bde117(a,3)),super(s,new $d5b33d7c30034067$export$fbaaa33907730a0c({color:r,toneMapped:!1})),this.object=n,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(n){if(void 0!==n&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&$d5b33d7c30034067$var$_box.setFromObject(this.object),$d5b33d7c30034067$var$_box.isEmpty())return;let r=$d5b33d7c30034067$var$_box.min,i=$d5b33d7c30034067$var$_box.max,a=this.geometry.attributes.position,s=a.array;s[0]=i.x,s[1]=i.y,s[2]=i.z,s[3]=r.x,s[4]=i.y,s[5]=i.z,s[6]=r.x,s[7]=r.y,s[8]=i.z,s[9]=i.x,s[10]=r.y,s[11]=i.z,s[12]=i.x,s[13]=i.y,s[14]=r.z,s[15]=r.x,s[16]=i.y,s[17]=r.z,s[18]=r.x,s[19]=r.y,s[20]=r.z,s[21]=i.x,s[22]=r.y,s[23]=r.z,a.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(n){return this.object=n,this.update(),this}copy(n,r){return super.copy(n,r),this.object=n.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class $d5b33d7c30034067$export$ce39f4bb96c9a290 extends $d5b33d7c30034067$export$ff1ed10fedfdd604{constructor(n,r=16776960){let i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),a=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],s=new $d5b33d7c30034067$export$b7be63a67df8959;s.setIndex(new $d5b33d7c30034067$export$8dea267bd6bde117(i,1)),s.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(a,3)),super(s,new $d5b33d7c30034067$export$fbaaa33907730a0c({color:r,toneMapped:!1})),this.box=n,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(n){let r=this.box;r.isEmpty()||(r.getCenter(this.position),r.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(n))}dispose(){this.geometry.dispose(),this.material.dispose()}}class $d5b33d7c30034067$export$a34fe8156c66e5d7 extends $d5b33d7c30034067$export$17d680238e50603e{constructor(n,r=1,i=16776960){let a=i,s=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new $d5b33d7c30034067$export$b7be63a67df8959;o.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(s,3)),o.computeBoundingSphere(),super(o,new $d5b33d7c30034067$export$fbaaa33907730a0c({color:a,toneMapped:!1})),this.type="PlaneHelper",this.plane=n,this.size=r;let l=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],u=new $d5b33d7c30034067$export$b7be63a67df8959;u.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(l,3)),u.computeBoundingSphere(),this.add(new $d5b33d7c30034067$export$e176487c05830cc5(u,new $d5b33d7c30034067$export$55cbcc9b622fe1f5({color:a,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(n){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(n)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const $d5b33d7c30034067$var$_axis=/*@__PURE__*/new $d5b33d7c30034067$export$64b5c384219d3699;class $d5b33d7c30034067$export$a3008e7bd8d2cbe7 extends $d5b33d7c30034067$export$e4dd07dff30cc924{// dir is assumed to be normalized
constructor(n=new $d5b33d7c30034067$export$64b5c384219d3699(0,0,1),r=new $d5b33d7c30034067$export$64b5c384219d3699(0,0,0),i=1,a=16776960,s=.2*i,o=.2*s){super(),this.type="ArrowHelper",void 0===$d5b33d7c30034067$var$_lineGeometry&&(($d5b33d7c30034067$var$_lineGeometry=new $d5b33d7c30034067$export$b7be63a67df8959).setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd([0,0,0,0,1,0],3)),($d5b33d7c30034067$var$_coneGeometry=new $d5b33d7c30034067$export$68f745719dbe5198(0,.5,1,5,1)).translate(0,-.5,0)),this.position.copy(r),this.line=new $d5b33d7c30034067$export$17d680238e50603e($d5b33d7c30034067$var$_lineGeometry,new $d5b33d7c30034067$export$fbaaa33907730a0c({color:a,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new $d5b33d7c30034067$export$e176487c05830cc5($d5b33d7c30034067$var$_coneGeometry,new $d5b33d7c30034067$export$55cbcc9b622fe1f5({color:a,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(n),this.setLength(i,s,o)}setDirection(n){// dir is assumed to be normalized
if(n.y>.99999)this.quaternion.set(0,0,0,1);else if(n.y<-.99999)this.quaternion.set(1,0,0,0);else{$d5b33d7c30034067$var$_axis.set(n.z,0,-n.x).normalize();let r=Math.acos(n.y);this.quaternion.setFromAxisAngle($d5b33d7c30034067$var$_axis,r)}}setLength(n,r=.2*n,i=.2*r){this.line.scale.set(1,Math.max(1e-4,n-r),1),this.line.updateMatrix(),this.cone.scale.set(i,r,i),this.cone.position.y=n,this.cone.updateMatrix()}setColor(n){this.line.material.color.set(n),this.cone.material.color.set(n)}copy(n){return super.copy(n,!1),this.line.copy(n.line),this.cone.copy(n.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class $d5b33d7c30034067$export$6c8303f35b8578fd extends $d5b33d7c30034067$export$ff1ed10fedfdd604{constructor(n=1){let r=[0,0,0,n,0,0,0,0,0,0,n,0,0,0,0,0,0,n],i=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],a=new $d5b33d7c30034067$export$b7be63a67df8959;a.setAttribute("position",new $d5b33d7c30034067$export$cbe7a62641830ebd(r,3)),a.setAttribute("color",new $d5b33d7c30034067$export$cbe7a62641830ebd(i,3));let s=new $d5b33d7c30034067$export$fbaaa33907730a0c({vertexColors:!0,toneMapped:!1});super(a,s),this.type="AxesHelper"}setColors(n,r,i){let a=new $d5b33d7c30034067$export$892596cec99bc70e,s=this.geometry.attributes.color.array;return a.set(n),a.toArray(s,0),a.toArray(s,3),a.set(r),a.toArray(s,6),a.toArray(s,9),a.set(i),a.toArray(s,12),a.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class $d5b33d7c30034067$export$148534a3c727230b{constructor(){this.type="ShapePath",this.color=new $d5b33d7c30034067$export$892596cec99bc70e,this.subPaths=[],this.currentPath=null}moveTo(n,r){return this.currentPath=new $d5b33d7c30034067$export$4b2950bdac9b6ee9,this.subPaths.push(this.currentPath),this.currentPath.moveTo(n,r),this}lineTo(n,r){return this.currentPath.lineTo(n,r),this}quadraticCurveTo(n,r,i,a){return this.currentPath.quadraticCurveTo(n,r,i,a),this}bezierCurveTo(n,r,i,a,s,o){return this.currentPath.bezierCurveTo(n,r,i,a,s,o),this}splineThru(n){return this.currentPath.splineThru(n),this}toShapes(n){let r,i,a,s,o;function l(n){let r=[];for(let i=0,a=n.length;i<a;i++){let a=n[i],s=new $d5b33d7c30034067$export$6428a7f2611ef1fa;s.curves=a.curves,r.push(s)}return r}function u(n,r){let i=r.length,a=!1;for(let s=i-1,o=0;o<i;s=o++){let i=r[s],l=r[o],u=l.x-i.x,c=l.y-i.y;if(Math.abs(c)>Number.EPSILON){if(c<0&&(i=r[o],u=-u,l=r[s],c=-c),n.y<i.y||n.y>l.y)continue;if(n.y===i.y){if(n.x===i.x)return!0;// inPt is on contour ?
}else{let r=c*(n.x-i.x)-u*(n.y-i.y);if(0===r)return!0;// inPt is on contour ?
if(r<0)continue;a=!a;// true intersection left of inPt
}}else{// parallel or collinear
if(n.y!==i.y)continue;// parallel
// edge lies on the same horizontal line as inPt
if(l.x<=n.x&&n.x<=i.x||i.x<=n.x&&n.x<=l.x)return!0;// inPt: Point on contour !
// continue;
}}return a}let c=$d5b33d7c30034067$export$96bdf6d9c66d7ba8.isClockWise,h=this.subPaths;if(0===h.length)return[];let d=[];if(1===h.length)return i=h[0],(a=new $d5b33d7c30034067$export$6428a7f2611ef1fa).curves=i.curves,d.push(a),d;let p=!c(h[0].getPoints());p=n?!p:p;// console.log("Holes first", holesFirst);
let f=[],m=[],g=[],_=0;m[0]=void 0,g[_]=[];for(let a=0,o=h.length;a<o;a++)r=c(s=(i=h[a]).getPoints()),(r=n?!r:r)?(!p&&m[_]&&_++,m[_]={s:new $d5b33d7c30034067$export$6428a7f2611ef1fa,p:s},m[_].s.curves=i.curves,p&&_++,g[_]=[]):g[_].push({h:i,p:s[0]});// only Holes? -> probably all Shapes with wrong orientation
if(!m[0])return l(h);if(m.length>1){let n=!1,r=0;for(let n=0,r=m.length;n<r;n++)f[n]=[];for(let i=0,a=m.length;i<a;i++){let a=g[i];for(let s=0;s<a.length;s++){let o=a[s],l=!0;for(let a=0;a<m.length;a++)u(o.p,m[a].p)&&(i!==a&&r++,l?(l=!1,f[a].push(o)):n=!0);l&&f[i].push(o)}}r>0&&!1===n&&(g=f)}for(let n=0,r=m.length;n<r;n++){a=m[n].s,d.push(a),o=g[n];for(let n=0,r=o.length;n<r;n++)a.holes.push(o[n].h)}//console.log("shape", shapes);
return d}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:$d5b33d7c30034067$export$3545e07a80636437}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=$d5b33d7c30034067$export$3545e07a80636437);const $ba30e20475feac5a$export$e506a1d27d1eaa20={AUDIOS_PATH:"assets/audios",AVATAR_PATH:"assets/models/avatar.glb",ANIMATIONS_PATH:"assets/animations",EMBEDDINGS_PATH:"assets/embeddings.json",TEXTS_PATH:"assets/texts.json",MOTION_AMPLITUDE:.95,LIPSYNC_CORRESPONDENCE:{default:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],A:[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],B:[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],C:[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],D:[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],E:[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],F:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],G:[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],H:[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],X:[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},CAMERA_POSITION:[0,.1,1]},$443c013b983d0324$var$_changeEvent={type:"change"},$443c013b983d0324$var$_startEvent={type:"start"},$443c013b983d0324$var$_endEvent={type:"end"},$443c013b983d0324$var$_ray=new $d5b33d7c30034067$export$a186db52eed6d40e,$443c013b983d0324$var$_plane=new $d5b33d7c30034067$export$7ff5ac152ef991b0,$443c013b983d0324$var$TILT_LIMIT=Math.cos(70*$d5b33d7c30034067$export$6a7ef315a0d1ef07.DEG2RAD);class $443c013b983d0324$export$8ff7788029dfdf52 extends $d5b33d7c30034067$export$ec8b666c5fe2c75a{constructor(n,r){super(),this.object=n,this.domElement=r,this.domElement.style.touchAction="none",// Set to false to disable this control
this.enabled=!0,// "target" sets the location of focus, where the object orbits around
this.target=new $d5b33d7c30034067$export$64b5c384219d3699,// How far you can dolly in and out ( PerspectiveCamera only )
this.minDistance=0,this.maxDistance=1/0,// How far you can zoom in and out ( OrthographicCamera only )
this.minZoom=0,this.maxZoom=1/0,// How far you can orbit vertically, upper and lower limits.
// Range is 0 to Math.PI radians.
this.minPolarAngle=0,this.maxPolarAngle=Math.PI,// How far you can orbit horizontally, upper and lower limits.
// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,// Set to true to enable damping (inertia)
// If damping is enabled, you must call controls.update() in your animation loop
this.enableDamping=!1,this.dampingFactor=.05,// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
// Set to false to disable zooming
this.enableZoom=!0,this.zoomSpeed=1,// Set to false to disable rotating
this.enableRotate=!0,this.rotateSpeed=1,// Set to false to disable panning
this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,// Set to true to automatically rotate around the target
// If auto-rotate is enabled, you must call controls.update() in your animation loop
this.autoRotate=!1,this.autoRotateSpeed=2,// The four arrow keys
this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},// Mouse buttons
this.mouseButtons={LEFT:$d5b33d7c30034067$export$7177b3e430c2d7ca.ROTATE,MIDDLE:$d5b33d7c30034067$export$7177b3e430c2d7ca.DOLLY,RIGHT:$d5b33d7c30034067$export$7177b3e430c2d7ca.PAN},// Touch fingers
this.touches={ONE:$d5b33d7c30034067$export$d46bd3ead7cc759b.ROTATE,TWO:$d5b33d7c30034067$export$d46bd3ead7cc759b.DOLLY_PAN},// for reset
this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,// the target DOM element for key events
this._domElementKeyEvents=null,//
// public methods
//
this.getPolarAngle=function(){return l.phi},this.getAzimuthalAngle=function(){return l.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(n){n.addEventListener("keydown",eo),this._domElementKeyEvents=n},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",eo),this._domElementKeyEvents=null},this.saveState=function(){i.target0.copy(i.target),i.position0.copy(i.object.position),i.zoom0=i.object.zoom},this.reset=function(){i.target.copy(i.target0),i.object.position.copy(i.position0),i.object.zoom=i.zoom0,i.object.updateProjectionMatrix(),i.dispatchEvent($443c013b983d0324$var$_changeEvent),i.update(),s=a.NONE},// this method is exposed, but perhaps it would be better if we can make it private...
this.update=function(){let r=new $d5b33d7c30034067$export$64b5c384219d3699,d=new $d5b33d7c30034067$export$23d6a54f0bbc85a3().setFromUnitVectors(n.up,new $d5b33d7c30034067$export$64b5c384219d3699(0,1,0)),p=d.clone().invert(),f=new $d5b33d7c30034067$export$64b5c384219d3699,m=new $d5b33d7c30034067$export$23d6a54f0bbc85a3,g=new $d5b33d7c30034067$export$64b5c384219d3699,_=2*Math.PI;return function(y=null){let b=i.object.position;r.copy(b).sub(i.target),// rotate offset to "y-axis-is-up" space
r.applyQuaternion(d),// angle from z-axis around y-axis
l.setFromVector3(r),i.autoRotate&&s===a.NONE&&I(A(y)),i.enableDamping?(l.theta+=u.theta*i.dampingFactor,l.phi+=u.phi*i.dampingFactor):(l.theta+=u.theta,l.phi+=u.phi);// restrict theta to be between desired limits
let v=i.minAzimuthAngle,S=i.maxAzimuthAngle;isFinite(v)&&isFinite(S)&&(v<-Math.PI?v+=_:v>Math.PI&&(v-=_),S<-Math.PI?S+=_:S>Math.PI&&(S-=_),v<=S?l.theta=Math.max(v,Math.min(S,l.theta)):l.theta=l.theta>(v+S)/2?Math.max(v,l.theta):Math.min(S,l.theta)),// restrict phi to be between desired limits
l.phi=Math.max(i.minPolarAngle,Math.min(i.maxPolarAngle,l.phi)),l.makeSafe(),!0===i.enableDamping?i.target.addScaledVector(h,i.dampingFactor):i.target.add(h),i.zoomToCursor&&T||i.object.isOrthographicCamera?l.radius=k(l.radius):l.radius=k(l.radius*c),r.setFromSpherical(l),// rotate offset back to "camera-up-vector-is-up" space
r.applyQuaternion(p),b.copy(i.target).add(r),i.object.lookAt(i.target),!0===i.enableDamping?(u.theta*=1-i.dampingFactor,u.phi*=1-i.dampingFactor,h.multiplyScalar(1-i.dampingFactor)):(u.set(0,0,0),h.set(0,0,0));// adjust camera position
let E=!1;if(i.zoomToCursor&&T){let a=null;if(i.object.isPerspectiveCamera){// move the camera down the pointer ray
// this method avoids floating point error
let n=r.length();a=k(n*c);let s=n-a;i.object.position.addScaledVector(x,s),i.object.updateMatrixWorld()}else if(i.object.isOrthographicCamera){// adjust the ortho camera position based on zoom changes
let n=new $d5b33d7c30034067$export$64b5c384219d3699(w.x,w.y,0);n.unproject(i.object),i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/c)),i.object.updateProjectionMatrix(),E=!0;let s=new $d5b33d7c30034067$export$64b5c384219d3699(w.x,w.y,0);s.unproject(i.object),i.object.position.sub(s).add(n),i.object.updateMatrixWorld(),a=r.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),i.zoomToCursor=!1;// handle the placement of the target
null!==a&&(this.screenSpacePanning?i.target.set(0,0,-1).transformDirection(i.object.matrix).multiplyScalar(a).add(i.object.position):(// get the ray and translation plane to compute target
$443c013b983d0324$var$_ray.origin.copy(i.object.position),$443c013b983d0324$var$_ray.direction.set(0,0,-1).transformDirection(i.object.matrix),Math.abs(i.object.up.dot($443c013b983d0324$var$_ray.direction))<$443c013b983d0324$var$TILT_LIMIT?n.lookAt(i.target):($443c013b983d0324$var$_plane.setFromNormalAndCoplanarPoint(i.object.up,i.target),$443c013b983d0324$var$_ray.intersectPlane($443c013b983d0324$var$_plane,i.target))))}else i.object.isOrthographicCamera&&(i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/c)),i.object.updateProjectionMatrix(),E=!0);return(// update condition is:
// min(camera displacement, camera rotation in radians)^2 > EPS
// using small-angle approximation cos(x/2) = 1 - x^2 / 8
c=1,T=!1,!!(E||f.distanceToSquared(i.object.position)>o||8*(1-m.dot(i.object.quaternion))>o||g.distanceToSquared(i.target)>0)&&(i.dispatchEvent($443c013b983d0324$var$_changeEvent),f.copy(i.object.position),m.copy(i.object.quaternion),g.copy(i.target),E=!1,!0))}}(),this.dispose=function(){i.domElement.removeEventListener("contextmenu",ec),i.domElement.removeEventListener("pointerdown",et),i.domElement.removeEventListener("pointercancel",er),i.domElement.removeEventListener("wheel",es),i.domElement.removeEventListener("pointermove",en),i.domElement.removeEventListener("pointerup",er),null!==i._domElementKeyEvents&&(i._domElementKeyEvents.removeEventListener("keydown",eo),i._domElementKeyEvents=null);//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
};//
// internals
//
let i=this,a={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},s=a.NONE,o=1e-6,l=new $d5b33d7c30034067$export$d712cd887b4a00f7,u=new $d5b33d7c30034067$export$d712cd887b4a00f7,c=1,h=new $d5b33d7c30034067$export$64b5c384219d3699,d=new $d5b33d7c30034067$export$c977b3e384af9ae1,p=new $d5b33d7c30034067$export$c977b3e384af9ae1,f=new $d5b33d7c30034067$export$c977b3e384af9ae1,m=new $d5b33d7c30034067$export$c977b3e384af9ae1,g=new $d5b33d7c30034067$export$c977b3e384af9ae1,_=new $d5b33d7c30034067$export$c977b3e384af9ae1,y=new $d5b33d7c30034067$export$c977b3e384af9ae1,b=new $d5b33d7c30034067$export$c977b3e384af9ae1,v=new $d5b33d7c30034067$export$c977b3e384af9ae1,x=new $d5b33d7c30034067$export$64b5c384219d3699,w=new $d5b33d7c30034067$export$c977b3e384af9ae1,T=!1,S=[],E={};function A(n){return null!==n?2*Math.PI/60*i.autoRotateSpeed*n:2*Math.PI/60/60*i.autoRotateSpeed}function M(){return Math.pow(.95,i.zoomSpeed)}function I(n){u.theta-=n}function P(n){u.phi-=n}let O=function(){let n=new $d5b33d7c30034067$export$64b5c384219d3699;return function(r,i){n.setFromMatrixColumn(i,0),n.multiplyScalar(-r),h.add(n)}}(),R=function(){let n=new $d5b33d7c30034067$export$64b5c384219d3699;return function(r,a){!0===i.screenSpacePanning?n.setFromMatrixColumn(a,1):(n.setFromMatrixColumn(a,0),n.crossVectors(i.object.up,n)),n.multiplyScalar(r),h.add(n)}}(),C=function(){let n=new $d5b33d7c30034067$export$64b5c384219d3699;return function(r,a){let s=i.domElement;if(i.object.isPerspectiveCamera){// perspective
let o=i.object.position;n.copy(o).sub(i.target);let l=n.length();// we use only clientHeight here so aspect ratio does not distort speed
O(2*r*// half of the fov is center to top of screen
(l*=Math.tan(i.object.fov/2*Math.PI/180))/s.clientHeight,i.object.matrix),R(2*a*l/s.clientHeight,i.object.matrix)}else i.object.isOrthographicCamera?(// orthographic
O(r*(i.object.right-i.object.left)/i.object.zoom/s.clientWidth,i.object.matrix),R(a*(i.object.top-i.object.bottom)/i.object.zoom/s.clientHeight,i.object.matrix)):(// camera neither orthographic nor perspective
console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),i.enablePan=!1)}}();function L(n){i.object.isPerspectiveCamera||i.object.isOrthographicCamera?c/=n:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function D(n){i.object.isPerspectiveCamera||i.object.isOrthographicCamera?c*=n:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function N(n){if(!i.zoomToCursor)return;T=!0;let r=i.domElement.getBoundingClientRect(),a=n.clientX-r.left,s=n.clientY-r.top,o=r.width,l=r.height;w.x=a/o*2-1,w.y=-(2*(s/l))+1,x.set(w.x,w.y,1).unproject(i.object).sub(i.object.position).normalize()}function k(n){return Math.max(i.minDistance,Math.min(i.maxDistance,n))}//
// event callbacks - update the object state
//
function U(n){d.set(n.clientX,n.clientY)}function F(n){N(n),y.set(n.clientX,n.clientY)}function B(n){m.set(n.clientX,n.clientY)}function z(n){p.set(n.clientX,n.clientY),f.subVectors(p,d).multiplyScalar(i.rotateSpeed);let r=i.domElement;I(2*Math.PI*f.x/r.clientHeight),P(2*Math.PI*f.y/r.clientHeight),d.copy(p),i.update()}function V(n){b.set(n.clientX,n.clientY),v.subVectors(b,y),v.y>0?L(M()):v.y<0&&D(M()),y.copy(b),i.update()}function G(n){g.set(n.clientX,n.clientY),_.subVectors(g,m).multiplyScalar(i.panSpeed),C(_.x,_.y),m.copy(g),i.update()}function j(n){N(n),n.deltaY<0?D(M()):n.deltaY>0&&L(M()),i.update()}function H(n){let r=!1;switch(n.code){case i.keys.UP:n.ctrlKey||n.metaKey||n.shiftKey?P(2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):C(0,i.keyPanSpeed),r=!0;break;case i.keys.BOTTOM:n.ctrlKey||n.metaKey||n.shiftKey?P(-2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):C(0,-i.keyPanSpeed),r=!0;break;case i.keys.LEFT:n.ctrlKey||n.metaKey||n.shiftKey?I(2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):C(i.keyPanSpeed,0),r=!0;break;case i.keys.RIGHT:n.ctrlKey||n.metaKey||n.shiftKey?I(-2*Math.PI*i.rotateSpeed/i.domElement.clientHeight):C(-i.keyPanSpeed,0),r=!0}r&&(// prevent the browser from scrolling on cursor keys
n.preventDefault(),i.update())}function $(){if(1===S.length)d.set(S[0].pageX,S[0].pageY);else{let n=.5*(S[0].pageX+S[1].pageX),r=.5*(S[0].pageY+S[1].pageY);d.set(n,r)}}function W(){if(1===S.length)m.set(S[0].pageX,S[0].pageY);else{let n=.5*(S[0].pageX+S[1].pageX),r=.5*(S[0].pageY+S[1].pageY);m.set(n,r)}}function X(){let n=S[0].pageX-S[1].pageX,r=S[0].pageY-S[1].pageY,i=Math.sqrt(n*n+r*r);y.set(0,i)}function q(){i.enableZoom&&X(),i.enablePan&&W()}function Y(){i.enableZoom&&X(),i.enableRotate&&$()}function K(n){if(1==S.length)p.set(n.pageX,n.pageY);else{let r=ef(n),i=.5*(n.pageX+r.x),a=.5*(n.pageY+r.y);p.set(i,a)}f.subVectors(p,d).multiplyScalar(i.rotateSpeed);let r=i.domElement;I(2*Math.PI*f.x/r.clientHeight),P(2*Math.PI*f.y/r.clientHeight),d.copy(p)}function Z(n){if(1===S.length)g.set(n.pageX,n.pageY);else{let r=ef(n),i=.5*(n.pageX+r.x),a=.5*(n.pageY+r.y);g.set(i,a)}_.subVectors(g,m).multiplyScalar(i.panSpeed),C(_.x,_.y),m.copy(g)}function J(n){let r=ef(n),a=n.pageX-r.x,s=n.pageY-r.y,o=Math.sqrt(a*a+s*s);b.set(0,o),v.set(0,Math.pow(b.y/y.y,i.zoomSpeed)),L(v.y),y.copy(b)}function Q(n){i.enableZoom&&J(n),i.enablePan&&Z(n)}function ee(n){i.enableZoom&&J(n),i.enableRotate&&K(n)}//
// event handlers - FSM: listen for events and reset state
//
function et(n){!1!==i.enabled&&(0===S.length&&(i.domElement.setPointerCapture(n.pointerId),i.domElement.addEventListener("pointermove",en),i.domElement.addEventListener("pointerup",er)),//
eh(n),"touch"===n.pointerType?el(n):ei(n))}function en(n){!1!==i.enabled&&("touch"===n.pointerType?eu(n):ea(n))}function er(n){ed(n),0===S.length&&(i.domElement.releasePointerCapture(n.pointerId),i.domElement.removeEventListener("pointermove",en),i.domElement.removeEventListener("pointerup",er)),i.dispatchEvent($443c013b983d0324$var$_endEvent),s=a.NONE}function ei(n){let r;switch(n.button){case 0:r=i.mouseButtons.LEFT;break;case 1:r=i.mouseButtons.MIDDLE;break;case 2:r=i.mouseButtons.RIGHT;break;default:r=-1}switch(r){case $d5b33d7c30034067$export$7177b3e430c2d7ca.DOLLY:if(!1===i.enableZoom)return;F(n),s=a.DOLLY;break;case $d5b33d7c30034067$export$7177b3e430c2d7ca.ROTATE:if(n.ctrlKey||n.metaKey||n.shiftKey){if(!1===i.enablePan)return;B(n),s=a.PAN}else{if(!1===i.enableRotate)return;U(n),s=a.ROTATE}break;case $d5b33d7c30034067$export$7177b3e430c2d7ca.PAN:if(n.ctrlKey||n.metaKey||n.shiftKey){if(!1===i.enableRotate)return;U(n),s=a.ROTATE}else{if(!1===i.enablePan)return;B(n),s=a.PAN}break;default:s=a.NONE}s!==a.NONE&&i.dispatchEvent($443c013b983d0324$var$_startEvent)}function ea(n){switch(s){case a.ROTATE:if(!1===i.enableRotate)return;z(n);break;case a.DOLLY:if(!1===i.enableZoom)return;V(n);break;case a.PAN:if(!1===i.enablePan)return;G(n)}}function es(n){!1!==i.enabled&&!1!==i.enableZoom&&s===a.NONE&&(n.preventDefault(),i.dispatchEvent($443c013b983d0324$var$_startEvent),j(n),i.dispatchEvent($443c013b983d0324$var$_endEvent))}function eo(n){!1!==i.enabled&&!1!==i.enablePan&&H(n)}function el(n){switch(ep(n),S.length){case 1:switch(i.touches.ONE){case $d5b33d7c30034067$export$d46bd3ead7cc759b.ROTATE:if(!1===i.enableRotate)return;$(),s=a.TOUCH_ROTATE;break;case $d5b33d7c30034067$export$d46bd3ead7cc759b.PAN:if(!1===i.enablePan)return;W(),s=a.TOUCH_PAN;break;default:s=a.NONE}break;case 2:switch(i.touches.TWO){case $d5b33d7c30034067$export$d46bd3ead7cc759b.DOLLY_PAN:if(!1===i.enableZoom&&!1===i.enablePan)return;q(),s=a.TOUCH_DOLLY_PAN;break;case $d5b33d7c30034067$export$d46bd3ead7cc759b.DOLLY_ROTATE:if(!1===i.enableZoom&&!1===i.enableRotate)return;Y(),s=a.TOUCH_DOLLY_ROTATE;break;default:s=a.NONE}break;default:s=a.NONE}s!==a.NONE&&i.dispatchEvent($443c013b983d0324$var$_startEvent)}function eu(n){switch(ep(n),s){case a.TOUCH_ROTATE:if(!1===i.enableRotate)return;K(n),i.update();break;case a.TOUCH_PAN:if(!1===i.enablePan)return;Z(n),i.update();break;case a.TOUCH_DOLLY_PAN:if(!1===i.enableZoom&&!1===i.enablePan)return;Q(n),i.update();break;case a.TOUCH_DOLLY_ROTATE:if(!1===i.enableZoom&&!1===i.enableRotate)return;ee(n),i.update();break;default:s=a.NONE}}function ec(n){!1!==i.enabled&&n.preventDefault()}function eh(n){S.push(n)}function ed(n){delete E[n.pointerId];for(let r=0;r<S.length;r++)if(S[r].pointerId==n.pointerId){S.splice(r,1);return}}function ep(n){let r=E[n.pointerId];void 0===r&&(r=new $d5b33d7c30034067$export$c977b3e384af9ae1,E[n.pointerId]=r),r.set(n.pageX,n.pageY)}function ef(n){let r=n.pointerId===S[0].pointerId?S[1]:S[0];return E[r.pointerId]}//
i.domElement.addEventListener("contextmenu",ec),i.domElement.addEventListener("pointerdown",et),i.domElement.addEventListener("pointercancel",er),i.domElement.addEventListener("wheel",es,{passive:!1}),// force an update at start
this.update()}}/**
 * @param {BufferGeometry} geometry
 * @param {number} drawMode
 * @return {BufferGeometry}
 */function $5451ea62abbe5f68$export$5492ca6e5c0c7aa0(n,r){if(r===$d5b33d7c30034067$export$4c28c87c2dc84758)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),n;if(r!==$d5b33d7c30034067$export$f0d8293634f88842&&r!==$d5b33d7c30034067$export$b23a071aa286eb29)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),n;{let i=n.getIndex();// generate index if not present
if(null===i){let r=[],a=n.getAttribute("position");if(void 0===a)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n;for(let n=0;n<a.count;n++)r.push(n);n.setIndex(r),i=n.getIndex()}//
let a=i.count-2,s=[];if(r===$d5b33d7c30034067$export$f0d8293634f88842)for(let n=1;n<=a;n++)s.push(i.getX(0)),s.push(i.getX(n)),s.push(i.getX(n+1));else // gl.TRIANGLE_STRIP
for(let n=0;n<a;n++)n%2==0?(s.push(i.getX(n)),s.push(i.getX(n+1)),s.push(i.getX(n+2))):(s.push(i.getX(n+2)),s.push(i.getX(n+1)),s.push(i.getX(n)));s.length/3!==a&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");// build final geometry
let o=n.clone();return o.setIndex(s),o.clearGroups(),o}}class $559434fcc6e6401d$export$aa93f11e7884f0f4 extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(n){return new $559434fcc6e6401d$var$GLTFMaterialsClearcoatExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFTextureBasisUExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFTextureWebPExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFTextureAVIFExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFMaterialsSheenExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFMaterialsTransmissionExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFMaterialsVolumeExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFMaterialsIorExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFMaterialsEmissiveStrengthExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFMaterialsSpecularExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFMaterialsIridescenceExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFMaterialsAnisotropyExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFLightsExtension(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFMeshoptCompression(n)}),this.register(function(n){return new $559434fcc6e6401d$var$GLTFMeshGpuInstancing(n)})}load(n,r,i,a){let s;let o=this;s=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:$d5b33d7c30034067$export$b5d2dc08d867e41a.extractUrlBase(n),// Tells the LoadingManager to track an extra item, which resolves after
// the model is fully loaded. This means the count of items loaded will
// be incorrect, but ensures manager.onLoad() does not fire early.
this.manager.itemStart(n);let l=function(r){a?a(r):console.error(r),o.manager.itemError(n),o.manager.itemEnd(n)},u=new $d5b33d7c30034067$export$98435a25b5cf7b2b(this.manager);u.setPath(this.path),u.setResponseType("arraybuffer"),u.setRequestHeader(this.requestHeader),u.setWithCredentials(this.withCredentials),u.load(n,function(i){try{o.parse(i,s,function(i){r(i),o.manager.itemEnd(n)},l)}catch(n){l(n)}},i,l)}setDRACOLoader(n){return this.dracoLoader=n,this}setDDSLoader(){throw Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(n){return this.ktx2Loader=n,this}setMeshoptDecoder(n){return this.meshoptDecoder=n,this}register(n){return -1===this.pluginCallbacks.indexOf(n)&&this.pluginCallbacks.push(n),this}unregister(n){return -1!==this.pluginCallbacks.indexOf(n)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(n),1),this}parse(n,r,i,a){let s;let o={},l={},u=new TextDecoder;if("string"==typeof n)s=JSON.parse(n);else if(n instanceof ArrayBuffer){let r=u.decode(new Uint8Array(n,0,4));if(r===$559434fcc6e6401d$var$BINARY_EXTENSION_HEADER_MAGIC){try{o[$559434fcc6e6401d$var$EXTENSIONS.KHR_BINARY_GLTF]=new $559434fcc6e6401d$var$GLTFBinaryExtension(n)}catch(n){a&&a(n);return}s=JSON.parse(o[$559434fcc6e6401d$var$EXTENSIONS.KHR_BINARY_GLTF].content)}else s=JSON.parse(u.decode(n))}else s=n;if(void 0===s.asset||s.asset.version[0]<2){a&&a(Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}let c=new $559434fcc6e6401d$var$GLTFParser(s,{path:r||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let n=0;n<this.pluginCallbacks.length;n++){let r=this.pluginCallbacks[n](c);l[r.name]=r,// Workaround to avoid determining as unknown extension
// in addUnknownExtensionsToUserData().
// Remove this workaround if we move all the existing
// extension handlers to plugin system
o[r.name]=!0}if(s.extensionsUsed)for(let n=0;n<s.extensionsUsed.length;++n){let r=s.extensionsUsed[n],i=s.extensionsRequired||[];switch(r){case $559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_UNLIT:o[r]=new $559434fcc6e6401d$var$GLTFMaterialsUnlitExtension;break;case $559434fcc6e6401d$var$EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:o[r]=new $559434fcc6e6401d$var$GLTFDracoMeshCompressionExtension(s,this.dracoLoader);break;case $559434fcc6e6401d$var$EXTENSIONS.KHR_TEXTURE_TRANSFORM:o[r]=new $559434fcc6e6401d$var$GLTFTextureTransformExtension;break;case $559434fcc6e6401d$var$EXTENSIONS.KHR_MESH_QUANTIZATION:o[r]=new $559434fcc6e6401d$var$GLTFMeshQuantizationExtension;break;default:i.indexOf(r)>=0&&void 0===l[r]&&console.warn('THREE.GLTFLoader: Unknown extension "'+r+'".')}}c.setExtensions(o),c.setPlugins(l),c.parse(i,a)}parseAsync(n,r){let i=this;return new Promise(function(a,s){i.parse(n,r,a,s)})}}/* GLTFREGISTRY */function $559434fcc6e6401d$var$GLTFRegistry(){let n={};return{get:function(r){return n[r]},add:function(r,i){n[r]=i},remove:function(r){delete n[r]},removeAll:function(){n={}}}}/*********************************//********** EXTENSIONS ***********//*********************************/const $559434fcc6e6401d$var$EXTENSIONS={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */class $559434fcc6e6401d$var$GLTFLightsExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_LIGHTS_PUNCTUAL,// Object3D instance caches
this.cache={refs:{},uses:{}}}_markDefs(){let n=this.parser,r=this.parser.json.nodes||[];for(let i=0,a=r.length;i<a;i++){let a=r[i];a.extensions&&a.extensions[this.name]&&void 0!==a.extensions[this.name].light&&n._addNodeRef(this.cache,a.extensions[this.name].light)}}_loadLight(n){let r;let i=this.parser,a="light:"+n,s=i.cache.get(a);if(s)return s;let o=i.json,l=o.extensions&&o.extensions[this.name]||{},u=l.lights||[],c=u[n],h=new $d5b33d7c30034067$export$892596cec99bc70e(16777215);void 0!==c.color&&h.setRGB(c.color[0],c.color[1],c.color[2],$d5b33d7c30034067$export$42429b3acfb233a4);let d=void 0!==c.range?c.range:0;switch(c.type){case"directional":(r=new $d5b33d7c30034067$export$3fea33cc9972c868(h)).target.position.set(0,0,-1),r.add(r.target);break;case"point":(r=new $d5b33d7c30034067$export$4c9c1cb3f0b6f455(h)).distance=d;break;case"spot":(r=new $d5b33d7c30034067$export$81495cbb73897362(h)).distance=d,// Handle spotlight properties.
c.spot=c.spot||{},c.spot.innerConeAngle=void 0!==c.spot.innerConeAngle?c.spot.innerConeAngle:0,c.spot.outerConeAngle=void 0!==c.spot.outerConeAngle?c.spot.outerConeAngle:Math.PI/4,r.angle=c.spot.outerConeAngle,r.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,r.target.position.set(0,0,-1),r.add(r.target);break;default:throw Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return(// Some lights (e.g. spot) default to a position other than the origin. Reset the position
// here, because node-level parsing will only override position if explicitly specified.
r.position.set(0,0,0),r.decay=2,$559434fcc6e6401d$var$assignExtrasToUserData(r,c),void 0!==c.intensity&&(r.intensity=c.intensity),r.name=i.createUniqueName(c.name||"light_"+n),s=Promise.resolve(r),i.cache.add(a,s),s)}getDependency(n,r){if("light"===n)return this._loadLight(r)}createNodeAttachment(n){let r=this,i=this.parser,a=i.json,s=a.nodes[n],o=s.extensions&&s.extensions[this.name]||{},l=o.light;return void 0===l?null:this._loadLight(l).then(function(n){return i._getNodeRef(r.cache,l,n)})}}/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */class $559434fcc6e6401d$var$GLTFMaterialsUnlitExtension{constructor(){this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_UNLIT}getMaterialType(){return $d5b33d7c30034067$export$55cbcc9b622fe1f5}extendParams(n,r,i){let a=[];n.color=new $d5b33d7c30034067$export$892596cec99bc70e(1,1,1),n.opacity=1;let s=r.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){let r=s.baseColorFactor;n.color.setRGB(r[0],r[1],r[2],$d5b33d7c30034067$export$42429b3acfb233a4),n.opacity=r[3]}void 0!==s.baseColorTexture&&a.push(i.assignTexture(n,"map",s.baseColorTexture,$d5b33d7c30034067$export$561f394b24edfcaa))}return Promise.all(a)}}/**
 * Materials Emissive Strength Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
 */class $559434fcc6e6401d$var$GLTFMaterialsEmissiveStrengthExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(n,r){let i=this.parser,a=i.json.materials[n];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();let s=a.extensions[this.name].emissiveStrength;return void 0!==s&&(r.emissiveIntensity=s),Promise.resolve()}}/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */class $559434fcc6e6401d$var$GLTFMaterialsClearcoatExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_CLEARCOAT}getMaterialType(n){let r=this.parser,i=r.json.materials[n];return i.extensions&&i.extensions[this.name]?$d5b33d7c30034067$export$28d04986c4269c9f:null}extendMaterialParams(n,r){let i=this.parser,a=i.json.materials[n];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();let s=[],o=a.extensions[this.name];if(void 0!==o.clearcoatFactor&&(r.clearcoat=o.clearcoatFactor),void 0!==o.clearcoatTexture&&s.push(i.assignTexture(r,"clearcoatMap",o.clearcoatTexture)),void 0!==o.clearcoatRoughnessFactor&&(r.clearcoatRoughness=o.clearcoatRoughnessFactor),void 0!==o.clearcoatRoughnessTexture&&s.push(i.assignTexture(r,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),void 0!==o.clearcoatNormalTexture&&(s.push(i.assignTexture(r,"clearcoatNormalMap",o.clearcoatNormalTexture)),void 0!==o.clearcoatNormalTexture.scale)){let n=o.clearcoatNormalTexture.scale;r.clearcoatNormalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1(n,n)}return Promise.all(s)}}/**
 * Iridescence Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
 */class $559434fcc6e6401d$var$GLTFMaterialsIridescenceExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_IRIDESCENCE}getMaterialType(n){let r=this.parser,i=r.json.materials[n];return i.extensions&&i.extensions[this.name]?$d5b33d7c30034067$export$28d04986c4269c9f:null}extendMaterialParams(n,r){let i=this.parser,a=i.json.materials[n];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();let s=[],o=a.extensions[this.name];return void 0!==o.iridescenceFactor&&(r.iridescence=o.iridescenceFactor),void 0!==o.iridescenceTexture&&s.push(i.assignTexture(r,"iridescenceMap",o.iridescenceTexture)),void 0!==o.iridescenceIor&&(r.iridescenceIOR=o.iridescenceIor),void 0===r.iridescenceThicknessRange&&(r.iridescenceThicknessRange=[100,400]),void 0!==o.iridescenceThicknessMinimum&&(r.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),void 0!==o.iridescenceThicknessMaximum&&(r.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),void 0!==o.iridescenceThicknessTexture&&s.push(i.assignTexture(r,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(s)}}/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */class $559434fcc6e6401d$var$GLTFMaterialsSheenExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_SHEEN}getMaterialType(n){let r=this.parser,i=r.json.materials[n];return i.extensions&&i.extensions[this.name]?$d5b33d7c30034067$export$28d04986c4269c9f:null}extendMaterialParams(n,r){let i=this.parser,a=i.json.materials[n];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();let s=[];r.sheenColor=new $d5b33d7c30034067$export$892596cec99bc70e(0,0,0),r.sheenRoughness=0,r.sheen=1;let o=a.extensions[this.name];if(void 0!==o.sheenColorFactor){let n=o.sheenColorFactor;r.sheenColor.setRGB(n[0],n[1],n[2],$d5b33d7c30034067$export$42429b3acfb233a4)}return void 0!==o.sheenRoughnessFactor&&(r.sheenRoughness=o.sheenRoughnessFactor),void 0!==o.sheenColorTexture&&s.push(i.assignTexture(r,"sheenColorMap",o.sheenColorTexture,$d5b33d7c30034067$export$561f394b24edfcaa)),void 0!==o.sheenRoughnessTexture&&s.push(i.assignTexture(r,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(s)}}/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */class $559434fcc6e6401d$var$GLTFMaterialsTransmissionExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_TRANSMISSION}getMaterialType(n){let r=this.parser,i=r.json.materials[n];return i.extensions&&i.extensions[this.name]?$d5b33d7c30034067$export$28d04986c4269c9f:null}extendMaterialParams(n,r){let i=this.parser,a=i.json.materials[n];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();let s=[],o=a.extensions[this.name];return void 0!==o.transmissionFactor&&(r.transmission=o.transmissionFactor),void 0!==o.transmissionTexture&&s.push(i.assignTexture(r,"transmissionMap",o.transmissionTexture)),Promise.all(s)}}/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */class $559434fcc6e6401d$var$GLTFMaterialsVolumeExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_VOLUME}getMaterialType(n){let r=this.parser,i=r.json.materials[n];return i.extensions&&i.extensions[this.name]?$d5b33d7c30034067$export$28d04986c4269c9f:null}extendMaterialParams(n,r){let i=this.parser,a=i.json.materials[n];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();let s=[],o=a.extensions[this.name];r.thickness=void 0!==o.thicknessFactor?o.thicknessFactor:0,void 0!==o.thicknessTexture&&s.push(i.assignTexture(r,"thicknessMap",o.thicknessTexture)),r.attenuationDistance=o.attenuationDistance||1/0;let l=o.attenuationColor||[1,1,1];return r.attenuationColor=new $d5b33d7c30034067$export$892596cec99bc70e().setRGB(l[0],l[1],l[2],$d5b33d7c30034067$export$42429b3acfb233a4),Promise.all(s)}}/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */class $559434fcc6e6401d$var$GLTFMaterialsIorExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_IOR}getMaterialType(n){let r=this.parser,i=r.json.materials[n];return i.extensions&&i.extensions[this.name]?$d5b33d7c30034067$export$28d04986c4269c9f:null}extendMaterialParams(n,r){let i=this.parser,a=i.json.materials[n];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();let s=a.extensions[this.name];return r.ior=void 0!==s.ior?s.ior:1.5,Promise.resolve()}}/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */class $559434fcc6e6401d$var$GLTFMaterialsSpecularExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_SPECULAR}getMaterialType(n){let r=this.parser,i=r.json.materials[n];return i.extensions&&i.extensions[this.name]?$d5b33d7c30034067$export$28d04986c4269c9f:null}extendMaterialParams(n,r){let i=this.parser,a=i.json.materials[n];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();let s=[],o=a.extensions[this.name];r.specularIntensity=void 0!==o.specularFactor?o.specularFactor:1,void 0!==o.specularTexture&&s.push(i.assignTexture(r,"specularIntensityMap",o.specularTexture));let l=o.specularColorFactor||[1,1,1];return r.specularColor=new $d5b33d7c30034067$export$892596cec99bc70e().setRGB(l[0],l[1],l[2],$d5b33d7c30034067$export$42429b3acfb233a4),void 0!==o.specularColorTexture&&s.push(i.assignTexture(r,"specularColorMap",o.specularColorTexture,$d5b33d7c30034067$export$561f394b24edfcaa)),Promise.all(s)}}/**
 * Materials anisotropy Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy
 */class $559434fcc6e6401d$var$GLTFMaterialsAnisotropyExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_ANISOTROPY}getMaterialType(n){let r=this.parser,i=r.json.materials[n];return i.extensions&&i.extensions[this.name]?$d5b33d7c30034067$export$28d04986c4269c9f:null}extendMaterialParams(n,r){let i=this.parser,a=i.json.materials[n];if(!a.extensions||!a.extensions[this.name])return Promise.resolve();let s=[],o=a.extensions[this.name];return void 0!==o.anisotropyStrength&&(r.anisotropy=o.anisotropyStrength),void 0!==o.anisotropyRotation&&(r.anisotropyRotation=o.anisotropyRotation),void 0!==o.anisotropyTexture&&s.push(i.assignTexture(r,"anisotropyMap",o.anisotropyTexture)),Promise.all(s)}}/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */class $559434fcc6e6401d$var$GLTFTextureBasisUExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_TEXTURE_BASISU}loadTexture(n){let r=this.parser,i=r.json,a=i.textures[n];if(!a.extensions||!a.extensions[this.name])return null;let s=a.extensions[this.name],o=r.options.ktx2Loader;if(!o){if(!(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0))return null;throw Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures")}return r.loadTextureImage(n,s.source,o)}}/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */class $559434fcc6e6401d$var$GLTFTextureWebPExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(n){let r=this.name,i=this.parser,a=i.json,s=a.textures[n];if(!s.extensions||!s.extensions[r])return null;let o=s.extensions[r],l=a.images[o.source],u=i.textureLoader;if(l.uri){let n=i.options.manager.getHandler(l.uri);null!==n&&(u=n)}return this.detectSupport().then(function(s){if(s)return i.loadTextureImage(n,o.source,u);if(a.extensionsRequired&&a.extensionsRequired.indexOf(r)>=0)throw Error("THREE.GLTFLoader: WebP required by asset but unsupported.");// Fall back to PNG or JPEG.
return i.loadTexture(n)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(n){let r=new Image;// Lossy test image. Support for lossy images doesn't guarantee support for all
// WebP images, unfortunately.
r.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",r.onload=r.onerror=function(){n(1===r.height)}})),this.isSupported}}/**
 * AVIF Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif
 */class $559434fcc6e6401d$var$GLTFTextureAVIFExtension{constructor(n){this.parser=n,this.name=$559434fcc6e6401d$var$EXTENSIONS.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(n){let r=this.name,i=this.parser,a=i.json,s=a.textures[n];if(!s.extensions||!s.extensions[r])return null;let o=s.extensions[r],l=a.images[o.source],u=i.textureLoader;if(l.uri){let n=i.options.manager.getHandler(l.uri);null!==n&&(u=n)}return this.detectSupport().then(function(s){if(s)return i.loadTextureImage(n,o.source,u);if(a.extensionsRequired&&a.extensionsRequired.indexOf(r)>=0)throw Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");// Fall back to PNG or JPEG.
return i.loadTexture(n)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(n){let r=new Image;// Lossy test image.
r.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",r.onload=r.onerror=function(){n(1===r.height)}})),this.isSupported}}/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */class $559434fcc6e6401d$var$GLTFMeshoptCompression{constructor(n){this.name=$559434fcc6e6401d$var$EXTENSIONS.EXT_MESHOPT_COMPRESSION,this.parser=n}loadBufferView(n){let r=this.parser.json,i=r.bufferViews[n];if(!i.extensions||!i.extensions[this.name])return null;{let n=i.extensions[this.name],a=this.parser.getDependency("buffer",n.buffer),s=this.parser.options.meshoptDecoder;if(!s||!s.supported){if(!(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0))return null;throw Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files")}return a.then(function(r){let i=n.byteOffset||0,a=n.byteLength||0,o=n.count,l=n.byteStride,u=new Uint8Array(r,i,a);return s.decodeGltfBufferAsync?s.decodeGltfBufferAsync(o,l,u,n.mode,n.filter).then(function(n){return n.buffer}):s.ready.then(function(){let r=new ArrayBuffer(o*l);return s.decodeGltfBuffer(new Uint8Array(r),o,l,u,n.mode,n.filter),r})})}}}/**
 * GPU Instancing Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
 *
 */class $559434fcc6e6401d$var$GLTFMeshGpuInstancing{constructor(n){this.name=$559434fcc6e6401d$var$EXTENSIONS.EXT_MESH_GPU_INSTANCING,this.parser=n}createNodeMesh(n){let r=this.parser.json,i=r.nodes[n];if(!i.extensions||!i.extensions[this.name]||void 0===i.mesh)return null;let a=r.meshes[i.mesh];// No Points or Lines + Instancing support yet
for(let n of a.primitives)if(n.mode!==$559434fcc6e6401d$var$WEBGL_CONSTANTS.TRIANGLES&&n.mode!==$559434fcc6e6401d$var$WEBGL_CONSTANTS.TRIANGLE_STRIP&&n.mode!==$559434fcc6e6401d$var$WEBGL_CONSTANTS.TRIANGLE_FAN&&void 0!==n.mode)return null;let s=i.extensions[this.name],o=s.attributes,l=[],u={};for(let n in o)l.push(this.parser.getDependency("accessor",o[n]).then(r=>(u[n]=r,u[n])));return l.length<1?null:(l.push(this.parser.createNodeMesh(n)),Promise.all(l).then(n=>{let r=n.pop(),i=r.isGroup?r.children:[r],a=n[0].count,s=[];for(let n of i){// Temporal variables
let r=new $d5b33d7c30034067$export$2ae72fc923e5eb5,i=new $d5b33d7c30034067$export$64b5c384219d3699,o=new $d5b33d7c30034067$export$23d6a54f0bbc85a3,l=new $d5b33d7c30034067$export$64b5c384219d3699(1,1,1),c=new $d5b33d7c30034067$export$f3c979c331175ad7(n.geometry,n.material,a);for(let n=0;n<a;n++)u.TRANSLATION&&i.fromBufferAttribute(u.TRANSLATION,n),u.ROTATION&&o.fromBufferAttribute(u.ROTATION,n),u.SCALE&&l.fromBufferAttribute(u.SCALE,n),c.setMatrixAt(n,r.compose(i,o,l));// Add instance attributes to the geometry, excluding TRS.
for(let r in u)"TRANSLATION"!==r&&"ROTATION"!==r&&"SCALE"!==r&&n.geometry.setAttribute(r,u[r]);$d5b33d7c30034067$export$e4dd07dff30cc924.prototype.copy.call(c,n),this.parser.assignFinalMaterial(c),s.push(c)}return r.isGroup?(r.clear(),r.add(...s),r):s[0]}))}}/* BINARY EXTENSION */const $559434fcc6e6401d$var$BINARY_EXTENSION_HEADER_MAGIC="glTF",$559434fcc6e6401d$var$BINARY_EXTENSION_HEADER_LENGTH=12,$559434fcc6e6401d$var$BINARY_EXTENSION_CHUNK_TYPES={JSON:1313821514,BIN:5130562};class $559434fcc6e6401d$var$GLTFBinaryExtension{constructor(n){this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_BINARY_GLTF,this.content=null,this.body=null;let r=new DataView(n,0,$559434fcc6e6401d$var$BINARY_EXTENSION_HEADER_LENGTH),i=new TextDecoder;if(this.header={magic:i.decode(new Uint8Array(n.slice(0,4))),version:r.getUint32(4,!0),length:r.getUint32(8,!0)},this.header.magic!==$559434fcc6e6401d$var$BINARY_EXTENSION_HEADER_MAGIC)throw Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw Error("THREE.GLTFLoader: Legacy binary file detected.");let a=this.header.length-$559434fcc6e6401d$var$BINARY_EXTENSION_HEADER_LENGTH,s=new DataView(n,$559434fcc6e6401d$var$BINARY_EXTENSION_HEADER_LENGTH),o=0;for(;o<a;){let r=s.getUint32(o,!0);o+=4;let a=s.getUint32(o,!0);if(o+=4,a===$559434fcc6e6401d$var$BINARY_EXTENSION_CHUNK_TYPES.JSON){let a=new Uint8Array(n,$559434fcc6e6401d$var$BINARY_EXTENSION_HEADER_LENGTH+o,r);this.content=i.decode(a)}else if(a===$559434fcc6e6401d$var$BINARY_EXTENSION_CHUNK_TYPES.BIN){let i=$559434fcc6e6401d$var$BINARY_EXTENSION_HEADER_LENGTH+o;this.body=n.slice(i,i+r)}// Clients must ignore chunks with unknown types.
o+=r}if(null===this.content)throw Error("THREE.GLTFLoader: JSON content not found.")}}/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */class $559434fcc6e6401d$var$GLTFDracoMeshCompressionExtension{constructor(n,r){if(!r)throw Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_DRACO_MESH_COMPRESSION,this.json=n,this.dracoLoader=r,this.dracoLoader.preload()}decodePrimitive(n,r){let i=this.json,a=this.dracoLoader,s=n.extensions[this.name].bufferView,o=n.extensions[this.name].attributes,l={},u={},c={};for(let n in o){let r=$559434fcc6e6401d$var$ATTRIBUTES[n]||n.toLowerCase();l[r]=o[n]}for(let r in n.attributes){let a=$559434fcc6e6401d$var$ATTRIBUTES[r]||r.toLowerCase();if(void 0!==o[r]){let s=i.accessors[n.attributes[r]],o=$559434fcc6e6401d$var$WEBGL_COMPONENT_TYPES[s.componentType];c[a]=o.name,u[a]=!0===s.normalized}}return r.getDependency("bufferView",s).then(function(n){return new Promise(function(r){a.decodeDracoFile(n,function(n){for(let r in n.attributes){let i=n.attributes[r],a=u[r];void 0!==a&&(i.normalized=a)}r(n)},l,c)})})}}/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */class $559434fcc6e6401d$var$GLTFTextureTransformExtension{constructor(){this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_TEXTURE_TRANSFORM}extendTexture(n,r){return(void 0===r.texCoord||r.texCoord===n.channel)&&void 0===r.offset&&void 0===r.rotation&&void 0===r.scale||(n=n.clone(),void 0!==r.texCoord&&(n.channel=r.texCoord),void 0!==r.offset&&n.offset.fromArray(r.offset),void 0!==r.rotation&&(n.rotation=r.rotation),void 0!==r.scale&&n.repeat.fromArray(r.scale),n.needsUpdate=!0),n}}/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */class $559434fcc6e6401d$var$GLTFMeshQuantizationExtension{constructor(){this.name=$559434fcc6e6401d$var$EXTENSIONS.KHR_MESH_QUANTIZATION}}/*********************************//********** INTERPOLATION ********//*********************************/// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class $559434fcc6e6401d$var$GLTFCubicSplineInterpolant extends $d5b33d7c30034067$export$b558baee9c0f72d3{constructor(n,r,i,a){super(n,r,i,a)}copySampleValue_(n){// Copies a sample value to the result buffer. See description of glTF
// CUBICSPLINE values layout in interpolate_() function below.
let r=this.resultBuffer,i=this.sampleValues,a=this.valueSize,s=n*a*3+a;for(let n=0;n!==a;n++)r[n]=i[s+n];return r}interpolate_(n,r,i,a){let s=this.resultBuffer,o=this.sampleValues,l=this.valueSize,u=2*l,c=3*l,h=a-r,d=(i-r)/h,p=d*d,f=p*d,m=n*c,g=m-c,_=-2*f+3*p,y=f-p,b=1-_,v=y-p+d;// Layout of keyframe output values for CUBICSPLINE animations:
//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
for(let n=0;n!==l;n++){let r=o[g+n+l],i=o[g+n+u]*h,a=o[m+n+l],c=o[m+n]*h;// splineVertex_k
s[n]=b*r+v*i+_*a+y*c}return s}}const $559434fcc6e6401d$var$_q=new $d5b33d7c30034067$export$23d6a54f0bbc85a3;class $559434fcc6e6401d$var$GLTFCubicSplineQuaternionInterpolant extends $559434fcc6e6401d$var$GLTFCubicSplineInterpolant{interpolate_(n,r,i,a){let s=super.interpolate_(n,r,i,a);return $559434fcc6e6401d$var$_q.fromArray(s).normalize().toArray(s),s}}/*********************************//********** INTERNALS ************//*********************************//* CONSTANTS */const $559434fcc6e6401d$var$WEBGL_CONSTANTS={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},$559434fcc6e6401d$var$WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},$559434fcc6e6401d$var$WEBGL_FILTERS={9728:$d5b33d7c30034067$export$727aa5ec3fe39bf0,9729:$d5b33d7c30034067$export$8a72f490b25c56c8,9984:$d5b33d7c30034067$export$d129e38cf6feaa8c,9985:$d5b33d7c30034067$export$19a719f377145a13,9986:$d5b33d7c30034067$export$d2327c1afe5bfdf2,9987:$d5b33d7c30034067$export$5d8599b6a933fb1b},$559434fcc6e6401d$var$WEBGL_WRAPPINGS={33071:$d5b33d7c30034067$export$9d9334239a5a5e06,33648:$d5b33d7c30034067$export$c7e7c00b14f51a4f,10497:$d5b33d7c30034067$export$533346c8e8dac0f5},$559434fcc6e6401d$var$WEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},$559434fcc6e6401d$var$ATTRIBUTES={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},$559434fcc6e6401d$var$PATH_PROPERTIES={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},$559434fcc6e6401d$var$INTERPOLATION={CUBICSPLINE:void 0,// keyframe track will be initialized with a default interpolation type, then modified.
LINEAR:$d5b33d7c30034067$export$30fac1aace31cf4d,STEP:$d5b33d7c30034067$export$995b32462a65e855},$559434fcc6e6401d$var$ALPHA_MODES={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */function $559434fcc6e6401d$var$createDefaultMaterial(n){return void 0===n.DefaultMaterial&&(n.DefaultMaterial=new $d5b33d7c30034067$export$f2980790215acccd({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:$d5b33d7c30034067$export$2ede184fc2998901})),n.DefaultMaterial}function $559434fcc6e6401d$var$addUnknownExtensionsToUserData(n,r,i){// Add unknown glTF extensions to an object's userData.
for(let a in i.extensions)void 0===n[a]&&(r.userData.gltfExtensions=r.userData.gltfExtensions||{},r.userData.gltfExtensions[a]=i.extensions[a])}/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */function $559434fcc6e6401d$var$assignExtrasToUserData(n,r){void 0!==r.extras&&("object"==typeof r.extras?Object.assign(n.userData,r.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+r.extras))}/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */function $559434fcc6e6401d$var$addMorphTargets(n,r,i){let a=!1,s=!1,o=!1;for(let n=0,i=r.length;n<i;n++){let i=r[n];if(void 0!==i.POSITION&&(a=!0),void 0!==i.NORMAL&&(s=!0),void 0!==i.COLOR_0&&(o=!0),a&&s&&o)break}if(!a&&!s&&!o)return Promise.resolve(n);let l=[],u=[],c=[];for(let h=0,d=r.length;h<d;h++){let d=r[h];if(a){let r=void 0!==d.POSITION?i.getDependency("accessor",d.POSITION):n.attributes.position;l.push(r)}if(s){let r=void 0!==d.NORMAL?i.getDependency("accessor",d.NORMAL):n.attributes.normal;u.push(r)}if(o){let r=void 0!==d.COLOR_0?i.getDependency("accessor",d.COLOR_0):n.attributes.color;c.push(r)}}return Promise.all([Promise.all(l),Promise.all(u),Promise.all(c)]).then(function(r){let i=r[0],l=r[1],u=r[2];return a&&(n.morphAttributes.position=i),s&&(n.morphAttributes.normal=l),o&&(n.morphAttributes.color=u),n.morphTargetsRelative=!0,n})}/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */function $559434fcc6e6401d$var$updateMorphTargets(n,r){if(n.updateMorphTargets(),void 0!==r.weights)for(let i=0,a=r.weights.length;i<a;i++)n.morphTargetInfluences[i]=r.weights[i];// .extras has user-defined data, so check that .extras.targetNames is an array.
if(r.extras&&Array.isArray(r.extras.targetNames)){let i=r.extras.targetNames;if(n.morphTargetInfluences.length===i.length){n.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++)n.morphTargetDictionary[i[r]]=r}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function $559434fcc6e6401d$var$createPrimitiveKey(n){let r;let i=n.extensions&&n.extensions[$559434fcc6e6401d$var$EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];if(r=i?"draco:"+i.bufferView+":"+i.indices+":"+$559434fcc6e6401d$var$createAttributesKey(i.attributes):n.indices+":"+$559434fcc6e6401d$var$createAttributesKey(n.attributes)+":"+n.mode,void 0!==n.targets)for(let i=0,a=n.targets.length;i<a;i++)r+=":"+$559434fcc6e6401d$var$createAttributesKey(n.targets[i]);return r}function $559434fcc6e6401d$var$createAttributesKey(n){let r="",i=Object.keys(n).sort();for(let a=0,s=i.length;a<s;a++)r+=i[a]+":"+n[i[a]]+";";return r}function $559434fcc6e6401d$var$getNormalizedComponentScale(n){// Reference:
// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function $559434fcc6e6401d$var$getImageURIMimeType(n){return n.search(/\.jpe?g($|\?)/i)>0||0===n.search(/^data\:image\/jpeg/)?"image/jpeg":n.search(/\.webp($|\?)/i)>0||0===n.search(/^data\:image\/webp/)?"image/webp":"image/png"}const $559434fcc6e6401d$var$_identityMatrix=new $d5b33d7c30034067$export$2ae72fc923e5eb5;/* GLTF PARSER */class $559434fcc6e6401d$var$GLTFParser{constructor(n={},r={}){this.json=n,this.extensions={},this.plugins={},this.options=r,// loader object cache
this.cache=new $559434fcc6e6401d$var$GLTFRegistry,// associations between Three.js objects and glTF elements
this.associations=new Map,// BufferGeometry caching
this.primitiveCache={},// Node cache
this.nodeCache={},// Object3D instance caches
this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},// Track node names, to ensure no duplicates
this.nodeNamesUsed={};// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
// expensive work of uploading a texture to the GPU off the main thread.
let i=!1,a=!1,s=-1;"undefined"!=typeof navigator&&(i=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),s=(a=navigator.userAgent.indexOf("Firefox")>-1)?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),"undefined"==typeof createImageBitmap||i||a&&s<98?this.textureLoader=new $d5b33d7c30034067$export$fd1bfc71f64c538c(this.options.manager):this.textureLoader=new $d5b33d7c30034067$export$52286b55c4a9b51f(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new $d5b33d7c30034067$export$98435a25b5cf7b2b(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(n){this.extensions=n}setPlugins(n){this.plugins=n}parse(n,r){let i=this,a=this.json,s=this.extensions;// Clear the loader cache
this.cache.removeAll(),this.nodeCache={},// Mark the special nodes/meshes in json for efficient parse
this._invokeAll(function(n){return n._markDefs&&n._markDefs()}),Promise.all(this._invokeAll(function(n){return n.beforeRoot&&n.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(r){let o={scene:r[0][a.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:a.asset,parser:i,userData:{}};$559434fcc6e6401d$var$addUnknownExtensionsToUserData(s,o,a),$559434fcc6e6401d$var$assignExtrasToUserData(o,a),Promise.all(i._invokeAll(function(n){return n.afterRoot&&n.afterRoot(o)})).then(function(){n(o)})}).catch(r)}/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */_markDefs(){let n=this.json.nodes||[],r=this.json.skins||[],i=this.json.meshes||[];// Nothing in the node definition indicates whether it is a Bone or an
// Object3D. Use the skins' joint references to mark bones.
for(let i=0,a=r.length;i<a;i++){let a=r[i].joints;for(let r=0,i=a.length;r<i;r++)n[a[r]].isBone=!0}// Iterate over all nodes, marking references to shared resources,
// as well as skeleton joints.
for(let r=0,a=n.length;r<a;r++){let a=n[r];void 0!==a.mesh&&(this._addNodeRef(this.meshCache,a.mesh),void 0!==a.skin&&(i[a.mesh].isSkinnedMesh=!0)),void 0!==a.camera&&this._addNodeRef(this.cameraCache,a.camera)}}/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */_addNodeRef(n,r){void 0!==r&&(void 0===n.refs[r]&&(n.refs[r]=n.uses[r]=0),n.refs[r]++)}/** Returns a reference to a shared resource, cloning it if necessary. */_getNodeRef(n,r,i){if(n.refs[r]<=1)return i;let a=i.clone(),s=(n,r)=>{let i=this.associations.get(n);for(let[a,o]of(null!=i&&this.associations.set(r,i),n.children.entries()))s(o,r.children[a])};return s(i,a),a.name+="_instance_"+n.uses[r]++,a}_invokeOne(n){let r=Object.values(this.plugins);r.push(this);for(let i=0;i<r.length;i++){let a=n(r[i]);if(a)return a}return null}_invokeAll(n){let r=Object.values(this.plugins);r.unshift(this);let i=[];for(let a=0;a<r.length;a++){let s=n(r[a]);s&&i.push(s)}return i}/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */getDependency(n,r){let i=n+":"+r,a=this.cache.get(i);if(!a){switch(n){case"scene":a=this.loadScene(r);break;case"node":a=this._invokeOne(function(n){return n.loadNode&&n.loadNode(r)});break;case"mesh":a=this._invokeOne(function(n){return n.loadMesh&&n.loadMesh(r)});break;case"accessor":a=this.loadAccessor(r);break;case"bufferView":a=this._invokeOne(function(n){return n.loadBufferView&&n.loadBufferView(r)});break;case"buffer":a=this.loadBuffer(r);break;case"material":a=this._invokeOne(function(n){return n.loadMaterial&&n.loadMaterial(r)});break;case"texture":a=this._invokeOne(function(n){return n.loadTexture&&n.loadTexture(r)});break;case"skin":a=this.loadSkin(r);break;case"animation":a=this._invokeOne(function(n){return n.loadAnimation&&n.loadAnimation(r)});break;case"camera":a=this.loadCamera(r);break;default:if(!(a=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(n,r)})))throw Error("Unknown type: "+n)}this.cache.add(i,a)}return a}/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */getDependencies(n){let r=this.cache.get(n);if(!r){let i=this,a=this.json[n+("mesh"===n?"es":"s")]||[];r=Promise.all(a.map(function(r,a){return i.getDependency(n,a)})),this.cache.add(n,r)}return r}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */loadBuffer(n){let r=this.json.buffers[n],i=this.fileLoader;if(r.type&&"arraybuffer"!==r.type)throw Error("THREE.GLTFLoader: "+r.type+" buffer type is not supported.");// If present, GLB container is required to be the first buffer.
if(void 0===r.uri&&0===n)return Promise.resolve(this.extensions[$559434fcc6e6401d$var$EXTENSIONS.KHR_BINARY_GLTF].body);let a=this.options;return new Promise(function(n,s){i.load($d5b33d7c30034067$export$b5d2dc08d867e41a.resolveURL(r.uri,a.path),n,void 0,function(){s(Error('THREE.GLTFLoader: Failed to load buffer "'+r.uri+'".'))})})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */loadBufferView(n){let r=this.json.bufferViews[n];return this.getDependency("buffer",r.buffer).then(function(n){let i=r.byteLength||0,a=r.byteOffset||0;return n.slice(a,a+i)})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */loadAccessor(n){let r=this,i=this.json,a=this.json.accessors[n];if(void 0===a.bufferView&&void 0===a.sparse){let n=$559434fcc6e6401d$var$WEBGL_TYPE_SIZES[a.type],r=$559434fcc6e6401d$var$WEBGL_COMPONENT_TYPES[a.componentType],i=!0===a.normalized,s=new r(a.count*n);return Promise.resolve(new $d5b33d7c30034067$export$8dea267bd6bde117(s,n,i))}let s=[];return void 0!==a.bufferView?s.push(this.getDependency("bufferView",a.bufferView)):s.push(null),void 0!==a.sparse&&(s.push(this.getDependency("bufferView",a.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",a.sparse.values.bufferView))),Promise.all(s).then(function(n){let s,o;let l=n[0],u=$559434fcc6e6401d$var$WEBGL_TYPE_SIZES[a.type],c=$559434fcc6e6401d$var$WEBGL_COMPONENT_TYPES[a.componentType],h=c.BYTES_PER_ELEMENT,d=h*u,p=a.byteOffset||0,f=void 0!==a.bufferView?i.bufferViews[a.bufferView].byteStride:void 0,m=!0===a.normalized;// The buffer is not interleaved if the stride is the item size in bytes.
if(f&&f!==d){// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
// This makes sure that IBA.count reflects accessor.count properly
let n=Math.floor(p/f),i="InterleavedBuffer:"+a.bufferView+":"+a.componentType+":"+n+":"+a.count,d=r.cache.get(i);d||(s=new c(l,n*f,a.count*f/h),// Integer parameters to IB/IBA are in array elements, not bytes.
d=new $d5b33d7c30034067$export$3d5cd879f108f53f(s,f/h),r.cache.add(i,d)),o=new $d5b33d7c30034067$export$920b6d07334599c7(d,u,p%f/h,m)}else s=null===l?new c(a.count*u):new c(l,p,a.count*u),o=new $d5b33d7c30034067$export$8dea267bd6bde117(s,u,m);// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
if(void 0!==a.sparse){let r=$559434fcc6e6401d$var$WEBGL_TYPE_SIZES.SCALAR,i=$559434fcc6e6401d$var$WEBGL_COMPONENT_TYPES[a.sparse.indices.componentType],s=a.sparse.indices.byteOffset||0,h=a.sparse.values.byteOffset||0,d=new i(n[1],s,a.sparse.count*r),p=new c(n[2],h,a.sparse.count*u);null!==l&&(o=new $d5b33d7c30034067$export$8dea267bd6bde117(o.array.slice(),o.itemSize,o.normalized));for(let n=0,r=d.length;n<r;n++){let r=d[n];if(o.setX(r,p[n*u]),u>=2&&o.setY(r,p[n*u+1]),u>=3&&o.setZ(r,p[n*u+2]),u>=4&&o.setW(r,p[n*u+3]),u>=5)throw Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return o})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture|null>}
	 */loadTexture(n){let r=this.json,i=this.options,a=r.textures[n],s=a.source,o=r.images[s],l=this.textureLoader;if(o.uri){let n=i.manager.getHandler(o.uri);null!==n&&(l=n)}return this.loadTextureImage(n,s,l)}loadTextureImage(n,r,i){let a=this,s=this.json,o=s.textures[n],l=s.images[r],u=(l.uri||l.bufferView)+":"+o.sampler;if(this.textureCache[u])return this.textureCache[u];let c=this.loadImageSource(r,i).then(function(r){r.flipY=!1,r.name=o.name||l.name||"",""===r.name&&"string"==typeof l.uri&&!1===l.uri.startsWith("data:image/")&&(r.name=l.uri);let i=s.samplers||{},u=i[o.sampler]||{};return r.magFilter=$559434fcc6e6401d$var$WEBGL_FILTERS[u.magFilter]||$d5b33d7c30034067$export$8a72f490b25c56c8,r.minFilter=$559434fcc6e6401d$var$WEBGL_FILTERS[u.minFilter]||$d5b33d7c30034067$export$5d8599b6a933fb1b,r.wrapS=$559434fcc6e6401d$var$WEBGL_WRAPPINGS[u.wrapS]||$d5b33d7c30034067$export$533346c8e8dac0f5,r.wrapT=$559434fcc6e6401d$var$WEBGL_WRAPPINGS[u.wrapT]||$d5b33d7c30034067$export$533346c8e8dac0f5,a.associations.set(r,{textures:n}),r}).catch(function(){return null});return this.textureCache[u]=c,c}loadImageSource(n,r){let i=this,a=this.json,s=this.options;if(void 0!==this.sourceCache[n])return this.sourceCache[n].then(n=>n.clone());let o=a.images[n],l=self.URL||self.webkitURL,u=o.uri||"",c=!1;if(void 0!==o.bufferView)u=i.getDependency("bufferView",o.bufferView).then(function(n){c=!0;let r=new Blob([n],{type:o.mimeType});return u=l.createObjectURL(r)});else if(void 0===o.uri)throw Error("THREE.GLTFLoader: Image "+n+" is missing URI and bufferView");let h=Promise.resolve(u).then(function(n){return new Promise(function(i,a){let o=i;!0===r.isImageBitmapLoader&&(o=function(n){let r=new $d5b33d7c30034067$export$5431306cf43de24a(n);r.needsUpdate=!0,i(r)}),r.load($d5b33d7c30034067$export$b5d2dc08d867e41a.resolveURL(n,s.path),o,void 0,a)})}).then(function(n){return!0===c&&l.revokeObjectURL(u),n.userData.mimeType=o.mimeType||$559434fcc6e6401d$var$getImageURIMimeType(o.uri),n}).catch(function(n){throw console.error("THREE.GLTFLoader: Couldn't load texture",u),n});return this.sourceCache[n]=h,h}/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */assignTexture(n,r,i,a){let s=this;return this.getDependency("texture",i.index).then(function(o){if(!o)return null;if(void 0!==i.texCoord&&i.texCoord>0&&((o=o.clone()).channel=i.texCoord),s.extensions[$559434fcc6e6401d$var$EXTENSIONS.KHR_TEXTURE_TRANSFORM]){let n=void 0!==i.extensions?i.extensions[$559434fcc6e6401d$var$EXTENSIONS.KHR_TEXTURE_TRANSFORM]:void 0;if(n){let r=s.associations.get(o);o=s.extensions[$559434fcc6e6401d$var$EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(o,n),s.associations.set(o,r)}}return void 0!==a&&(o.colorSpace=a),n[r]=o,o})}/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */assignFinalMaterial(n){let r=n.geometry,i=n.material,a=void 0===r.attributes.tangent,s=void 0!==r.attributes.color,o=void 0===r.attributes.normal;if(n.isPoints){let n="PointsMaterial:"+i.uuid,r=this.cache.get(n);r||(r=new $d5b33d7c30034067$export$a178c45366ce5d6b,$d5b33d7c30034067$export$a2d8b23205c25948.prototype.copy.call(r,i),r.color.copy(i.color),r.map=i.map,r.sizeAttenuation=!1,this.cache.add(n,r)),i=r}else if(n.isLine){let n="LineBasicMaterial:"+i.uuid,r=this.cache.get(n);r||(r=new $d5b33d7c30034067$export$fbaaa33907730a0c,$d5b33d7c30034067$export$a2d8b23205c25948.prototype.copy.call(r,i),r.color.copy(i.color),r.map=i.map,this.cache.add(n,r)),i=r}// Clone the material if it will be modified
if(a||s||o){let n="ClonedMaterial:"+i.uuid+":";a&&(n+="derivative-tangents:"),s&&(n+="vertex-colors:"),o&&(n+="flat-shading:");let r=this.cache.get(n);r||(r=i.clone(),s&&(r.vertexColors=!0),o&&(r.flatShading=!0),a&&(r.normalScale&&(r.normalScale.y*=-1),r.clearcoatNormalScale&&(r.clearcoatNormalScale.y*=-1)),this.cache.add(n,r),this.associations.set(r,this.associations.get(i))),i=r}n.material=i}getMaterialType(){return $d5b33d7c30034067$export$f2980790215acccd}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */loadMaterial(n){let r;let i=this,a=this.json,s=this.extensions,o=a.materials[n],l={},u=o.extensions||{},c=[];if(u[$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_UNLIT]){let n=s[$559434fcc6e6401d$var$EXTENSIONS.KHR_MATERIALS_UNLIT];r=n.getMaterialType(),c.push(n.extendParams(l,o,i))}else{// Specification:
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
let a=o.pbrMetallicRoughness||{};if(l.color=new $d5b33d7c30034067$export$892596cec99bc70e(1,1,1),l.opacity=1,Array.isArray(a.baseColorFactor)){let n=a.baseColorFactor;l.color.setRGB(n[0],n[1],n[2],$d5b33d7c30034067$export$42429b3acfb233a4),l.opacity=n[3]}void 0!==a.baseColorTexture&&c.push(i.assignTexture(l,"map",a.baseColorTexture,$d5b33d7c30034067$export$561f394b24edfcaa)),l.metalness=void 0!==a.metallicFactor?a.metallicFactor:1,l.roughness=void 0!==a.roughnessFactor?a.roughnessFactor:1,void 0!==a.metallicRoughnessTexture&&(c.push(i.assignTexture(l,"metalnessMap",a.metallicRoughnessTexture)),c.push(i.assignTexture(l,"roughnessMap",a.metallicRoughnessTexture))),r=this._invokeOne(function(r){return r.getMaterialType&&r.getMaterialType(n)}),c.push(Promise.all(this._invokeAll(function(r){return r.extendMaterialParams&&r.extendMaterialParams(n,l)})))}!0===o.doubleSided&&(l.side=$d5b33d7c30034067$export$3b296b6f144d5b03);let h=o.alphaMode||$559434fcc6e6401d$var$ALPHA_MODES.OPAQUE;if(h===$559434fcc6e6401d$var$ALPHA_MODES.BLEND?(l.transparent=!0,// See: https://github.com/mrdoob/three.js/issues/17706
l.depthWrite=!1):(l.transparent=!1,h===$559434fcc6e6401d$var$ALPHA_MODES.MASK&&(l.alphaTest=void 0!==o.alphaCutoff?o.alphaCutoff:.5)),void 0!==o.normalTexture&&r!==$d5b33d7c30034067$export$55cbcc9b622fe1f5&&(c.push(i.assignTexture(l,"normalMap",o.normalTexture)),l.normalScale=new $d5b33d7c30034067$export$c977b3e384af9ae1(1,1),void 0!==o.normalTexture.scale)){let n=o.normalTexture.scale;l.normalScale.set(n,n)}if(void 0!==o.occlusionTexture&&r!==$d5b33d7c30034067$export$55cbcc9b622fe1f5&&(c.push(i.assignTexture(l,"aoMap",o.occlusionTexture)),void 0!==o.occlusionTexture.strength&&(l.aoMapIntensity=o.occlusionTexture.strength)),void 0!==o.emissiveFactor&&r!==$d5b33d7c30034067$export$55cbcc9b622fe1f5){let n=o.emissiveFactor;l.emissive=new $d5b33d7c30034067$export$892596cec99bc70e().setRGB(n[0],n[1],n[2],$d5b33d7c30034067$export$42429b3acfb233a4)}return void 0!==o.emissiveTexture&&r!==$d5b33d7c30034067$export$55cbcc9b622fe1f5&&c.push(i.assignTexture(l,"emissiveMap",o.emissiveTexture,$d5b33d7c30034067$export$561f394b24edfcaa)),Promise.all(c).then(function(){let a=new r(l);return o.name&&(a.name=o.name),$559434fcc6e6401d$var$assignExtrasToUserData(a,o),i.associations.set(a,{materials:n}),o.extensions&&$559434fcc6e6401d$var$addUnknownExtensionsToUserData(s,a,o),a})}/** When Object3D instances are targeted by animation, they need unique names. */createUniqueName(n){let r=$d5b33d7c30034067$export$7bf70fcf9f891893.sanitizeNodeName(n||"");return r in this.nodeNamesUsed?r+"_"+ ++this.nodeNamesUsed[r]:(this.nodeNamesUsed[r]=0,r)}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */loadGeometries(n){let r=this,i=this.extensions,a=this.primitiveCache;function s(n){return i[$559434fcc6e6401d$var$EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(n,r).then(function(i){return $559434fcc6e6401d$var$addPrimitiveAttributes(i,n,r)})}let o=[];for(let i=0,l=n.length;i<l;i++){let l=n[i],u=$559434fcc6e6401d$var$createPrimitiveKey(l),c=a[u];if(c)o.push(c.promise);else{let n;n=l.extensions&&l.extensions[$559434fcc6e6401d$var$EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?s(l):$559434fcc6e6401d$var$addPrimitiveAttributes(new $d5b33d7c30034067$export$b7be63a67df8959,l,r),// Cache this geometry
a[u]={primitive:l,promise:n},o.push(n)}}return Promise.all(o)}/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */loadMesh(n){let r=this,i=this.json,a=this.extensions,s=i.meshes[n],o=s.primitives,l=[];for(let n=0,r=o.length;n<r;n++){let r=void 0===o[n].material?$559434fcc6e6401d$var$createDefaultMaterial(this.cache):this.getDependency("material",o[n].material);l.push(r)}return l.push(r.loadGeometries(o)),Promise.all(l).then(function(i){let l=i.slice(0,i.length-1),u=i[i.length-1],c=[];for(let i=0,h=u.length;i<h;i++){let h;let d=u[i],p=o[i],f=l[i];if(p.mode===$559434fcc6e6401d$var$WEBGL_CONSTANTS.TRIANGLES||p.mode===$559434fcc6e6401d$var$WEBGL_CONSTANTS.TRIANGLE_STRIP||p.mode===$559434fcc6e6401d$var$WEBGL_CONSTANTS.TRIANGLE_FAN||void 0===p.mode)!0===// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
(h=!0===s.isSkinnedMesh?new $d5b33d7c30034067$export$b303577035157ecf(d,f):new $d5b33d7c30034067$export$e176487c05830cc5(d,f)).isSkinnedMesh&&h.normalizeSkinWeights(),p.mode===$559434fcc6e6401d$var$WEBGL_CONSTANTS.TRIANGLE_STRIP?h.geometry=$5451ea62abbe5f68$export$5492ca6e5c0c7aa0(h.geometry,$d5b33d7c30034067$export$b23a071aa286eb29):p.mode===$559434fcc6e6401d$var$WEBGL_CONSTANTS.TRIANGLE_FAN&&(h.geometry=$5451ea62abbe5f68$export$5492ca6e5c0c7aa0(h.geometry,$d5b33d7c30034067$export$f0d8293634f88842));else if(p.mode===$559434fcc6e6401d$var$WEBGL_CONSTANTS.LINES)h=new $d5b33d7c30034067$export$ff1ed10fedfdd604(d,f);else if(p.mode===$559434fcc6e6401d$var$WEBGL_CONSTANTS.LINE_STRIP)h=new $d5b33d7c30034067$export$17d680238e50603e(d,f);else if(p.mode===$559434fcc6e6401d$var$WEBGL_CONSTANTS.LINE_LOOP)h=new $d5b33d7c30034067$export$f85a24d745e4f17d(d,f);else if(p.mode===$559434fcc6e6401d$var$WEBGL_CONSTANTS.POINTS)h=new $d5b33d7c30034067$export$1c787534cb11aa3e(d,f);else throw Error("THREE.GLTFLoader: Primitive mode unsupported: "+p.mode);Object.keys(h.geometry.morphAttributes).length>0&&$559434fcc6e6401d$var$updateMorphTargets(h,s),h.name=r.createUniqueName(s.name||"mesh_"+n),$559434fcc6e6401d$var$assignExtrasToUserData(h,s),p.extensions&&$559434fcc6e6401d$var$addUnknownExtensionsToUserData(a,h,p),r.assignFinalMaterial(h),c.push(h)}for(let i=0,a=c.length;i<a;i++)r.associations.set(c[i],{meshes:n,primitives:i});if(1===c.length)return s.extensions&&$559434fcc6e6401d$var$addUnknownExtensionsToUserData(a,c[0],s),c[0];let h=new $d5b33d7c30034067$export$eb2fcfdbd7ba97d4;s.extensions&&$559434fcc6e6401d$var$addUnknownExtensionsToUserData(a,h,s),r.associations.set(h,{meshes:n});for(let n=0,r=c.length;n<r;n++)h.add(c[n]);return h})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */loadCamera(n){let r;let i=this.json.cameras[n],a=i[i.type];if(!a){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return"perspective"===i.type?r=new $d5b33d7c30034067$export$74e4ae24825f68d7($d5b33d7c30034067$export$6a7ef315a0d1ef07.radToDeg(a.yfov),a.aspectRatio||1,a.znear||1,a.zfar||2e6):"orthographic"===i.type&&(r=new $d5b33d7c30034067$export$9ebf355ee4ed261b(-a.xmag,a.xmag,a.ymag,-a.ymag,a.znear,a.zfar)),i.name&&(r.name=this.createUniqueName(i.name)),$559434fcc6e6401d$var$assignExtrasToUserData(r,i),Promise.resolve(r)}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Skeleton>}
	 */loadSkin(n){let r=this.json.skins[n],i=[];for(let n=0,a=r.joints.length;n<a;n++)i.push(this._loadNodeShallow(r.joints[n]));return void 0!==r.inverseBindMatrices?i.push(this.getDependency("accessor",r.inverseBindMatrices)):i.push(null),Promise.all(i).then(function(n){let i=n.pop(),a=n,s=[],o=[];for(let n=0,l=a.length;n<l;n++){let l=a[n];if(l){s.push(l);let r=new $d5b33d7c30034067$export$2ae72fc923e5eb5;null!==i&&r.fromArray(i.array,16*n),o.push(r)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',r.joints[n])}return new $d5b33d7c30034067$export$8f31e4c4a37b8e9c(s,o)})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */loadAnimation(n){let r=this.json,i=this,a=r.animations[n],s=a.name?a.name:"animation_"+n,o=[],l=[],u=[],c=[],h=[];for(let n=0,r=a.channels.length;n<r;n++){let r=a.channels[n],i=a.samplers[r.sampler],s=r.target,d=s.node,p=void 0!==a.parameters?a.parameters[i.input]:i.input,f=void 0!==a.parameters?a.parameters[i.output]:i.output;void 0!==s.node&&(o.push(this.getDependency("node",d)),l.push(this.getDependency("accessor",p)),u.push(this.getDependency("accessor",f)),c.push(i),h.push(s))}return Promise.all([Promise.all(o),Promise.all(l),Promise.all(u),Promise.all(c),Promise.all(h)]).then(function(n){let r=n[0],a=n[1],o=n[2],l=n[3],u=n[4],c=[];for(let n=0,s=r.length;n<s;n++){let s=r[n],h=a[n],d=o[n],p=l[n],f=u[n];if(void 0===s)continue;s.updateMatrix&&s.updateMatrix();let m=i._createAnimationTracks(s,h,d,p,f);if(m)for(let n=0;n<m.length;n++)c.push(m[n])}return new $d5b33d7c30034067$export$d942c706bf23829c(s,void 0,c)})}createNodeMesh(n){let r=this.json,i=this,a=r.nodes[n];return void 0===a.mesh?null:i.getDependency("mesh",a.mesh).then(function(n){let r=i._getNodeRef(i.meshCache,a.mesh,n);return void 0!==a.weights&&r.traverse(function(n){if(n.isMesh)for(let r=0,i=a.weights.length;r<i;r++)n.morphTargetInfluences[r]=a.weights[r]}),r})}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */loadNode(n){let r=this.json,i=this,a=r.nodes[n],s=i._loadNodeShallow(n),o=[],l=a.children||[];for(let n=0,r=l.length;n<r;n++)o.push(i.getDependency("node",l[n]));let u=void 0===a.skin?Promise.resolve(null):i.getDependency("skin",a.skin);return Promise.all([s,Promise.all(o),u]).then(function(n){let r=n[0],i=n[1],a=n[2];null!==a&&// child glTF nodes have not been added to this node yet.
r.traverse(function(n){n.isSkinnedMesh&&n.bind(a,$559434fcc6e6401d$var$_identityMatrix)});for(let n=0,a=i.length;n<a;n++)r.add(i[n]);return r})}// ._loadNodeShallow() parses a single node.
// skin and child nodes are created and added in .loadNode() (no '_' prefix).
_loadNodeShallow(n){let r=this.json,i=this.extensions,a=this;// This method is called from .loadNode() and .loadSkin().
// Cache a node to avoid duplication.
if(void 0!==this.nodeCache[n])return this.nodeCache[n];let s=r.nodes[n],o=s.name?a.createUniqueName(s.name):"",l=[],u=a._invokeOne(function(r){return r.createNodeMesh&&r.createNodeMesh(n)});return u&&l.push(u),void 0!==s.camera&&l.push(a.getDependency("camera",s.camera).then(function(n){return a._getNodeRef(a.cameraCache,s.camera,n)})),a._invokeAll(function(r){return r.createNodeAttachment&&r.createNodeAttachment(n)}).forEach(function(n){l.push(n)}),this.nodeCache[n]=Promise.all(l).then(function(r){let l;if((l=!0===s.isBone?new $d5b33d7c30034067$export$b127726e56765aa4:r.length>1?new $d5b33d7c30034067$export$eb2fcfdbd7ba97d4:1===r.length?r[0]:new $d5b33d7c30034067$export$e4dd07dff30cc924)!==r[0])for(let n=0,i=r.length;n<i;n++)l.add(r[n]);if(s.name&&(l.userData.name=s.name,l.name=o),$559434fcc6e6401d$var$assignExtrasToUserData(l,s),s.extensions&&$559434fcc6e6401d$var$addUnknownExtensionsToUserData(i,l,s),void 0!==s.matrix){let n=new $d5b33d7c30034067$export$2ae72fc923e5eb5;n.fromArray(s.matrix),l.applyMatrix4(n)}else void 0!==s.translation&&l.position.fromArray(s.translation),void 0!==s.rotation&&l.quaternion.fromArray(s.rotation),void 0!==s.scale&&l.scale.fromArray(s.scale);return a.associations.has(l)||a.associations.set(l,{}),a.associations.get(l).nodes=n,l}),this.nodeCache[n]}/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */loadScene(n){let r=this.extensions,i=this.json.scenes[n],a=this,s=new $d5b33d7c30034067$export$eb2fcfdbd7ba97d4;i.name&&(s.name=a.createUniqueName(i.name)),$559434fcc6e6401d$var$assignExtrasToUserData(s,i),i.extensions&&$559434fcc6e6401d$var$addUnknownExtensionsToUserData(r,s,i);let o=i.nodes||[],l=[];for(let n=0,r=o.length;n<r;n++)l.push(a.getDependency("node",o[n]));return Promise.all(l).then(function(n){for(let r=0,i=n.length;r<i;r++)s.add(n[r]);// Removes dangling associations, associations that reference a node that
// didn't make it into the scene.
let r=n=>{let r=new Map;for(let[n,i]of a.associations)(n instanceof $d5b33d7c30034067$export$a2d8b23205c25948||n instanceof $d5b33d7c30034067$export$5431306cf43de24a)&&r.set(n,i);return n.traverse(n=>{let i=a.associations.get(n);null!=i&&r.set(n,i)}),r};return a.associations=r(s),s})}_createAnimationTracks(n,r,i,a,s){let o;let l=[],u=n.name?n.name:n.uuid,c=[];switch($559434fcc6e6401d$var$PATH_PROPERTIES[s.path]===$559434fcc6e6401d$var$PATH_PROPERTIES.weights?n.traverse(function(n){n.morphTargetInfluences&&c.push(n.name?n.name:n.uuid)}):c.push(u),$559434fcc6e6401d$var$PATH_PROPERTIES[s.path]){case $559434fcc6e6401d$var$PATH_PROPERTIES.weights:o=$d5b33d7c30034067$export$d45f0d1a4d9a9314;break;case $559434fcc6e6401d$var$PATH_PROPERTIES.rotation:o=$d5b33d7c30034067$export$b8043f12b5aafbd7;break;case $559434fcc6e6401d$var$PATH_PROPERTIES.position:case $559434fcc6e6401d$var$PATH_PROPERTIES.scale:o=$d5b33d7c30034067$export$5ce2dcb4cc9f2bff;break;default:o=1===i.itemSize?$d5b33d7c30034067$export$d45f0d1a4d9a9314:$d5b33d7c30034067$export$5ce2dcb4cc9f2bff}let h=void 0!==a.interpolation?$559434fcc6e6401d$var$INTERPOLATION[a.interpolation]:$d5b33d7c30034067$export$30fac1aace31cf4d,d=this._getArrayFromAccessor(i);for(let n=0,i=c.length;n<i;n++){let i=new o(c[n]+"."+$559434fcc6e6401d$var$PATH_PROPERTIES[s.path],r.array,d,h);"CUBICSPLINE"===a.interpolation&&this._createCubicSplineTrackInterpolant(i),l.push(i)}return l}_getArrayFromAccessor(n){let r=n.array;if(n.normalized){let n=$559434fcc6e6401d$var$getNormalizedComponentScale(r.constructor),i=new Float32Array(r.length);for(let a=0,s=r.length;a<s;a++)i[a]=r[a]*n;r=i}return r}_createCubicSplineTrackInterpolant(n){n.createInterpolant=function(n){// A CUBICSPLINE keyframe in glTF has three output values for each input value,
// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
// must be divided by three to get the interpolant's sampleSize argument.
let r=this instanceof $d5b33d7c30034067$export$b8043f12b5aafbd7?$559434fcc6e6401d$var$GLTFCubicSplineQuaternionInterpolant:$559434fcc6e6401d$var$GLTFCubicSplineInterpolant;return new r(this.times,this.values,this.getValueSize()/3,n)},// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */function $559434fcc6e6401d$var$computeBounds(n,r,i){let a=r.attributes,s=new $d5b33d7c30034067$export$6f7d5a9418ab2aa3;if(void 0===a.POSITION)return;{let n=i.json.accessors[a.POSITION],r=n.min,o=n.max;// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.
if(void 0!==r&&void 0!==o){if(s.set(new $d5b33d7c30034067$export$64b5c384219d3699(r[0],r[1],r[2]),new $d5b33d7c30034067$export$64b5c384219d3699(o[0],o[1],o[2])),n.normalized){let r=$559434fcc6e6401d$var$getNormalizedComponentScale($559434fcc6e6401d$var$WEBGL_COMPONENT_TYPES[n.componentType]);s.min.multiplyScalar(r),s.max.multiplyScalar(r)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}let o=r.targets;if(void 0!==o){let n=new $d5b33d7c30034067$export$64b5c384219d3699,r=new $d5b33d7c30034067$export$64b5c384219d3699;for(let a=0,s=o.length;a<s;a++){let s=o[a];if(void 0!==s.POSITION){let a=i.json.accessors[s.POSITION],o=a.min,l=a.max;// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.
if(void 0!==o&&void 0!==l){if(// we need to get max of absolute components because target weight is [-1,1]
r.setX(Math.max(Math.abs(o[0]),Math.abs(l[0]))),r.setY(Math.max(Math.abs(o[1]),Math.abs(l[1]))),r.setZ(Math.max(Math.abs(o[2]),Math.abs(l[2]))),a.normalized){let n=$559434fcc6e6401d$var$getNormalizedComponentScale($559434fcc6e6401d$var$WEBGL_COMPONENT_TYPES[a.componentType]);r.multiplyScalar(n)}// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
// are used to implement key-frame animations and as such only two are active at a time - this results in very large
// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
n.max(r)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
s.expandByVector(n)}n.boundingBox=s;let l=new $d5b33d7c30034067$export$805e8b72413ccaba;s.getCenter(l.center),l.radius=s.min.distanceTo(s.max)/2,n.boundingSphere=l}/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */function $559434fcc6e6401d$var$addPrimitiveAttributes(n,r,i){let a=r.attributes,s=[];function o(r,a){return i.getDependency("accessor",r).then(function(r){n.setAttribute(a,r)})}for(let r in a){let i=$559434fcc6e6401d$var$ATTRIBUTES[r]||r.toLowerCase();// Skip attributes already provided by e.g. Draco extension.
i in n.attributes||s.push(o(a[r],i))}if(void 0!==r.indices&&!n.index){let a=i.getDependency("accessor",r.indices).then(function(r){n.setIndex(r)});s.push(a)}return $d5b33d7c30034067$export$5e6fd513f44698c.workingColorSpace!==$d5b33d7c30034067$export$42429b3acfb233a4&&"COLOR_0"in a&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${$d5b33d7c30034067$export$5e6fd513f44698c.workingColorSpace}" not supported.`),$559434fcc6e6401d$var$assignExtrasToUserData(n,r),$559434fcc6e6401d$var$computeBounds(n,r,i),Promise.all(s).then(function(){return void 0!==r.targets?$559434fcc6e6401d$var$addMorphTargets(n,r.targets,i):n})}/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
// https://tools.ietf.org/html/rfc1951
// You may also wish to take a look at the guide I made about this program:
// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
// Some of the following code is similar to that of UZIP.js:
// https://github.com/photopea/UZIP.js
// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
// is better for memory in most engines (I *think*).
var $53691bda533d12d0$var$ch2={},$53691bda533d12d0$var$durl=function(n){return URL.createObjectURL(new Blob([n],{type:"text/javascript"}))},$53691bda533d12d0$var$cwk=function(n){return new Worker(n)};try{URL.revokeObjectURL($53691bda533d12d0$var$durl(""))}catch(e){// We're in Deno or a very old browser
$53691bda533d12d0$var$durl=function(n){return"data:application/javascript;charset=UTF-8,"+encodeURI(n)},// If Deno, this is necessary; if not, this changes nothing
$53691bda533d12d0$var$cwk=function(n){return new Worker(n,{type:"module"})}}var $53691bda533d12d0$var$wk=function(n,r,i,a,s){var o=$53691bda533d12d0$var$cwk($53691bda533d12d0$var$ch2[r]||($53691bda533d12d0$var$ch2[r]=$53691bda533d12d0$var$durl(n)));return o.onerror=function(n){return s(n.error,null)},o.onmessage=function(n){return s(null,n.data)},o.postMessage(i,a),o},$53691bda533d12d0$var$u8=Uint8Array,$53691bda533d12d0$var$u16=Uint16Array,$53691bda533d12d0$var$u32=Uint32Array,$53691bda533d12d0$var$fleb=new $53691bda533d12d0$var$u8([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,/* unused */0,0,/* impossible */0]),$53691bda533d12d0$var$fdeb=new $53691bda533d12d0$var$u8([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,/* unused */0,0]),$53691bda533d12d0$var$clim=new $53691bda533d12d0$var$u8([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),$53691bda533d12d0$var$freb=function(n,r){for(var i=new $53691bda533d12d0$var$u16(31),a=0;a<31;++a)i[a]=r+=1<<n[a-1];for(var s=new $53691bda533d12d0$var$u32(i[30]),a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return[i,s]},$53691bda533d12d0$var$_a=$53691bda533d12d0$var$freb($53691bda533d12d0$var$fleb,2),$53691bda533d12d0$var$fl=$53691bda533d12d0$var$_a[0],$53691bda533d12d0$var$revfl=$53691bda533d12d0$var$_a[1];// we can ignore the fact that the other numbers are wrong; they never happen anyway
$53691bda533d12d0$var$fl[28]=258,$53691bda533d12d0$var$revfl[258]=28;for(var $53691bda533d12d0$var$_b=$53691bda533d12d0$var$freb($53691bda533d12d0$var$fdeb,0),$53691bda533d12d0$var$fd=$53691bda533d12d0$var$_b[0],$53691bda533d12d0$var$revfd=$53691bda533d12d0$var$_b[1],$53691bda533d12d0$var$rev=new $53691bda533d12d0$var$u16(32768),$53691bda533d12d0$var$i=0;$53691bda533d12d0$var$i<32768;++$53691bda533d12d0$var$i){// reverse table algorithm from SO
var $53691bda533d12d0$var$x=(43690&$53691bda533d12d0$var$i)>>>1|(21845&$53691bda533d12d0$var$i)<<1;$53691bda533d12d0$var$x=(61680&($53691bda533d12d0$var$x=(52428&$53691bda533d12d0$var$x)>>>2|(13107&$53691bda533d12d0$var$x)<<2))>>>4|(3855&$53691bda533d12d0$var$x)<<4,$53691bda533d12d0$var$rev[$53691bda533d12d0$var$i]=((65280&$53691bda533d12d0$var$x)>>>8|(255&$53691bda533d12d0$var$x)<<8)>>>1}for(var $53691bda533d12d0$var$hMap=function(n,r,i){// length of cd must be 288 (total # of codes)
for(var a,s=n.length,o=0,l=new $53691bda533d12d0$var$u16(r);o<s;++o)++l[n[o]-1];// u16 "map": index -> minimum code for bit length = index
var u=new $53691bda533d12d0$var$u16(r);for(o=0;o<r;++o)u[o]=u[o-1]+l[o-1]<<1;if(i){// u16 "map": index -> number of actual bits, symbol for code
a=new $53691bda533d12d0$var$u16(1<<r);// bits to remove for reverser
var c=15-r;for(o=0;o<s;++o)if(n[o])// m is end value
for(var h=o<<4|n[o],d=r-n[o],p=u[n[o]-1]++<<d,f=p|(1<<d)-1;p<=f;++p)a[$53691bda533d12d0$var$rev[p]>>>c]=h}else for(o=0,a=new $53691bda533d12d0$var$u16(s);o<s;++o)n[o]&&(a[o]=$53691bda533d12d0$var$rev[u[n[o]-1]++]>>>15-n[o]);return a},$53691bda533d12d0$var$flt=new $53691bda533d12d0$var$u8(288),$53691bda533d12d0$var$i=0;$53691bda533d12d0$var$i<144;++$53691bda533d12d0$var$i)$53691bda533d12d0$var$flt[$53691bda533d12d0$var$i]=8;for(var $53691bda533d12d0$var$i=144;$53691bda533d12d0$var$i<256;++$53691bda533d12d0$var$i)$53691bda533d12d0$var$flt[$53691bda533d12d0$var$i]=9;for(var $53691bda533d12d0$var$i=256;$53691bda533d12d0$var$i<280;++$53691bda533d12d0$var$i)$53691bda533d12d0$var$flt[$53691bda533d12d0$var$i]=7;for(var $53691bda533d12d0$var$i=280;$53691bda533d12d0$var$i<288;++$53691bda533d12d0$var$i)$53691bda533d12d0$var$flt[$53691bda533d12d0$var$i]=8;for(var $53691bda533d12d0$var$fdt=new $53691bda533d12d0$var$u8(32),$53691bda533d12d0$var$i=0;$53691bda533d12d0$var$i<32;++$53691bda533d12d0$var$i)$53691bda533d12d0$var$fdt[$53691bda533d12d0$var$i]=5;var $53691bda533d12d0$var$flm=/*#__PURE__*/$53691bda533d12d0$var$hMap($53691bda533d12d0$var$flt,9,0),$53691bda533d12d0$var$flrm=/*#__PURE__*/$53691bda533d12d0$var$hMap($53691bda533d12d0$var$flt,9,1),$53691bda533d12d0$var$fdm=/*#__PURE__*/$53691bda533d12d0$var$hMap($53691bda533d12d0$var$fdt,5,0),$53691bda533d12d0$var$fdrm=/*#__PURE__*/$53691bda533d12d0$var$hMap($53691bda533d12d0$var$fdt,5,1),$53691bda533d12d0$var$max=function(n){for(var r=n[0],i=1;i<n.length;++i)n[i]>r&&(r=n[i]);return r},$53691bda533d12d0$var$bits=function(n,r,i){var a=r/8|0;return(n[a]|n[a+1]<<8)>>(7&r)&i},$53691bda533d12d0$var$bits16=function(n,r){var i=r/8|0;return(n[i]|n[i+1]<<8|n[i+2]<<16)>>(7&r)},$53691bda533d12d0$var$shft=function(n){return(n/8|0)+(7&n&&1)},$53691bda533d12d0$var$slc=function(n,r,i){(null==r||r<0)&&(r=0),(null==i||i>n.length)&&(i=n.length);// can't use .constructor in case user-supplied
var a=new(n instanceof $53691bda533d12d0$var$u16?$53691bda533d12d0$var$u16:n instanceof $53691bda533d12d0$var$u32?$53691bda533d12d0$var$u32:$53691bda533d12d0$var$u8)(i-r);return a.set(n.subarray(r,i)),a},$53691bda533d12d0$var$inflt=function(n,r,i){// source length
var a=n.length;if(!a||i&&!i.l&&a<5)return r||new $53691bda533d12d0$var$u8(0);// have to estimate size
var s=!r||i,o=!i||i.i;i||(i={}),r||(r=new $53691bda533d12d0$var$u8(3*a));// ensure buffer can fit at least l elements
var l=function(n){var i=r.length;// need to increase size to fit
if(n>i){// Double or set to necessary, whichever is greater
var a=new $53691bda533d12d0$var$u8(Math.max(2*i,n));a.set(r),r=a}},u=i.f||0,c=i.p||0,h=i.b||0,d=i.l,p=i.d,f=i.m,m=i.n,g=8*a;do{if(!d){// BFINAL - this is only 1 when last chunk is next
i.f=u=$53691bda533d12d0$var$bits(n,c,1);// type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
var _=$53691bda533d12d0$var$bits(n,c+1,3);if(c+=3,_){if(1==_)d=$53691bda533d12d0$var$flrm,p=$53691bda533d12d0$var$fdrm,f=9,m=5;else if(2==_){//  literal                            lengths
var y=$53691bda533d12d0$var$bits(n,c,31)+257,b=$53691bda533d12d0$var$bits(n,c+10,15)+4,v=y+$53691bda533d12d0$var$bits(n,c+5,31)+1;c+=14;for(var x=new $53691bda533d12d0$var$u8(v),w=new $53691bda533d12d0$var$u8(19),T=0;T<b;++T)w[$53691bda533d12d0$var$clim[T]]=$53691bda533d12d0$var$bits(n,c+3*T,7);c+=3*b;for(var S=$53691bda533d12d0$var$max(w),E=(1<<S)-1,A=$53691bda533d12d0$var$hMap(w,S,1),T=0;T<v;){var M=A[$53691bda533d12d0$var$bits(n,c,E)];// bits read
c+=15&M;// symbol
var I=M>>>4;// code length to copy
if(I<16)x[T++]=I;else{//  copy   count
var P=0,O=0;for(16==I?(O=3+$53691bda533d12d0$var$bits(n,c,3),c+=2,P=x[T-1]):17==I?(O=3+$53691bda533d12d0$var$bits(n,c,7),c+=3):18==I&&(O=11+$53691bda533d12d0$var$bits(n,c,127),c+=7);O--;)x[T++]=P}}// code lengths bits
var R=x.subarray(0,y),C=x.subarray(y);// max length bits
f=$53691bda533d12d0$var$max(R),// max dist bits
m=$53691bda533d12d0$var$max(C),d=$53691bda533d12d0$var$hMap(R,f,1),p=$53691bda533d12d0$var$hMap(C,m,1)}else throw"invalid block type"}else{// go to end of byte boundary
var I=$53691bda533d12d0$var$shft(c)+4,L=n[I-4]|n[I-3]<<8,D=I+L;if(D>a){if(o)throw"unexpected EOF";break}s&&l(h+L),// Copy over uncompressed data
r.set(n.subarray(I,D),h),// Get new bitpos, update byte count
i.b=h+=L,i.p=c=8*D;continue}if(c>g){if(o)throw"unexpected EOF";break}}s&&l(h+131072);for(var N=(1<<f)-1,k=(1<<m)-1,U=c;;U=c){// bits read, code
var P=d[$53691bda533d12d0$var$bits16(n,c)&N],F=P>>>4;if((c+=15&P)>g){if(o)throw"unexpected EOF";break}if(!P)throw"invalid length/literal";if(F<256)r[h++]=F;else if(256==F){U=c,d=null;break}else{var B=F-254;// no extra bits needed if less
if(F>264){// index
var T=F-257,z=$53691bda533d12d0$var$fleb[T];B=$53691bda533d12d0$var$bits(n,c,(1<<z)-1)+$53691bda533d12d0$var$fl[T],c+=z}// dist
var V=p[$53691bda533d12d0$var$bits16(n,c)&k],G=V>>>4;if(!V)throw"invalid distance";c+=15&V;var C=$53691bda533d12d0$var$fd[G];if(G>3){var z=$53691bda533d12d0$var$fdeb[G];C+=$53691bda533d12d0$var$bits16(n,c)&(1<<z)-1,c+=z}if(c>g){if(o)throw"unexpected EOF";break}s&&l(h+131072);for(var j=h+B;h<j;h+=4)r[h]=r[h-C],r[h+1]=r[h+1-C],r[h+2]=r[h+2-C],r[h+3]=r[h+3-C];h=j}}i.l=d,i.p=U,i.b=h,d&&(u=1,i.m=f,i.d=p,i.n=m)}while(!u)return h==r.length?r:$53691bda533d12d0$var$slc(r,0,h)},$53691bda533d12d0$var$wbits=function(n,r,i){i<<=7&r;var a=r/8|0;n[a]|=i,n[a+1]|=i>>>8},$53691bda533d12d0$var$wbits16=function(n,r,i){i<<=7&r;var a=r/8|0;n[a]|=i,n[a+1]|=i>>>8,n[a+2]|=i>>>16},$53691bda533d12d0$var$hTree=function(n,r){for(var i=[],a=0;a<n.length;++a)n[a]&&i.push({s:a,f:n[a]});// Need extra info to make a tree
var s=i.length,o=i.slice();if(!s)return[$53691bda533d12d0$var$et,0];if(1==s){var l=new $53691bda533d12d0$var$u8(i[0].s+1);return l[i[0].s]=1,[l,1]}i.sort(function(n,r){return n.f-r.f}),// after i2 reaches last ind, will be stopped
// freq must be greater than largest possible number of symbols
i.push({s:-1,f:25001});var u=i[0],c=i[1],h=0,d=1,p=2;// efficient algorithm from UZIP.js
// i0 is lookbehind, i2 is lookahead - after processing two low-freq
// symbols that combined have high freq, will start processing i2 (high-freq,
// non-composite) symbols instead
// see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
for(i[0]={s:-1,f:u.f+c.f,l:u,r:c};d!=s-1;)u=i[i[h].f<i[p].f?h++:p++],c=i[h!=d&&i[h].f<i[p].f?h++:p++],i[d++]={s:-1,f:u.f+c.f,l:u,r:c};for(var f=o[0].s,a=1;a<s;++a)o[a].s>f&&(f=o[a].s);var m=new $53691bda533d12d0$var$u16(f+1),g=$53691bda533d12d0$var$ln(i[d-1],m,0);if(g>r){// more algorithms from UZIP.js
// TODO: find out how this code works (debt)
//  ind    debt
var a=0,_=0,y=g-r,b=1<<y;for(o.sort(function(n,r){return m[r.s]-m[n.s]||n.f-r.f});a<s;++a){var v=o[a].s;if(m[v]>r)_+=b-(1<<g-m[v]),m[v]=r;else break}for(_>>>=y;_>0;){var x=o[a].s;m[x]<r?_-=1<<r-m[x]++-1:++a}for(;a>=0&&_;--a){var w=o[a].s;m[w]==r&&(--m[w],++_)}g=r}return[new $53691bda533d12d0$var$u8(m),g]},$53691bda533d12d0$var$ln=function(n,r,i){return -1==n.s?Math.max($53691bda533d12d0$var$ln(n.l,r,i+1),$53691bda533d12d0$var$ln(n.r,r,i+1)):r[n.s]=i},$53691bda533d12d0$var$lc=function(n){// Note that the semicolon was intentional
for(var r=n.length;r&&!n[--r];);for(var i=new $53691bda533d12d0$var$u16(++r),a=0,s=n[0],o=1,l=function(n){i[a++]=n},u=1;u<=r;++u)if(n[u]==s&&u!=r)++o;else{if(!s&&o>2){for(;o>138;o-=138)l(32754);o>2&&(l(o>10?o-11<<5|28690:o-3<<5|12305),o=0)}else if(o>3){for(l(s),--o;o>6;o-=6)l(8304);o>2&&(l(o-3<<5|8208),o=0)}for(;o--;)l(s);o=1,s=n[u]}return[i.subarray(0,a),r]},$53691bda533d12d0$var$clen=function(n,r){for(var i=0,a=0;a<r.length;++a)i+=n[a]*r[a];return i},$53691bda533d12d0$var$wfblk=function(n,r,i){// no need to write 00 as type: TypedArray defaults to 0
var a=i.length,s=$53691bda533d12d0$var$shft(r+2);n[s]=255&a,n[s+1]=a>>>8,n[s+2]=255^n[s],n[s+3]=255^n[s+1];for(var o=0;o<a;++o)n[s+o+4]=i[o];return(s+4+a)*8},$53691bda533d12d0$var$wblk=function(n,r,i,a,s,o,l,u,c,h,d){$53691bda533d12d0$var$wbits(r,d++,i),++s[256];for(var p,f,m,g,_=$53691bda533d12d0$var$hTree(s,15),y=_[0],b=_[1],v=$53691bda533d12d0$var$hTree(o,15),x=v[0],w=v[1],T=$53691bda533d12d0$var$lc(y),S=T[0],E=T[1],A=$53691bda533d12d0$var$lc(x),M=A[0],I=A[1],P=new $53691bda533d12d0$var$u16(19),O=0;O<S.length;++O)P[31&S[O]]++;for(var O=0;O<M.length;++O)P[31&M[O]]++;for(var R=$53691bda533d12d0$var$hTree(P,7),C=R[0],L=R[1],D=19;D>4&&!C[$53691bda533d12d0$var$clim[D-1]];--D);var N=h+5<<3,k=$53691bda533d12d0$var$clen(s,$53691bda533d12d0$var$flt)+$53691bda533d12d0$var$clen(o,$53691bda533d12d0$var$fdt)+l,U=$53691bda533d12d0$var$clen(s,y)+$53691bda533d12d0$var$clen(o,x)+l+14+3*D+$53691bda533d12d0$var$clen(P,C)+(2*P[16]+3*P[17]+7*P[18]);if(N<=k&&N<=U)return $53691bda533d12d0$var$wfblk(r,d,n.subarray(c,c+h));if($53691bda533d12d0$var$wbits(r,d,1+(U<k)),d+=2,U<k){p=$53691bda533d12d0$var$hMap(y,b,0),f=y,m=$53691bda533d12d0$var$hMap(x,w,0),g=x;var F=$53691bda533d12d0$var$hMap(C,L,0);$53691bda533d12d0$var$wbits(r,d,E-257),$53691bda533d12d0$var$wbits(r,d+5,I-1),$53691bda533d12d0$var$wbits(r,d+10,D-4),d+=14;for(var O=0;O<D;++O)$53691bda533d12d0$var$wbits(r,d+3*O,C[$53691bda533d12d0$var$clim[O]]);d+=3*D;for(var B=[S,M],z=0;z<2;++z)for(var V=B[z],O=0;O<V.length;++O){var G=31&V[O];$53691bda533d12d0$var$wbits(r,d,F[G]),d+=C[G],G>15&&($53691bda533d12d0$var$wbits(r,d,V[O]>>>5&127),d+=V[O]>>>12)}}else p=$53691bda533d12d0$var$flm,f=$53691bda533d12d0$var$flt,m=$53691bda533d12d0$var$fdm,g=$53691bda533d12d0$var$fdt;for(var O=0;O<u;++O)if(a[O]>255){var G=a[O]>>>18&31;$53691bda533d12d0$var$wbits16(r,d,p[G+257]),d+=f[G+257],G>7&&($53691bda533d12d0$var$wbits(r,d,a[O]>>>23&31),d+=$53691bda533d12d0$var$fleb[G]);var j=31&a[O];$53691bda533d12d0$var$wbits16(r,d,m[j]),d+=g[j],j>3&&($53691bda533d12d0$var$wbits16(r,d,a[O]>>>5&8191),d+=$53691bda533d12d0$var$fdeb[j])}else $53691bda533d12d0$var$wbits16(r,d,p[a[O]]),d+=f[a[O]];return $53691bda533d12d0$var$wbits16(r,d,p[256]),d+f[256]},$53691bda533d12d0$var$deo=/*#__PURE__*/new $53691bda533d12d0$var$u32([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),$53691bda533d12d0$var$et=/*#__PURE__*/new $53691bda533d12d0$var$u8(0),$53691bda533d12d0$var$dflt=function(n,r,i,a,s,o){var l=n.length,u=new $53691bda533d12d0$var$u8(a+l+5*(1+Math.ceil(l/7e3))+s),c=u.subarray(a,u.length-s),h=0;if(!r||l<8)for(var d=0;d<=l;d+=65535){// end
var p=d+65535;p<l?h=$53691bda533d12d0$var$wfblk(c,h,n.subarray(d,p)):(// write final block
c[d]=o,h=$53691bda533d12d0$var$wfblk(c,h,n.subarray(d,l)))}else{for(var f=$53691bda533d12d0$var$deo[r-1],m=f>>>13,g=8191&f,_=(1<<i)-1,y=new $53691bda533d12d0$var$u16(32768),b=new $53691bda533d12d0$var$u16(_+1),v=Math.ceil(i/3),x=2*v,w=function(r){return(n[r]^n[r+1]<<v^n[r+2]<<x)&_},T=new $53691bda533d12d0$var$u32(25e3),S=new $53691bda533d12d0$var$u16(288),E=new $53691bda533d12d0$var$u16(32),A=0,M=0,d=0,I=0,P=0,O=0;d<l;++d){// hash value
// deopt when i > s - 3 - at end, deopt acceptable
var R=w(d),C=32767&d,L=b[R];// We always should modify head and prev, but only add symbols if
// this data is not yet processed ("wait" for wait index)
if(y[C]=L,b[R]=C,P<=d){// bytes remaining
var D=l-d;if((A>7e3||I>24576)&&D>423){h=$53691bda533d12d0$var$wblk(n,c,0,T,S,E,M,I,O,d-O,h),I=A=M=0,O=d;for(var N=0;N<286;++N)S[N]=0;for(var N=0;N<30;++N)E[N]=0}//  len    dist   chain
var k=2,U=0,F=g,B=C-L&32767;if(D>2&&R==w(d-B))for(var z=Math.min(m,D)-1,V=Math.min(32767,d),G=Math.min(258,D);B<=V&&--F&&C!=L;){if(n[d+k]==n[d+k-B]){for(var j=0;j<G&&n[d+j]==n[d+j-B];++j);if(j>k){// break out early when we reach "nice" (we are satisfied enough)
if(k=j,U=B,j>z)break;for(var H=Math.min(B,j-2),$=0,N=0;N<H;++N){var W=d-B+N+32768&32767,X=y[W],q=W-X+32768&32767;q>$&&($=q,L=W)}}}L=y[// check the previous match
C=L],B+=C-L+32768&32767}// d will be nonzero only when a match was found
if(U){// store both dist and len data in one Uint32
// Make sure this is recognized as a len/dist with 28th bit (2^28)
T[I++]=268435456|$53691bda533d12d0$var$revfl[k]<<18|$53691bda533d12d0$var$revfd[U];var Y=31&$53691bda533d12d0$var$revfl[k],K=31&$53691bda533d12d0$var$revfd[U];M+=$53691bda533d12d0$var$fleb[Y]+$53691bda533d12d0$var$fdeb[K],++S[257+Y],++E[K],P=d+k,++A}else T[I++]=n[d],++S[n[d]]}}h=$53691bda533d12d0$var$wblk(n,c,o,T,S,E,M,I,O,d-O,h),!o&&7&h&&(h=$53691bda533d12d0$var$wfblk(c,h+1,$53691bda533d12d0$var$et))}return $53691bda533d12d0$var$slc(u,0,a+$53691bda533d12d0$var$shft(h)+s)},$53691bda533d12d0$var$crct=/*#__PURE__*/function(){for(var n=new $53691bda533d12d0$var$u32(256),r=0;r<256;++r){for(var i=r,a=9;--a;)i=(1&i&&3988292384)^i>>>1;n[r]=i}return n}(),$53691bda533d12d0$var$crc=function(){var n=-1;return{p:function(r){for(var i=n,a=0;a<r.length;++a)i=$53691bda533d12d0$var$crct[255&i^r[a]]^i>>>8;n=i},d:function(){return~n}}},$53691bda533d12d0$var$adler=function(){var n=1,r=0;return{p:function(i){for(var a=n,s=r,o=i.length,l=0;l!=o;){for(var u=Math.min(l+2655,o);l<u;++l)s+=a+=i[l];a=(65535&a)+15*(a>>16),s=(65535&s)+15*(s>>16)}n=a,r=s},d:function(){return n%=65521,r%=65521,(255&n)<<24|n>>>8<<16|(255&r)<<8|r>>>8}}},$53691bda533d12d0$var$dopt=function(n,r,i,a,s){return $53691bda533d12d0$var$dflt(n,null==r.level?6:r.level,null==r.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(n.length)))):12+r.mem,i,a,!s)},$53691bda533d12d0$var$mrg=function(n,r){var i={};for(var a in n)i[a]=n[a];for(var a in r)i[a]=r[a];return i},$53691bda533d12d0$var$wcln=function(n,r,i){for(var a=n(),s=n.toString(),o=s.slice(s.indexOf("[")+1,s.lastIndexOf("]")).replace(/ /g,"").split(","),l=0;l<a.length;++l){var u=a[l],c=o[l];if("function"==typeof u){r+=";"+c+"=";var h=u.toString();if(u.prototype){// for global objects
if(-1!=h.indexOf("[native code]")){var d=h.indexOf(" ",8)+1;r+=h.slice(d,h.indexOf("(",d))}else for(var p in r+=h,u.prototype)r+=";"+c+".prototype."+p+"="+u.prototype[p].toString()}else r+=h}else i[c]=u}return[r,i]},$53691bda533d12d0$var$ch=[],$53691bda533d12d0$var$cbfs=function(n){var r=[];for(var i in n)(n[i]instanceof $53691bda533d12d0$var$u8||n[i]instanceof $53691bda533d12d0$var$u16||n[i]instanceof $53691bda533d12d0$var$u32)&&r.push((n[i]=new n[i].constructor(n[i])).buffer);return r},$53691bda533d12d0$var$wrkr=function(n,r,i,a){if(!$53691bda533d12d0$var$ch[i]){for(var s,o="",l={},u=n.length-1,c=0;c<u;++c)o=(s=$53691bda533d12d0$var$wcln(n[c],o,l))[0],l=s[1];$53691bda533d12d0$var$ch[i]=$53691bda533d12d0$var$wcln(n[u],o,l)}var h=$53691bda533d12d0$var$mrg({},$53691bda533d12d0$var$ch[i][1]);return $53691bda533d12d0$var$wk($53691bda533d12d0$var$ch[i][0]+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+r.toString()+"}",i,h,$53691bda533d12d0$var$cbfs(h),a)},$53691bda533d12d0$var$bInflt=function(){return[$53691bda533d12d0$var$u8,$53691bda533d12d0$var$u16,$53691bda533d12d0$var$u32,$53691bda533d12d0$var$fleb,$53691bda533d12d0$var$fdeb,$53691bda533d12d0$var$clim,$53691bda533d12d0$var$fl,$53691bda533d12d0$var$fd,$53691bda533d12d0$var$flrm,$53691bda533d12d0$var$fdrm,$53691bda533d12d0$var$rev,$53691bda533d12d0$var$hMap,$53691bda533d12d0$var$max,$53691bda533d12d0$var$bits,$53691bda533d12d0$var$bits16,$53691bda533d12d0$var$shft,$53691bda533d12d0$var$slc,$53691bda533d12d0$var$inflt,$53691bda533d12d0$export$90366d8b308ba94a,$53691bda533d12d0$var$pbf,$53691bda533d12d0$var$gu8]},$53691bda533d12d0$var$bDflt=function(){return[$53691bda533d12d0$var$u8,$53691bda533d12d0$var$u16,$53691bda533d12d0$var$u32,$53691bda533d12d0$var$fleb,$53691bda533d12d0$var$fdeb,$53691bda533d12d0$var$clim,$53691bda533d12d0$var$revfl,$53691bda533d12d0$var$revfd,$53691bda533d12d0$var$flm,$53691bda533d12d0$var$flt,$53691bda533d12d0$var$fdm,$53691bda533d12d0$var$fdt,$53691bda533d12d0$var$rev,$53691bda533d12d0$var$deo,$53691bda533d12d0$var$et,$53691bda533d12d0$var$hMap,$53691bda533d12d0$var$wbits,$53691bda533d12d0$var$wbits16,$53691bda533d12d0$var$hTree,$53691bda533d12d0$var$ln,$53691bda533d12d0$var$lc,$53691bda533d12d0$var$clen,$53691bda533d12d0$var$wfblk,$53691bda533d12d0$var$wblk,$53691bda533d12d0$var$shft,$53691bda533d12d0$var$slc,$53691bda533d12d0$var$dflt,$53691bda533d12d0$var$dopt,$53691bda533d12d0$export$21533ff51b8a0b4a,$53691bda533d12d0$var$pbf]},$53691bda533d12d0$var$gze=function(){return[$53691bda533d12d0$var$gzh,$53691bda533d12d0$var$gzhl,$53691bda533d12d0$var$wbytes,$53691bda533d12d0$var$crc,$53691bda533d12d0$var$crct]},$53691bda533d12d0$var$guze=function(){return[$53691bda533d12d0$var$gzs,$53691bda533d12d0$var$gzl]},$53691bda533d12d0$var$zle=function(){return[$53691bda533d12d0$var$zlh,$53691bda533d12d0$var$wbytes,$53691bda533d12d0$var$adler]},$53691bda533d12d0$var$zule=function(){return[$53691bda533d12d0$var$zlv]},$53691bda533d12d0$var$pbf=function(n){return postMessage(n,[n.buffer])},$53691bda533d12d0$var$gu8=function(n){return n&&n.size&&new $53691bda533d12d0$var$u8(n.size)},$53691bda533d12d0$var$astrm=function(n){return n.ondata=function(n,r){return postMessage([n,r],[n.buffer])},function(r){return n.push(r.data[0],r.data[1])}},$53691bda533d12d0$var$astrmify=function(n,r,i,a,s){var o,l=$53691bda533d12d0$var$wrkr(n,a,s,function(n,i){n?(l.terminate(),r.ondata.call(r,n)):(i[1]&&l.terminate(),r.ondata.call(r,n,i[0],i[1]))});l.postMessage(i),r.push=function(n,i){if(o)throw"stream finished";if(!r.ondata)throw"no stream handler";l.postMessage([n,o=i],[n.buffer])},r.terminate=function(){l.terminate()}},$53691bda533d12d0$var$b2=function(n,r){return n[r]|n[r+1]<<8},$53691bda533d12d0$var$b4=function(n,r){return(n[r]|n[r+1]<<8|n[r+2]<<16|n[r+3]<<24)>>>0},$53691bda533d12d0$var$b8=function(n,r){return $53691bda533d12d0$var$b4(n,r)+4294967296*$53691bda533d12d0$var$b4(n,r+4)},$53691bda533d12d0$var$wbytes=function(n,r,i){for(;i;++r)n[r]=i,i>>>=8},$53691bda533d12d0$var$gzh=function(n,r){var i=r.filename;if(n[0]=31,n[1]=139,n[2]=8,n[8]=r.level<2?4:9==r.level?2:0,n[9]=3,0!=r.mtime&&$53691bda533d12d0$var$wbytes(n,4,Math.floor(new Date(r.mtime||Date.now())/1e3)),i){n[3]=8;for(var a=0;a<=i.length;++a)n[a+10]=i.charCodeAt(a)}},$53691bda533d12d0$var$gzs=function(n){if(31!=n[0]||139!=n[1]||8!=n[2])throw"invalid gzip data";var r=n[3],i=10;4&r&&(i+=n[10]|(n[11]<<8)+2);for(var a=(r>>3&1)+(r>>4&1);a>0;a-=!n[i++]);return i+(2&r)},$53691bda533d12d0$var$gzl=function(n){var r=n.length;return(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0},$53691bda533d12d0$var$gzhl=function(n){return 10+(n.filename&&n.filename.length+1||0)},$53691bda533d12d0$var$zlh=function(n,r){var i=r.level,a=0==i?0:i<6?1:9==i?3:2;n[0]=120,n[1]=a<<6|(a?32-2*a:1)},$53691bda533d12d0$var$zlv=function(n){if((15&n[0])!=8||n[0]>>>4>7||(n[0]<<8|n[1])%31)throw"invalid zlib data";if(32&n[1])throw"invalid zlib data: preset dictionaries not supported"};function $53691bda533d12d0$var$AsyncCmpStrm(n,r){return r||"function"!=typeof n||(r=n,n={}),this.ondata=r,n}// zlib footer: -4 to -0 is Adler32
/**
 * Streaming DEFLATE compression
 */var $53691bda533d12d0$export$ae157b6234afe138=/*#__PURE__*/function(){function n(n,r){r||"function"!=typeof n||(r=n,n={}),this.ondata=r,this.o=n||{}}return n.prototype.p=function(n,r){this.ondata($53691bda533d12d0$var$dopt(n,this.o,0,0,!r),r)},/**
     * Pushes a chunk to be deflated
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */n.prototype.push=function(n,r){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";this.d=r,this.p(n,r||!1)},n}(),$53691bda533d12d0$export$84e526fabcba03e3=/*#__PURE__*/function(){return function(n,r){$53691bda533d12d0$var$astrmify([$53691bda533d12d0$var$bDflt,function(){return[$53691bda533d12d0$var$astrm,$53691bda533d12d0$export$ae157b6234afe138]}],this,$53691bda533d12d0$var$AsyncCmpStrm.call(this,n,r),function(n){onmessage=$53691bda533d12d0$var$astrm(new $53691bda533d12d0$export$ae157b6234afe138(n.data))},6)}}();function $53691bda533d12d0$export$21533ff51b8a0b4a(n,r){return $53691bda533d12d0$var$dopt(n,r||{},0,0)}/**
 * Streaming DEFLATE decompression
 */var $53691bda533d12d0$export$d1de70a877d6e43c=/*#__PURE__*/function(){/**
     * Creates an inflation stream
     * @param cb The callback to call whenever data is inflated
     */function n(n){this.s={},this.p=new $53691bda533d12d0$var$u8(0),this.ondata=n}return n.prototype.e=function(n){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";var r=this.p.length,i=new $53691bda533d12d0$var$u8(r+n.length);i.set(this.p),i.set(n,r),this.p=i},n.prototype.c=function(n){this.d=this.s.i=n||!1;var r=this.s.b,i=$53691bda533d12d0$var$inflt(this.p,this.o,this.s);this.ondata($53691bda533d12d0$var$slc(i,r,this.s.b),this.d),this.o=$53691bda533d12d0$var$slc(i,this.s.b-32768),this.s.b=this.o.length,this.p=$53691bda533d12d0$var$slc(this.p,this.s.p/8|0),this.s.p&=7},/**
     * Pushes a chunk to be inflated
     * @param chunk The chunk to push
     * @param final Whether this is the final chunk
     */n.prototype.push=function(n,r){this.e(n),this.c(r)},n}(),$53691bda533d12d0$export$fff8358d6dbaa9cc=/*#__PURE__*/function(){return(/**
     * Creates an asynchronous inflation stream
     * @param cb The callback to call whenever data is deflated
     */function(n){this.ondata=n,$53691bda533d12d0$var$astrmify([$53691bda533d12d0$var$bInflt,function(){return[$53691bda533d12d0$var$astrm,$53691bda533d12d0$export$d1de70a877d6e43c]}],this,0,function(){onmessage=$53691bda533d12d0$var$astrm(new $53691bda533d12d0$export$d1de70a877d6e43c)},7)})}();function $53691bda533d12d0$export$90366d8b308ba94a(n,r){return $53691bda533d12d0$var$inflt(n,r)}// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.
/**
 * Streaming GZIP compression
 */var $53691bda533d12d0$export$8e4b66d280bf8342=/*#__PURE__*/function(){function n(n,r){this.c=$53691bda533d12d0$var$crc(),this.l=0,this.v=1,$53691bda533d12d0$export$ae157b6234afe138.call(this,n,r)}return(/**
     * Pushes a chunk to be GZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */n.prototype.push=function(n,r){$53691bda533d12d0$export$ae157b6234afe138.prototype.push.call(this,n,r)},n.prototype.p=function(n,r){this.c.p(n),this.l+=n.length;var i=$53691bda533d12d0$var$dopt(n,this.o,this.v&&$53691bda533d12d0$var$gzhl(this.o),r&&8,!r);this.v&&($53691bda533d12d0$var$gzh(i,this.o),this.v=0),r&&($53691bda533d12d0$var$wbytes(i,i.length-8,this.c.d()),$53691bda533d12d0$var$wbytes(i,i.length-4,this.l)),this.ondata(i,r)},n)}(),$53691bda533d12d0$export$4cb607de6db70415=/*#__PURE__*/function(){/**
     * Creates a GUNZIP stream
     * @param cb The callback to call whenever data is inflated
     */function n(n){this.v=1,$53691bda533d12d0$export$d1de70a877d6e43c.call(this,n)}return(/**
     * Pushes a chunk to be GUNZIPped
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */n.prototype.push=function(n,r){if($53691bda533d12d0$export$d1de70a877d6e43c.prototype.e.call(this,n),this.v){var i=this.p.length>3?$53691bda533d12d0$var$gzs(this.p):4;if(i>=this.p.length&&!r)return;this.p=this.p.subarray(i),this.v=0}if(r){if(this.p.length<8)throw"invalid gzip stream";this.p=this.p.subarray(0,-8)}// necessary to prevent TS from using the closure value
// This allows for workerization to function correctly
$53691bda533d12d0$export$d1de70a877d6e43c.prototype.c.call(this,r)},n)}(),$53691bda533d12d0$export$d5adcdd968132151=/*#__PURE__*/function(){return(/**
     * Creates an asynchronous GUNZIP stream
     * @param cb The callback to call whenever data is deflated
     */function(n){this.ondata=n,$53691bda533d12d0$var$astrmify([$53691bda533d12d0$var$bInflt,$53691bda533d12d0$var$guze,function(){return[$53691bda533d12d0$var$astrm,$53691bda533d12d0$export$d1de70a877d6e43c,$53691bda533d12d0$export$4cb607de6db70415]}],this,0,function(){onmessage=$53691bda533d12d0$var$astrm(new $53691bda533d12d0$export$4cb607de6db70415)},9)})}(),$53691bda533d12d0$export$4187ccf2467013b9=/*#__PURE__*/function(){function n(n,r){this.c=$53691bda533d12d0$var$adler(),this.v=1,$53691bda533d12d0$export$ae157b6234afe138.call(this,n,r)}return(/**
     * Pushes a chunk to be zlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */n.prototype.push=function(n,r){$53691bda533d12d0$export$ae157b6234afe138.prototype.push.call(this,n,r)},n.prototype.p=function(n,r){this.c.p(n);var i=$53691bda533d12d0$var$dopt(n,this.o,this.v&&2,r&&4,!r);this.v&&($53691bda533d12d0$var$zlh(i,this.o),this.v=0),r&&$53691bda533d12d0$var$wbytes(i,i.length-4,this.c.d()),this.ondata(i,r)},n)}(),$53691bda533d12d0$export$af2424f875ff1b17=/*#__PURE__*/function(){/**
     * Creates a Zlib decompression stream
     * @param cb The callback to call whenever data is inflated
     */function n(n){this.v=1,$53691bda533d12d0$export$d1de70a877d6e43c.call(this,n)}return(/**
     * Pushes a chunk to be unzlibbed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */n.prototype.push=function(n,r){if($53691bda533d12d0$export$d1de70a877d6e43c.prototype.e.call(this,n),this.v){if(this.p.length<2&&!r)return;this.p=this.p.subarray(2),this.v=0}if(r){if(this.p.length<4)throw"invalid zlib stream";this.p=this.p.subarray(0,-4)}// necessary to prevent TS from using the closure value
// This allows for workerization to function correctly
$53691bda533d12d0$export$d1de70a877d6e43c.prototype.c.call(this,r)},n)}(),$53691bda533d12d0$export$cf6668790220dcad=/*#__PURE__*/function(){return(/**
     * Creates an asynchronous Zlib decompression stream
     * @param cb The callback to call whenever data is deflated
     */function(n){this.ondata=n,$53691bda533d12d0$var$astrmify([$53691bda533d12d0$var$bInflt,$53691bda533d12d0$var$zule,function(){return[$53691bda533d12d0$var$astrm,$53691bda533d12d0$export$d1de70a877d6e43c,$53691bda533d12d0$export$af2424f875ff1b17]}],this,0,function(){onmessage=$53691bda533d12d0$var$astrm(new $53691bda533d12d0$export$af2424f875ff1b17)},11)})}();function $53691bda533d12d0$export$9ec8134f0f1b9fc6(n,r){return $53691bda533d12d0$var$inflt(($53691bda533d12d0$var$zlv(n),n.subarray(2,-4)),r)}/**
 * Streaming GZIP, Zlib, or raw DEFLATE decompression
 */var $53691bda533d12d0$export$578fe199ef655b76=/*#__PURE__*/function(){/**
     * Creates a decompression stream
     * @param cb The callback to call whenever data is decompressed
     */function n(n){this.G=$53691bda533d12d0$export$4cb607de6db70415,this.I=$53691bda533d12d0$export$d1de70a877d6e43c,this.Z=$53691bda533d12d0$export$af2424f875ff1b17,this.ondata=n}return(/**
     * Pushes a chunk to be decompressed
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */n.prototype.push=function(n,r){if(!this.ondata)throw"no stream handler";if(this.s)this.s.push(n,r);else{if(this.p&&this.p.length){var i=new $53691bda533d12d0$var$u8(this.p.length+n.length);i.set(this.p),i.set(n,this.p.length)}else this.p=n;if(this.p.length>2){var a=this,s=function(){a.ondata.apply(a,arguments)};this.s=31==this.p[0]&&139==this.p[1]&&8==this.p[2]?new this.G(s):(15&this.p[0])!=8||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(s):new this.Z(s),this.s.push(this.p,r),this.p=null}}},n)}(),$53691bda533d12d0$var$fltn=function(n,r,i,a){for(var s in n){var o=n[s],l=r+s;o instanceof $53691bda533d12d0$var$u8?i[l]=[o,a]:Array.isArray(o)?i[l]=[o[0],$53691bda533d12d0$var$mrg(a,o[1])]:$53691bda533d12d0$var$fltn(o,l+"/",i,a)}},$53691bda533d12d0$var$te="undefined"!=typeof TextEncoder&&/*#__PURE__*/new TextEncoder,$53691bda533d12d0$var$td="undefined"!=typeof TextDecoder&&/*#__PURE__*/new TextDecoder,$53691bda533d12d0$var$tds=0;try{$53691bda533d12d0$var$td.decode($53691bda533d12d0$var$et,{stream:!0}),$53691bda533d12d0$var$tds=1}catch(e){}// decode UTF8
var $53691bda533d12d0$var$dutf8=function(n){for(var r="",i=0;;){var a=n[i++],s=(a>127)+(a>223)+(a>239);if(i+s>n.length)return[r,$53691bda533d12d0$var$slc(n,i-1)];s?3==s?r+=String.fromCharCode(55296|(a=((15&a)<<18|(63&n[i++])<<12|(63&n[i++])<<6|63&n[i++])-65536)>>10,56320|1023&a):1&s?r+=String.fromCharCode((31&a)<<6|63&n[i++]):r+=String.fromCharCode((15&a)<<12|(63&n[i++])<<6|63&n[i++]):r+=String.fromCharCode(a)}};function $53691bda533d12d0$export$366b39a6daa8ed7a(n,r){if(r){for(var i=new $53691bda533d12d0$var$u8(n.length),a=0;a<n.length;++a)i[a]=n.charCodeAt(a);return i}if($53691bda533d12d0$var$te)return $53691bda533d12d0$var$te.encode(n);for(var s=n.length,o=new $53691bda533d12d0$var$u8(n.length+(n.length>>1)),l=0,u=function(n){o[l++]=n},a=0;a<s;++a){if(l+5>o.length){var c=new $53691bda533d12d0$var$u8(l+8+(s-a<<1));c.set(o),o=c}var h=n.charCodeAt(a);h<128||r?u(h):(h<2048?u(192|h>>6):(h>55295&&h<57344?(u(240|(h=65536+(1047552&h)|1023&n.charCodeAt(++a))>>18),u(128|h>>12&63)):u(224|h>>12),u(128|h>>6&63)),u(128|63&h))}return $53691bda533d12d0$var$slc(o,0,l)}function $53691bda533d12d0$export$adb211f8cb999894(n,r){if(r){for(var i="",a=0;a<n.length;a+=16384)i+=String.fromCharCode.apply(null,n.subarray(a,a+16384));return i}if($53691bda533d12d0$var$td)return $53691bda533d12d0$var$td.decode(n);var s=$53691bda533d12d0$var$dutf8(n),o=s[0];if(s[1].length)throw"invalid utf-8 data";return o}// deflate bit flag
var $53691bda533d12d0$var$dbf=function(n){return 1==n?3:n<6?2:9==n?1:0},$53691bda533d12d0$var$z64e=function(n,r){for(;1!=$53691bda533d12d0$var$b2(n,r);r+=4+$53691bda533d12d0$var$b2(n,r+2));return[$53691bda533d12d0$var$b8(n,r+12),$53691bda533d12d0$var$b8(n,r+4),$53691bda533d12d0$var$b8(n,r+20)]},$53691bda533d12d0$var$exfl=function(n){var r=0;if(n)for(var i in n){var a=n[i].length;if(a>65535)throw"extra field too long";r+=a+4}return r},$53691bda533d12d0$var$wzh=function(n,r,i,a,s,o,l,u){var c=a.length,h=i.extra,d=u&&u.length,p=$53691bda533d12d0$var$exfl(h);$53691bda533d12d0$var$wbytes(n,r,null!=l?33639248:67324752),r+=4,null!=l&&(n[r++]=20,n[r++]=i.os),n[r]=20,r+=2,n[r++]=i.flag<<1|(null==o&&8),n[r++]=s&&8,n[r++]=255&i.compression,n[r++]=i.compression>>8;var f=new Date(null==i.mtime?Date.now():i.mtime),m=f.getFullYear()-1980;if(m<0||m>119)throw"date not in range 1980-2099";if($53691bda533d12d0$var$wbytes(n,r,m<<25|f.getMonth()+1<<21|f.getDate()<<16|f.getHours()<<11|f.getMinutes()<<5|f.getSeconds()>>>1),r+=4,null!=o&&($53691bda533d12d0$var$wbytes(n,r,i.crc),$53691bda533d12d0$var$wbytes(n,r+4,o),$53691bda533d12d0$var$wbytes(n,r+8,i.size)),$53691bda533d12d0$var$wbytes(n,r+12,c),$53691bda533d12d0$var$wbytes(n,r+14,p),r+=16,null!=l&&($53691bda533d12d0$var$wbytes(n,r,d),$53691bda533d12d0$var$wbytes(n,r+6,i.attrs),$53691bda533d12d0$var$wbytes(n,r+10,l),r+=14),n.set(a,r),r+=c,p)for(var g in h){var _=h[g],y=_.length;$53691bda533d12d0$var$wbytes(n,r,+g),$53691bda533d12d0$var$wbytes(n,r+2,y),n.set(_,r+4),r+=4+y}return d&&(n.set(u,r),r+=d),r},$53691bda533d12d0$var$wzf=function(n,r,i,a,s){$53691bda533d12d0$var$wbytes(n,r,101010256),$53691bda533d12d0$var$wbytes(n,r+8,i),$53691bda533d12d0$var$wbytes(n,r+10,i),$53691bda533d12d0$var$wbytes(n,r+12,a),$53691bda533d12d0$var$wbytes(n,r+16,s)},$53691bda533d12d0$export$2b25194e1767ea06=/*#__PURE__*/function(){/**
     * Creates a pass-through stream that can be added to ZIP archives
     * @param filename The filename to associate with this data stream
     */function n(n){this.filename=n,this.c=$53691bda533d12d0$var$crc(),this.size=0,this.compression=0}return(/**
     * Processes a chunk and pushes to the output stream. You can override this
     * method in a subclass for custom behavior, but by default this passes
     * the data through. You must call this.ondata(err, chunk, final) at some
     * point in this method.
     * @param chunk The chunk to process
     * @param final Whether this is the last chunk
     */n.prototype.process=function(n,r){this.ondata(null,n,r)},/**
     * Pushes a chunk to be added. If you are subclassing this with a custom
     * compression algorithm, note that you must push data from the source
     * file only, pre-compression.
     * @param chunk The chunk to push
     * @param final Whether this is the last chunk
     */n.prototype.push=function(n,r){if(!this.ondata)throw"no callback - add to ZIP archive before pushing";this.c.p(n),this.size+=n.length,r&&(this.crc=this.c.d()),this.process(n,r||!1)},n)}(),$53691bda533d12d0$export$93f81d5bbbb7c6bf=/*#__PURE__*/function(){function n(){}return n.prototype.push=function(n,r){this.ondata(null,n,r)},n.compression=0,n}();/**
 * NURBS utils
 *
 * See NURBSCurve and NURBSSurface.
 **//**************************************************************
 *	NURBS Utils
 **************************************************************//*
Finds knot vector span.

p : degree
u : parametric value
U : knot vector

returns the span
*/function $3de20e7c02944e1d$export$5d44f085c0641ab4(n,r,i){let a=i.length-n-1;if(r>=i[a])return a-1;if(r<=i[n])return n;let s=n,o=a,l=Math.floor((s+o)/2);for(;r<i[l]||r>=i[l+1];)r<i[l]?o=l:s=l,l=Math.floor((s+o)/2);return l}/*
Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2

span : span in which u lies
u    : parametric point
p    : degree
U    : knot vector

returns array[p+1] with basis functions values.
*/function $3de20e7c02944e1d$export$bbebd61f407f7f41(n,r,i,a){let s=[],o=[],l=[];s[0]=1;for(let u=1;u<=i;++u){o[u]=r-a[n+1-u],l[u]=a[n+u]-r;let i=0;for(let n=0;n<u;++n){let r=l[n+1],a=o[u-n],c=s[n]/(r+a);s[n]=i+r*c,i=a*c}s[u]=i}return s}/*
Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.

p : degree of B-Spline
U : knot vector
P : control points (x, y, z, w)
u : parametric point

returns point for given u
*/function $3de20e7c02944e1d$export$3672a5d5ca534534(n,r,i,a){let s=$3de20e7c02944e1d$export$5d44f085c0641ab4(n,a,r),o=$3de20e7c02944e1d$export$bbebd61f407f7f41(s,a,n,r),l=new $d5b33d7c30034067$export$fa7daccca11cdbe3(0,0,0,0);for(let r=0;r<=n;++r){let a=i[s-n+r],u=o[r],c=a.w*u;l.x+=a.x*c,l.y+=a.y*c,l.z+=a.z*c,l.w+=a.w*u}return l}/*
Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.

span : span in which u lies
u    : parametric point
p    : degree
n    : number of derivatives to calculate
U    : knot vector

returns array[n+1][p+1] with basis functions derivatives
*/function $3de20e7c02944e1d$export$70bfab2ede47286(n,r,i,a,s){let o=[];for(let n=0;n<=i;++n)o[n]=0;let l=[];for(let n=0;n<=a;++n)l[n]=o.slice(0);let u=[];for(let n=0;n<=i;++n)u[n]=o.slice(0);u[0][0]=1;let c=o.slice(0),h=o.slice(0);for(let a=1;a<=i;++a){c[a]=r-s[n+1-a],h[a]=s[n+a]-r;let i=0;for(let n=0;n<a;++n){let r=h[n+1],s=c[a-n];u[a][n]=r+s;let o=u[n][a-1]/u[a][n];u[n][a]=i+r*o,i=s*o}u[a][a]=i}for(let n=0;n<=i;++n)l[0][n]=u[n][i];for(let n=0;n<=i;++n){let r=0,s=1,c=[];for(let n=0;n<=i;++n)c[n]=o.slice(0);c[0][0]=1;for(let o=1;o<=a;++o){let a=0,h=n-o,d=i-o;n>=o&&(c[s][0]=c[r][0]/u[d+1][h],a=c[s][0]*u[h][d]);let p=h>=-1?1:-h,f=n-1<=d?o-1:i-n;for(let n=p;n<=f;++n)c[s][n]=(c[r][n]-c[r][n-1])/u[d+1][h+n],a+=c[s][n]*u[h+n][d];n<=d&&(c[s][o]=-c[r][o-1]/u[d+1][n],a+=c[s][o]*u[n][d]),l[o][n]=a;let m=r;r=s,s=m}}let d=i;for(let n=1;n<=a;++n){for(let r=0;r<=i;++r)l[n][r]*=d;d*=i-n}return l}/*
	Calculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.

	p  : degree
	U  : knot vector
	P  : control points
	u  : Parametric points
	nd : number of derivatives

	returns array[d+1] with derivatives
	*/function $3de20e7c02944e1d$export$ae5bff7435823e13(n,r,i,a,s){let o=s<n?s:n,l=[],u=$3de20e7c02944e1d$export$5d44f085c0641ab4(n,a,r),c=$3de20e7c02944e1d$export$70bfab2ede47286(u,a,n,o,r),h=[];for(let n=0;n<i.length;++n){let r=i[n].clone(),a=r.w;r.x*=a,r.y*=a,r.z*=a,h[n]=r}for(let r=0;r<=o;++r){let i=h[u-n].clone().multiplyScalar(c[r][0]);for(let a=1;a<=n;++a)i.add(h[u-n+a].clone().multiplyScalar(c[r][a]));l[r]=i}for(let n=o+1;n<=s+1;++n)l[n]=new $d5b33d7c30034067$export$fa7daccca11cdbe3(0,0,0);return l}/*
Calculate "K over I"

returns k!/(i!(k-i)!)
*/function $3de20e7c02944e1d$export$3c88b91ac9312187(n,r){let i=1;for(let r=2;r<=n;++r)i*=r;let a=1;for(let n=2;n<=r;++n)a*=n;for(let i=2;i<=n-r;++i)a*=i;return i/a}/*
Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.

Pders : result of function calcBSplineDerivatives

returns array with derivatives for rational curve.
*/function $3de20e7c02944e1d$export$66805edec2c1a55d(n){let r=n.length,i=[],a=[];for(let s=0;s<r;++s){let r=n[s];i[s]=new $d5b33d7c30034067$export$64b5c384219d3699(r.x,r.y,r.z),a[s]=r.w}let s=[];for(let n=0;n<r;++n){let r=i[n].clone();for(let i=1;i<=n;++i)r.sub(s[n-i].clone().multiplyScalar($3de20e7c02944e1d$export$3c88b91ac9312187(n,i)*a[i]));s[n]=r.divideScalar(a[0])}return s}/*
Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.

p  : degree
U  : knot vector
P  : control points in homogeneous space
u  : parametric points
nd : number of derivatives

returns array with derivatives.
*/function $3de20e7c02944e1d$export$692f68f163c8f6b(n,r,i,a,s){let o=$3de20e7c02944e1d$export$ae5bff7435823e13(n,r,i,a,s);return $3de20e7c02944e1d$export$66805edec2c1a55d(o)}/**
 * NURBS curve object
 *
 * Derives from Curve, overriding getPoint and getTangent.
 *
 * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.
 *
 **/class $94b07e67f83726ad$export$12efb26d7429b049 extends $d5b33d7c30034067$export$b0e83c3ef8d2db1{constructor(n,r/* array of reals */,i/* array of Vector(2|3|4) */,a/* index in knots */,s/* index in knots */){super(),this.degree=n,this.knots=r,this.controlPoints=[],// Used by periodic NURBS to remove hidden spans
this.startKnot=a||0,this.endKnot=s||this.knots.length-1;for(let n=0;n<i.length;++n){// ensure Vector4 for control points
let r=i[n];this.controlPoints[n]=new $d5b33d7c30034067$export$fa7daccca11cdbe3(r.x,r.y,r.z,r.w)}}getPoint(n,r=new $d5b33d7c30034067$export$64b5c384219d3699){let i=r,a=this.knots[this.startKnot]+n*(this.knots[this.endKnot]-this.knots[this.startKnot]),s=$3de20e7c02944e1d$export$3672a5d5ca534534(this.degree,this.knots,this.controlPoints,a);return 1!==s.w&&s.divideScalar(s.w),i.set(s.x,s.y,s.z)}getTangent(n,r=new $d5b33d7c30034067$export$64b5c384219d3699){let i=r,a=this.knots[0]+n*(this.knots[this.knots.length-1]-this.knots[0]),s=$3de20e7c02944e1d$export$692f68f163c8f6b(this.degree,this.knots,this.controlPoints,a,1);return i.copy(s[1]).normalize(),i}}class $04ef886a022e9ae8$export$60c52e42bb04b96 extends $d5b33d7c30034067$export$3b0d6d7590275603{constructor(n){super(n)}load(n,r,i,a){let s=this,o=""===s.path?$d5b33d7c30034067$export$b5d2dc08d867e41a.extractUrlBase(n):s.path,l=new $d5b33d7c30034067$export$98435a25b5cf7b2b(this.manager);l.setPath(s.path),l.setResponseType("arraybuffer"),l.setRequestHeader(s.requestHeader),l.setWithCredentials(s.withCredentials),l.load(n,function(i){try{r(s.parse(i,o))}catch(r){a?a(r):console.error(r),s.manager.itemError(n)}},i,a)}parse(n,r){if($04ef886a022e9ae8$var$isFbxFormatBinary(n))$04ef886a022e9ae8$var$fbxTree=new $04ef886a022e9ae8$var$BinaryParser().parse(n);else{let r=$04ef886a022e9ae8$var$convertArrayBufferToString(n);if(!$04ef886a022e9ae8$var$isFbxFormatASCII(r))throw Error("THREE.FBXLoader: Unknown format.");if(7e3>$04ef886a022e9ae8$var$getFbxVersion(r))throw Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+$04ef886a022e9ae8$var$getFbxVersion(r));$04ef886a022e9ae8$var$fbxTree=new $04ef886a022e9ae8$var$TextParser().parse(r)}// console.log( fbxTree );
let i=new $d5b33d7c30034067$export$fd1bfc71f64c538c(this.manager).setPath(this.resourcePath||r).setCrossOrigin(this.crossOrigin);return new $04ef886a022e9ae8$var$FBXTreeParser(i,this.manager).parse($04ef886a022e9ae8$var$fbxTree)}}// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group
class $04ef886a022e9ae8$var$FBXTreeParser{constructor(n,r){this.textureLoader=n,this.manager=r}parse(){$04ef886a022e9ae8$var$connections=this.parseConnections();let n=this.parseImages(),r=this.parseTextures(n),i=this.parseMaterials(r),a=this.parseDeformers(),s=new $04ef886a022e9ae8$var$GeometryParser().parse(a);return this.parseScene(a,s,i),$04ef886a022e9ae8$var$sceneGraph}// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
// and details the connection type
parseConnections(){let n=new Map;if("Connections"in $04ef886a022e9ae8$var$fbxTree){let r=$04ef886a022e9ae8$var$fbxTree.Connections.connections;r.forEach(function(r){let i=r[0],a=r[1],s=r[2];n.has(i)||n.set(i,{parents:[],children:[]});let o={ID:a,relationship:s};n.get(i).parents.push(o),n.has(a)||n.set(a,{parents:[],children:[]});let l={ID:i,relationship:s};n.get(a).children.push(l)})}return n}// Parse FBXTree.Objects.Video for embedded image data
// These images are connected to textures in FBXTree.Objects.Textures
// via FBXTree.Connections.
parseImages(){let n={},r={};if("Video"in $04ef886a022e9ae8$var$fbxTree.Objects){let i=$04ef886a022e9ae8$var$fbxTree.Objects.Video;for(let a in i){let s=i[a],o=parseInt(a);// raw image data is in videoNode.Content
if(n[o]=s.RelativeFilename||s.Filename,"Content"in s){let n=s.Content instanceof ArrayBuffer&&s.Content.byteLength>0,o="string"==typeof s.Content&&""!==s.Content;if(n||o){let n=this.parseImage(i[a]);r[s.RelativeFilename||s.Filename]=n}}}}for(let i in n){let a=n[i];void 0!==r[a]?n[i]=r[a]:n[i]=n[i].split("\\").pop()}return n}// Parse embedded image data in FBXTree.Video.Content
parseImage(n){let r;let i=n.Content,a=n.RelativeFilename||n.Filename,s=a.slice(a.lastIndexOf(".")+1).toLowerCase();switch(s){case"bmp":r="image/bmp";break;case"jpg":case"jpeg":r="image/jpeg";break;case"png":r="image/png";break;case"tif":r="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",a),r="image/tga";break;default:console.warn('FBXLoader: Image type "'+s+'" is not supported.');return}if("string"==typeof i)return"data:"+r+";base64,"+i;{let n=new Uint8Array(i);return window.URL.createObjectURL(new Blob([n],{type:r}))}}// Parse nodes in FBXTree.Objects.Texture
// These contain details such as UV scaling, cropping, rotation etc and are connected
// to images in FBXTree.Objects.Video
parseTextures(n){let r=new Map;if("Texture"in $04ef886a022e9ae8$var$fbxTree.Objects){let i=$04ef886a022e9ae8$var$fbxTree.Objects.Texture;for(let a in i){let s=this.parseTexture(i[a],n);r.set(parseInt(a),s)}}return r}// Parse individual node in FBXTree.Objects.Texture
parseTexture(n,r){let i=this.loadTexture(n,r);i.ID=n.id,i.name=n.attrName;let a=n.WrapModeU,s=n.WrapModeV,o=void 0!==a?a.value:0,l=void 0!==s?s.value:0;if(// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
// 0: repeat(default), 1: clamp
i.wrapS=0===o?$d5b33d7c30034067$export$533346c8e8dac0f5:$d5b33d7c30034067$export$9d9334239a5a5e06,i.wrapT=0===l?$d5b33d7c30034067$export$533346c8e8dac0f5:$d5b33d7c30034067$export$9d9334239a5a5e06,"Scaling"in n){let r=n.Scaling.value;i.repeat.x=r[0],i.repeat.y=r[1]}if("Translation"in n){let r=n.Translation.value;i.offset.x=r[0],i.offset.y=r[1]}return i}// load a texture specified as a blob or data URI, or via an external URL using TextureLoader
loadTexture(n,r){let i,a;let s=this.textureLoader.path,o=$04ef886a022e9ae8$var$connections.get(n.id).children;void 0!==o&&o.length>0&&void 0!==r[o[0].ID]&&(0===(i=r[o[0].ID]).indexOf("blob:")||0===i.indexOf("data:"))&&this.textureLoader.setPath(void 0);let l=n.FileName.slice(-3).toLowerCase();if("tga"===l){let r=this.manager.getHandler(".tga");null===r?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",n.RelativeFilename),a=new $d5b33d7c30034067$export$5431306cf43de24a):(r.setPath(this.textureLoader.path),a=r.load(i))}else"psd"===l?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",n.RelativeFilename),a=new $d5b33d7c30034067$export$5431306cf43de24a):a=this.textureLoader.load(i);return this.textureLoader.setPath(s),a}// Parse nodes in FBXTree.Objects.Material
parseMaterials(n){let r=new Map;if("Material"in $04ef886a022e9ae8$var$fbxTree.Objects){let i=$04ef886a022e9ae8$var$fbxTree.Objects.Material;for(let a in i){let s=this.parseMaterial(i[a],n);null!==s&&r.set(parseInt(a),s)}}return r}// Parse single node in FBXTree.Objects.Material
// Materials are connected to texture maps in FBXTree.Objects.Textures
// FBX format currently only supports Lambert and Phong shading models
parseMaterial(n,r){let i;let a=n.id,s=n.attrName,o=n.ShadingModel;// Ignore unused materials which don't have any connections.
if("object"==typeof o&&(o=o.value),!$04ef886a022e9ae8$var$connections.has(a))return null;let l=this.parseParameters(n,r,a);switch(o.toLowerCase()){case"phong":i=new $d5b33d7c30034067$export$24c72f71cbaf0678;break;case"lambert":i=new $d5b33d7c30034067$export$5023a9a8114806b8;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',o),i=new $d5b33d7c30034067$export$24c72f71cbaf0678}return i.setValues(l),i.name=s,i}// Parse FBX material and return parameters suitable for a three.js material
// Also parse the texture map and return any textures associated with the material
parseParameters(n,r,i){let a={};n.BumpFactor&&(a.bumpScale=n.BumpFactor.value),n.Diffuse?a.color=new $d5b33d7c30034067$export$892596cec99bc70e().fromArray(n.Diffuse.value).convertSRGBToLinear():n.DiffuseColor&&("Color"===n.DiffuseColor.type||"ColorRGB"===n.DiffuseColor.type)&&(a.color=new $d5b33d7c30034067$export$892596cec99bc70e().fromArray(n.DiffuseColor.value).convertSRGBToLinear()),n.DisplacementFactor&&(a.displacementScale=n.DisplacementFactor.value),n.Emissive?a.emissive=new $d5b33d7c30034067$export$892596cec99bc70e().fromArray(n.Emissive.value).convertSRGBToLinear():n.EmissiveColor&&("Color"===n.EmissiveColor.type||"ColorRGB"===n.EmissiveColor.type)&&(a.emissive=new $d5b33d7c30034067$export$892596cec99bc70e().fromArray(n.EmissiveColor.value).convertSRGBToLinear()),n.EmissiveFactor&&(a.emissiveIntensity=parseFloat(n.EmissiveFactor.value)),n.Opacity&&(a.opacity=parseFloat(n.Opacity.value)),a.opacity<1&&(a.transparent=!0),n.ReflectionFactor&&(a.reflectivity=n.ReflectionFactor.value),n.Shininess&&(a.shininess=n.Shininess.value),n.Specular?a.specular=new $d5b33d7c30034067$export$892596cec99bc70e().fromArray(n.Specular.value).convertSRGBToLinear():n.SpecularColor&&"Color"===n.SpecularColor.type&&(a.specular=new $d5b33d7c30034067$export$892596cec99bc70e().fromArray(n.SpecularColor.value).convertSRGBToLinear());let s=this;return $04ef886a022e9ae8$var$connections.get(i).children.forEach(function(n){let i=n.relationship;switch(i){case"Bump":a.bumpMap=s.getTexture(r,n.ID);break;case"Maya|TEX_ao_map":a.aoMap=s.getTexture(r,n.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":a.map=s.getTexture(r,n.ID),void 0!==a.map&&(a.map.colorSpace=$d5b33d7c30034067$export$561f394b24edfcaa);break;case"DisplacementColor":a.displacementMap=s.getTexture(r,n.ID);break;case"EmissiveColor":a.emissiveMap=s.getTexture(r,n.ID),void 0!==a.emissiveMap&&(a.emissiveMap.colorSpace=$d5b33d7c30034067$export$561f394b24edfcaa);break;case"NormalMap":case"Maya|TEX_normal_map":a.normalMap=s.getTexture(r,n.ID);break;case"ReflectionColor":a.envMap=s.getTexture(r,n.ID),void 0!==a.envMap&&(a.envMap.mapping=$d5b33d7c30034067$export$d64030b316d3b087,a.envMap.colorSpace=$d5b33d7c30034067$export$561f394b24edfcaa);break;case"SpecularColor":a.specularMap=s.getTexture(r,n.ID),void 0!==a.specularMap&&(a.specularMap.colorSpace=$d5b33d7c30034067$export$561f394b24edfcaa);break;case"TransparentColor":case"TransparencyFactor":a.alphaMap=s.getTexture(r,n.ID),a.transparent=!0;break;default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",i)}}),a}// get a texture from the textureMap for use by a material.
getTexture(n,r){return"LayeredTexture"in $04ef886a022e9ae8$var$fbxTree.Objects&&r in $04ef886a022e9ae8$var$fbxTree.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),r=$04ef886a022e9ae8$var$connections.get(r).children[0].ID),n.get(r)}// Parse nodes in FBXTree.Objects.Deformer
// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
// Generates map of Skeleton-like objects for use later when generating and binding skeletons.
parseDeformers(){let n={},r={};if("Deformer"in $04ef886a022e9ae8$var$fbxTree.Objects){let i=$04ef886a022e9ae8$var$fbxTree.Objects.Deformer;for(let a in i){let s=i[a],o=$04ef886a022e9ae8$var$connections.get(parseInt(a));if("Skin"===s.attrType){let r=this.parseSkeleton(o,i);r.ID=a,o.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),r.geometryID=o.parents[0].ID,n[a]=r}else if("BlendShape"===s.attrType){let n={id:a};n.rawTargets=this.parseMorphTargets(o,i),n.id=a,o.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),r[a]=n}}}return{skeletons:n,morphTargets:r}}// Parse single nodes in FBXTree.Objects.Deformer
// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
// Each skin node represents a skeleton and each cluster node represents a bone
parseSkeleton(n,r){let i=[];return n.children.forEach(function(n){let a=r[n.ID];if("Cluster"!==a.attrType)return;let s={ID:n.ID,indices:[],weights:[],transformLink:new $d5b33d7c30034067$export$2ae72fc923e5eb5().fromArray(a.TransformLink.a)};"Indexes"in a&&(s.indices=a.Indexes.a,s.weights=a.Weights.a),i.push(s)}),{rawBones:i,bones:[]}}// The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
parseMorphTargets(n,r){let i=[];for(let a=0;a<n.children.length;a++){let s=n.children[a],o=r[s.ID],l={name:o.attrName,initialWeight:o.DeformPercent,id:o.id,fullWeights:o.FullWeights.a};if("BlendShapeChannel"!==o.attrType)return;l.geoID=$04ef886a022e9ae8$var$connections.get(parseInt(s.ID)).children.filter(function(n){return void 0===n.relationship})[0].ID,i.push(l)}return i}// create the main Group() to be returned by the loader
parseScene(n,r,i){$04ef886a022e9ae8$var$sceneGraph=new $d5b33d7c30034067$export$eb2fcfdbd7ba97d4;let a=this.parseModels(n.skeletons,r,i),s=$04ef886a022e9ae8$var$fbxTree.Objects.Model,o=this;a.forEach(function(n){let r=s[n.ID];o.setLookAtProperties(n,r);let i=$04ef886a022e9ae8$var$connections.get(n.ID).parents;i.forEach(function(r){let i=a.get(r.ID);void 0!==i&&i.add(n)}),null===n.parent&&$04ef886a022e9ae8$var$sceneGraph.add(n)}),this.bindSkeleton(n.skeletons,r,a),this.createAmbientLight(),$04ef886a022e9ae8$var$sceneGraph.traverse(function(n){if(n.userData.transformData){n.parent&&(n.userData.transformData.parentMatrix=n.parent.matrix,n.userData.transformData.parentMatrixWorld=n.parent.matrixWorld);let r=$04ef886a022e9ae8$var$generateTransform(n.userData.transformData);n.applyMatrix4(r),n.updateWorldMatrix()}});let l=new $04ef886a022e9ae8$var$AnimationParser().parse();1===$04ef886a022e9ae8$var$sceneGraph.children.length&&$04ef886a022e9ae8$var$sceneGraph.children[0].isGroup&&($04ef886a022e9ae8$var$sceneGraph.children[0].animations=l,$04ef886a022e9ae8$var$sceneGraph=$04ef886a022e9ae8$var$sceneGraph.children[0]),$04ef886a022e9ae8$var$sceneGraph.animations=l}// parse nodes in FBXTree.Objects.Model
parseModels(n,r,i){let a=new Map,s=$04ef886a022e9ae8$var$fbxTree.Objects.Model;for(let o in s){let l=parseInt(o),u=s[o],c=$04ef886a022e9ae8$var$connections.get(l),h=this.buildSkeleton(c,n,l,u.attrName);if(!h){switch(u.attrType){case"Camera":h=this.createCamera(c);break;case"Light":h=this.createLight(c);break;case"Mesh":h=this.createMesh(c,r,i);break;case"NurbsCurve":h=this.createCurve(c,r);break;case"LimbNode":case"Root":h=new $d5b33d7c30034067$export$b127726e56765aa4;break;default:h=new $d5b33d7c30034067$export$eb2fcfdbd7ba97d4}h.name=u.attrName?$d5b33d7c30034067$export$7bf70fcf9f891893.sanitizeNodeName(u.attrName):"",h.userData.originalName=u.attrName,h.ID=l}this.getTransformData(h,u),a.set(l,h)}return a}buildSkeleton(n,r,i,a){let s=null;return n.parents.forEach(function(n){for(let o in r){let l=r[o];l.rawBones.forEach(function(r,o){if(r.ID===n.ID){let n=s;(s=new $d5b33d7c30034067$export$b127726e56765aa4).matrixWorld.copy(r.transformLink),// set name and id here - otherwise in cases where "subBone" is created it will not have a name / id
s.name=a?$d5b33d7c30034067$export$7bf70fcf9f891893.sanitizeNodeName(a):"",s.userData.originalName=a,s.ID=i,l.bones[o]=s,null!==n&&s.add(n)}})}}),s}// create a PerspectiveCamera or OrthographicCamera
createCamera(n){let r,i;if(n.children.forEach(function(n){let r=$04ef886a022e9ae8$var$fbxTree.Objects.NodeAttribute[n.ID];void 0!==r&&(i=r)}),void 0===i)r=new $d5b33d7c30034067$export$e4dd07dff30cc924;else{let n=0;void 0!==i.CameraProjectionType&&1===i.CameraProjectionType.value&&(n=1);let a=1;void 0!==i.NearPlane&&(a=i.NearPlane.value/1e3);let s=1e3;void 0!==i.FarPlane&&(s=i.FarPlane.value/1e3);let o=window.innerWidth,l=window.innerHeight;void 0!==i.AspectWidth&&void 0!==i.AspectHeight&&(o=i.AspectWidth.value,l=i.AspectHeight.value);let u=o/l,c=45;void 0!==i.FieldOfView&&(c=i.FieldOfView.value);let h=i.FocalLength?i.FocalLength.value:null;switch(n){case 0:r=new $d5b33d7c30034067$export$74e4ae24825f68d7(c,u,a,s),null!==h&&r.setFocalLength(h);break;case 1:r=new $d5b33d7c30034067$export$9ebf355ee4ed261b(-o/2,o/2,l/2,-l/2,a,s);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+n+"."),r=new $d5b33d7c30034067$export$e4dd07dff30cc924}}return r}// Create a DirectionalLight, PointLight or SpotLight
createLight(n){let r,i;if(n.children.forEach(function(n){let r=$04ef886a022e9ae8$var$fbxTree.Objects.NodeAttribute[n.ID];void 0!==r&&(i=r)}),void 0===i)r=new $d5b33d7c30034067$export$e4dd07dff30cc924;else{let n;// LightType can be undefined for Point lights
n=void 0===i.LightType?0:i.LightType.value;let a=16777215;void 0!==i.Color&&(a=new $d5b33d7c30034067$export$892596cec99bc70e().fromArray(i.Color.value).convertSRGBToLinear());let s=void 0===i.Intensity?1:i.Intensity.value/100;// light disabled
void 0!==i.CastLightOnObject&&0===i.CastLightOnObject.value&&(s=0);let o=0;void 0!==i.FarAttenuationEnd&&(o=void 0!==i.EnableFarAttenuation&&0===i.EnableFarAttenuation.value?0:i.FarAttenuationEnd.value);// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?
let l=1;switch(n){case 0:r=new $d5b33d7c30034067$export$4c9c1cb3f0b6f455(a,s,o,l);break;case 1:r=new $d5b33d7c30034067$export$3fea33cc9972c868(a,s);break;case 2:let u=Math.PI/3;void 0!==i.InnerAngle&&(u=$d5b33d7c30034067$export$6a7ef315a0d1ef07.degToRad(i.InnerAngle.value));let c=0;void 0!==i.OuterAngle&&(c=Math.max(// TODO: this is not correct - FBX calculates outer and inner angle in degrees
// with OuterAngle > InnerAngle && OuterAngle <= Math.PI
// while three.js uses a penumbra between (0, 1) to attenuate the inner angle
c=$d5b33d7c30034067$export$6a7ef315a0d1ef07.degToRad(i.OuterAngle.value),1)),r=new $d5b33d7c30034067$export$81495cbb73897362(a,s,o,u,c,l);break;default:console.warn("THREE.FBXLoader: Unknown light type "+i.LightType.value+", defaulting to a PointLight."),r=new $d5b33d7c30034067$export$4c9c1cb3f0b6f455(a,s)}void 0!==i.CastShadows&&1===i.CastShadows.value&&(r.castShadow=!0)}return r}createMesh(n,r,i){let a;let s=null,o=null,l=[];return(// get geometry and materials(s) from connections
n.children.forEach(function(n){r.has(n.ID)&&(s=r.get(n.ID)),i.has(n.ID)&&l.push(i.get(n.ID))}),l.length>1?o=l:l.length>0?o=l[0]:(o=new $d5b33d7c30034067$export$24c72f71cbaf0678({name:$d5b33d7c30034067$export$3b0d6d7590275603.DEFAULT_MATERIAL_NAME,color:13421772}),l.push(o)),"color"in s.attributes&&l.forEach(function(n){n.vertexColors=!0}),s.FBX_Deformer?(a=new $d5b33d7c30034067$export$b303577035157ecf(s,o)).normalizeSkinWeights():a=new $d5b33d7c30034067$export$e176487c05830cc5(s,o),a)}createCurve(n,r){let i=n.children.reduce(function(n,i){return r.has(i.ID)&&(n=r.get(i.ID)),n},null),a=new $d5b33d7c30034067$export$fbaaa33907730a0c({name:$d5b33d7c30034067$export$3b0d6d7590275603.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new $d5b33d7c30034067$export$17d680238e50603e(i,a)}// parse the model node for transform data
getTransformData(n,r){let i={};"InheritType"in r&&(i.inheritType=parseInt(r.InheritType.value)),"RotationOrder"in r?i.eulerOrder=$04ef886a022e9ae8$var$getEulerOrder(r.RotationOrder.value):i.eulerOrder="ZYX","Lcl_Translation"in r&&(i.translation=r.Lcl_Translation.value),"PreRotation"in r&&(i.preRotation=r.PreRotation.value),"Lcl_Rotation"in r&&(i.rotation=r.Lcl_Rotation.value),"PostRotation"in r&&(i.postRotation=r.PostRotation.value),"Lcl_Scaling"in r&&(i.scale=r.Lcl_Scaling.value),"ScalingOffset"in r&&(i.scalingOffset=r.ScalingOffset.value),"ScalingPivot"in r&&(i.scalingPivot=r.ScalingPivot.value),"RotationOffset"in r&&(i.rotationOffset=r.RotationOffset.value),"RotationPivot"in r&&(i.rotationPivot=r.RotationPivot.value),n.userData.transformData=i}setLookAtProperties(n,r){if("LookAtProperty"in r){let r=$04ef886a022e9ae8$var$connections.get(n.ID).children;r.forEach(function(r){if("LookAtProperty"===r.relationship){let i=$04ef886a022e9ae8$var$fbxTree.Objects.Model[r.ID];if("Lcl_Translation"in i){let r=i.Lcl_Translation.value;// DirectionalLight, SpotLight
void 0!==n.target?(n.target.position.fromArray(r),$04ef886a022e9ae8$var$sceneGraph.add(n.target)):n.lookAt(new $d5b33d7c30034067$export$64b5c384219d3699().fromArray(r))}}})}}bindSkeleton(n,r,i){let a=this.parsePoseNodes();for(let s in n){let o=n[s],l=$04ef886a022e9ae8$var$connections.get(parseInt(o.ID)).parents;l.forEach(function(n){if(r.has(n.ID)){let r=n.ID,s=$04ef886a022e9ae8$var$connections.get(r);s.parents.forEach(function(n){if(i.has(n.ID)){let r=i.get(n.ID);r.bind(new $d5b33d7c30034067$export$8f31e4c4a37b8e9c(o.bones),a[n.ID])}})}})}}parsePoseNodes(){let n={};if("Pose"in $04ef886a022e9ae8$var$fbxTree.Objects){let r=$04ef886a022e9ae8$var$fbxTree.Objects.Pose;for(let i in r)if("BindPose"===r[i].attrType&&r[i].NbPoseNodes>0){let a=r[i].PoseNode;Array.isArray(a)?a.forEach(function(r){n[r.Node]=new $d5b33d7c30034067$export$2ae72fc923e5eb5().fromArray(r.Matrix.a)}):n[a.Node]=new $d5b33d7c30034067$export$2ae72fc923e5eb5().fromArray(a.Matrix.a)}}return n}// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
createAmbientLight(){if("GlobalSettings"in $04ef886a022e9ae8$var$fbxTree&&"AmbientColor"in $04ef886a022e9ae8$var$fbxTree.GlobalSettings){let n=$04ef886a022e9ae8$var$fbxTree.GlobalSettings.AmbientColor.value,r=n[0],i=n[1],a=n[2];if(0!==r||0!==i||0!==a){let n=new $d5b33d7c30034067$export$892596cec99bc70e(r,i,a).convertSRGBToLinear();$04ef886a022e9ae8$var$sceneGraph.add(new $d5b33d7c30034067$export$af279bfef9ec2c96(n,1))}}}}// parse Geometry data from FBXTree and return map of BufferGeometries
class $04ef886a022e9ae8$var$GeometryParser{constructor(){this.negativeMaterialIndices=!1}// Parse nodes in FBXTree.Objects.Geometry
parse(n){let r=new Map;if("Geometry"in $04ef886a022e9ae8$var$fbxTree.Objects){let i=$04ef886a022e9ae8$var$fbxTree.Objects.Geometry;for(let a in i){let s=$04ef886a022e9ae8$var$connections.get(parseInt(a)),o=this.parseGeometry(s,i[a],n);r.set(parseInt(a),o)}}return!0===this.negativeMaterialIndices&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),r}// Parse single node in FBXTree.Objects.Geometry
parseGeometry(n,r,i){switch(r.attrType){case"Mesh":return this.parseMeshGeometry(n,r,i);case"NurbsCurve":return this.parseNurbsGeometry(r)}}// Parse single node mesh geometry in FBXTree.Objects.Geometry
parseMeshGeometry(n,r,i){let a=i.skeletons,s=[],o=n.parents.map(function(n){return $04ef886a022e9ae8$var$fbxTree.Objects.Model[n.ID]});// don't create geometry if it is not associated with any models
if(0===o.length)return;let l=n.children.reduce(function(n,r){return void 0!==a[r.ID]&&(n=a[r.ID]),n},null);n.children.forEach(function(n){void 0!==i.morphTargets[n.ID]&&s.push(i.morphTargets[n.ID])});// Assume one model and get the preRotation from that
// if there is more than one model associated with the geometry this may cause problems
let u=o[0],c={};"RotationOrder"in u&&(c.eulerOrder=$04ef886a022e9ae8$var$getEulerOrder(u.RotationOrder.value)),"InheritType"in u&&(c.inheritType=parseInt(u.InheritType.value)),"GeometricTranslation"in u&&(c.translation=u.GeometricTranslation.value),"GeometricRotation"in u&&(c.rotation=u.GeometricRotation.value),"GeometricScaling"in u&&(c.scale=u.GeometricScaling.value);let h=$04ef886a022e9ae8$var$generateTransform(c);return this.genGeometry(r,l,s,h)}// Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
genGeometry(n,r,i,a){let s=new $d5b33d7c30034067$export$b7be63a67df8959;n.attrName&&(s.name=n.attrName);let o=this.parseGeoNode(n,r),l=this.genBuffers(o),u=new $d5b33d7c30034067$export$cbe7a62641830ebd(l.vertex,3);if(u.applyMatrix4(a),s.setAttribute("position",u),l.colors.length>0&&s.setAttribute("color",new $d5b33d7c30034067$export$cbe7a62641830ebd(l.colors,3)),r&&(s.setAttribute("skinIndex",new $d5b33d7c30034067$export$640a853f68025f2e(l.weightsIndices,4)),s.setAttribute("skinWeight",new $d5b33d7c30034067$export$cbe7a62641830ebd(l.vertexWeights,4)),// used later to bind the skeleton to the model
s.FBX_Deformer=r),l.normal.length>0){let n=new $d5b33d7c30034067$export$8ff26dafa08918().getNormalMatrix(a),r=new $d5b33d7c30034067$export$cbe7a62641830ebd(l.normal,3);r.applyNormalMatrix(n),s.setAttribute("normal",r)}if(l.uvs.forEach(function(n,r){let i=0===r?"uv":`uv${r}`;s.setAttribute(i,new $d5b33d7c30034067$export$cbe7a62641830ebd(l.uvs[r],2))}),o.material&&"AllSame"!==o.material.mappingType){// Convert the material indices of each vertex into rendering groups on the geometry.
let n=l.materialIndex[0],r=0;// the loop above doesn't add the last group, do that here.
if(l.materialIndex.forEach(function(i,a){i!==n&&(s.addGroup(r,a-r,n),n=i,r=a)}),s.groups.length>0){let r=s.groups[s.groups.length-1],i=r.start+r.count;i!==l.materialIndex.length&&s.addGroup(i,l.materialIndex.length-i,n)}0===s.groups.length&&s.addGroup(0,l.materialIndex.length,l.materialIndex[0])}return this.addMorphTargets(s,n,i,a),s}parseGeoNode(n,r){let i={};if(i.vertexPositions=void 0!==n.Vertices?n.Vertices.a:[],i.vertexIndices=void 0!==n.PolygonVertexIndex?n.PolygonVertexIndex.a:[],n.LayerElementColor&&(i.color=this.parseVertexColors(n.LayerElementColor[0])),n.LayerElementMaterial&&(i.material=this.parseMaterialIndices(n.LayerElementMaterial[0])),n.LayerElementNormal&&(i.normal=this.parseNormals(n.LayerElementNormal[0])),n.LayerElementUV){i.uv=[];let r=0;for(;n.LayerElementUV[r];)n.LayerElementUV[r].UV&&i.uv.push(this.parseUVs(n.LayerElementUV[r])),r++}return i.weightTable={},null!==r&&(i.skeleton=r,r.rawBones.forEach(function(n,r){// loop over the bone's vertex indices and weights
n.indices.forEach(function(a,s){void 0===i.weightTable[a]&&(i.weightTable[a]=[]),i.weightTable[a].push({id:r,weight:n.weights[s]})})})),i}genBuffers(n){let r={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]},i=0,a=0,s=!1,o=[],l=[],u=[],c=[],h=[],d=[],p=this;return n.vertexIndices.forEach(function(f,m){let g;let _=!1;f<0&&(f^=-1,_=!0);let y=[],b=[];if(o.push(3*f,3*f+1,3*f+2),n.color){let r=$04ef886a022e9ae8$var$getData(m,i,f,n.color);u.push(r[0],r[1],r[2])}if(n.skeleton){if(void 0!==n.weightTable[f]&&n.weightTable[f].forEach(function(n){b.push(n.weight),y.push(n.id)}),b.length>4){s||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),s=!0);let n=[0,0,0,0],r=[0,0,0,0];b.forEach(function(i,a){let s=i,o=y[a];r.forEach(function(r,i,a){if(s>r){a[i]=s,s=r;let l=n[i];n[i]=o,o=l}})}),y=n,b=r}// if the weight array is shorter than 4 pad with 0s
for(;b.length<4;)b.push(0),y.push(0);for(let n=0;n<4;++n)h.push(b[n]),d.push(y[n])}if(n.normal){let r=$04ef886a022e9ae8$var$getData(m,i,f,n.normal);l.push(r[0],r[1],r[2])}n.material&&"AllSame"!==n.material.mappingType&&(g=$04ef886a022e9ae8$var$getData(m,i,f,n.material)[0])<0&&(p.negativeMaterialIndices=!0,g=0),n.uv&&n.uv.forEach(function(n,r){let a=$04ef886a022e9ae8$var$getData(m,i,f,n);void 0===c[r]&&(c[r]=[]),c[r].push(a[0]),c[r].push(a[1])}),a++,_&&(a>4&&console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."),p.genFace(r,n,o,g,l,u,c,h,d,a),i++,a=0,// reset arrays for the next face
o=[],l=[],u=[],c=[],h=[],d=[])}),r}// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
genFace(n,r,i,a,s,o,l,u,c,h){for(let d=2;d<h;d++)n.vertex.push(r.vertexPositions[i[0]]),n.vertex.push(r.vertexPositions[i[1]]),n.vertex.push(r.vertexPositions[i[2]]),n.vertex.push(r.vertexPositions[i[(d-1)*3]]),n.vertex.push(r.vertexPositions[i[(d-1)*3+1]]),n.vertex.push(r.vertexPositions[i[(d-1)*3+2]]),n.vertex.push(r.vertexPositions[i[3*d]]),n.vertex.push(r.vertexPositions[i[3*d+1]]),n.vertex.push(r.vertexPositions[i[3*d+2]]),r.skeleton&&(n.vertexWeights.push(u[0]),n.vertexWeights.push(u[1]),n.vertexWeights.push(u[2]),n.vertexWeights.push(u[3]),n.vertexWeights.push(u[(d-1)*4]),n.vertexWeights.push(u[(d-1)*4+1]),n.vertexWeights.push(u[(d-1)*4+2]),n.vertexWeights.push(u[(d-1)*4+3]),n.vertexWeights.push(u[4*d]),n.vertexWeights.push(u[4*d+1]),n.vertexWeights.push(u[4*d+2]),n.vertexWeights.push(u[4*d+3]),n.weightsIndices.push(c[0]),n.weightsIndices.push(c[1]),n.weightsIndices.push(c[2]),n.weightsIndices.push(c[3]),n.weightsIndices.push(c[(d-1)*4]),n.weightsIndices.push(c[(d-1)*4+1]),n.weightsIndices.push(c[(d-1)*4+2]),n.weightsIndices.push(c[(d-1)*4+3]),n.weightsIndices.push(c[4*d]),n.weightsIndices.push(c[4*d+1]),n.weightsIndices.push(c[4*d+2]),n.weightsIndices.push(c[4*d+3])),r.color&&(n.colors.push(o[0]),n.colors.push(o[1]),n.colors.push(o[2]),n.colors.push(o[(d-1)*3]),n.colors.push(o[(d-1)*3+1]),n.colors.push(o[(d-1)*3+2]),n.colors.push(o[3*d]),n.colors.push(o[3*d+1]),n.colors.push(o[3*d+2])),r.material&&"AllSame"!==r.material.mappingType&&(n.materialIndex.push(a),n.materialIndex.push(a),n.materialIndex.push(a)),r.normal&&(n.normal.push(s[0]),n.normal.push(s[1]),n.normal.push(s[2]),n.normal.push(s[(d-1)*3]),n.normal.push(s[(d-1)*3+1]),n.normal.push(s[(d-1)*3+2]),n.normal.push(s[3*d]),n.normal.push(s[3*d+1]),n.normal.push(s[3*d+2])),r.uv&&r.uv.forEach(function(r,i){void 0===n.uvs[i]&&(n.uvs[i]=[]),n.uvs[i].push(l[i][0]),n.uvs[i].push(l[i][1]),n.uvs[i].push(l[i][(d-1)*2]),n.uvs[i].push(l[i][(d-1)*2+1]),n.uvs[i].push(l[i][2*d]),n.uvs[i].push(l[i][2*d+1])})}addMorphTargets(n,r,i,a){if(0===i.length)return;n.morphTargetsRelative=!0,n.morphAttributes.position=[];// parentGeo.morphAttributes.normal = []; // not implemented
let s=this;i.forEach(function(i){i.rawTargets.forEach(function(i){let o=$04ef886a022e9ae8$var$fbxTree.Objects.Geometry[i.geoID];void 0!==o&&s.genMorphGeometry(n,r,o,a,i.name)})})}// a morph geometry node is similar to a standard  node, and the node is also contained
// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
// and a special attribute Index defining which vertices of the original geometry are affected
// Normal and position attributes only have data for the vertices that are affected by the morph
genMorphGeometry(n,r,i,a,s){let o=void 0!==r.PolygonVertexIndex?r.PolygonVertexIndex.a:[],l=void 0!==i.Vertices?i.Vertices.a:[],u=void 0!==i.Indexes?i.Indexes.a:[],c=3*n.attributes.position.count,h=new Float32Array(c);for(let n=0;n<u.length;n++){let r=3*u[n];h[r]=l[3*n],h[r+1]=l[3*n+1],h[r+2]=l[3*n+2]}// TODO: add morph normal support
let d={vertexIndices:o,vertexPositions:h},p=this.genBuffers(d),f=new $d5b33d7c30034067$export$cbe7a62641830ebd(p.vertex,3);f.name=s||i.attrName,f.applyMatrix4(a),n.morphAttributes.position.push(f)}// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
parseNormals(n){let r=n.MappingInformationType,i=n.ReferenceInformationType,a=n.Normals.a,s=[];return"IndexToDirect"===i&&("NormalIndex"in n?s=n.NormalIndex.a:"NormalsIndex"in n&&(s=n.NormalsIndex.a)),{dataSize:3,buffer:a,indices:s,mappingType:r,referenceType:i}}// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
parseUVs(n){let r=n.MappingInformationType,i=n.ReferenceInformationType,a=n.UV.a,s=[];return"IndexToDirect"===i&&(s=n.UVIndex.a),{dataSize:2,buffer:a,indices:s,mappingType:r,referenceType:i}}// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
parseVertexColors(n){let r=n.MappingInformationType,i=n.ReferenceInformationType,a=n.Colors.a,s=[];"IndexToDirect"===i&&(s=n.ColorIndex.a);for(let n=0,r=new $d5b33d7c30034067$export$892596cec99bc70e;n<a.length;n+=4)r.fromArray(a,n).convertSRGBToLinear().toArray(a,n);return{dataSize:4,buffer:a,indices:s,mappingType:r,referenceType:i}}// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
parseMaterialIndices(n){let r=n.MappingInformationType,i=n.ReferenceInformationType;if("NoMappingInformation"===r)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:i};let a=n.Materials.a,s=[];for(let n=0;n<a.length;++n)s.push(n);return{dataSize:1,buffer:a,indices:s,mappingType:r,referenceType:i}}// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
parseNurbsGeometry(n){let r,i;let a=parseInt(n.Order);if(isNaN(a))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",n.Order,n.id),new $d5b33d7c30034067$export$b7be63a67df8959;let s=a-1,o=n.KnotVector.a,l=[],u=n.Points.a;for(let n=0,r=u.length;n<r;n+=4)l.push(new $d5b33d7c30034067$export$fa7daccca11cdbe3().fromArray(u,n));if("Closed"===n.Form)l.push(l[0]);else if("Periodic"===n.Form){r=s,i=o.length-1-r;for(let n=0;n<s;++n)l.push(l[n])}let c=new $94b07e67f83726ad$export$12efb26d7429b049(s,o,l,r,i),h=c.getPoints(12*l.length);return new $d5b33d7c30034067$export$b7be63a67df8959().setFromPoints(h)}}// parse animation data from FBXTree
class $04ef886a022e9ae8$var$AnimationParser{// take raw animation clips and turn them into three.js animation clips
parse(){let n=[],r=this.parseClips();if(void 0!==r)for(let i in r){let a=r[i],s=this.addClip(a);n.push(s)}return n}parseClips(){// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,
// if this is undefined we can safely assume there are no animations
if(void 0===$04ef886a022e9ae8$var$fbxTree.Objects.AnimationCurve)return;let n=this.parseAnimationCurveNodes();this.parseAnimationCurves(n);let r=this.parseAnimationLayers(n),i=this.parseAnimStacks(r);return i}// parse nodes in FBXTree.Objects.AnimationCurveNode
// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
// and is referenced by an AnimationLayer
parseAnimationCurveNodes(){let n=$04ef886a022e9ae8$var$fbxTree.Objects.AnimationCurveNode,r=new Map;for(let i in n){let a=n[i];if(null!==a.attrName.match(/S|R|T|DeformPercent/)){let n={id:a.id,attr:a.attrName,curves:{}};r.set(n.id,n)}}return r}// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
// axis ( e.g. times and values of x rotation)
parseAnimationCurves(n){let r=$04ef886a022e9ae8$var$fbxTree.Objects.AnimationCurve;// TODO: Many values are identical up to roundoff error, but won't be optimised
// e.g. position times: [0, 0.4, 0. 8]
// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]
// clearly, this should be optimised to
// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]
// this shows up in nearly every FBX file, and generally time array is length > 100
for(let i in r){let a={id:r[i].id,times:r[i].KeyTime.a.map($04ef886a022e9ae8$var$convertFBXTimeToSeconds),values:r[i].KeyValueFloat.a},s=$04ef886a022e9ae8$var$connections.get(a.id);if(void 0!==s){let r=s.parents[0].ID,i=s.parents[0].relationship;i.match(/X/)?n.get(r).curves.x=a:i.match(/Y/)?n.get(r).curves.y=a:i.match(/Z/)?n.get(r).curves.z=a:i.match(/DeformPercent/)&&n.has(r)&&(n.get(r).curves.morph=a)}}}// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
// to various AnimationCurveNodes and is referenced by an AnimationStack node
// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
parseAnimationLayers(n){let r=$04ef886a022e9ae8$var$fbxTree.Objects.AnimationLayer,i=new Map;for(let a in r){let r=[],s=$04ef886a022e9ae8$var$connections.get(parseInt(a));if(void 0!==s){// all the animationCurveNodes used in the layer
let o=s.children;o.forEach(function(i,a){if(n.has(i.ID)){let s=n.get(i.ID);// check that the curves are defined for at least one axis, otherwise ignore the curveNode
if(void 0!==s.curves.x||void 0!==s.curves.y||void 0!==s.curves.z){if(void 0===r[a]){let n=$04ef886a022e9ae8$var$connections.get(i.ID).parents.filter(function(n){return void 0!==n.relationship})[0].ID;if(void 0!==n){let s=$04ef886a022e9ae8$var$fbxTree.Objects.Model[n.toString()];if(void 0===s){console.warn("THREE.FBXLoader: Encountered a unused curve.",i);return}let o={modelName:s.attrName?$d5b33d7c30034067$export$7bf70fcf9f891893.sanitizeNodeName(s.attrName):"",ID:s.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};$04ef886a022e9ae8$var$sceneGraph.traverse(function(n){n.ID===s.id&&(o.transform=n.matrix,n.userData.transformData&&(o.eulerOrder=n.userData.transformData.eulerOrder))}),o.transform||(o.transform=new $d5b33d7c30034067$export$2ae72fc923e5eb5),"PreRotation"in s&&(o.preRotation=s.PreRotation.value),"PostRotation"in s&&(o.postRotation=s.PostRotation.value),r[a]=o}}r[a]&&(r[a][s.attr]=s)}else if(void 0!==s.curves.morph){if(void 0===r[a]){let n=$04ef886a022e9ae8$var$connections.get(i.ID).parents.filter(function(n){return void 0!==n.relationship})[0].ID,s=$04ef886a022e9ae8$var$connections.get(n).parents[0].ID,o=$04ef886a022e9ae8$var$connections.get(s).parents[0].ID,l=$04ef886a022e9ae8$var$connections.get(o).parents[0].ID,u=$04ef886a022e9ae8$var$fbxTree.Objects.Model[l],c={modelName:u.attrName?$d5b33d7c30034067$export$7bf70fcf9f891893.sanitizeNodeName(u.attrName):"",morphName:$04ef886a022e9ae8$var$fbxTree.Objects.Deformer[n].attrName};r[a]=c}r[a][s.attr]=s}}}),i.set(parseInt(a),r)}}return i}// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
// hierarchy. Each Stack node will be used to create a AnimationClip
parseAnimStacks(n){let r=$04ef886a022e9ae8$var$fbxTree.Objects.AnimationStack,i={};for(let a in r){let s=$04ef886a022e9ae8$var$connections.get(parseInt(a)).children;s.length>1&&// where there are multiple layers per stack, we'll display a warning
console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");let o=n.get(s[0].ID);i[a]={name:r[a].attrName,layer:o}}return i}addClip(n){let r=[],i=this;return n.layer.forEach(function(n){r=r.concat(i.generateTracks(n))}),new $d5b33d7c30034067$export$d942c706bf23829c(n.name,-1,r)}generateTracks(n){let r=[],i=new $d5b33d7c30034067$export$64b5c384219d3699,a=new $d5b33d7c30034067$export$23d6a54f0bbc85a3,s=new $d5b33d7c30034067$export$64b5c384219d3699;if(n.transform&&n.transform.decompose(i,a,s),i=i.toArray(),a=new $d5b33d7c30034067$export$d93cc409a0768c5f().setFromQuaternion(a,n.eulerOrder).toArray(),s=s.toArray(),void 0!==n.T&&Object.keys(n.T.curves).length>0){let a=this.generateVectorTrack(n.modelName,n.T.curves,i,"position");void 0!==a&&r.push(a)}if(void 0!==n.R&&Object.keys(n.R.curves).length>0){let i=this.generateRotationTrack(n.modelName,n.R.curves,a,n.preRotation,n.postRotation,n.eulerOrder);void 0!==i&&r.push(i)}if(void 0!==n.S&&Object.keys(n.S.curves).length>0){let i=this.generateVectorTrack(n.modelName,n.S.curves,s,"scale");void 0!==i&&r.push(i)}if(void 0!==n.DeformPercent){let i=this.generateMorphTrack(n);void 0!==i&&r.push(i)}return r}generateVectorTrack(n,r,i,a){let s=this.getTimesForAllAxes(r),o=this.getKeyframeTrackValues(s,r,i);return new $d5b33d7c30034067$export$5ce2dcb4cc9f2bff(n+"."+a,s,o)}generateRotationTrack(n,r,i,a,s,o){void 0!==r.x&&(this.interpolateRotations(r.x),r.x.values=r.x.values.map($d5b33d7c30034067$export$6a7ef315a0d1ef07.degToRad)),void 0!==r.y&&(this.interpolateRotations(r.y),r.y.values=r.y.values.map($d5b33d7c30034067$export$6a7ef315a0d1ef07.degToRad)),void 0!==r.z&&(this.interpolateRotations(r.z),r.z.values=r.z.values.map($d5b33d7c30034067$export$6a7ef315a0d1ef07.degToRad));let l=this.getTimesForAllAxes(r),u=this.getKeyframeTrackValues(l,r,i);void 0!==a&&((a=a.map($d5b33d7c30034067$export$6a7ef315a0d1ef07.degToRad)).push(o),a=new $d5b33d7c30034067$export$d93cc409a0768c5f().fromArray(a),a=new $d5b33d7c30034067$export$23d6a54f0bbc85a3().setFromEuler(a)),void 0!==s&&((s=s.map($d5b33d7c30034067$export$6a7ef315a0d1ef07.degToRad)).push(o),s=new $d5b33d7c30034067$export$d93cc409a0768c5f().fromArray(s),s=new $d5b33d7c30034067$export$23d6a54f0bbc85a3().setFromEuler(s).invert());let c=new $d5b33d7c30034067$export$23d6a54f0bbc85a3,h=new $d5b33d7c30034067$export$d93cc409a0768c5f,d=[];for(let n=0;n<u.length;n+=3)h.set(u[n],u[n+1],u[n+2],o),c.setFromEuler(h),void 0!==a&&c.premultiply(a),void 0!==s&&c.multiply(s),c.toArray(d,n/3*4);return new $d5b33d7c30034067$export$b8043f12b5aafbd7(n+".quaternion",l,d)}generateMorphTrack(n){let r=n.DeformPercent.curves.morph,i=r.values.map(function(n){return n/100}),a=$04ef886a022e9ae8$var$sceneGraph.getObjectByName(n.modelName).morphTargetDictionary[n.morphName];return new $d5b33d7c30034067$export$d45f0d1a4d9a9314(n.modelName+".morphTargetInfluences["+a+"]",r.times,i)}// For all animated objects, times are defined separately for each axis
// Here we'll combine the times into one sorted array without duplicates
getTimesForAllAxes(n){let r=[];// and remove duplicates
if(void 0!==n.x&&(r=r.concat(n.x.times)),void 0!==n.y&&(r=r.concat(n.y.times)),void 0!==n.z&&(r=r.concat(n.z.times)),// then sort them
(r=r.sort(function(n,r){return n-r})).length>1){let n=1,i=r[0];for(let a=1;a<r.length;a++){let s=r[a];s!==i&&(r[n]=s,i=s,n++)}r=r.slice(0,n)}return r}getKeyframeTrackValues(n,r,i){let a=i,s=[],o=-1,l=-1,u=-1;return n.forEach(function(n){// if there is an x value defined for this frame, use that
if(r.x&&(o=r.x.times.indexOf(n)),r.y&&(l=r.y.times.indexOf(n)),r.z&&(u=r.z.times.indexOf(n)),-1!==o){let n=r.x.values[o];s.push(n),a[0]=n}else s.push(a[0]);if(-1!==l){let n=r.y.values[l];s.push(n),a[1]=n}else s.push(a[1]);if(-1!==u){let n=r.z.values[u];s.push(n),a[2]=n}else s.push(a[2])}),s}// Rotations are defined as Euler angles which can have values  of any size
// These will be converted to quaternions which don't support values greater than
// PI, so we'll interpolate large rotations
interpolateRotations(n){for(let r=1;r<n.values.length;r++){let i=n.values[r-1],a=n.values[r]-i,s=Math.abs(a);if(s>=180){let o=s/180,l=a/o,u=i+l,c=n.times[r-1],h=n.times[r]-c,d=h/o,p=c+d,f=[],m=[];for(;p<n.times[r];)f.push(p),p+=d,m.push(u),u+=l;n.times=$04ef886a022e9ae8$var$inject(n.times,r,f),n.values=$04ef886a022e9ae8$var$inject(n.values,r,m)}}}}// parse an FBX file in ASCII format
class $04ef886a022e9ae8$var$TextParser{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(n){this.nodeStack.push(n),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(n,r){this.currentProp=n,this.currentPropName=r}parse(n){this.currentIndent=0,this.allNodes=new $04ef886a022e9ae8$var$FBXTree,this.nodeStack=[],this.currentProp=[],this.currentPropName="";let r=this,i=n.split(/[\r\n]+/);return i.forEach(function(n,a){let s=n.match(/^[\s\t]*;/),o=n.match(/^[\s\t]*$/);if(s||o)return;let l=n.match("^\\t{"+r.currentIndent+"}(\\w+):(.*){",""),u=n.match("^\\t{"+r.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),c=n.match("^\\t{"+(r.currentIndent-1)+"}}");l?r.parseNodeBegin(n,l):u?r.parseNodeProperty(n,u,i[++a]):c?r.popStack():n.match(/^[^\s\t}]/)&&// if this is encountered the line needs to be joined to the previous line
r.parseNodePropertyContinued(n)}),this.allNodes}parseNodeBegin(n,r){let i=r[1].trim().replace(/^"/,"").replace(/"$/,""),a=r[2].split(",").map(function(n){return n.trim().replace(/^"/,"").replace(/"$/,"")}),s={name:i},o=this.parseNodeAttr(a),l=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(i,s):i in l?("PoseNode"===i?l.PoseNode.push(s):void 0!==l[i].id&&(l[i]={},l[i][l[i].id]=l[i]),""!==o.id&&(l[i][o.id]=s)):"number"==typeof o.id?(l[i]={},l[i][o.id]=s):"Properties70"!==i&&("PoseNode"===i?l[i]=[s]:l[i]=s),"number"==typeof o.id&&(s.id=o.id),""!==o.name&&(s.attrName=o.name),""!==o.type&&(s.attrType=o.type),this.pushStack(s)}parseNodeAttr(n){let r=n[0];""!==n[0]&&isNaN(r=parseInt(n[0]))&&(r=n[0]);let i="",a="";return n.length>1&&(i=n[1].replace(/^(\w+)::/,""),a=n[2]),{id:r,name:i,type:a}}parseNodeProperty(n,r,i){let a=r[1].replace(/^"/,"").replace(/"$/,"").trim(),s=r[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===a&&","===s&&(s=i.replace(/"/g,"").replace(/,$/,"").trim());let o=this.getCurrentNode(),l=o.name;if("Properties70"===l){this.parseNodeSpecialProperty(n,a,s);return}// Connections
if("C"===a){let n=s.split(",").slice(1),r=parseInt(n[0]),i=parseInt(n[1]),l=s.split(",").slice(3);l=l.map(function(n){return n.trim().replace(/^"/,"")}),a="connections",$04ef886a022e9ae8$var$append(s=[r,i],l),void 0===o[a]&&(o[a]=[])}"Node"===a&&(o.id=s),a in o&&Array.isArray(o[a])?o[a].push(s):"a"!==a?o[a]=s:o.a=s,this.setCurrentProp(o,a),"a"===a&&","!==s.slice(-1)&&(o.a=$04ef886a022e9ae8$var$parseNumberArray(s))}parseNodePropertyContinued(n){let r=this.getCurrentNode();r.a+=n,","!==n.slice(-1)&&(r.a=$04ef886a022e9ae8$var$parseNumberArray(r.a))}// parse "Property70"
parseNodeSpecialProperty(n,r,i){// split this
// P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
// into array like below
// ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
let a=i.split('",').map(function(n){return n.trim().replace(/^\"/,"").replace(/\s/,"_")}),s=a[0],o=a[1],l=a[2],u=a[3],c=a[4];// cast values where needed, otherwise leave as strings
switch(o){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=$04ef886a022e9ae8$var$parseNumberArray(c)}// CAUTION: these props must append to parent's parent
this.getPrevNode()[s]={type:o,type2:l,flag:u,value:c},this.setCurrentProp(this.getPrevNode(),s)}}// Parse an FBX file in Binary format
class $04ef886a022e9ae8$var$BinaryParser{parse(n){let r=new $04ef886a022e9ae8$var$BinaryReader(n);r.skip(23);// skip magic 23 bytes
let i=r.getUint32();if(i<6400)throw Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+i);let a=new $04ef886a022e9ae8$var$FBXTree;for(;!this.endOfContent(r);){let n=this.parseNode(r,i);null!==n&&a.add(n.name,n)}return a}// Check if reader has reached the end of content.
endOfContent(n){return(// footer size: 160bytes + 16-byte alignment padding
// - 16bytes: magic
// - padding til 16-byte alignment (at least 1byte?)
//	(seems like some exporters embed fixed 15 or 16bytes?)
// - 4bytes: magic
// - 4bytes: version
// - 120bytes: zero
// - 16bytes: magic
n.size()%16==0?(n.getOffset()+160+16&-16)>=n.size():n.getOffset()+160+16>=n.size())}// recursively parse nodes until the end of the file is reached
parseNode(n,r){let i={},a=r>=7500?n.getUint64():n.getUint32(),s=r>=7500?n.getUint64():n.getUint32();r>=7500?n.getUint64():n.getUint32();let o=n.getUint8(),l=n.getString(o);// Regards this node as NULL-record if endOffset is zero
if(0===a)return null;let u=[];for(let r=0;r<s;r++)u.push(this.parseProperty(n));// Regards the first three elements in propertyList as id, attrName, and attrType
let c=u.length>0?u[0]:"",h=u.length>1?u[1]:"",d=u.length>2?u[2]:"";for(// check if this node represents just a single property
// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
i.singleProperty=1===s&&n.getOffset()===a;a>n.getOffset();){let a=this.parseNode(n,r);null!==a&&this.parseSubNode(l,i,a)}return i.propertyList=u,"number"==typeof c&&(i.id=c),""!==h&&(i.attrName=h),""!==d&&(i.attrType=d),""!==l&&(i.name=l),i}parseSubNode(n,r,i){// special case: child node is single property
if(!0===i.singleProperty){let n=i.propertyList[0];Array.isArray(n)?(r[i.name]=i,i.a=n):r[i.name]=n}else if("Connections"===n&&"C"===i.name){let n=[];i.propertyList.forEach(function(r,i){// first Connection is FBX type (OO, OP, etc.). We'll discard these
0!==i&&n.push(r)}),void 0===r.connections&&(r.connections=[]),r.connections.push(n)}else if("Properties70"===i.name){let n=Object.keys(i);n.forEach(function(n){r[n]=i[n]})}else if("Properties70"===n&&"P"===i.name){let n,a=i.propertyList[0],s=i.propertyList[1],o=i.propertyList[2],l=i.propertyList[3];0===a.indexOf("Lcl ")&&(a=a.replace("Lcl ","Lcl_")),0===s.indexOf("Lcl ")&&(s=s.replace("Lcl ","Lcl_")),n="Color"===s||"ColorRGB"===s||"Vector"===s||"Vector3D"===s||0===s.indexOf("Lcl_")?[i.propertyList[4],i.propertyList[5],i.propertyList[6]]:i.propertyList[4],// this will be copied to parent, see above
r[a]={type:s,type2:o,flag:l,value:n}}else void 0===r[i.name]?"number"==typeof i.id?(r[i.name]={},r[i.name][i.id]=i):r[i.name]=i:"PoseNode"===i.name?(Array.isArray(r[i.name])||(r[i.name]=[r[i.name]]),r[i.name].push(i)):void 0===r[i.name][i.id]&&(r[i.name][i.id]=i)}parseProperty(n){let r;let i=n.getString(1);switch(i){case"C":return n.getBoolean();case"D":return n.getFloat64();case"F":return n.getFloat32();case"I":return n.getInt32();case"L":return n.getInt64();case"R":return r=n.getUint32(),n.getArrayBuffer(r);case"S":return r=n.getUint32(),n.getString(r);case"Y":return n.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":let a=n.getUint32(),s=n.getUint32(),o=n.getUint32();if(0===s)switch(i){case"b":case"c":return n.getBooleanArray(a);case"d":return n.getFloat64Array(a);case"f":return n.getFloat32Array(a);case"i":return n.getInt32Array(a);case"l":return n.getInt64Array(a)}let l=$53691bda533d12d0$export$9ec8134f0f1b9fc6(new Uint8Array(n.getArrayBuffer(o))),u=new $04ef886a022e9ae8$var$BinaryReader(l.buffer);switch(i){case"b":case"c":return u.getBooleanArray(a);case"d":return u.getFloat64Array(a);case"f":return u.getFloat32Array(a);case"i":return u.getInt32Array(a);case"l":return u.getInt64Array(a)}break;// cannot happen but is required by the DeepScan
default:throw Error("THREE.FBXLoader: Unknown property type "+i)}}}class $04ef886a022e9ae8$var$BinaryReader{constructor(n,r){this.dv=new DataView(n),this.offset=0,this.littleEndian=void 0===r||r,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(n){this.offset+=n}// seems like true/false representation depends on exporter.
// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
// then sees LSB.
getBoolean(){return(1&this.getUint8())==1}getBooleanArray(n){let r=[];for(let i=0;i<n;i++)r.push(this.getBoolean());return r}getUint8(){let n=this.dv.getUint8(this.offset);return this.offset+=1,n}getInt16(){let n=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,n}getInt32(){let n=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,n}getInt32Array(n){let r=[];for(let i=0;i<n;i++)r.push(this.getInt32());return r}getUint32(){let n=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,n}// JavaScript doesn't support 64-bit integer so calculate this here
// 1 << 32 will return 1 so using multiply operation instead here.
// There's a possibility that this method returns wrong value if the value
// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
// TODO: safely handle 64-bit integer
getInt64(){let n,r;return(// calculate negative value
(this.littleEndian?(n=this.getUint32(),r=this.getUint32()):(r=this.getUint32(),n=this.getUint32()),2147483648&r)?(r=4294967295&~r,4294967295==(n=4294967295&~n)&&(r=r+1&4294967295),-(4294967296*r+(n=n+1&4294967295))):4294967296*r+n)}getInt64Array(n){let r=[];for(let i=0;i<n;i++)r.push(this.getInt64());return r}// Note: see getInt64() comment
getUint64(){let n,r;return this.littleEndian?(n=this.getUint32(),r=this.getUint32()):(r=this.getUint32(),n=this.getUint32()),4294967296*r+n}getFloat32(){let n=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,n}getFloat32Array(n){let r=[];for(let i=0;i<n;i++)r.push(this.getFloat32());return r}getFloat64(){let n=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,n}getFloat64Array(n){let r=[];for(let i=0;i<n;i++)r.push(this.getFloat64());return r}getArrayBuffer(n){let r=this.dv.buffer.slice(this.offset,this.offset+n);return this.offset+=n,r}getString(n){let r=this.offset,i=new Uint8Array(this.dv.buffer,r,n);this.skip(n);let a=i.indexOf(0);return a>=0&&(i=new Uint8Array(this.dv.buffer,r,a)),this._textDecoder.decode(i)}}// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)
// and BinaryParser( FBX Binary format)
class $04ef886a022e9ae8$var$FBXTree{add(n,r){this[n]=r}}// ************** UTILITY FUNCTIONS **************
function $04ef886a022e9ae8$var$isFbxFormatBinary(n){let r="Kaydara FBX Binary  \x00";return n.byteLength>=r.length&&r===$04ef886a022e9ae8$var$convertArrayBufferToString(n,0,r.length)}function $04ef886a022e9ae8$var$isFbxFormatASCII(n){let r=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"],i=0;function a(r){let a=n[r-1];return n=n.slice(i+r),i++,a}for(let n=0;n<r.length;++n){let i=a(1);if(i===r[n])return!1}return!0}function $04ef886a022e9ae8$var$getFbxVersion(n){let r=/FBXVersion: (\d+)/,i=n.match(r);if(i){let n=parseInt(i[1]);return n}throw Error("THREE.FBXLoader: Cannot find the version number for the file given.")}// Converts FBX ticks into real time seconds.
function $04ef886a022e9ae8$var$convertFBXTimeToSeconds(n){return n/46186158e3}const $04ef886a022e9ae8$var$dataArray=[];// extracts the data from the correct position in the FBX array based on indexing type
function $04ef886a022e9ae8$var$getData(n,r,i,a){let s;switch(a.mappingType){case"ByPolygonVertex":s=n;break;case"ByPolygon":s=r;break;case"ByVertice":s=i;break;case"AllSame":s=a.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+a.mappingType)}"IndexToDirect"===a.referenceType&&(s=a.indices[s]);let o=s*a.dataSize,l=o+a.dataSize;return $04ef886a022e9ae8$var$slice($04ef886a022e9ae8$var$dataArray,a.buffer,o,l)}const $04ef886a022e9ae8$var$tempEuler=new $d5b33d7c30034067$export$d93cc409a0768c5f,$04ef886a022e9ae8$var$tempVec=new $d5b33d7c30034067$export$64b5c384219d3699;// generate transformation from FBX transform data
// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm
// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e
function $04ef886a022e9ae8$var$generateTransform(n){let r=new $d5b33d7c30034067$export$2ae72fc923e5eb5,i=new $d5b33d7c30034067$export$2ae72fc923e5eb5,a=new $d5b33d7c30034067$export$2ae72fc923e5eb5,s=new $d5b33d7c30034067$export$2ae72fc923e5eb5,o=new $d5b33d7c30034067$export$2ae72fc923e5eb5,l=new $d5b33d7c30034067$export$2ae72fc923e5eb5,u=new $d5b33d7c30034067$export$2ae72fc923e5eb5,c=new $d5b33d7c30034067$export$2ae72fc923e5eb5,h=new $d5b33d7c30034067$export$2ae72fc923e5eb5,d=new $d5b33d7c30034067$export$2ae72fc923e5eb5,p=new $d5b33d7c30034067$export$2ae72fc923e5eb5,f=new $d5b33d7c30034067$export$2ae72fc923e5eb5,m=n.inheritType?n.inheritType:0;if(n.translation&&r.setPosition($04ef886a022e9ae8$var$tempVec.fromArray(n.translation)),n.preRotation){let r=n.preRotation.map($d5b33d7c30034067$export$6a7ef315a0d1ef07.degToRad);r.push(n.eulerOrder||$d5b33d7c30034067$export$d93cc409a0768c5f.DEFAULT_ORDER),i.makeRotationFromEuler($04ef886a022e9ae8$var$tempEuler.fromArray(r))}if(n.rotation){let r=n.rotation.map($d5b33d7c30034067$export$6a7ef315a0d1ef07.degToRad);r.push(n.eulerOrder||$d5b33d7c30034067$export$d93cc409a0768c5f.DEFAULT_ORDER),a.makeRotationFromEuler($04ef886a022e9ae8$var$tempEuler.fromArray(r))}if(n.postRotation){let r=n.postRotation.map($d5b33d7c30034067$export$6a7ef315a0d1ef07.degToRad);r.push(n.eulerOrder||$d5b33d7c30034067$export$d93cc409a0768c5f.DEFAULT_ORDER),s.makeRotationFromEuler($04ef886a022e9ae8$var$tempEuler.fromArray(r)),s.invert()}n.scale&&o.scale($04ef886a022e9ae8$var$tempVec.fromArray(n.scale)),n.scalingOffset&&u.setPosition($04ef886a022e9ae8$var$tempVec.fromArray(n.scalingOffset)),n.scalingPivot&&l.setPosition($04ef886a022e9ae8$var$tempVec.fromArray(n.scalingPivot)),n.rotationOffset&&c.setPosition($04ef886a022e9ae8$var$tempVec.fromArray(n.rotationOffset)),n.rotationPivot&&h.setPosition($04ef886a022e9ae8$var$tempVec.fromArray(n.rotationPivot)),n.parentMatrixWorld&&(p.copy(n.parentMatrix),d.copy(n.parentMatrixWorld));let g=i.clone().multiply(a).multiply(s),_=new $d5b33d7c30034067$export$2ae72fc923e5eb5;_.extractRotation(d);// Global Shear*Scaling
let y=new $d5b33d7c30034067$export$2ae72fc923e5eb5;y.copyPosition(d);let b=y.clone().invert().multiply(d),v=_.clone().invert().multiply(b),x=o,w=new $d5b33d7c30034067$export$2ae72fc923e5eb5;if(0===m)w.copy(_).multiply(g).multiply(v).multiply(x);else if(1===m)w.copy(_).multiply(v).multiply(g).multiply(x);else{let n=new $d5b33d7c30034067$export$2ae72fc923e5eb5().scale(new $d5b33d7c30034067$export$64b5c384219d3699().setFromMatrixScale(p)),r=n.clone().invert(),i=v.clone().multiply(r);w.copy(_).multiply(g).multiply(i).multiply(x)}let T=h.clone().invert(),S=l.clone().invert(),E=r.clone().multiply(c).multiply(h).multiply(i).multiply(a).multiply(s).multiply(T).multiply(u).multiply(l).multiply(o).multiply(S),A=new $d5b33d7c30034067$export$2ae72fc923e5eb5().copyPosition(E),M=d.clone().multiply(A);return f.copyPosition(M),// from global to local
(E=f.clone().multiply(w)).premultiply(d.invert()),E}// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order
// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html
function $04ef886a022e9ae8$var$getEulerOrder(n){n=n||0;let r=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===n?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),r[0]):r[n]}// Parses comma separated list of numbers and returns them an array.
// Used internally by the TextParser
function $04ef886a022e9ae8$var$parseNumberArray(n){let r=n.split(",").map(function(n){return parseFloat(n)});return r}function $04ef886a022e9ae8$var$convertArrayBufferToString(n,r,i){return void 0===r&&(r=0),void 0===i&&(i=n.byteLength),new TextDecoder().decode(new Uint8Array(n,r,i))}function $04ef886a022e9ae8$var$append(n,r){for(let i=0,a=n.length,s=r.length;i<s;i++,a++)n[a]=r[i]}function $04ef886a022e9ae8$var$slice(n,r,i,a){for(let s=i,o=0;s<a;s++,o++)n[o]=r[s];return n}// inject array a2 into array a1 at index
function $04ef886a022e9ae8$var$inject(n,r,i){return n.slice(0,r).concat(i).concat(n.slice(r))}function $7c432a5c23fdd3a1$var$addModelToScene(n,r){r.add(n);// Remove loading spinner
let i=document.querySelector(".spinner-border");i.parentNode.removeChild(i);// Show form
let a=document.getElementById("content");a.style.visibility="visible"}function $7c432a5c23fdd3a1$export$7ae28b8722707c61(n){let r=new $d5b33d7c30034067$export$99cc795e99919eed;r.onLoad=()=>{console.log("Loading complete!")};let i=new $559434fcc6e6401d$export$aa93f11e7884f0f4(r);i.load($ba30e20475feac5a$export$e506a1d27d1eaa20.AVATAR_PATH,r=>{($7c432a5c23fdd3a1$var$model=r.scene).position.set(0,-1.5,0),$7c432a5c23fdd3a1$var$model.traverse(n=>{n.isMesh&&(n.castShadow=!0,n.receiveShadow=!0,n.material.map&&(n.material.map.anisotropy=16))}),// Create an AnimationMixer, and get the list of AnimationClip instances
$7c432a5c23fdd3a1$var$mixer=new $d5b33d7c30034067$export$fbd77e5aefaa0102($7c432a5c23fdd3a1$var$model);// Load the idle animation
let i=new $04ef886a022e9ae8$export$60c52e42bb04b96;i.load(`${$ba30e20475feac5a$export$e506a1d27d1eaa20.ANIMATIONS_PATH}/idle.fbx`,r=>{let i=$7c432a5c23fdd3a1$var$mixer.clipAction(r.animations[0]);i.play(),$7c432a5c23fdd3a1$var$addModelToScene($7c432a5c23fdd3a1$var$model,n)});// Get eyes
let a=$7c432a5c23fdd3a1$var$model.getObjectByName("Hips").getObjectByName("Spine").children[0].children[0];$7c432a5c23fdd3a1$var$leftEye=a.getObjectByName("Neck").getObjectByName("Head").getObjectByName("LeftEye"),$7c432a5c23fdd3a1$var$rightEye=a.getObjectByName("Neck").getObjectByName("Head").getObjectByName("RightEye"),// Setup blinking eyes
$7c432a5c23fdd3a1$var$startBlinkingEyes()})}function $7c432a5c23fdd3a1$var$startBlinkingEyes(){let n=$7c432a5c23fdd3a1$var$model.getObjectByName("Wolf3D_Head");if(!n)return;let r=n.morphTargetDictionary.eyeBlinkLeft,i=n.morphTargetDictionary.eyeBlinkRight;if(void 0===r||void 0===i)return;n.morphTargetInfluences[r]=1,n.morphTargetInfluences[i]=1;let a=100*Math.random()+100;setTimeout(()=>{n.morphTargetInfluences[r]=0,n.morphTargetInfluences[i]=0,setTimeout($7c432a5c23fdd3a1$var$startBlinkingEyes,4e3*Math.random()+1e3)},a)}/**
 * Plays an audio file and loads its corresponding mouth cues.
 * @param {string} filename - The name of the audio file to play.
 */function $7c432a5c23fdd3a1$export$96ad37876925c7e6(n,r){// Play audio
($7c432a5c23fdd3a1$var$audio=new Audio(`${$ba30e20475feac5a$export$e506a1d27d1eaa20.AUDIOS_PATH}/${n}.ogg`)).play();// Load mouth cues
let i=new $d5b33d7c30034067$export$98435a25b5cf7b2b;i.load(`${$ba30e20475feac5a$export$e506a1d27d1eaa20.AUDIOS_PATH}/${n}.json`,n=>{$7c432a5c23fdd3a1$var$mouthCues=JSON.parse(n).mouthCues}),// Reset mouth when audio ends
$7c432a5c23fdd3a1$var$audio.onended=()=>{$7c432a5c23fdd3a1$var$audio=null,$7c432a5c23fdd3a1$var$mouthCues=null,$7c432a5c23fdd3a1$var$resetMouth(),r&&r()}}function $7c432a5c23fdd3a1$var$resetMouth(){let n=$7c432a5c23fdd3a1$var$model.getObjectByName("Wolf3D_Head"),r=$7c432a5c23fdd3a1$var$model.getObjectByName("Wolf3D_Teeth"),i=$ba30e20475feac5a$export$e506a1d27d1eaa20.LIPSYNC_CORRESPONDENCE.default;n.morphTargetInfluences=i.concat(n.morphTargetInfluences.slice(-2)),r.morphTargetInfluences=i.concat(r.morphTargetInfluences.slice(-2))}function $7c432a5c23fdd3a1$var$lookAtCamera(n){let r=.1,i=Math.PI/8;if($7c432a5c23fdd3a1$var$leftEye&&$7c432a5c23fdd3a1$var$rightEye){let a=n.position.clone();$7c432a5c23fdd3a1$var$leftEye.lookAt(a),$7c432a5c23fdd3a1$var$rightEye.lookAt(a),// add opening
$7c432a5c23fdd3a1$var$leftEye.rotation.y+=r,$7c432a5c23fdd3a1$var$rightEye.rotation.y-=r,$7c432a5c23fdd3a1$var$leftEye.rotation.y=Math.max(-i,Math.min(i,$7c432a5c23fdd3a1$var$leftEye.rotation.y)),$7c432a5c23fdd3a1$var$rightEye.rotation.y=Math.max(-i,Math.min(i,$7c432a5c23fdd3a1$var$rightEye.rotation.y)),$7c432a5c23fdd3a1$var$leftEye.rotation.x=Math.max(-i,Math.min(i,$7c432a5c23fdd3a1$var$leftEye.rotation.x)),$7c432a5c23fdd3a1$var$rightEye.rotation.x=Math.max(-i,Math.min(i,$7c432a5c23fdd3a1$var$rightEye.rotation.x))}}/**
 * Calculates the new target influences for the mouth based on the current and next mouth cues.
 * @param {Object} currentCue - The current mouth cue.
 * @param {Object} nextCue - The next mouth cue.
 * @returns {Array} An array of new target influences for the mouth.
 */function $7c432a5c23fdd3a1$var$calculateNewTargetInfluences(n,r){// Calculate progress between current and next cue
let i=($7c432a5c23fdd3a1$var$audio.currentTime-n.start)/(n.end-n.start),a=$ba30e20475feac5a$export$e506a1d27d1eaa20.LIPSYNC_CORRESPONDENCE[n.value],s=$ba30e20475feac5a$export$e506a1d27d1eaa20.LIPSYNC_CORRESPONDENCE[r.value],o=a.map((n,r)=>(n+(s[r]-n)*i)*$ba30e20475feac5a$export$e506a1d27d1eaa20.MOTION_AMPLITUDE);return o}/**
 * Processes the lip sync for the current audio cue.
 */function $7c432a5c23fdd3a1$var$processLipSync(){let n=null,r=null;// Find the current and next cue based on the current audio time
for(let i of $7c432a5c23fdd3a1$var$mouthCues)if($7c432a5c23fdd3a1$var$audio.currentTime>=i.start&&$7c432a5c23fdd3a1$var$audio.currentTime<=i.end){n=i,r=$7c432a5c23fdd3a1$var$mouthCues[Math.min($7c432a5c23fdd3a1$var$mouthCues.indexOf(i)+1,$7c432a5c23fdd3a1$var$mouthCues.length-1)];break}// Update the morph target influences for the head and teeth meshes
if(n){let i=$7c432a5c23fdd3a1$var$model.getObjectByName("Wolf3D_Head"),a=$7c432a5c23fdd3a1$var$model.getObjectByName("Wolf3D_Teeth");if(i&&a){let s=$7c432a5c23fdd3a1$var$calculateNewTargetInfluences(n,r);i.morphTargetInfluences=s.concat(i.morphTargetInfluences.slice(-2)),a.morphTargetInfluences=s.concat(a.morphTargetInfluences.slice(-2))}}}function $7c432a5c23fdd3a1$export$6909a70fbe283d38(n,r){$7c432a5c23fdd3a1$var$mixer&&$7c432a5c23fdd3a1$var$mixer.update(n),$7c432a5c23fdd3a1$var$model&&r&&$7c432a5c23fdd3a1$var$lookAtCamera(r),$7c432a5c23fdd3a1$var$audio&&$7c432a5c23fdd3a1$var$mouthCues&&$7c432a5c23fdd3a1$var$processLipSync()}// @ts-nocheck
/**
 * @file Entry point for the Transformers.js library. Only the exports from this file
 * are available to the end user, and are grouped as follows:
 * 
 * 1. [Pipelines](./pipelines)
 * 2. [Environment variables](./env)
 * 3. [Models](./models)
 * 4. [Tokenizers](./tokenizers)
 * 5. [Processors](./processors)
 * 
 * @module transformers
 *//**
 * @file Pipelines provide a high-level, easy to use, API for running machine learning models.
 * 
 * **Example:** Instantiate pipeline using the `pipeline` function.
 * ```javascript
 * import { pipeline } from '@xenova/transformers';
 * 
 * let classifier = await pipeline('sentiment-analysis');
 * let output = await classifier('I love transformers!');
 * // [{'label': 'POSITIVE', 'score': 0.999817686}]
 * ```
 * 
 * @module pipelines
 *//**
 * @file Tokenizers are used to prepare textual inputs for a model.
 * 
 * **Example:** Create an `AutoTokenizer` and use it to tokenize a sentence.
 * This will automatically detect the tokenizer type based on the tokenizer class defined in `tokenizer.json`.
 * ```javascript
 * import { AutoTokenizer } from '@xenova/transformers';
 * 
 * let tokenizer = await AutoTokenizer.from_pretrained('Xenova/bert-base-uncased');
 * let { input_ids } = await tokenizer('I love transformers!');
 * // Tensor {
 * //   data: BigInt64Array(6) [101n, 1045n, 2293n, 19081n, 999n, 102n],
 * //   dims: [1, 6],
 * //   type: 'int64',
 * //   size: 6,
 * // }
 * ```
 * 
 * @module tokenizers
 *//**
 * @file Core utility functions/classes for Transformers.js.
 * 
 * These are only used internally, meaning an end-user shouldn't
 * need to access anything here.
 * 
 * @module utils/core
 *//**
 * Helper function to dispatch progress callbacks.
 *
 * @param {function} progress_callback The progress callback function to dispatch.
 * @param {any} data The data to pass to the progress callback function.
 * @returns {void}
 * @private
 */function $2a81087eb92e3db1$export$184fc9ac8342b224(n,r){null!==n&&n(r)}function $2a81087eb92e3db1$export$2c62c6689f9e9be0(n){// https://ultimatecourses.com/blog/reverse-object-keys-and-values-in-javascript
return Object.fromEntries(Object.entries(n).map(([n,r])=>[r,n]))}function $2a81087eb92e3db1$export$7c57da42ce8e346f(n){return n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");// $& means the whole matched string
}const $2a81087eb92e3db1$export$c2c029f59bc4b5e=/** @type {any} */class{/**
    * Creates a new instance of the Callable class.
    */constructor(){/**
         * Creates a closure that delegates to a private method '_call' with the given arguments.
         * @type {any}
         * @param {...any} args Zero or more arguments to pass to the '_call' method.
         * @returns {*} The result of calling the '_call' method.
         */let n=function(...r){return n._call(...r)};return Object.setPrototypeOf(n,new.target.prototype)}/**
     * This method should be implemented in subclasses to provide the
     * functionality of the callable object.
     *
     * @param {any[]} args
     * @throws {Error} If the subclass does not implement the `_call` method.
     */_call(...n){throw Error("Must implement _call method in subclass")}};function $2a81087eb92e3db1$export$844ec244b1367d54(n){return"string"==typeof n||n instanceof String}function $2a81087eb92e3db1$export$b119cc7e1840e59c(n){return n?.prototype?.__proto__?.constructor?.name==="TypedArray"}function $2a81087eb92e3db1$export$47ed7831511ab4cd(n){return Number.isInteger(n)||"bigint"==typeof n}function $2a81087eb92e3db1$export$f7e9f41ea797a17(n){return null!=n}function $2a81087eb92e3db1$export$da67e68efa508cf6(n){let r=[],i=n;for(;Array.isArray(i);)r.push(i.length),i=i[0];return r}function $2a81087eb92e3db1$export$3e41007ebfff0e64(n,r,i){let a=n[r];if(void 0!==a)return delete n[r],a;if(void 0===i)throw Error(`Key ${r} does not exist in object.`);return i}function $2a81087eb92e3db1$export$9826fe7ad3921016(...n){return Array.prototype.concat.apply([],n)}function $2a81087eb92e3db1$export$dbd0f18357df1ddd(...n){// Cartesian product of items
// Adapted from https://stackoverflow.com/a/43053803
return n.reduce((n,r)=>n.flatMap(n=>r.map(r=>[n,r])))}/**
 * @file Utility functions to interact with the Hugging Face Hub (https://huggingface.co/models)
 * 
 * @module utils/hub
 */var $7a70da87fd49fc04$exports={},$2CD9z=parcelRequire("2CD9z"),$hPtJY=parcelRequire("hPtJY");const $b8705bfef224a9de$export$114f36f141c3ad7c=[// 'webgpu',
"wasm"];if(void 0!==$hPtJY&&$hPtJY?.release?.name==="node")// Running in a node-like environment.
$b8705bfef224a9de$export$1cf47f9eac95b665=$7a70da87fd49fc04$exports.default??$7a70da87fd49fc04$exports,// Add `cpu` execution provider, with higher precedence that `wasm`.
$b8705bfef224a9de$export$114f36f141c3ad7c.unshift("cpu");else{// Running in a browser-environment
$b8705bfef224a9de$export$1cf47f9eac95b665=$2CD9z.default??$2CD9z;// SIMD for WebAssembly does not operate correctly in some recent versions of iOS (16.4.x).
// As a temporary fix, we disable it for now.
// For more information, see: https://github.com/microsoft/onnxruntime/issues/15644
let isIOS="undefined"!=typeof navigator&&/iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent);isIOS&&($b8705bfef224a9de$export$1cf47f9eac95b665.env.wasm.simd=!1)}const{env:$b7c5c2295e1edeeb$var$onnx_env}=$b8705bfef224a9de$export$1cf47f9eac95b665,$b7c5c2295e1edeeb$var$VERSION="2.6.1",$b7c5c2295e1edeeb$var$WEB_CACHE_AVAILABLE="undefined"!=typeof self&&"caches"in self,$b7c5c2295e1edeeb$var$FS_AVAILABLE=!$b7c5c2295e1edeeb$var$isEmpty(/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports)),$b7c5c2295e1edeeb$var$PATH_AVAILABLE=!$b7c5c2295e1edeeb$var$isEmpty(/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports)),$b7c5c2295e1edeeb$var$RUNNING_LOCALLY=$b7c5c2295e1edeeb$var$FS_AVAILABLE&&$b7c5c2295e1edeeb$var$PATH_AVAILABLE,$b7c5c2295e1edeeb$var$__dirname=$b7c5c2295e1edeeb$var$RUNNING_LOCALLY?/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).dirname(/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).dirname(/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).fileURLToPath("file:///node_modules/@xenova/transformers/src/env.js"))):"./",$b7c5c2295e1edeeb$var$DEFAULT_CACHE_DIR=$b7c5c2295e1edeeb$var$RUNNING_LOCALLY?/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).join($b7c5c2295e1edeeb$var$__dirname,"/.cache/"):null,$b7c5c2295e1edeeb$var$DEFAULT_LOCAL_MODEL_PATH="/models/",$b7c5c2295e1edeeb$var$localModelPath=$b7c5c2295e1edeeb$var$RUNNING_LOCALLY?/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).join($b7c5c2295e1edeeb$var$__dirname,$b7c5c2295e1edeeb$var$DEFAULT_LOCAL_MODEL_PATH):$b7c5c2295e1edeeb$var$DEFAULT_LOCAL_MODEL_PATH;// Set path to wasm files. This is needed when running in a web worker.
// https://onnxruntime.ai/docs/api/js/interfaces/Env.WebAssemblyFlags.html#wasmPaths
// We use remote wasm files by default to make it easier for newer users.
// In practice, users should probably self-host the necessary .wasm files.
$b7c5c2295e1edeeb$var$onnx_env.wasm.wasmPaths=$b7c5c2295e1edeeb$var$RUNNING_LOCALLY?/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).join($b7c5c2295e1edeeb$var$__dirname,"/dist/"):`https://cdn.jsdelivr.net/npm/@xenova/transformers@${$b7c5c2295e1edeeb$var$VERSION}/dist/`;const $b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3={version:$b7c5c2295e1edeeb$var$VERSION,/////////////////// Model settings ///////////////////
allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!0,localModelPath:$b7c5c2295e1edeeb$var$localModelPath,useFS:$b7c5c2295e1edeeb$var$FS_AVAILABLE,/////////////////// Cache settings ///////////////////
useBrowserCache:$b7c5c2295e1edeeb$var$WEB_CACHE_AVAILABLE,useFSCache:$b7c5c2295e1edeeb$var$FS_AVAILABLE,cacheDir:$b7c5c2295e1edeeb$var$DEFAULT_CACHE_DIR,useCustomCache:!1,customCache:null};/**
 * @param {Object} obj
 * @private
 */function $b7c5c2295e1edeeb$var$isEmpty(n){return 0===Object.keys(n).length}var $hPtJY=parcelRequire("hPtJY");$eeb0961446aae8e3$export$d622b2ad8d90c771=$eeb0961446aae8e3$var$toByteArray,$eeb0961446aae8e3$export$6100ba28696e12de=$eeb0961446aae8e3$var$fromByteArray;for(var $eeb0961446aae8e3$var$lookup=[],$eeb0961446aae8e3$var$revLookup=[],$eeb0961446aae8e3$var$Arr="undefined"!=typeof Uint8Array?Uint8Array:Array,$eeb0961446aae8e3$var$code="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",$eeb0961446aae8e3$var$i=0,$eeb0961446aae8e3$var$len=$eeb0961446aae8e3$var$code.length;$eeb0961446aae8e3$var$i<$eeb0961446aae8e3$var$len;++$eeb0961446aae8e3$var$i)$eeb0961446aae8e3$var$lookup[$eeb0961446aae8e3$var$i]=$eeb0961446aae8e3$var$code[$eeb0961446aae8e3$var$i],$eeb0961446aae8e3$var$revLookup[$eeb0961446aae8e3$var$code.charCodeAt($eeb0961446aae8e3$var$i)]=$eeb0961446aae8e3$var$i;function $eeb0961446aae8e3$var$getLens(n){var r=n.length;if(r%4>0)throw Error("Invalid string. Length must be a multiple of 4");// Trim off extra bytes after placeholder bytes are found
// See: https://github.com/beatgammit/base64-js/issues/42
var i=n.indexOf("=");-1===i&&(i=r);var a=i===r?0:4-i%4;return[i,a]}// base64 is 4/3 + up to two characters of the original data
function $eeb0961446aae8e3$var$byteLength(n){var r=$eeb0961446aae8e3$var$getLens(n),i=r[0],a=r[1];return(i+a)*3/4-a}function $eeb0961446aae8e3$var$_byteLength(n,r,i){return(r+i)*3/4-i}function $eeb0961446aae8e3$var$toByteArray(n){var r,i,a=$eeb0961446aae8e3$var$getLens(n),s=a[0],o=a[1],l=new $eeb0961446aae8e3$var$Arr($eeb0961446aae8e3$var$_byteLength(n,s,o)),u=0,c=o>0?s-4:s;for(i=0;i<c;i+=4)r=$eeb0961446aae8e3$var$revLookup[n.charCodeAt(i)]<<18|$eeb0961446aae8e3$var$revLookup[n.charCodeAt(i+1)]<<12|$eeb0961446aae8e3$var$revLookup[n.charCodeAt(i+2)]<<6|$eeb0961446aae8e3$var$revLookup[n.charCodeAt(i+3)],l[u++]=r>>16&255,l[u++]=r>>8&255,l[u++]=255&r;return 2===o&&(r=$eeb0961446aae8e3$var$revLookup[n.charCodeAt(i)]<<2|$eeb0961446aae8e3$var$revLookup[n.charCodeAt(i+1)]>>4,l[u++]=255&r),1===o&&(r=$eeb0961446aae8e3$var$revLookup[n.charCodeAt(i)]<<10|$eeb0961446aae8e3$var$revLookup[n.charCodeAt(i+1)]<<4|$eeb0961446aae8e3$var$revLookup[n.charCodeAt(i+2)]>>2,l[u++]=r>>8&255,l[u++]=255&r),l}function $eeb0961446aae8e3$var$tripletToBase64(n){return $eeb0961446aae8e3$var$lookup[n>>18&63]+$eeb0961446aae8e3$var$lookup[n>>12&63]+$eeb0961446aae8e3$var$lookup[n>>6&63]+$eeb0961446aae8e3$var$lookup[63&n]}function $eeb0961446aae8e3$var$encodeChunk(n,r,i){for(var a=[],s=r;s<i;s+=3)a.push($eeb0961446aae8e3$var$tripletToBase64((n[s]<<16&16711680)+(n[s+1]<<8&65280)+(255&n[s+2])));return a.join("")}function $eeb0961446aae8e3$var$fromByteArray(n){// go through the array every three bytes, we'll deal with trailing stuff later
for(var r,i=n.length,a=i%3// if we have 1 byte left, pad 2 bytes
,s=[],o=16383// must be multiple of 3
,l=0,u=i-a;l<u;l+=o)s.push($eeb0961446aae8e3$var$encodeChunk(n,l,l+o>u?u:l+o));return 1===a?s.push($eeb0961446aae8e3$var$lookup[(r=n[i-1])>>2]+$eeb0961446aae8e3$var$lookup[r<<4&63]+"=="):2===a&&s.push($eeb0961446aae8e3$var$lookup[(r=(n[i-2]<<8)+n[i-1])>>10]+$eeb0961446aae8e3$var$lookup[r>>4&63]+$eeb0961446aae8e3$var$lookup[r<<2&63]+"="),s.join("")}// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
$eeb0961446aae8e3$var$revLookup["-".charCodeAt(0)]=62,$eeb0961446aae8e3$var$revLookup["_".charCodeAt(0)]=63,$7221566bd4d49f44$export$aafa59e2e03f2942=function(n,r,i,a,s){var o,l,u=8*s-a-1,c=(1<<u)-1,h=c>>1,d=-7,p=i?s-1:0,f=i?-1:1,m=n[r+p];for(p+=f,o=m&(1<<-d)-1,m>>=-d,d+=u;d>0;o=256*o+n[r+p],p+=f,d-=8);for(l=o&(1<<-d)-1,o>>=-d,d+=a;d>0;l=256*l+n[r+p],p+=f,d-=8);if(0===o)o=1-h;else{if(o===c)return l?NaN:(m?-1:1)*(1/0);l+=Math.pow(2,a),o-=h}return(m?-1:1)*l*Math.pow(2,o-a)},$7221566bd4d49f44$export$68d8715fc104d294=function(n,r,i,a,s,o){var l,u,c,h=8*o-s-1,d=(1<<h)-1,p=d>>1,f=23===s?5960464477539062e-23:0,m=a?0:o-1,g=a?1:-1,_=r<0||0===r&&1/r<0?1:0;for(isNaN(r=Math.abs(r))||r===1/0?(u=isNaN(r)?1:0,l=d):(l=Math.floor(Math.log(r)/Math.LN2),r*(c=Math.pow(2,-l))<1&&(l--,c*=2),l+p>=1?r+=f/c:r+=f*Math.pow(2,1-p),r*c>=2&&(l++,c/=2),l+p>=d?(u=0,l=d):l+p>=1?(u=(r*c-1)*Math.pow(2,s),l+=p):(u=r*Math.pow(2,p-1)*Math.pow(2,s),l=0));s>=8;n[i+m]=255&u,m+=g,u/=256,s-=8);for(l=l<<s|u,h+=s;h>0;n[i+m]=255&l,m+=g,l/=256,h-=8);n[i+m-g]|=128*_};var $51861dfc7ca9d588$var$customInspectSymbol="function"==typeof Symbol&&"function"// eslint-disable-line dot-notation
==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom")// eslint-disable-line dot-notation
:null;$51861dfc7ca9d588$export$a143d493d941bafc=$51861dfc7ca9d588$var$Buffer,$51861dfc7ca9d588$export$f99ded8fe4b79145=50;var $51861dfc7ca9d588$var$K_MAX_LENGTH=2147483647;function $51861dfc7ca9d588$var$typedArraySupport(){// Can typed array instances can be augmented?
try{var n=new Uint8Array(1),r={foo:function(){return 42}};return Object.setPrototypeOf(r,Uint8Array.prototype),Object.setPrototypeOf(n,r),42===n.foo()}catch(n){return!1}}function $51861dfc7ca9d588$var$createBuffer(n){if(n>$51861dfc7ca9d588$var$K_MAX_LENGTH)throw RangeError('The value "'+n+'" is invalid for option "size"');// Return an augmented `Uint8Array` instance
var r=new Uint8Array(n);return Object.setPrototypeOf(r,$51861dfc7ca9d588$var$Buffer.prototype),r}/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */function $51861dfc7ca9d588$var$Buffer(n,r,i){// Common case.
if("number"==typeof n){if("string"==typeof r)throw TypeError('The "string" argument must be of type string. Received type number');return $51861dfc7ca9d588$var$allocUnsafe(n)}return $51861dfc7ca9d588$var$from(n,r,i)}function $51861dfc7ca9d588$var$from(n,r,i){if("string"==typeof n)return $51861dfc7ca9d588$var$fromString(n,r);if(ArrayBuffer.isView(n))return $51861dfc7ca9d588$var$fromArrayView(n);if(null==n)throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof n);if($51861dfc7ca9d588$var$isInstance(n,ArrayBuffer)||n&&$51861dfc7ca9d588$var$isInstance(n.buffer,ArrayBuffer)||"undefined"!=typeof SharedArrayBuffer&&($51861dfc7ca9d588$var$isInstance(n,SharedArrayBuffer)||n&&$51861dfc7ca9d588$var$isInstance(n.buffer,SharedArrayBuffer)))return $51861dfc7ca9d588$var$fromArrayBuffer(n,r,i);if("number"==typeof n)throw TypeError('The "value" argument must not be of type number. Received type number');var a=n.valueOf&&n.valueOf();if(null!=a&&a!==n)return $51861dfc7ca9d588$var$Buffer.from(a,r,i);var s=$51861dfc7ca9d588$var$fromObject(n);if(s)return s;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof n[Symbol.toPrimitive])return $51861dfc7ca9d588$var$Buffer.from(n[Symbol.toPrimitive]("string"),r,i);throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof n)}function $51861dfc7ca9d588$var$assertSize(n){if("number"!=typeof n)throw TypeError('"size" argument must be of type number');if(n<0)throw RangeError('The value "'+n+'" is invalid for option "size"')}function $51861dfc7ca9d588$var$alloc(n,r,i){return($51861dfc7ca9d588$var$assertSize(n),n<=0)?$51861dfc7ca9d588$var$createBuffer(n):void 0!==r?"string"==typeof i?$51861dfc7ca9d588$var$createBuffer(n).fill(r,i):$51861dfc7ca9d588$var$createBuffer(n).fill(r):$51861dfc7ca9d588$var$createBuffer(n)}function $51861dfc7ca9d588$var$allocUnsafe(n){return $51861dfc7ca9d588$var$assertSize(n),$51861dfc7ca9d588$var$createBuffer(n<0?0:0|$51861dfc7ca9d588$var$checked(n))}function $51861dfc7ca9d588$var$fromString(n,r){if(("string"!=typeof r||""===r)&&(r="utf8"),!$51861dfc7ca9d588$var$Buffer.isEncoding(r))throw TypeError("Unknown encoding: "+r);var i=0|$51861dfc7ca9d588$var$byteLength(n,r),a=$51861dfc7ca9d588$var$createBuffer(i),s=a.write(n,r);return s!==i&&// cause everything after the first invalid character to be ignored. (e.g.
// 'abxxcd' will be treated as 'ab')
(a=a.slice(0,s)),a}function $51861dfc7ca9d588$var$fromArrayLike(n){for(var r=n.length<0?0:0|$51861dfc7ca9d588$var$checked(n.length),i=$51861dfc7ca9d588$var$createBuffer(r),a=0;a<r;a+=1)i[a]=255&n[a];return i}function $51861dfc7ca9d588$var$fromArrayView(n){if($51861dfc7ca9d588$var$isInstance(n,Uint8Array)){var r=new Uint8Array(n);return $51861dfc7ca9d588$var$fromArrayBuffer(r.buffer,r.byteOffset,r.byteLength)}return $51861dfc7ca9d588$var$fromArrayLike(n)}function $51861dfc7ca9d588$var$fromArrayBuffer(n,r,i){var a;if(r<0||n.byteLength<r)throw RangeError('"offset" is outside of buffer bounds');if(n.byteLength<r+(i||0))throw RangeError('"length" is outside of buffer bounds');return(// Return an augmented `Uint8Array` instance
Object.setPrototypeOf(a=void 0===r&&void 0===i?new Uint8Array(n):void 0===i?new Uint8Array(n,r):new Uint8Array(n,r,i),$51861dfc7ca9d588$var$Buffer.prototype),a)}function $51861dfc7ca9d588$var$fromObject(n){if($51861dfc7ca9d588$var$Buffer.isBuffer(n)){var r=0|$51861dfc7ca9d588$var$checked(n.length),i=$51861dfc7ca9d588$var$createBuffer(r);return 0===i.length||n.copy(i,0,0,r),i}return void 0!==n.length?"number"!=typeof n.length||$51861dfc7ca9d588$var$numberIsNaN(n.length)?$51861dfc7ca9d588$var$createBuffer(0):$51861dfc7ca9d588$var$fromArrayLike(n):"Buffer"===n.type&&Array.isArray(n.data)?$51861dfc7ca9d588$var$fromArrayLike(n.data):void 0}function $51861dfc7ca9d588$var$checked(n){// Note: cannot use `length < K_MAX_LENGTH` here because that fails when
// length is NaN (which is otherwise coerced to zero.)
if(n>=$51861dfc7ca9d588$var$K_MAX_LENGTH)throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+$51861dfc7ca9d588$var$K_MAX_LENGTH.toString(16)+" bytes");return 0|n}function $51861dfc7ca9d588$var$SlowBuffer(n){return+n!=n&&(n=0),$51861dfc7ca9d588$var$Buffer.alloc(+n)}function $51861dfc7ca9d588$var$byteLength(n,r){if($51861dfc7ca9d588$var$Buffer.isBuffer(n))return n.length;if(ArrayBuffer.isView(n)||$51861dfc7ca9d588$var$isInstance(n,ArrayBuffer))return n.byteLength;if("string"!=typeof n)throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof n);var i=n.length,a=arguments.length>2&&!0===arguments[2];if(!a&&0===i)return 0;for(// Use a for loop to avoid recursion
var s=!1;;)switch(r){case"ascii":case"latin1":case"binary":return i;case"utf8":case"utf-8":return $51861dfc7ca9d588$var$utf8ToBytes(n).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*i;case"hex":return i>>>1;case"base64":return $51861dfc7ca9d588$var$base64ToBytes(n).length;default:if(s)return a?-1:$51861dfc7ca9d588$var$utf8ToBytes(n).length// assume utf8
;r=(""+r).toLowerCase(),s=!0}}function $51861dfc7ca9d588$var$slowToString(n,r,i){var a=!1;// Return early if start > this.length. Done here to prevent potential uint32
// coercion fail below.
if((void 0===r||r<0)&&(r=0),r>this.length||((void 0===i||i>this.length)&&(i=this.length),i<=0||// Force coercion to uint32. This will also coerce falsey/NaN values to 0.
(i>>>=0)<=(r>>>=0)))return"";for(n||(n="utf8");;)switch(n){case"hex":return $51861dfc7ca9d588$var$hexSlice(this,r,i);case"utf8":case"utf-8":return $51861dfc7ca9d588$var$utf8Slice(this,r,i);case"ascii":return $51861dfc7ca9d588$var$asciiSlice(this,r,i);case"latin1":case"binary":return $51861dfc7ca9d588$var$latin1Slice(this,r,i);case"base64":return $51861dfc7ca9d588$var$base64Slice(this,r,i);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return $51861dfc7ca9d588$var$utf16leSlice(this,r,i);default:if(a)throw TypeError("Unknown encoding: "+n);n=(n+"").toLowerCase(),a=!0}}function $51861dfc7ca9d588$var$swap(n,r,i){var a=n[r];n[r]=n[i],n[i]=a}// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function $51861dfc7ca9d588$var$bidirectionalIndexOf(n,r,i,a,s){// Empty buffer means no match
if(0===n.length)return -1;if("string"==typeof i?(a=i,i=0):i>2147483647?i=2147483647:i<-2147483648&&(i=-2147483648),$51861dfc7ca9d588$var$numberIsNaN(i=+i// Coerce to Number.
)&&(i=s?0:n.length-1),i<0&&(i=n.length+i),i>=n.length){if(s)return -1;i=n.length-1}else if(i<0){if(!s)return -1;i=0}// Finally, search either indexOf (if dir is true) or lastIndexOf
if("string"==typeof r&&(r=$51861dfc7ca9d588$var$Buffer.from(r,a)),$51861dfc7ca9d588$var$Buffer.isBuffer(r))return(// Special case: looking for empty string/buffer always fails
0===r.length?-1:$51861dfc7ca9d588$var$arrayIndexOf(n,r,i,a,s));if("number"==typeof r)return(r&=255// Search for a byte value [0-255]
,"function"==typeof Uint8Array.prototype.indexOf)?s?Uint8Array.prototype.indexOf.call(n,r,i):Uint8Array.prototype.lastIndexOf.call(n,r,i):$51861dfc7ca9d588$var$arrayIndexOf(n,[r],i,a,s);throw TypeError("val must be string, number or Buffer")}function $51861dfc7ca9d588$var$arrayIndexOf(n,r,i,a,s){var o,l=1,u=n.length,c=r.length;if(void 0!==a&&("ucs2"===(a=String(a).toLowerCase())||"ucs-2"===a||"utf16le"===a||"utf-16le"===a)){if(n.length<2||r.length<2)return -1;l=2,u/=2,c/=2,i/=2}function h(n,r){return 1===l?n[r]:n.readUInt16BE(r*l)}if(s){var d=-1;for(o=i;o<u;o++)if(h(n,o)===h(r,-1===d?0:o-d)){if(-1===d&&(d=o),o-d+1===c)return d*l}else -1!==d&&(o-=o-d),d=-1}else for(i+c>u&&(i=u-c),o=i;o>=0;o--){for(var p=!0,f=0;f<c;f++)if(h(n,o+f)!==h(r,f)){p=!1;break}if(p)return o}return -1}function $51861dfc7ca9d588$var$hexWrite(n,r,i,a){i=Number(i)||0;var s=n.length-i;a?(a=Number(a))>s&&(a=s):a=s;var o=r.length;a>o/2&&(a=o/2);for(var l=0;l<a;++l){var u=parseInt(r.substr(2*l,2),16);if($51861dfc7ca9d588$var$numberIsNaN(u))break;n[i+l]=u}return l}function $51861dfc7ca9d588$var$utf8Write(n,r,i,a){return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$utf8ToBytes(r,n.length-i),n,i,a)}function $51861dfc7ca9d588$var$asciiWrite(n,r,i,a){return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$asciiToBytes(r),n,i,a)}function $51861dfc7ca9d588$var$base64Write(n,r,i,a){return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$base64ToBytes(r),n,i,a)}function $51861dfc7ca9d588$var$ucs2Write(n,r,i,a){return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$utf16leToBytes(r,n.length-i),n,i,a)}function $51861dfc7ca9d588$var$base64Slice(n,r,i){return 0===r&&i===n.length?$eeb0961446aae8e3$export$6100ba28696e12de(n):$eeb0961446aae8e3$export$6100ba28696e12de(n.slice(r,i))}function $51861dfc7ca9d588$var$utf8Slice(n,r,i){i=Math.min(n.length,i);for(var a=[],s=r;s<i;){var o,l,u,c,h=n[s],d=null,p=h>239?4:h>223?3:h>191?2:1;if(s+p<=i)switch(p){case 1:h<128&&(d=h);break;case 2:(192&(o=n[s+1]))==128&&(c=(31&h)<<6|63&o)>127&&(d=c);break;case 3:o=n[s+1],l=n[s+2],(192&o)==128&&(192&l)==128&&(c=(15&h)<<12|(63&o)<<6|63&l)>2047&&(c<55296||c>57343)&&(d=c);break;case 4:o=n[s+1],l=n[s+2],u=n[s+3],(192&o)==128&&(192&l)==128&&(192&u)==128&&(c=(15&h)<<18|(63&o)<<12|(63&l)<<6|63&u)>65535&&c<1114112&&(d=c)}null===d?(// we did not generate a valid codePoint so insert a
// replacement char (U+FFFD) and advance only 1 byte
d=65533,p=1):d>65535&&(// encode to utf16 (surrogate pair dance)
d-=65536,a.push(d>>>10&1023|55296),d=56320|1023&d),a.push(d),s+=p}return $51861dfc7ca9d588$var$decodeCodePointsArray(a)}/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */$51861dfc7ca9d588$var$Buffer.TYPED_ARRAY_SUPPORT=$51861dfc7ca9d588$var$typedArraySupport(),$51861dfc7ca9d588$var$Buffer.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty($51861dfc7ca9d588$var$Buffer.prototype,"parent",{enumerable:!0,get:function(){if($51861dfc7ca9d588$var$Buffer.isBuffer(this))return this.buffer}}),Object.defineProperty($51861dfc7ca9d588$var$Buffer.prototype,"offset",{enumerable:!0,get:function(){if($51861dfc7ca9d588$var$Buffer.isBuffer(this))return this.byteOffset}}),$51861dfc7ca9d588$var$Buffer.poolSize=8192// not used by this implementation
,/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/$51861dfc7ca9d588$var$Buffer.from=function(n,r,i){return $51861dfc7ca9d588$var$from(n,r,i)},// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf($51861dfc7ca9d588$var$Buffer.prototype,Uint8Array.prototype),Object.setPrototypeOf($51861dfc7ca9d588$var$Buffer,Uint8Array),/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/$51861dfc7ca9d588$var$Buffer.alloc=function(n,r,i){return $51861dfc7ca9d588$var$alloc(n,r,i)},/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */$51861dfc7ca9d588$var$Buffer.allocUnsafe=function(n){return $51861dfc7ca9d588$var$allocUnsafe(n)},/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */$51861dfc7ca9d588$var$Buffer.allocUnsafeSlow=function(n){return $51861dfc7ca9d588$var$allocUnsafe(n)},$51861dfc7ca9d588$var$Buffer.isBuffer=function(n){return null!=n&&!0===n._isBuffer&&n!==$51861dfc7ca9d588$var$Buffer.prototype// so Buffer.isBuffer(Buffer.prototype) will be false
},$51861dfc7ca9d588$var$Buffer.compare=function(n,r){if($51861dfc7ca9d588$var$isInstance(n,Uint8Array)&&(n=$51861dfc7ca9d588$var$Buffer.from(n,n.offset,n.byteLength)),$51861dfc7ca9d588$var$isInstance(r,Uint8Array)&&(r=$51861dfc7ca9d588$var$Buffer.from(r,r.offset,r.byteLength)),!$51861dfc7ca9d588$var$Buffer.isBuffer(n)||!$51861dfc7ca9d588$var$Buffer.isBuffer(r))throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(n===r)return 0;for(var i=n.length,a=r.length,s=0,o=Math.min(i,a);s<o;++s)if(n[s]!==r[s]){i=n[s],a=r[s];break}return i<a?-1:a<i?1:0},$51861dfc7ca9d588$var$Buffer.isEncoding=function(n){switch(String(n).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},$51861dfc7ca9d588$var$Buffer.concat=function(n,r){if(!Array.isArray(n))throw TypeError('"list" argument must be an Array of Buffers');if(0===n.length)return $51861dfc7ca9d588$var$Buffer.alloc(0);if(void 0===r)for(i=0,r=0;i<n.length;++i)r+=n[i].length;var i,a=$51861dfc7ca9d588$var$Buffer.allocUnsafe(r),s=0;for(i=0;i<n.length;++i){var o=n[i];if($51861dfc7ca9d588$var$isInstance(o,Uint8Array))s+o.length>a.length?$51861dfc7ca9d588$var$Buffer.from(o).copy(a,s):Uint8Array.prototype.set.call(a,o,s);else if($51861dfc7ca9d588$var$Buffer.isBuffer(o))o.copy(a,s);else throw TypeError('"list" argument must be an Array of Buffers');s+=o.length}return a},$51861dfc7ca9d588$var$Buffer.byteLength=$51861dfc7ca9d588$var$byteLength,// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
$51861dfc7ca9d588$var$Buffer.prototype._isBuffer=!0,$51861dfc7ca9d588$var$Buffer.prototype.swap16=function(){var n=this.length;if(n%2!=0)throw RangeError("Buffer size must be a multiple of 16-bits");for(var r=0;r<n;r+=2)$51861dfc7ca9d588$var$swap(this,r,r+1);return this},$51861dfc7ca9d588$var$Buffer.prototype.swap32=function(){var n=this.length;if(n%4!=0)throw RangeError("Buffer size must be a multiple of 32-bits");for(var r=0;r<n;r+=4)$51861dfc7ca9d588$var$swap(this,r,r+3),$51861dfc7ca9d588$var$swap(this,r+1,r+2);return this},$51861dfc7ca9d588$var$Buffer.prototype.swap64=function(){var n=this.length;if(n%8!=0)throw RangeError("Buffer size must be a multiple of 64-bits");for(var r=0;r<n;r+=8)$51861dfc7ca9d588$var$swap(this,r,r+7),$51861dfc7ca9d588$var$swap(this,r+1,r+6),$51861dfc7ca9d588$var$swap(this,r+2,r+5),$51861dfc7ca9d588$var$swap(this,r+3,r+4);return this},$51861dfc7ca9d588$var$Buffer.prototype.toString=function(){var n=this.length;return 0===n?"":0==arguments.length?$51861dfc7ca9d588$var$utf8Slice(this,0,n):$51861dfc7ca9d588$var$slowToString.apply(this,arguments)},$51861dfc7ca9d588$var$Buffer.prototype.toLocaleString=$51861dfc7ca9d588$var$Buffer.prototype.toString,$51861dfc7ca9d588$var$Buffer.prototype.equals=function(n){if(!$51861dfc7ca9d588$var$Buffer.isBuffer(n))throw TypeError("Argument must be a Buffer");return this===n||0===$51861dfc7ca9d588$var$Buffer.compare(this,n)},$51861dfc7ca9d588$var$Buffer.prototype.inspect=function(){var n="",r=$51861dfc7ca9d588$export$f99ded8fe4b79145;return n=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(n+=" ... "),"<Buffer "+n+">"},$51861dfc7ca9d588$var$customInspectSymbol&&($51861dfc7ca9d588$var$Buffer.prototype[$51861dfc7ca9d588$var$customInspectSymbol]=$51861dfc7ca9d588$var$Buffer.prototype.inspect),$51861dfc7ca9d588$var$Buffer.prototype.compare=function(n,r,i,a,s){if($51861dfc7ca9d588$var$isInstance(n,Uint8Array)&&(n=$51861dfc7ca9d588$var$Buffer.from(n,n.offset,n.byteLength)),!$51861dfc7ca9d588$var$Buffer.isBuffer(n))throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof n);if(void 0===r&&(r=0),void 0===i&&(i=n?n.length:0),void 0===a&&(a=0),void 0===s&&(s=this.length),r<0||i>n.length||a<0||s>this.length)throw RangeError("out of range index");if(a>=s&&r>=i)return 0;if(a>=s)return -1;if(r>=i)return 1;if(r>>>=0,i>>>=0,a>>>=0,s>>>=0,this===n)return 0;for(var o=s-a,l=i-r,u=Math.min(o,l),c=this.slice(a,s),h=n.slice(r,i),d=0;d<u;++d)if(c[d]!==h[d]){o=c[d],l=h[d];break}return o<l?-1:l<o?1:0},$51861dfc7ca9d588$var$Buffer.prototype.includes=function(n,r,i){return -1!==this.indexOf(n,r,i)},$51861dfc7ca9d588$var$Buffer.prototype.indexOf=function(n,r,i){return $51861dfc7ca9d588$var$bidirectionalIndexOf(this,n,r,i,!0)},$51861dfc7ca9d588$var$Buffer.prototype.lastIndexOf=function(n,r,i){return $51861dfc7ca9d588$var$bidirectionalIndexOf(this,n,r,i,!1)},$51861dfc7ca9d588$var$Buffer.prototype.write=function(n,r,i,a){// Buffer#write(string)
if(void 0===r)a="utf8",i=this.length,r=0;else if(void 0===i&&"string"==typeof r)a=r,i=this.length,r=0;else if(isFinite(r))r>>>=0,isFinite(i)?(i>>>=0,void 0===a&&(a="utf8")):(a=i,i=void 0);else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");var s=this.length-r;if((void 0===i||i>s)&&(i=s),n.length>0&&(i<0||r<0)||r>this.length)throw RangeError("Attempt to write outside buffer bounds");a||(a="utf8");for(var o=!1;;)switch(a){case"hex":return $51861dfc7ca9d588$var$hexWrite(this,n,r,i);case"utf8":case"utf-8":return $51861dfc7ca9d588$var$utf8Write(this,n,r,i);case"ascii":case"latin1":case"binary":return $51861dfc7ca9d588$var$asciiWrite(this,n,r,i);case"base64":// Warning: maxLength not taken into account in base64Write
return $51861dfc7ca9d588$var$base64Write(this,n,r,i);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return $51861dfc7ca9d588$var$ucs2Write(this,n,r,i);default:if(o)throw TypeError("Unknown encoding: "+a);a=(""+a).toLowerCase(),o=!0}},$51861dfc7ca9d588$var$Buffer.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH=4096;function $51861dfc7ca9d588$var$decodeCodePointsArray(n){var r=n.length;if(r<=$51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,n)// avoid extra slice()
;for(// Decode in chunks to avoid "call stack size exceeded".
var i="",a=0;a<r;)i+=String.fromCharCode.apply(String,n.slice(a,a+=$51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH));return i}function $51861dfc7ca9d588$var$asciiSlice(n,r,i){var a="";i=Math.min(n.length,i);for(var s=r;s<i;++s)a+=String.fromCharCode(127&n[s]);return a}function $51861dfc7ca9d588$var$latin1Slice(n,r,i){var a="";i=Math.min(n.length,i);for(var s=r;s<i;++s)a+=String.fromCharCode(n[s]);return a}function $51861dfc7ca9d588$var$hexSlice(n,r,i){var a=n.length;(!r||r<0)&&(r=0),(!i||i<0||i>a)&&(i=a);for(var s="",o=r;o<i;++o)s+=$51861dfc7ca9d588$var$hexSliceLookupTable[n[o]];return s}function $51861dfc7ca9d588$var$utf16leSlice(n,r,i){// If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
for(var a=n.slice(r,i),s="",o=0;o<a.length-1;o+=2)s+=String.fromCharCode(a[o]+256*a[o+1]);return s}/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */function $51861dfc7ca9d588$var$checkOffset(n,r,i){if(n%1!=0||n<0)throw RangeError("offset is not uint");if(n+r>i)throw RangeError("Trying to access beyond buffer length")}function $51861dfc7ca9d588$var$checkInt(n,r,i,a,s,o){if(!$51861dfc7ca9d588$var$Buffer.isBuffer(n))throw TypeError('"buffer" argument must be a Buffer instance');if(r>s||r<o)throw RangeError('"value" argument is out of bounds');if(i+a>n.length)throw RangeError("Index out of range")}function $51861dfc7ca9d588$var$checkIEEE754(n,r,i,a,s,o){if(i+a>n.length||i<0)throw RangeError("Index out of range")}function $51861dfc7ca9d588$var$writeFloat(n,r,i,a,s){return r=+r,i>>>=0,s||$51861dfc7ca9d588$var$checkIEEE754(n,r,i,4,34028234663852886e22,-34028234663852886e22),$7221566bd4d49f44$export$68d8715fc104d294(n,r,i,a,23,4),i+4}function $51861dfc7ca9d588$var$writeDouble(n,r,i,a,s){return r=+r,i>>>=0,s||$51861dfc7ca9d588$var$checkIEEE754(n,r,i,8,17976931348623157e292,-17976931348623157e292),$7221566bd4d49f44$export$68d8715fc104d294(n,r,i,a,52,8),i+8}$51861dfc7ca9d588$var$Buffer.prototype.slice=function(n,r){var i=this.length;n=~~n,r=void 0===r?i:~~r,n<0?(n+=i)<0&&(n=0):n>i&&(n=i),r<0?(r+=i)<0&&(r=0):r>i&&(r=i),r<n&&(r=n);var a=this.subarray(n,r);return(// Return an augmented `Uint8Array` instance
Object.setPrototypeOf(a,$51861dfc7ca9d588$var$Buffer.prototype),a)},$51861dfc7ca9d588$var$Buffer.prototype.readUintLE=$51861dfc7ca9d588$var$Buffer.prototype.readUIntLE=function(n,r,i){n>>>=0,r>>>=0,i||$51861dfc7ca9d588$var$checkOffset(n,r,this.length);for(var a=this[n],s=1,o=0;++o<r&&(s*=256);)a+=this[n+o]*s;return a},$51861dfc7ca9d588$var$Buffer.prototype.readUintBE=$51861dfc7ca9d588$var$Buffer.prototype.readUIntBE=function(n,r,i){n>>>=0,r>>>=0,i||$51861dfc7ca9d588$var$checkOffset(n,r,this.length);for(var a=this[n+--r],s=1;r>0&&(s*=256);)a+=this[n+--r]*s;return a},$51861dfc7ca9d588$var$Buffer.prototype.readUint8=$51861dfc7ca9d588$var$Buffer.prototype.readUInt8=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,1,this.length),this[n]},$51861dfc7ca9d588$var$Buffer.prototype.readUint16LE=$51861dfc7ca9d588$var$Buffer.prototype.readUInt16LE=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,2,this.length),this[n]|this[n+1]<<8},$51861dfc7ca9d588$var$Buffer.prototype.readUint16BE=$51861dfc7ca9d588$var$Buffer.prototype.readUInt16BE=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,2,this.length),this[n]<<8|this[n+1]},$51861dfc7ca9d588$var$Buffer.prototype.readUint32LE=$51861dfc7ca9d588$var$Buffer.prototype.readUInt32LE=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,4,this.length),(this[n]|this[n+1]<<8|this[n+2]<<16)+16777216*this[n+3]},$51861dfc7ca9d588$var$Buffer.prototype.readUint32BE=$51861dfc7ca9d588$var$Buffer.prototype.readUInt32BE=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,4,this.length),16777216*this[n]+(this[n+1]<<16|this[n+2]<<8|this[n+3])},$51861dfc7ca9d588$var$Buffer.prototype.readIntLE=function(n,r,i){n>>>=0,r>>>=0,i||$51861dfc7ca9d588$var$checkOffset(n,r,this.length);for(var a=this[n],s=1,o=0;++o<r&&(s*=256);)a+=this[n+o]*s;return a>=(s*=128)&&(a-=Math.pow(2,8*r)),a},$51861dfc7ca9d588$var$Buffer.prototype.readIntBE=function(n,r,i){n>>>=0,r>>>=0,i||$51861dfc7ca9d588$var$checkOffset(n,r,this.length);for(var a=r,s=1,o=this[n+--a];a>0&&(s*=256);)o+=this[n+--a]*s;return o>=(s*=128)&&(o-=Math.pow(2,8*r)),o},$51861dfc7ca9d588$var$Buffer.prototype.readInt8=function(n,r){return(n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,1,this.length),128&this[n])?-((255-this[n]+1)*1):this[n]},$51861dfc7ca9d588$var$Buffer.prototype.readInt16LE=function(n,r){n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,2,this.length);var i=this[n]|this[n+1]<<8;return 32768&i?4294901760|i:i},$51861dfc7ca9d588$var$Buffer.prototype.readInt16BE=function(n,r){n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,2,this.length);var i=this[n+1]|this[n]<<8;return 32768&i?4294901760|i:i},$51861dfc7ca9d588$var$Buffer.prototype.readInt32LE=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,4,this.length),this[n]|this[n+1]<<8|this[n+2]<<16|this[n+3]<<24},$51861dfc7ca9d588$var$Buffer.prototype.readInt32BE=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,4,this.length),this[n]<<24|this[n+1]<<16|this[n+2]<<8|this[n+3]},$51861dfc7ca9d588$var$Buffer.prototype.readFloatLE=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,4,this.length),$7221566bd4d49f44$export$aafa59e2e03f2942(this,n,!0,23,4)},$51861dfc7ca9d588$var$Buffer.prototype.readFloatBE=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,4,this.length),$7221566bd4d49f44$export$aafa59e2e03f2942(this,n,!1,23,4)},$51861dfc7ca9d588$var$Buffer.prototype.readDoubleLE=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,8,this.length),$7221566bd4d49f44$export$aafa59e2e03f2942(this,n,!0,52,8)},$51861dfc7ca9d588$var$Buffer.prototype.readDoubleBE=function(n,r){return n>>>=0,r||$51861dfc7ca9d588$var$checkOffset(n,8,this.length),$7221566bd4d49f44$export$aafa59e2e03f2942(this,n,!1,52,8)},$51861dfc7ca9d588$var$Buffer.prototype.writeUintLE=$51861dfc7ca9d588$var$Buffer.prototype.writeUIntLE=function(n,r,i,a){if(n=+n,r>>>=0,i>>>=0,!a){var s=Math.pow(2,8*i)-1;$51861dfc7ca9d588$var$checkInt(this,n,r,i,s,0)}var o=1,l=0;for(this[r]=255&n;++l<i&&(o*=256);)this[r+l]=n/o&255;return r+i},$51861dfc7ca9d588$var$Buffer.prototype.writeUintBE=$51861dfc7ca9d588$var$Buffer.prototype.writeUIntBE=function(n,r,i,a){if(n=+n,r>>>=0,i>>>=0,!a){var s=Math.pow(2,8*i)-1;$51861dfc7ca9d588$var$checkInt(this,n,r,i,s,0)}var o=i-1,l=1;for(this[r+o]=255&n;--o>=0&&(l*=256);)this[r+o]=n/l&255;return r+i},$51861dfc7ca9d588$var$Buffer.prototype.writeUint8=$51861dfc7ca9d588$var$Buffer.prototype.writeUInt8=function(n,r,i){return n=+n,r>>>=0,i||$51861dfc7ca9d588$var$checkInt(this,n,r,1,255,0),this[r]=255&n,r+1},$51861dfc7ca9d588$var$Buffer.prototype.writeUint16LE=$51861dfc7ca9d588$var$Buffer.prototype.writeUInt16LE=function(n,r,i){return n=+n,r>>>=0,i||$51861dfc7ca9d588$var$checkInt(this,n,r,2,65535,0),this[r]=255&n,this[r+1]=n>>>8,r+2},$51861dfc7ca9d588$var$Buffer.prototype.writeUint16BE=$51861dfc7ca9d588$var$Buffer.prototype.writeUInt16BE=function(n,r,i){return n=+n,r>>>=0,i||$51861dfc7ca9d588$var$checkInt(this,n,r,2,65535,0),this[r]=n>>>8,this[r+1]=255&n,r+2},$51861dfc7ca9d588$var$Buffer.prototype.writeUint32LE=$51861dfc7ca9d588$var$Buffer.prototype.writeUInt32LE=function(n,r,i){return n=+n,r>>>=0,i||$51861dfc7ca9d588$var$checkInt(this,n,r,4,4294967295,0),this[r+3]=n>>>24,this[r+2]=n>>>16,this[r+1]=n>>>8,this[r]=255&n,r+4},$51861dfc7ca9d588$var$Buffer.prototype.writeUint32BE=$51861dfc7ca9d588$var$Buffer.prototype.writeUInt32BE=function(n,r,i){return n=+n,r>>>=0,i||$51861dfc7ca9d588$var$checkInt(this,n,r,4,4294967295,0),this[r]=n>>>24,this[r+1]=n>>>16,this[r+2]=n>>>8,this[r+3]=255&n,r+4},$51861dfc7ca9d588$var$Buffer.prototype.writeIntLE=function(n,r,i,a){if(n=+n,r>>>=0,!a){var s=Math.pow(2,8*i-1);$51861dfc7ca9d588$var$checkInt(this,n,r,i,s-1,-s)}var o=0,l=1,u=0;for(this[r]=255&n;++o<i&&(l*=256);)n<0&&0===u&&0!==this[r+o-1]&&(u=1),this[r+o]=(n/l>>0)-u&255;return r+i},$51861dfc7ca9d588$var$Buffer.prototype.writeIntBE=function(n,r,i,a){if(n=+n,r>>>=0,!a){var s=Math.pow(2,8*i-1);$51861dfc7ca9d588$var$checkInt(this,n,r,i,s-1,-s)}var o=i-1,l=1,u=0;for(this[r+o]=255&n;--o>=0&&(l*=256);)n<0&&0===u&&0!==this[r+o+1]&&(u=1),this[r+o]=(n/l>>0)-u&255;return r+i},$51861dfc7ca9d588$var$Buffer.prototype.writeInt8=function(n,r,i){return n=+n,r>>>=0,i||$51861dfc7ca9d588$var$checkInt(this,n,r,1,127,-128),n<0&&(n=255+n+1),this[r]=255&n,r+1},$51861dfc7ca9d588$var$Buffer.prototype.writeInt16LE=function(n,r,i){return n=+n,r>>>=0,i||$51861dfc7ca9d588$var$checkInt(this,n,r,2,32767,-32768),this[r]=255&n,this[r+1]=n>>>8,r+2},$51861dfc7ca9d588$var$Buffer.prototype.writeInt16BE=function(n,r,i){return n=+n,r>>>=0,i||$51861dfc7ca9d588$var$checkInt(this,n,r,2,32767,-32768),this[r]=n>>>8,this[r+1]=255&n,r+2},$51861dfc7ca9d588$var$Buffer.prototype.writeInt32LE=function(n,r,i){return n=+n,r>>>=0,i||$51861dfc7ca9d588$var$checkInt(this,n,r,4,2147483647,-2147483648),this[r]=255&n,this[r+1]=n>>>8,this[r+2]=n>>>16,this[r+3]=n>>>24,r+4},$51861dfc7ca9d588$var$Buffer.prototype.writeInt32BE=function(n,r,i){return n=+n,r>>>=0,i||$51861dfc7ca9d588$var$checkInt(this,n,r,4,2147483647,-2147483648),n<0&&(n=4294967295+n+1),this[r]=n>>>24,this[r+1]=n>>>16,this[r+2]=n>>>8,this[r+3]=255&n,r+4},$51861dfc7ca9d588$var$Buffer.prototype.writeFloatLE=function(n,r,i){return $51861dfc7ca9d588$var$writeFloat(this,n,r,!0,i)},$51861dfc7ca9d588$var$Buffer.prototype.writeFloatBE=function(n,r,i){return $51861dfc7ca9d588$var$writeFloat(this,n,r,!1,i)},$51861dfc7ca9d588$var$Buffer.prototype.writeDoubleLE=function(n,r,i){return $51861dfc7ca9d588$var$writeDouble(this,n,r,!0,i)},$51861dfc7ca9d588$var$Buffer.prototype.writeDoubleBE=function(n,r,i){return $51861dfc7ca9d588$var$writeDouble(this,n,r,!1,i)},// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
$51861dfc7ca9d588$var$Buffer.prototype.copy=function(n,r,i,a){if(!$51861dfc7ca9d588$var$Buffer.isBuffer(n))throw TypeError("argument should be a Buffer");// Copy 0 bytes; we're done
if(i||(i=0),a||0===a||(a=this.length),r>=n.length&&(r=n.length),r||(r=0),a>0&&a<i&&(a=i),a===i||0===n.length||0===this.length)return 0;// Fatal error conditions
if(r<0)throw RangeError("targetStart out of bounds");if(i<0||i>=this.length)throw RangeError("Index out of range");if(a<0)throw RangeError("sourceEnd out of bounds");a>this.length&&(a=this.length),n.length-r<a-i&&(a=n.length-r+i);var s=a-i;return this===n&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(r,i,a):Uint8Array.prototype.set.call(n,this.subarray(i,a),r),s},// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
$51861dfc7ca9d588$var$Buffer.prototype.fill=function(n,r,i,a){// Handle string cases:
if("string"==typeof n){if("string"==typeof r?(a=r,r=0,i=this.length):"string"==typeof i&&(a=i,i=this.length),void 0!==a&&"string"!=typeof a)throw TypeError("encoding must be a string");if("string"==typeof a&&!$51861dfc7ca9d588$var$Buffer.isEncoding(a))throw TypeError("Unknown encoding: "+a);if(1===n.length){var s,o=n.charCodeAt(0);("utf8"===a&&o<128||"latin1"===a)&&(n=o)}}else"number"==typeof n?n&=255:"boolean"==typeof n&&(n=Number(n));// Invalid ranges are not set to a default, so can range check early.
if(r<0||this.length<r||this.length<i)throw RangeError("Out of range index");if(i<=r)return this;if(r>>>=0,i=void 0===i?this.length:i>>>0,n||(n=0),"number"==typeof n)for(s=r;s<i;++s)this[s]=n;else{var l=$51861dfc7ca9d588$var$Buffer.isBuffer(n)?n:$51861dfc7ca9d588$var$Buffer.from(n,a),u=l.length;if(0===u)throw TypeError('The value "'+n+'" is invalid for argument "value"');for(s=0;s<i-r;++s)this[s+r]=l[s%u]}return this};// HELPER FUNCTIONS
// ================
var $51861dfc7ca9d588$var$INVALID_BASE64_RE=/[^+/0-9A-Za-z-_]/g;function $51861dfc7ca9d588$var$base64clean(n){// Node converts strings with length < 2 to ''
if(// Node strips out invalid characters like \n and \t from the string, base64-js does not
(n=// Node takes equal signs as end of the Base64 encoding
(n=n.split("=")[0]).trim().replace($51861dfc7ca9d588$var$INVALID_BASE64_RE,"")).length<2)return"";// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
for(;n.length%4!=0;)n+="=";return n}function $51861dfc7ca9d588$var$utf8ToBytes(n,r){r=r||1/0;for(var i,a=n.length,s=null,o=[],l=0;l<a;++l){// is surrogate component
if((i=n.charCodeAt(l))>55295&&i<57344){// last char was a lead
if(!s){// no lead yet
if(i>56319||l+1===a){// unexpected trail
(r-=3)>-1&&o.push(239,191,189);continue}// valid lead
s=i;continue}// 2 leads in a row
if(i<56320){(r-=3)>-1&&o.push(239,191,189),s=i;continue}// valid surrogate pair
i=(s-55296<<10|i-56320)+65536}else s&&(r-=3)>-1&&o.push(239,191,189);// encode utf8
if(s=null,i<128){if((r-=1)<0)break;o.push(i)}else if(i<2048){if((r-=2)<0)break;o.push(i>>6|192,63&i|128)}else if(i<65536){if((r-=3)<0)break;o.push(i>>12|224,i>>6&63|128,63&i|128)}else if(i<1114112){if((r-=4)<0)break;o.push(i>>18|240,i>>12&63|128,i>>6&63|128,63&i|128)}else throw Error("Invalid code point")}return o}function $51861dfc7ca9d588$var$asciiToBytes(n){for(var r=[],i=0;i<n.length;++i)r.push(255&n.charCodeAt(i));return r}function $51861dfc7ca9d588$var$utf16leToBytes(n,r){for(var i,a,s=[],o=0;o<n.length&&!((r-=2)<0);++o)a=(i=n.charCodeAt(o))>>8,s.push(i%256),s.push(a);return s}function $51861dfc7ca9d588$var$base64ToBytes(n){return $eeb0961446aae8e3$export$d622b2ad8d90c771($51861dfc7ca9d588$var$base64clean(n))}function $51861dfc7ca9d588$var$blitBuffer(n,r,i,a){for(var s=0;s<a&&!(s+i>=r.length)&&!(s>=n.length);++s)r[s+i]=n[s];return s}// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function $51861dfc7ca9d588$var$isInstance(n,r){return n instanceof r||null!=n&&null!=n.constructor&&null!=n.constructor.name&&n.constructor.name===r.name}function $51861dfc7ca9d588$var$numberIsNaN(n){// For IE11 support
return n!=n// eslint-disable-line no-self-compare
}// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var $51861dfc7ca9d588$var$hexSliceLookupTable=function(){for(var n="0123456789abcdef",r=Array(256),i=0;i<16;++i)for(var a=16*i,s=0;s<16;++s)r[a+s]=n[i]+n[s];return r}(),$fb1f2fa9752dcff4$require$Buffer=$51861dfc7ca9d588$export$a143d493d941bafc;globalThis.ReadableStream||(globalThis.ReadableStream=/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).ReadableStream);/**
 * @typedef {Object} PretrainedOptions Options for loading a pretrained model.     
 * @property {boolean?} [options.quantized=true] Whether to load the 8-bit quantized version of the model (only applicable when loading model files).
 * @property {function} [options.progress_callback=null] If specified, this function will be called during model construction, to provide the user with progress updates.
 * @property {Object} [options.config=null] Configuration for the model to use instead of an automatically loaded configuration. Configuration can be automatically loaded when:
 * - The model is a model provided by the library (loaded with the *model id* string of a pretrained model).
 * - The model is loaded by supplying a local directory as `pretrained_model_name_or_path` and a configuration JSON file named *config.json* is found in the directory.
 * @property {string} [options.cache_dir=null] Path to a directory in which a downloaded pretrained model configuration should be cached if the standard cache should not be used.
 * @property {boolean} [options.local_files_only=false] Whether or not to only look at local files (e.g., not try downloading the model).
 * @property {string} [options.revision='main'] The specific model version to use. It can be a branch name, a tag name, or a commit id,
 * since we use a git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any identifier allowed by git.
 * NOTE: This setting is ignored for local requests.
 * @property {string} [options.model_file_name=null] If specified, load the model with this name (excluding the .onnx suffix). Currently only valid for encoder- or decoder-only models.
 */class $fb1f2fa9752dcff4$var$FileResponse{/**
     * Mapping from file extensions to MIME types.
     */_CONTENT_TYPE_MAP={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};/**
     * Creates a new `FileResponse` object.
     * @param {string|URL} filePath
     */constructor(n){if(this.filePath=n,this.headers=new Headers,this.exists=/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).existsSync(n),this.exists){this.status=200,this.statusText="OK";let r=/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).statSync(n);this.headers.set("content-length",r.size.toString()),this.updateContentType();let i=this;this.body=new ReadableStream({start(n){i.arrayBuffer().then(r=>{n.enqueue(new Uint8Array(r)),n.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}/**
     * Updates the 'content-type' header property of the response based on the extension of
     * the file specified by the filePath property of the current object.
     * @returns {void}
     */updateContentType(){// Set content-type header based on file extension
let n=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",this._CONTENT_TYPE_MAP[n]??"application/octet-stream")}/**
     * Clone the current FileResponse object.
     * @returns {FileResponse} A new FileResponse object with the same properties as the current object.
     */clone(){let n=new $fb1f2fa9752dcff4$var$FileResponse(this.filePath);return n.exists=this.exists,n.status=this.status,n.statusText=this.statusText,n.headers=new Headers(this.headers),n}/**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with an ArrayBuffer containing the file's contents.
     * @returns {Promise<ArrayBuffer>} A Promise that resolves with an ArrayBuffer containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */async arrayBuffer(){let n=await /*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).promises.readFile(this.filePath);return n.buffer}/**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with a Blob containing the file's contents.
     * @returns {Promise<Blob>} A Promise that resolves with a Blob containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */async blob(){let n=await /*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).promises.readFile(this.filePath);return new Blob([n],{type:this.headers.get("content-type")})}/**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with a string containing the file's contents.
     * @returns {Promise<string>} A Promise that resolves with a string containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */async text(){let n=await /*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).promises.readFile(this.filePath,"utf8");return n}/**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with a parsed JavaScript object containing the file's contents.
     * 
     * @returns {Promise<Object>} A Promise that resolves with a parsed JavaScript object containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */async json(){return JSON.parse(await this.text())}}/**
 * Determines whether the given string is a valid HTTP or HTTPS URL.
 * @param {string|URL} string The string to test for validity as an HTTP or HTTPS URL.
 * @param {string[]} [validHosts=null] A list of valid hostnames. If specified, the URL's hostname must be in this list.
 * @returns {boolean} True if the string is a valid HTTP or HTTPS URL, false otherwise.
 */function $fb1f2fa9752dcff4$var$isValidHttpUrl(n,r=null){// https://stackoverflow.com/a/43467144
let i;try{i=new URL(n)}catch(n){return!1}return(!r||!!r.includes(i.hostname))&&("http:"===i.protocol||"https:"===i.protocol)}async function $fb1f2fa9752dcff4$export$8b3ca78f81ec578c(n){if($b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.useFS&&!$fb1f2fa9752dcff4$var$isValidHttpUrl(n))return new $fb1f2fa9752dcff4$var$FileResponse(n);if(void 0===$hPtJY||$hPtJY?.release?.name!=="node")// NOTE: We do not allow passing authorization headers in the browser,
// since this would require exposing the token to the client.
return fetch(n);{let r=!!$hPtJY.env?.TESTING_REMOTELY,i=$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.version,a=new Headers;a.set("User-Agent",`transformers.js/${i}; is_ci/${r};`);// Check whether we are making a request to the Hugging Face Hub.
let s=$fb1f2fa9752dcff4$var$isValidHttpUrl(n,["huggingface.co","hf.co"]);if(s){// If an access token is present in the environment variables,
// we add it to the request headers.
let n=$hPtJY.env?.HF_ACCESS_TOKEN;n&&a.set("Authorization",`Bearer ${n}`)}return fetch(n,{headers:a})}}const $fb1f2fa9752dcff4$var$ERROR_MAPPING={// 4xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)
400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",// 5xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)
500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};/**
 * Helper method to handle fatal errors that occur while trying to load a file from the Hugging Face Hub.
 * @param {number} status The HTTP status code of the error.
 * @param {string} remoteURL The URL of the file that could not be loaded.
 * @param {boolean} fatal Whether to raise an error if the file could not be loaded.
 * @returns {null} Returns `null` if `fatal = true`.
 * @throws {Error} If `fatal = false`.
 */function $fb1f2fa9752dcff4$var$handleError(n,r,i){if(!i)// TODO in future, cache the response?
return null;let a=$fb1f2fa9752dcff4$var$ERROR_MAPPING[n]??`Error (${n}) occurred while trying to load file`;throw Error(`${a}: "${r}".`)}class $fb1f2fa9752dcff4$var$FileCache{/**
     * Instantiate a `FileCache` object.
     * @param {string} path 
     */constructor(n){this.path=n}/**
     * Checks whether the given request is in the cache.
     * @param {string} request 
     * @returns {Promise<FileResponse | undefined>}
     */async match(n){let r=/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).join(this.path,n),i=new $fb1f2fa9752dcff4$var$FileResponse(r);return i.exists?i:void 0}/**
     * Adds the given response to the cache.
     * @param {string} request 
     * @param {Response|FileResponse} response 
     * @returns {Promise<void>}
     */async put(n,r){let i=$fb1f2fa9752dcff4$require$Buffer.from(await r.arrayBuffer()),a=/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).join(this.path,n);try{await /*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).promises.mkdir(/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).dirname(a),{recursive:!0}),await /*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports).promises.writeFile(a,i)}catch(n){console.warn("An error occurred while writing the file to cache:",n)}}}/**
 * 
 * @param {FileCache|Cache} cache The cache to search
 * @param {string[]} names The names of the item to search for
 * @returns {Promise<FileResponse|Response|undefined>} The item from the cache, or undefined if not found.
 */async function $fb1f2fa9752dcff4$var$tryCache(n,...r){for(let i of r)try{let r=await n.match(i);if(r)return r}catch(n){continue}}async function $fb1f2fa9752dcff4$export$e5c5b77f730156(n,r,i=!0,a={}){let s,o,l;if(!$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.allowLocalModels){// User has disabled local models, so we just make sure other settings are correct.
if(a.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}if($2a81087eb92e3db1$export$184fc9ac8342b224(a.progress_callback,{status:"initiate",name:n,file:r}),!s&&$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.useBrowserCache){if("undefined"==typeof caches)throw Error("Browser cache is not available in this environment.");try{// In some cases, the browser cache may be visible, but not accessible due to security restrictions.
// For example, when running an application in an iframe, if a user attempts to load the page in
// incognito mode, the following error is thrown: `DOMException: Failed to execute 'open' on 'CacheStorage':
// An attempt was made to break through the security policy of the user agent.`
// So, instead of crashing, we just ignore the error and continue without using the cache.
s=await caches.open("transformers-cache")}catch(n){console.warn("An error occurred while opening the browser cache:",n)}}if(!s&&$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.useFSCache&&// If `cache_dir` is not specified, use the default cache directory
(s=new $fb1f2fa9752dcff4$var$FileCache(a.cache_dir??$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.cacheDir)),!s&&$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.useCustomCache){// Allow the user to specify a custom cache system.
if(!$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");// Check that the required methods are defined:
if(!$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.customCache.match||!$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.customCache.put)throw Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");s=$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.customCache}let u=a.revision??"main",c=$fb1f2fa9752dcff4$var$pathJoin(n,r),h=$fb1f2fa9752dcff4$var$pathJoin($b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.localModelPath,c),d=$fb1f2fa9752dcff4$var$pathJoin($b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.remoteHost,$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.remotePathTemplate.replaceAll("{model}",n).replaceAll("{revision}",u),r),p="main"===u?c:$fb1f2fa9752dcff4$var$pathJoin(n,u,r),f=s instanceof $fb1f2fa9752dcff4$var$FileCache?p:d,m=!1;if(s&&//  1. We first try to get from cache using the local path. In some environments (like deno),
//     non-URL cache keys are not allowed. In these cases, `response` will be undefined.
//  2. If no response is found, we try to get from cache using the remote URL or file system cache.
(l=await $fb1f2fa9752dcff4$var$tryCache(s,h,f)),void 0===l){// Caching not available, or file is not cached, so we perform the request
if($b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.allowLocalModels){// Accessing local models is enabled, so we try to get the file locally.
// If request is a valid HTTP URL, we skip the local file check. Otherwise, we try to get the file locally.
let n=$fb1f2fa9752dcff4$var$isValidHttpUrl(c);if(n){if(a.local_files_only)throw Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${c}.`);if(!$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.allowRemoteModels)throw Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${c}.`)}else try{l=await $fb1f2fa9752dcff4$export$8b3ca78f81ec578c(h),o=h}catch(n){// Something went wrong while trying to get the file locally.
// NOTE: error handling is done in the next step (since `response` will be undefined)
console.warn(`Unable to load from local path "${h}": "${n}"`)}}if(void 0===l||404===l.status){// File not found locally. This means either:
// - The user has disabled local file access (`env.allowLocalModels=false`)
// - the path is a valid HTTP url (`response === undefined`)
// - the path is not a valid HTTP url and the file is not present on the file system or local server (`response.status === 404`)
if(a.local_files_only||!$b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.allowRemoteModels){// User requested local files only, but the file is not found locally.
if(!i)// TODO in future, cache the response?
return null;throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${h}".`)}if(200!==// File not found locally, so we try to download it from the remote server
(l=await $fb1f2fa9752dcff4$export$8b3ca78f81ec578c(d)).status)return $fb1f2fa9752dcff4$var$handleError(l.status,d,i);// Success! We use the proposed cache key from earlier
o=f}// Only cache the response if:
m=s// 1. A caching system is available
&&"undefined"// 2. `Response` is defined (i.e., we are in a browser-like environment)
!=typeof Response&&l instanceof Response// 3. result is a `Response` object (i.e., not a `FileResponse`)
&&200// 4. request was successful (status code 200)
===l.status}$2a81087eb92e3db1$export$184fc9ac8342b224(a.progress_callback,{status:"download",name:n,file:r});let g=await $fb1f2fa9752dcff4$var$readResponse(l,i=>{$2a81087eb92e3db1$export$184fc9ac8342b224(a.progress_callback,{status:"progress",...i,name:n,file:r})});return(// i.e., do not cache FileResponses (prevents duplication)
m&&o&&// Check again whether request is in cache. If not, we add the response to the cache
await s.match(o)===void 0&&await s.put(o,new Response(g,{headers:l.headers})).catch(n=>{// Do not crash if unable to add to cache (e.g., QuotaExceededError).
// Rather, log a warning and proceed with execution.
console.warn(`Unable to add response to browser cache: ${n}.`)}),$2a81087eb92e3db1$export$184fc9ac8342b224(a.progress_callback,{status:"done",name:n,file:r}),g)}async function $fb1f2fa9752dcff4$export$bdb2295ec9595824(n,r,i=!0,a={}){let s=await $fb1f2fa9752dcff4$export$e5c5b77f730156(n,r,i,a);return null===s?{}:JSON.parse(new TextDecoder("utf-8").decode(s))}/**
 * Read and track progress when reading a Response object
 *
 * @param {any} response The Response object to read
 * @param {function} progress_callback The function to call with progress updates
 * @returns {Promise<Uint8Array>} A Promise that resolves with the Uint8Array buffer
 */async function $fb1f2fa9752dcff4$var$readResponse(n,r){// Read and track progress when reading a Response object
let i=n.headers.get("Content-Length");null===i&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let a=parseInt(i??"0"),s=new Uint8Array(a),o=0,l=n.body.getReader();async function u(){let{done:n,value:i}=await l.read();if(n)return;let c=o+i.length;if(c>a){a=c;// Adding the new data will overflow buffer.
// In this case, we extend the buffer
let n=new Uint8Array(a);// copy contents
n.set(s),s=n}s.set(i,o),o=c;let h=o/a*100;return(// Call your function here
r({progress:h,loaded:o,total:a}),u())}return(// Actually read
await u(),s)}/**
 * Joins multiple parts of a path into a single path, while handling leading and trailing slashes.
 *
 * @param {...string} parts Multiple parts of a path.
 * @returns {string} A string representing the joined path.
 */function $fb1f2fa9752dcff4$var$pathJoin(...n){return(// https://stackoverflow.com/a/55142565
(n=n.map((r,i)=>(i&&(r=r.replace(RegExp("^/"),"")),i!==n.length-1&&(r=r.replace(RegExp("/$"),"")),r))).join("/"))}/**
 * @file Helper module for mathematical processing. 
 * 
 * These functions and classes are only used internally, 
 * meaning an end-user shouldn't need to access anything here.
 * 
 * @module utils/maths
 *//**
 * @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array} TypedArray
 * @typedef {BigInt64Array | BigUint64Array} BigTypedArray
 * @typedef {TypedArray | BigTypedArray} AnyTypedArray
 *//**
 * @param {TypedArray} input
 */function $821ef51da65e5775$export$132425e9e52225b9(n,[r,i,a],[s,o],l="bilinear",u=!1){// TODO use mode and align_corners
// Output image dimensions
let c=o/a,h=s/i,d=new n.constructor(s*o*r),p=i*a,f=s*o;for(let l=0;l<s;++l)for(let s=0;s<o;++s){// Calculate output offset
let u=l*o+s,m=(s+.5)/c-.5,g=(l+.5)/h-.5,_=Math.floor(m),y=Math.floor(g),b=Math.min(_+1,a-1),v=Math.min(y+1,i-1);_=Math.max(_,0),y=Math.max(y,0);// Calculate the fractional distances between the input pixel and the four nearest pixels
let x=m-_,w=g-y,T=(1-x)*(1-w),S=x*(1-w),E=(1-x)*w,A=x*w,M=y*a,I=v*a,P=M+_,O=M+b,R=I+_,C=I+b;for(let i=0;i<r;++i){// Calculate channel offset
let r=i*p;d[i*f+u]=T*n[r+P]+S*n[r+O]+E*n[r+R]+A*n[r+C]}}return d}function $821ef51da65e5775$export$1874c7f77119edd3(n,r,i){// Calculate the new shape of the transposed array
// and the stride of the original array
let a=Array(i.length),s=Array(i.length);for(let n=i.length-1,o=1;n>=0;--n)s[n]=o,a[n]=r[i[n]],o*=a[n];// Precompute inverse mapping of stride
let o=i.map((n,r)=>s[i.indexOf(r)]),l=new n.constructor(n.length);// Transpose the original array to the new array
for(let i=0;i<n.length;++i){let a=0;for(let n=r.length-1,s=i;n>=0;--n)a+=s%r[n]*o[n],s=Math.floor(s/r[n]);l[a]=n[i]}return[l,a]}function $821ef51da65e5775$export$e008137e76238601(n){// Compute the maximum value in the array
let r=$821ef51da65e5775$export$8960430cfd85939f(n)[0],i=n.map(n=>Math.exp(n-r)),a=i.reduce((n,r)=>n+r,0),s=i.map(n=>n/a);return s}function $821ef51da65e5775$export$82ac14ef2b5818d0(n){// Compute the softmax values
let r=$821ef51da65e5775$export$e008137e76238601(n),i=r.map(n=>Math.log(n));return i}function $821ef51da65e5775$export$94132a0e348806d4(n,r){return n.reduce((n,i,a)=>n+i*r[a],0)}function $821ef51da65e5775$export$dd136ade76918e5b(n,r=0){return(// if top == 0, return all
n=Array.from(n).map((n,r)=>[r,n])// Get indices ([index, score])
.sort((n,r)=>r[1]-n[1])// Sort by log probabilities
,r>0&&(n=n.slice(0,r)),n)}function $821ef51da65e5775$export$e9049d21b83f6c89(n,r){// Calculate dot product of the two arrays
let i=$821ef51da65e5775$export$94132a0e348806d4(n,r),a=$821ef51da65e5775$export$539b1fa16df3ef07(n),s=$821ef51da65e5775$export$539b1fa16df3ef07(r),o=i/(a*s);return o}function $821ef51da65e5775$export$539b1fa16df3ef07(n){return Math.sqrt(n.reduce((n,r)=>n+r*r,0))}function $821ef51da65e5775$export$96ec731ed4dcb222(n){if(0===n.length)throw Error("Array must not be empty");let r=n[0],i=0;for(let a=1;a<n.length;++a)n[a]<r&&(r=n[a],i=a);return[r,i]}function $821ef51da65e5775$export$8960430cfd85939f(n){if(0===n.length)throw Error("Array must not be empty");let r=n[0],i=0;for(let a=1;a<n.length;++a)n[a]>r&&(r=n[a],i=a);return[r,i]}function $821ef51da65e5775$export$9e48bff21cf1b9ab(n,r=1){if(!Number.isInteger(n))throw TypeError(`n should be an integer, but ${n} given.`);let i=1/(n*r),a=Math.floor(n/2)+1,s=Array(a);for(let n=0;n<a;++n)s[n]=n*i;return s}class $821ef51da65e5775$export$677347237c014ba{/**
     * @param {number} size The size of the input array. Must be a power of two and bigger than 1.
     * @throws {Error} FFT size must be a power of two and bigger than 1.
     */constructor(n){if(this.size=0|n,this.size<=1||(this.size&this.size-1)!=0)throw Error("FFT size must be a power of two and bigger than 1");this._csize=n<<1,this.table=new Float32Array(2*this.size);for(let n=0;n<this.table.length;n+=2){let r=Math.PI*n/this.size;this.table[n]=Math.cos(r),this.table[n+1]=-Math.sin(r)}// Find size's power of two
let r=0;for(let n=1;this.size>n;n<<=1)++r;// Calculate initial step's width:
//   * If we are full radix-4, it is 2x smaller to give inital len=8
//   * Otherwise it is the same as `power` to give len=4
this._width=r%2==0?r-1:r,// Pre-compute bit-reversal patterns
this._bitrev=new Int32Array(1<<this._width);for(let n=0;n<this._bitrev.length;++n){this._bitrev[n]=0;for(let r=0;r<this._width;r+=2){let i=this._width-r-2;this._bitrev[n]|=(n>>>r&3)<<i}}}/**
     * Create a complex number array with size `2 * size`
     *
     * @returns {Float32Array} A complex number array with size `2 * size`
     */createComplexArray(){return new Float32Array(this._csize)}/**
     * Converts a complex number representation stored in a Float32Array to an array of real numbers.
     * 
     * @param {Float32Array} complex The complex number representation to be converted.
     * @param {number[]} [storage] An optional array to store the result in.
     * @returns {number[]} An array of real numbers representing the input complex number representation.
     */fromComplexArray(n,r){let i=r||Array(n.length>>>1);for(let r=0;r<n.length;r+=2)i[r>>>1]=n[r];return i}/**
     * Convert a real-valued input array to a complex-valued output array.
     * @param {Float32Array} input The real-valued input array.
     * @param {Float32Array} [storage] Optional buffer to store the output array.
     * @returns {Float32Array} The complex-valued output array.
     */toComplexArray(n,r){let i=r||this.createComplexArray();for(let r=0;r<i.length;r+=2)i[r]=n[r>>>1],i[r+1]=0;return i}/**
     * Completes the spectrum by adding its mirrored negative frequency components.
     * @param {Float32Array} spectrum The input spectrum.
     * @returns {void}
     */completeSpectrum(n){let r=this._csize,i=r>>>1;for(let a=2;a<i;a+=2)n[r-a]=n[a],n[r-a+1]=-n[a+1]}/**
     * Performs a Fast Fourier Transform (FFT) on the given input data and stores the result in the output buffer.
     * 
     * @param {Float32Array} out The output buffer to store the result.
     * @param {Float32Array} data The input data to transform.
     * 
     * @throws {Error} Input and output buffers must be different.
     * 
     * @returns {void}
     */transform(n,r){if(n===r)throw Error("Input and output buffers must be different");this._transform4(n,r,1/* DONE */)}/**
     * Performs a real-valued forward FFT on the given input buffer and stores the result in the given output buffer.
     * The input buffer must contain real values only, while the output buffer will contain complex values. The input and
     * output buffers must be different.
     *
     * @param {Float32Array} out The output buffer.
     * @param {Float32Array} data The input buffer containing real values.
     *
     * @throws {Error} If the input and output buffers are the same.
     */realTransform(n,r){if(n===r)throw Error("Input and output buffers must be different");this._realTransform4(n,r,1/* DONE */)}/**
     * Performs an inverse FFT transformation on the given `data` array, and stores the result in `out`.
     * The `out` array must be a different buffer than the `data` array. The `out` array will contain the
     * result of the transformation. The `data` array will not be modified.
     * 
     * @param {Float32Array} out The output buffer for the transformed data.
     * @param {Float32Array} data The input data to transform.
     * @throws {Error} If `out` and `data` refer to the same buffer.
     * @returns {void}
     */inverseTransform(n,r){if(n===r)throw Error("Input and output buffers must be different");this._transform4(n,r,-1/* DONE */);for(let r=0;r<n.length;++r)n[r]/=this.size}/**
     * Performs a radix-4 implementation of a discrete Fourier transform on a given set of data.
     *
     * @param {Float32Array} out The output buffer for the transformed data.
     * @param {Float32Array} data The input buffer of data to be transformed.
     * @param {number} inv A scaling factor to apply to the transform.
     * @returns {void}
     */_transform4(n,r,i){let a,s;// radix-4 implementation
let o=this._csize,l=this._width,u=1<<l,c=o/u<<1,h=this._bitrev;if(4===c)for(a=0,s=0;a<o;a+=c,++s){let i=h[s];this._singleTransform2(r,n,a,i,u)}else for(a=0,s=0;a<o;a+=c,++s){let o=h[s];this._singleTransform4(r,n,a,o,u,i)}// Loop through steps in decreasing order
for(u>>=2;u>=2;u>>=2){let r=(c=o/u<<1)>>>2;// Loop through offsets in the data
for(a=0;a<o;a+=c){// Full case
let s=a+r;for(let o=a,l=0;o<s;o+=2,l+=u){let a=o,s=a+r,u=s+r,c=u+r,h=n[a],d=n[a+1],p=n[s],f=n[s+1],m=n[u],g=n[u+1],_=n[c],y=n[c+1],b=this.table[l],v=i*this.table[l+1],x=p*b-f*v,w=p*v+f*b,T=this.table[2*l],S=i*this.table[2*l+1],E=m*T-g*S,A=m*S+g*T,M=this.table[3*l],I=i*this.table[3*l+1],P=_*M-y*I,O=_*I+y*M,R=h+E,C=d+A,L=h-E,D=d-A,N=x+P,k=w+O,U=i*(x-P),F=i*(w-O);// Final values
n[a]=R+N,n[a+1]=C+k,n[s]=L+F,n[s+1]=D-U,n[u]=R-N,n[u+1]=C-k,n[c]=L-F,n[c+1]=D+U}}}}/**
     * Performs a radix-2 implementation of a discrete Fourier transform on a given set of data.
     *
     * @param {Float32Array} data The input buffer of data to be transformed.
     * @param {Float32Array} out The output buffer for the transformed data.
     * @param {number} outOff The offset at which to write the output data.
     * @param {number} off The offset at which to begin reading the input data.
     * @param {number} step The step size for indexing the input data.
     * @returns {void}
     */_singleTransform2(n,r,i,a,s){// radix-2 implementation
// NOTE: Only called for len=4
let o=n[a],l=n[a+1],u=n[a+s],c=n[a+s+1];r[i]=o+u,r[i+1]=l+c,r[i+2]=o-u,r[i+3]=l-c}/**
     * Performs radix-4 transformation on input data of length 8
     *
     * @param {Float32Array} data Input data array of length 8
     * @param {Float32Array} out Output data array of length 8
     * @param {number} outOff Index of output array to start writing from
     * @param {number} off Index of input array to start reading from
     * @param {number} step Step size between elements in input array
     * @param {number} inv Scaling factor for inverse transform
     * 
     * @returns {void}
     */_singleTransform4(n,r,i,a,s,o){// radix-4
// NOTE: Only called for len=8
let l=2*s,u=3*s,c=n[a],h=n[a+1],d=n[a+s],p=n[a+s+1],f=n[a+l],m=n[a+l+1],g=n[a+u],_=n[a+u+1],y=c+f,b=h+m,v=c-f,x=h-m,w=d+g,T=p+_,S=o*(d-g),E=o*(p-_);// Final values
r[i]=y+w,r[i+1]=b+T,r[i+2]=v+E,r[i+3]=x-S,r[i+4]=y-w,r[i+5]=b-T,r[i+6]=v-E,r[i+7]=x+S}/**
     * Real input radix-4 implementation
     * @param {Float32Array} out Output array for the transformed data
     * @param {Float32Array} data Input array of real data to be transformed
     * @param {number} inv The scale factor used to normalize the inverse transform
     */_realTransform4(n,r,i){// Real input radix-4 implementation
let a=this._csize,s=this._width,o=1<<s,l=a/o<<1;var u,c,h=this._bitrev;if(4===l)for(u=0,c=0;u<a;u+=l,++c){let i=h[c];this._singleRealTransform2(r,n,u,i>>>1,o>>>1)}else for(u=0,c=0;u<a;u+=l,++c){let a=h[c];this._singleRealTransform4(r,n,u,a>>>1,o>>>1,i)}// Loop through steps in decreasing order
for(o>>=2;o>=2;o>>=2){l=a/o<<1;let r=l>>>1,s=r>>>1,c=s>>>1;// Loop through offsets in the data
for(u=0;u<a;u+=l)for(let a=0,l=0;a<=c;a+=2,l+=o){let o=u+a,h=o+s,d=h+s,p=d+s,f=n[o],m=n[o+1],g=n[h],_=n[h+1],y=n[d],b=n[d+1],v=n[p],x=n[p+1],w=this.table[l],T=i*this.table[l+1],S=g*w-_*T,E=g*T+_*w,A=this.table[2*l],M=i*this.table[2*l+1],I=y*A-b*M,P=y*M+b*A,O=this.table[3*l],R=i*this.table[3*l+1],C=v*O-x*R,L=v*R+x*O,D=f+I,N=m+P,k=f-I,U=m-P,F=S+C,B=E+L,z=i*(S-C),V=i*(E-L);// Output final middle point
if(// Final values
n[o]=D+F,n[o+1]=N+B,n[h]=k+V,n[h+1]=U-z,0===a){n[d]=D-F,n[d+1]=N-B;continue}// Do not overwrite ourselves
if(a===c)continue;let G=u+s-a,j=u+r-a;n[G]=k+-i*V,n[G+1]=-U-i*z,n[j]=D+-i*F,n[j+1]=-N+i*B}}}/**
     * Performs a single real input radix-2 transformation on the provided data
     * 
     * @param {Float32Array} data The input data array
     * @param {Float32Array} out The output data array
     * @param {number} outOff The output offset
     * @param {number} off The input offset
     * @param {number} step The step
     * 
     * @returns {void}
     */_singleRealTransform2(n,r,i,a,s){// radix-2 implementation
// NOTE: Only called for len=4
let o=n[a],l=n[a+s];r[i]=o+l,r[i+1]=0,r[i+2]=o-l,r[i+3]=0}/**
     * Computes a single real-valued transform using radix-4 algorithm.
     * This method is only called for len=8.
     *
     * @param {Float32Array} data The input data array.
     * @param {Float32Array} out The output data array.
     * @param {number} outOff The offset into the output array.
     * @param {number} off The offset into the input array.
     * @param {number} step The step size for the input array.
     * @param {number} inv The value of inverse.
     */_singleRealTransform4(n,r,i,a,s,o){// radix-4
// NOTE: Only called for len=8
let l=2*s,u=3*s,c=n[a],h=n[a+s],d=n[a+l],p=n[a+u],f=c+d,m=c-d,g=h+p,_=o*(h-p);// Final values
r[i]=f+g,r[i+1]=0,r[i+2]=m,r[i+3]=-_,r[i+4]=f-g,r[i+5]=0,r[i+6]=m,r[i+7]=_}}function $821ef51da65e5775$export$26eccfba0731e2c4(n,r){if(r%2==0||r<=0)throw Error("Window size must be a positive odd number");// @ts-ignore
let i=new n.constructor(n.length),a=new n.constructor(r),s=Math.floor(r/2);for(let r=0;r<n.length;++r){let o=0;for(let i=-s;i<=s;++i){let s=r+i;s<0?s=Math.abs(s):s>=n.length&&(s=2*(n.length-1)-s),a[o++]=n[s]}a.sort(),i[r]=a[s]}return i}function $821ef51da65e5775$export$2077e0241d6afd3c(n,r){let i=Math.pow(10,r);return Math.round(n*i)/i}/**
 * @file Helper module for `Tensor` processing.
 * 
 * These functions and classes are only used internally, 
 * meaning an end-user shouldn't need to access anything here.
 * 
 * @module utils/tensor
 *//**
 * @typedef {import('./maths.js').AnyTypedArray} AnyTypedArray
 *//** @type {Object} */const $970f59cad5f0fd6a$var$ONNXTensor=$b8705bfef224a9de$export$1cf47f9eac95b665.Tensor;class $970f59cad5f0fd6a$export$7b6b8d90402f8814 extends $970f59cad5f0fd6a$var$ONNXTensor{/**
     * Create a new Tensor or copy an existing Tensor.
     * @param {[string, Array|AnyTypedArray, number[]]|[ONNXTensor]} args
     */constructor(...n){return n[0]instanceof $b8705bfef224a9de$export$1cf47f9eac95b665.Tensor?super(n[0].type,n[0].data,n[0].dims):super(...n),new Proxy(this,{get:(n,r)=>{if("string"==typeof r){let i=Number(r);if(Number.isInteger(i))return n._getitem(i)}// @ts-ignore
return n[r]},set:(n,r,i)=>n[r]=i})}/**
     * Returns an iterator object for iterating over the tensor data in row-major order.
     * If the tensor has more than one dimension, the iterator will yield subarrays.
     * @returns {Iterator} An iterator object for iterating over the tensor data in row-major order.
     */*[Symbol.iterator](){let[n,...r]=this.dims;if(r.length>0){let i=r.reduce((n,r)=>n*r);for(let a=0;a<n;++a)yield this._subarray(a,i,r)}else yield*this.data}/**
     * Index into a Tensor object.
     * @param {number} index The index to access.
     * @returns {Tensor} The data at the specified index.
     */_getitem(n){let[r,...i]=this.dims;if(n=$970f59cad5f0fd6a$var$safeIndex(n,r),!(i.length>0))return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(this.type,[this.data[n]],i);{let r=i.reduce((n,r)=>n*r);return this._subarray(n,r,i)}}/**
     * @param {number|bigint} item The item to search for in the tensor
     * @returns {number} The index of the first occurrence of item in the tensor data.
     */indexOf(n){for(let r=0;r<this.data.length;++r)// Note: == instead of === so we can match Ints with BigInts
if(this.data[r]==n)return r;return -1}/**
     * @param {number} index 
     * @param {number} iterSize 
     * @param {any} iterDims 
     * @returns {Tensor}
     */_subarray(n,r,i){let a=this.data.subarray(n*r,(n+1)*r);return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(this.type,a,i)}/**
     * Returns the value of this tensor as a standard JavaScript Number. This only works
     * for tensors with one element. For other cases, see `Tensor.tolist()`.
     * @returns {number} The value of this tensor as a standard JavaScript Number.
     * @throws {Error} If the tensor has more than one element.
     */item(){if(1!==this.data.length)throw Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);return this.data[0]}/**
     * Convert tensor data to a n-dimensional JS list
     * @returns {Array}
     */tolist(){return $970f59cad5f0fd6a$var$reshape(this.data,this.dims)}/**
     * Return a new Tensor with the sigmoid function applied to each element.
     * @returns {Tensor} The tensor with the sigmoid function applied.
     */sigmoid(){return this.clone().sigmoid_()}/**
     * Applies the sigmoid function to the tensor in place.
     * @returns {Tensor} Returns `this`.
     */sigmoid_(){for(let n=0;n<this.data.length;++n)this.data[n]=1/(1+Math.exp(-this.data[n]));return this}clone(){return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(this.type,this.data.slice(),this.dims.slice())}slice(...n){// This allows for slicing with ranges and numbers
let r=[],i=[];// slices is an array of numbers or arrays of numbers
// e.g., slices = [0, [1, 3], null, [0, 3]]
for(let a=0;a<this.dims.length;++a){let s=n[a];if(null==s)// null or undefined means take the whole dimension
i.push([0,this.dims[a]]),r.push(this.dims[a]);else if("number"==typeof s)s=$970f59cad5f0fd6a$var$safeIndex(s,this.dims[a],a),// A number means take a single element
i.push([s,s+1]);else if(Array.isArray(s)&&2===s.length){// An array of length 2 means take a range of elements
if(s[0]>s[1])throw Error(`Invalid slice: ${s}`);let n=[Math.max(s[0],0),Math.min(s[1],this.dims[a])];i.push(n),r.push(n[1]-n[0])}else throw Error(`Invalid slice: ${s}`)}let a=i.map(([n,r])=>r-n),s=a.reduce((n,r)=>n*r),o=new this.data.constructor(s),l=this.stride();for(let n=0;n<s;++n){let r=0;for(let s=a.length-1,o=n;s>=0;--s){let n=a[s];r+=(o%n+i[s][0])*l[s],o=Math.floor(o/n)}o[n]=this.data[r]}return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(this.type,o,r)}/**
     * Return a transposed version of this Tensor, according to the provided dimensions.
     * @param  {...number} dims Dimensions to transpose.
     * @returns {Tensor} The transposed tensor.
     */transpose(...n){return $970f59cad5f0fd6a$export$9cb09a71b7d66923(this,n)}// TODO: rename transpose to permute
// TODO: implement transpose
// TODO add .max() and .min() methods
/**
     * Returns the sum of each row of the input tensor in the given dimension dim.
     * 
     * @param {number} [dim=null] The dimension or dimensions to reduce. If `null`, all dimensions are reduced.
     * @param {boolean} keepdim Whether the output tensor has `dim` retained or not.
     * @returns The summed tensor
     */sum(n=null,r=!1){return this.norm(1,n,r)}/**
     * Returns the matrix norm or vector norm of a given tensor.
     * @param {number|string} [p='fro'] The order of norm
     * @param {number} [dim=null] Specifies which dimension of the tensor to calculate the norm across.
     * If dim is None, the norm will be calculated across all dimensions of input.
     * @param {boolean} [keepdim=false] Whether the output tensors have dim retained or not.
     * @returns {Tensor} The norm of the tensor.
     */norm(n="fro",r=null,i=!1){if("fro"===n)n=2;else if("string"==typeof n)throw Error(`Unsupported norm: ${n}`);if(null===r){// @ts-ignore
let r=this.data.reduce((r,i)=>r+i**n,0)**(1/n);return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(this.type,[r],[])}// Negative indexing
r=$970f59cad5f0fd6a$var$safeIndex(r,this.dims.length);// Calculate the shape of the resulting array after summation
let a=this.dims.slice();// Copy the original dimensions
a[r]=1;// Create a new array to store the accumulated values
let s=new this.data.constructor(this.data.length/this.dims[r]);// Iterate over the data array
for(let i=0;i<this.data.length;++i){// Calculate the index in the resulting array
let o=0;for(let n=this.dims.length-1,s=i,l=1;n>=0;--n){let i=this.dims[n];if(n!==r){let r=s%i;o+=r*l,l*=a[n]}s=Math.floor(s/i)}// Accumulate the value at the current index
s[o]+=this.data[i]**n}if(1!==n)for(let r=0;r<s.length;++r)s[r]=s[r]**(1/n);return i||a.splice(r,1),new $970f59cad5f0fd6a$export$7b6b8d90402f8814(this.type,s,a)}/**
     * Performs `L_p` normalization of inputs over specified dimension. Operates in place.
     * @param {number} [p=2] The exponent value in the norm formulation
     * @param {number} [dim=1] The dimension to reduce
     * @returns {Tensor} `this` for operation chaining.
     */normalize_(n=2,r=1){r=$970f59cad5f0fd6a$var$safeIndex(r,this.dims.length);let i=this.norm(n,r,!0);for(let n=0;n<this.data.length;++n){// Calculate the index in the resulting array
let a=0;for(let i=this.dims.length-1,s=n,o=1;i>=0;--i){let n=this.dims[i];if(i!==r){let r=s%n;a+=r*o,o*=this.dims[i]}s=Math.floor(s/n)}// Divide by normalized value
this.data[n]/=i.data[a]}return this}/**
     * Performs `L_p` normalization of inputs over specified dimension.
     * @param {number} [p=2] The exponent value in the norm formulation
     * @param {number} [dim=1] The dimension to reduce
     * @returns {Tensor} The normalized tensor.
     */normalize(n=2,r=1){return this.clone().normalize_(n,r)}/**
     * Compute and return the stride of this tensor.
     * Stride is the jump necessary to go from one element to the next one in the specified dimension dim.
     * @returns {number[]} The stride of this tensor.
     */stride(){return $970f59cad5f0fd6a$var$dimsToStride(this.dims)}/**
     * Returns a tensor with all specified dimensions of input of size 1 removed.
     * 
     * NOTE: The returned tensor shares the storage with the input tensor, so changing the contents of one will change the contents of the other.
     * If you would like a copy, use `tensor.clone()` before squeezing.
     * 
     * @param {number} [dim=null] If given, the input will be squeezed only in the specified dimensions.
     * @returns The squeezed tensor
     */squeeze(n=null){return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(this.type,this.data,$970f59cad5f0fd6a$var$calc_squeeze_dims(this.dims,n))}/**
     * In-place version of @see {@link Tensor.squeeze}
     */squeeze_(n=null){return this.dims=$970f59cad5f0fd6a$var$calc_squeeze_dims(this.dims,n),this}/**
     * Returns a new tensor with a dimension of size one inserted at the specified position.
     * 
     * NOTE: The returned tensor shares the same underlying data with this tensor.
     * 
     * @param {number} dim The index at which to insert the singleton dimension
     * @returns The unsqueezed tensor
     */unsqueeze(n=null){return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(this.type,this.data,$970f59cad5f0fd6a$var$calc_unsqueeze_dims(this.dims,n))}/**
     * In-place version of @see {@link Tensor.unsqueeze}
     */unsqueeze_(n=null){return this.dims=$970f59cad5f0fd6a$var$calc_unsqueeze_dims(this.dims,n),this}/**
     * In-place version of @see {@link Tensor.flatten}
     */flatten_(n=0,r=-1){// TODO validate inputs
r=(r+this.dims.length)%this.dims.length;let i=this.dims.slice(0,n),a=this.dims.slice(n,r+1),s=this.dims.slice(r+1);return this.dims=[...i,a.reduce((n,r)=>n*r,1),...s],this}/**
     * Flattens input by reshaping it into a one-dimensional tensor.
     * If `start_dim` or `end_dim` are passed, only dimensions starting with `start_dim`
     * and ending with `end_dim` are flattened. The order of elements in input is unchanged.
     * @param {number} start_dim the first dim to flatten
     * @param {number} end_dim the last dim to flatten
     * @returns The flattened tensor.
     */flatten(n=0,r=-1){return this.clone().flatten_(n,r)}/**
     * Returns a new tensor with the same data as the `self` tensor but of a different `shape`.
     * @param  {...number} dims the desired size
     * @returns {Tensor} The tensor with the same data but different shape
     */view(...n){// TODO: validate dims
let r=-1;for(let i=0;i<n.length;++i)if(-1===n[i]){if(-1!==r)throw Error("Only one dimension can be inferred");r=i}if(-1!==r){// Some dimension must be inferred
let i=n.reduce((n,i,a)=>a!==r?n*i:n,1);n[r]=this.data.length/i}return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(this.type,this.data,n);// NOTE: uses same underlying storage
}neg_(){for(let n=0;n<this.data.length;++n)this.data[n]=-this.data[n];return this}neg(){return this.clone().neg_()}}/**
 * This creates a nested array of a given type and depth (see examples).
 * 
 * @example
 *   NestArray<string, 1>; // string[]
 * @example
 *   NestArray<number, 2>; // number[][]
 * @example
 *   NestArray<string, 3>; // string[][][] etc.
 * @template T
 * @template {number} Depth
 * @template {never[]} [Acc=[]]
 * @typedef {Acc['length'] extends Depth ? T : NestArray<T[], Depth, [...Acc, never]>} NestArray
 *//**
 * Reshapes a 1-dimensional array into an n-dimensional array, according to the provided dimensions.
 *
 * @example
 *   reshape([10                    ], [1      ]); // Type: number[]      Value: [10]
 *   reshape([1, 2, 3, 4            ], [2, 2   ]); // Type: number[][]    Value: [[1, 2], [3, 4]]
 *   reshape([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 2]); // Type: number[][][]  Value: [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
 *   reshape([1, 2, 3, 4, 5, 6, 7, 8], [4, 2   ]); // Type: number[][]    Value: [[1, 2], [3, 4], [5, 6], [7, 8]]
 * @param {T[]} data The input array to reshape.
 * @param {DIM} dimensions The target shape/dimensions.
 * @template T
 * @template {[number]|[number, number]|[number, number, number]|[number, number, number, number]} DIM
 * @returns {NestArray<T, DIM["length"]>} The reshaped array.
 */function $970f59cad5f0fd6a$var$reshape(n,r){let i=n.length,a=r.reduce((n,r)=>n*r);if(i!==a)throw Error(`cannot reshape array of size ${i} into shape (${r})`);/** @type {any} */let s=n;for(let n=r.length-1;n>=0;n--)s=s.reduce((i,a)=>{let s=i[i.length-1];return s.length<r[n]?s.push(a):i.push([a]),i},[[]]);return s[0]}function $970f59cad5f0fd6a$export$9cb09a71b7d66923(n,r){let[i,a]=$821ef51da65e5775$export$1874c7f77119edd3(n.data,n.dims,r);return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(n.type,i,a)}function $970f59cad5f0fd6a$export$89e29e4ab65e70a9(n,[r,i],a="bilinear",s=!1){// Input image dimensions
let o=n.dims.at(-3)??1,l=n.dims.at(-2),u=n.dims.at(-1),c=$821ef51da65e5775$export$132425e9e52225b9(n.data,[o,l,u],[r,i],a,s);return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(n.type,c,[o,r,i])}function $970f59cad5f0fd6a$export$821ee5c568efc6b5(n,r){// last_hidden_state: [batchSize, seqLength, embedDim]
// attention_mask:    [batchSize, seqLength]
let i=[n.dims[0],n.dims[2]],a=new n.data.constructor(i[0]*i[1]),[s,o,l]=n.dims,u=0;for(let i=0;i<s;++i){let s=i*l*o;for(let c=0;c<l;++c){let h=0,d=0,p=i*o,f=s+c;// Pool over all words in sequence
for(let i=0;i<o;++i){// index into attention mask
let a=Number(r.data[p+i]);d+=a,h+=n.data[f+i*l]*a}let m=h/d;a[u++]=m}}return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(n.type,a,i)}/**
 * Helper function to calculate new dimensions when performing a squeeze operation.
 * @param {number[]} dims The dimensions of the tensor.
 * @param {number|number[]|null} dim The dimension(s) to squeeze.
 * @returns The new dimensions.
 * @private
 */function $970f59cad5f0fd6a$var$calc_squeeze_dims(n,r){return n=n.slice(),null===r?n=n.filter(n=>1!==n):"number"==typeof r?1===n[r]&&n.splice(r,1):Array.isArray(r)&&(n=n.filter((n,i)=>1!==n||!r.includes(i))),n}/**
 * Helper function to calculate new dimensions when performing an unsqueeze operation.
 * @param {number[]} dims The dimensions of the tensor.
 * @param {number} dim The dimension to unsqueeze.
 * @returns The new dimensions.
 * @private
 */function $970f59cad5f0fd6a$var$calc_unsqueeze_dims(n,r){return(// Dimension out of range (e.g., "expected to be in range of [-4, 3], but got 4")
// + 1 since we allow inserting at the end (i.e. dim = -1)
r=$970f59cad5f0fd6a$var$safeIndex(r,n.length+1),// Insert 1 into specified dimension
(n=n.slice()).splice(r,0,1),n)}/**
 * Safely calculate the index for an array of a given size, allowing negative indexing.
 * @param {number} index The index that will be used.
 * @param {number} size The size of the array.
 * @param {number} [dimension=null] The dimension that the index is for (optional).
 * @returns {number} The index, guaranteed to be non-negative and less than `arrayLength`.
 * 
 * @throws {Error} If the index is out of range.
 * @private
 */function $970f59cad5f0fd6a$var$safeIndex(n,r,i=null){if(n<-r||n>=r)throw Error(`IndexError: index ${n} is out of bounds for dimension${null===i?"":" "+i} with size ${r}`);return n<0&&(n=(n%r+r)%r),n}function $970f59cad5f0fd6a$export$99aaa11fb71d263(n,r=0){r=$970f59cad5f0fd6a$var$safeIndex(r,n[0].dims.length);// TODO do validation of shapes
let i=n[0].dims.slice();i[r]=n.reduce((n,i)=>n+i.dims[r],0);// Create a new array to store the accumulated values
let a=i.reduce((n,r)=>n*r,1),s=new n[0].data.constructor(a),o=n[0].type;if(0===r){// Handle special case for performance reasons
let r=0;for(let i of n)s.set(i.data,r),r+=i.data.length}else{let a=0;for(let o=0;o<n.length;++o){let l=n[o];// Iterate over the data array
for(let n=0;n<l.data.length;++n){// Calculate the index in the resulting array
let o=0;for(let s=l.dims.length-1,u=n,c=1;s>=0;--s){let n=l.dims[s],h=u%n;s===r&&(h+=a),o+=h*c,c*=i[s],u=Math.floor(u/n)}// Accumulate the value at the current index
s[o]=l.data[n]}a+=l.dims[r]}}return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(o,s,i)}function $970f59cad5f0fd6a$export$a57ab32f40f83ea9(n,r=0){// TODO do validation of shapes
// NOTE: stack expects each tensor to be equal size
return $970f59cad5f0fd6a$export$99aaa11fb71d263(n.map(n=>n.unsqueeze(r)),r)}function $970f59cad5f0fd6a$export$a2ad268dbb52039d(n,r=null,i=1,a=!1){if(null===r){// None to reduce over all dimensions.
let r=n.data.reduce((n,r)=>n+r,0),a=r/n.data.length,s=Math.sqrt(n.data.reduce((n,r)=>n+(r-a)**2,0)/(n.data.length-i)),o=new $970f59cad5f0fd6a$export$7b6b8d90402f8814(n.type,[a],[]),l=new $970f59cad5f0fd6a$export$7b6b8d90402f8814(n.type,[s],[]);return[l,o]}// Negative indexing
r=$970f59cad5f0fd6a$var$safeIndex(r,n.dims.length);let s=$970f59cad5f0fd6a$export$1ce691f85baaa52(n,r,a),o=n.dims.slice();o[r]=1;// Remove the specified axis
// Create a new array to store the accumulated values
let l=new n.data.constructor(n.data.length/n.dims[r]);// Iterate over the data array
for(let i=0;i<n.data.length;++i){// Calculate the index in the resulting array
let a=0;for(let s=n.dims.length-1,l=i,u=1;s>=0;--s){let i=n.dims[s];if(s!==r){let n=l%i;a+=n*u,u*=o[s]}l=Math.floor(l/i)}// Accumulate the value at the current index
l[a]+=(n.data[i]-s.data[a])**2}for(let a=0;a<l.length;++a)l[a]=Math.sqrt(l[a]/(n.dims[r]-i));a||o.splice(r,1);let u=new $970f59cad5f0fd6a$export$7b6b8d90402f8814(n.type,l,o);return[u,s]}function $970f59cad5f0fd6a$export$1ce691f85baaa52(n,r=null,i=!1){if(null===r){// None to reduce over all dimensions.
let r=n.data.reduce((n,r)=>n+r,0);return new $970f59cad5f0fd6a$export$7b6b8d90402f8814(n.type,[r/n.data.length],[])}// Negative indexing
r=$970f59cad5f0fd6a$var$safeIndex(r,n.dims.length);// Calculate the shape of the resulting array after summation
let a=n.dims.slice();// Copy the original dimensions
a[r]=1;// Create a new array to store the accumulated values
let s=new n.data.constructor(n.data.length/n.dims[r]);// Iterate over the data array
for(let i=0;i<n.data.length;++i){// Calculate the index in the resulting array
let o=0;for(let s=n.dims.length-1,l=i,u=1;s>=0;--s){let i=n.dims[s];if(s!==r){let n=l%i;o+=n*u,u*=a[s]}l=Math.floor(l/i)}// Accumulate the value at the current index
s[o]+=n.data[i]}if(1!==n.dims[r])for(let i=0;i<s.length;++i)s[i]=s[i]/n.dims[r];return i||a.splice(r,1),new $970f59cad5f0fd6a$export$7b6b8d90402f8814(n.type,s,a)}function $970f59cad5f0fd6a$export$65a9a636508fbc8d(n){let[r,i]=n.dims,a=[r+1,i+1],s=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",new Float32Array(a[0]*a[1]).fill(1/0),a),o=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",new Float32Array(a[0]*a[1]).fill(-1),a);// same as `cost[0][0] = 0`;
s[0].data[0]=0;for(let a=1;a<i+1;++a)for(let i=1;i<r+1;++i){let r,l;let u=s[i-1][a-1].item(),c=s[i-1][a].item(),h=s[i][a-1].item();u<c&&u<h?(r=u,l=0):c<u&&c<h?(r=c,l=1):(r=h,l=2),s[i].data[a]=n[i-1][a-1].item()+r,o[i].data[a]=l}// backtrace
let l=r,u=i;o.data.fill(2,0,a[1])// trace[0, :] = 2
;for(let n=0;n<a[0];++n)o[n].data[0]=1;let c=[],h=[];for(;l>0||u>0;){c.push(l-1),h.push(u-1);let n=o[l][u].item();switch(n){case 0:--l,--u;break;case 1:--l;break;case 2:--u;break;default:throw Error(`Internal error in dynamic time warping. Unexpected trace[${l}, ${u}]. Please file a bug report.`)}}return c.reverse(),h.reverse(),[c,h]}function $970f59cad5f0fd6a$var$dimsToStride(n){let r=Array(n.length);for(let i=n.length-1,a=1;i>=0;--i)r[i]=a,a*=n[i];return r}/**
 * @file Custom data structures.
 * 
 * These are only used internally, meaning an end-user shouldn't
 * need to access anything here.
 * 
 * @module utils/data-structures
 *//**
 * Efficient Heap-based Implementation of a Priority Queue.
 * It uses an array-based binary heap, where the root is at index `0`, and the
 * children of node `i` are located at indices `2i + 1` and `2i + 2`, respectively.
 * 
 * Adapted from the following sources:
 * - https://stackoverflow.com/a/42919752/13989043 (original)
 * - https://github.com/belladoreai/llama-tokenizer-js (minor improvements)
 */class $b35f5df89a97db8e$export$8fbd1ac8e83536df{/**
     * Create a new PriorityQueue.
     * @param {Function} comparator Comparator function to determine priority. Defaults to a MaxHeap.
     */constructor(n=(n,r)=>n>r){this._heap=[],this._comparator=n}/**
     * The size of the queue
     */get size(){return this._heap.length}/**
     * Check if the queue is empty.
     * @returns {boolean} `true` if the queue is empty, `false` otherwise.
     */isEmpty(){return 0===this.size}/**
     * Return the element with the highest priority in the queue.
     * @returns {any} The highest priority element in the queue.
     */peek(){return this._heap[0]}/**
     * Add one or more elements to the queue.
     * @param  {...any} values The values to push into the queue.
     * @returns {number} The new size of the queue.
     */push(...n){return this.extend(n)}/**
     * Add multiple elements to the queue.
     * @param {any[]} values The values to push into the queue.
     * @returns {number} The new size of the queue.
     */extend(n){for(let r of n)this._heap.push(r),this._siftUp();return this.size}/**
     * Remove and return the element with the highest priority in the queue.
     * @returns {any} The element with the highest priority in the queue.
     */pop(){let n=this.peek(),r=this.size-1;return r>0&&this._swap(0,r),this._heap.pop(),this._siftDown(),n}/**
     * Replace the element with the highest priority in the queue with a new value.
     * @param {*} value The new value.
     * @returns {*} The replaced value.
     */replace(n){let r=this.peek();return this._heap[0]=n,this._siftDown(),r}/**
     * Compute the index for the parent of the node at index `i`.
     * @param {number} i The index of the node to get the parent of.
     * @returns {number} The index of the parent node.
     * @private
     */_parent(n){return(n+1>>>1)-1}/**
     * Compute the index for the left child of the node at index `i`.
     * @param {number} i The index of the node to get the left child of.
     * @returns {number} The index of the left child.
     * @private
     */_left(n){return(n<<1)+1}/**
     * Compute the index for the right child of the node at index `i`.
     * @param {number} i The index of the node to get the right child of.
     * @returns {number} The index of the right child.
     * @private
     */_right(n){return n+1<<1}/**
     * Check if the element at index `i` is greater than the element at index `j`.
     * @param {number} i The index of the first element to compare.
     * @param {number} j The index of the second element to compare.
     * @returns {boolean} `true` if the element at index `i` is greater than the element at index `j`, `false` otherwise.
     * @private
     */_greater(n,r){return this._comparator(this._heap[n],this._heap[r])}/**
     * Swap the elements at indices `i` and `j`.
     * @param {number} i The index of the first element to swap.
     * @param {number} j The index of the second element to swap.
     * @private
     */_swap(n,r){let i=this._heap[n];this._heap[n]=this._heap[r],this._heap[r]=i}/**
     * Maintain the heap property by updating positions in the heap,
     * starting at the last element and moving up the heap.
     * @private
     */_siftUp(){let n=this.size-1;for(;n>0&&this._greater(n,this._parent(n));)this._swap(n,this._parent(n)),n=this._parent(n)}/**
     * Maintain the heap property by updating positions in the heap,
     * starting at the first element and moving down the heap.
     * @private
     */_siftDown(){let n=0;for(;this._left(n)<this.size&&this._greater(this._left(n),n)||this._right(n)<this.size&&this._greater(this._right(n),n);){let r=this._right(n)<this.size&&this._greater(this._right(n),this._left(n))?this._right(n):this._left(n);this._swap(n,r),n=r}}}class $b35f5df89a97db8e$export$f71b64582e0bc858{constructor(){this.root=$b35f5df89a97db8e$var$CharTrieNode.default()}/**
     * Adds one or more `texts` to the trie.
     * @param {string[]} texts The strings to add to the trie.
     */extend(n){for(let r of n)this.push(r)}/**
     * Adds text to the trie.
     * @param {string} text The string to add to the trie.
     */push(n){let r=this.root;for(let i of n){let n=r.children.get(i);void 0===n&&(n=$b35f5df89a97db8e$var$CharTrieNode.default(),r.children.set(i,n)),r=n}r.isLeaf=!0}/**
     * Searches the trie for all strings with a common prefix of `text`.
     * @param {string} text The common prefix to search for.
     * @yields {string} Each string in the trie that has `text` as a prefix.
     */*commonPrefixSearch(n){let r=this.root,i="";for(let a=0;a<n.length&&void 0!==r;++a){let s=n[a];i+=s,void 0!==(r=r.children.get(s))&&r.isLeaf&&(yield i)}}}/**
 * Represents a node in a character trie.
 */class $b35f5df89a97db8e$var$CharTrieNode{/**
     * Create a new CharTrieNode.
     * @param {boolean} isLeaf Whether the node is a leaf node or not.
     * @param {Map<string, CharTrieNode>} children A map containing the node's children, where the key is a character and the value is a `CharTrieNode`.
     */constructor(n,r){this.isLeaf=n,this.children=r}/**
     * Returns a new `CharTrieNode` instance with default values.
     * @returns {CharTrieNode} A new `CharTrieNode` instance with `isLeaf` set to `false` and an empty `children` map.
     */static default(){return new $b35f5df89a97db8e$var$CharTrieNode(!1,new Map)}}class $b35f5df89a97db8e$export$eb65960645f606f8{/**
     * Creates a new TokenLattice instance.
     *
     * @param {string} sentence The input sentence to be tokenized.
     * @param {number} bosTokenId The beginning-of-sequence token ID.
     * @param {number} eosTokenId The end-of-sequence token ID.
     */constructor(n,r,i){this.sentence=n,this.len=n.length,this.bosTokenId=r,this.eosTokenId=i,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);let a=new $b35f5df89a97db8e$var$TokenLatticeNode(this.bosTokenId,0,0,0,0),s=new $b35f5df89a97db8e$var$TokenLatticeNode(this.eosTokenId,1,this.len,0,0);this.nodes.push(a.clone()),this.nodes.push(s.clone()),this.beginNodes[this.len].push(s),this.endNodes[0].push(a)}/**
     * Inserts a new token node into the token lattice.
     *
     * @param {number} pos The starting position of the token.
     * @param {number} length The length of the token.
     * @param {number} score The score of the token.
     * @param {number} tokenId The token ID of the token.
     */insert(n,r,i,a){let s=this.nodes.length,o=new $b35f5df89a97db8e$var$TokenLatticeNode(a,s,n,r,i);this.beginNodes[n].push(o),this.endNodes[n+r].push(o),this.nodes.push(o)}/**
     * Implements the Viterbi algorithm to compute the most likely sequence of tokens.
     *
     * @returns {TokenLatticeNode[]} The array of nodes representing the most likely sequence of tokens.
     */viterbi(){let n=this.len,r=0;for(;r<=n;){if(0==this.beginNodes[r].length)return[];for(let n of this.beginNodes[r]){n.prev=null;let i=0,a=null;for(let s of this.endNodes[r]){let r=s.backtraceScore+n.score;(null===a||r>i)&&(a=s.clone(),i=r)}if(null===a)return[];n.prev=a,n.backtraceScore=i}++r}let i=[],a=this.beginNodes[n][0],s=a.prev;if(null===s)return[];let o=s.clone();for(;null!==o.prev;){i.push(o.clone());let n=o.clone();o=n.prev.clone()}return i.reverse(),i}/**
     * @param {TokenLatticeNode} node
     * @returns {string} The array of nodes representing the most likely sequence of tokens.
     */piece(n){return this.sentence.slice(n.pos,n.pos+n.length)}/**
     * @returns {Array} The array of nodes representing the most likely sequence of tokens.
     */tokens(){let n=this.viterbi();return n.map(n=>this.piece(n))}/**
     * @returns {Array} The array of nodes representing the most likely sequence of tokens.
     */tokenIds(){let n=this.viterbi();return n.map(n=>n.tokenId)}}class $b35f5df89a97db8e$var$TokenLatticeNode{/**
     * Represents a node in a token lattice for a given sentence.
     * @param {number} tokenId The ID of the token associated with this node.
     * @param {number} nodeId The ID of this node.
     * @param {number} pos The starting position of the token in the sentence.
     * @param {number} length The length of the token.
     * @param {number} score The score associated with the token.
     */constructor(n,r,i,a,s){this.tokenId=n,this.nodeId=r,this.pos=i,this.length=a,this.score=s,this.prev=null,this.backtraceScore=0}/**
     * Returns a clone of this node.
     * @returns {TokenLatticeNode} A clone of this node.
     */clone(){let n=new $b35f5df89a97db8e$var$TokenLatticeNode(this.tokenId,this.nodeId,this.pos,this.length,this.score);return n.prev=this.prev,n.backtraceScore=this.backtraceScore,n}}/**
 * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions
 *//**
 * Loads a tokenizer from the specified path.
 * @param {string} pretrained_model_name_or_path The path to the tokenizer directory.
 * @param {PretrainedOptions} options Additional options for loading the tokenizer.
 * @returns {Promise<Array>} A promise that resolves with information about the loaded tokenizer.
 */async function $a6a9715ee3096371$var$loadTokenizer(n,r){return await Promise.all([$fb1f2fa9752dcff4$export$bdb2295ec9595824(n,"tokenizer.json",!0,r),$fb1f2fa9752dcff4$export$bdb2295ec9595824(n,"tokenizer_config.json",!0,r)])}/**
 * Helper method to construct a pattern from a config object.
 * @param {Object} pattern The pattern object.
 * @param {boolean} invert Whether to invert the pattern (only applicable for Regex patterns).
 * @returns {RegExp|string|null} The compiled pattern.
 */function $a6a9715ee3096371$var$createPattern(n,r=!0){return void 0!==n.Regex?RegExp(r?n.Regex:`(${n.Regex})`,"gu"):void 0!==n.String?n.String:(console.warn("Unknown pattern type:",n),null)}/**
 * Helper function to convert an Object to a Map
 * @param {Object} obj The object to convert.
 * @returns {Map<string, any>} The map.
 */function $a6a9715ee3096371$var$objectToMap(n){return new Map(Object.entries(n))}/**
 * Clean up a list of simple English tokenization artifacts like spaces before punctuations and abbreviated forms
 * @param {string} text The text to clean up.
 * @returns {string} The cleaned up text.
 */function $a6a9715ee3096371$var$clean_up_tokenization(n){// Clean up a list of simple English tokenization artifacts
// like spaces before punctuations and abbreviated forms
return n.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}/**
 * Helper function to remove accents from a string.
 * @param {string} text The text to remove accents from.
 * @returns {string} The text with accents removed.
 */function $a6a9715ee3096371$var$remove_accents(n){return n.replace(/[\u0300-\u036f]/g,"")}/**
 * Helper function to lowercase a string and remove accents.
 * @param {string} text The text to lowercase and remove accents from.
 * @returns {string} The lowercased text with accents removed.
 */function $a6a9715ee3096371$var$lowercase_and_remove_accent(n){return $a6a9715ee3096371$var$remove_accents(n.toLowerCase())}/**
 * Helper function to fuse consecutive values in an array equal to the specified value.
 * @param {Array} arr The input array
 * @param {any} value The value to fuse on.
 */function $a6a9715ee3096371$var$fuse(n,r){let i=[],a=0;for(;a<n.length;){if(i.push(n[a]),n[a]!==r){++a;continue}for(;a<n.length&&n[a]===r;)++a}return i}/**
 * Split a string on whitespace.
 * @param {string} text The text to split.
 * @returns {string[]} The split string.
 */function $a6a9715ee3096371$var$whitespace_split(n){return n.match(/\S+/g)||[]}const $a6a9715ee3096371$var$PUNCTUATION_REGEX="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E";class $a6a9715ee3096371$export$3cd9e7252bd18962 extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
     * Creates a new instance of TokenizerModel.
     * @param {Object} config The configuration object for the TokenizerModel.
     */constructor(n){super(),this.config=n,/** @type {string[]} */this.vocab=[],/**
         * A mapping of tokens to ids.
         * @type {Map<string, number>}
         */this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,/** @type {boolean} Whether to fuse unknown tokens when encoding. Defaults to false. */this.fuse_unk=this.config.fuse_unk??!1}/**
     * Instantiates a new TokenizerModel instance based on the configuration object provided.
     * @param {Object} config The configuration object for the TokenizerModel.
     * @param {...*} args Optional arguments to pass to the specific TokenizerModel constructor.
     * @returns {TokenizerModel} A new instance of a TokenizerModel.
     * @throws Will throw an error if the TokenizerModel type in the config is not recognized.
     */static fromConfig(n,...r){switch(n.type){case"WordPiece":return new $a6a9715ee3096371$var$WordPieceTokenizer(n);case"Unigram":// @ts-ignore
return new $a6a9715ee3096371$var$Unigram(n,...r);case"BPE":return new $a6a9715ee3096371$var$BPE(n);default:if(n.vocab)return new $a6a9715ee3096371$var$LegacyTokenizerModel(n,...r);throw Error(`Unknown TokenizerModel type: ${n.type}`)}}/**
     * Internal function to call the TokenizerModel instance.
     * @param {string[]} tokens The tokens to encode.
     * @returns {string[]} The encoded token IDs.
     */_call(n){return this.encode(n)}/**
     * Encodes a list of tokens into a list of token IDs.
     * @param {string[]} tokens The tokens to encode.
     * @returns {string[]} The encoded tokens.
     * @throws Will throw an error if not implemented in a subclass.
     */encode(n){throw Error("encode should be implemented in subclass.")}/**
     * Converts a list of tokens into a list of token IDs.
     * @param {string[]} tokens The tokens to convert.
     * @returns {number[]} The converted token IDs.
     */convert_tokens_to_ids(n){let r=n.map(n=>this.tokens_to_ids.get(n)??this.unk_token_id);return this.fuse_unk&&(r=$a6a9715ee3096371$var$fuse(r,this.unk_token_id)),r}/**
     * Converts a list of token IDs into a list of tokens.
     * @param {number[]} ids The token IDs to convert.
     * @returns {string[]} The converted tokens.
     */convert_ids_to_tokens(n){return n.map(n=>this.vocab[n]??this.unk_token)}}/**
 * A subclass of TokenizerModel that uses WordPiece encoding to encode tokens.
 * @extends TokenizerModel
 */class $a6a9715ee3096371$var$WordPieceTokenizer extends $a6a9715ee3096371$export$3cd9e7252bd18962{/**
     * @param {Object} config The configuration object.
     * @param {Object} config.vocab A mapping of tokens to ids.
     * @param {string} config.unk_token The unknown token string.
     * @param {string} config.continuing_subword_prefix The prefix to use for continuing subwords.
     */constructor(n){for(let[r,i]of(super(n),/**
         * A mapping of tokens to ids.
         * @type {Map<string, number>}
         */this.tokens_to_ids=$a6a9715ee3096371$var$objectToMap(n.vocab),/**
         * The id of the unknown token.
         * @type {number}
         */this.unk_token_id=this.tokens_to_ids.get(n.unk_token),/**
         * The unknown token string.
         * @type {string}
         */this.unk_token=n.unk_token,/**
         * An array of tokens.
         * @type {string[]}
         */this.vocab=Array(this.tokens_to_ids.size),this.tokens_to_ids))this.vocab[i]=r}/**
     * Encodes an array of tokens using WordPiece encoding.
     * @param {string[]} tokens The tokens to encode.
     * @returns {string[]} An array of encoded tokens.
     */encode(n){let r=[];for(let i of n){let n=[...i],a=!1,s=0,o=[];for(;s<n.length;){let r=n.length,i=null;for(;s<r;){let a=n.slice(s,r).join("");if(s>0&&(a=this.config.continuing_subword_prefix+a),this.tokens_to_ids.has(a)){i=a;break}--r}if(null===i){a=!0;break}o.push(i),s=r}a?r.push(this.unk_token):r.push(...o)}return r}}/**
 * Class representing a Unigram tokenizer model.
 * @extends TokenizerModel
 */class $a6a9715ee3096371$var$Unigram extends $a6a9715ee3096371$export$3cd9e7252bd18962{/**
     * Create a new Unigram tokenizer model.
     * @param {Object} config The configuration object for the Unigram model.
     * @param {number} config.unk_id The ID of the unknown token
     * @param {any[][]} config.vocab A 2D array representing a mapping of tokens to scores.
     * @param {Object} moreConfig Additional configuration object for the Unigram model.
     */constructor(n,r){super(n);let i=n.vocab.length;this.vocab=Array(i),this.scores=Array(i);for(let r=0;r<i;++r){let i=n.vocab[r];this.vocab[r]=i[0],this.scores[r]=i[1]}this.unk_token_id=n.unk_id,this.unk_token=this.vocab[n.unk_id],this.tokens_to_ids=new Map(this.vocab.map((n,r)=>[n,r])),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=r.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=$821ef51da65e5775$export$96ec731ed4dcb222(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new $b35f5df89a97db8e$export$f71b64582e0bc858,this.trie.extend(this.vocab),// NOTE: `fuse_unk` is hardcoded to true for Unigram models
// See: https://github.com/huggingface/tokenizers/blob/b58227c7f1ccf8b73ee2268354336da56d91e492/tokenizers/src/models/unigram/model.rs#L119
this.fuse_unk=!0}/**
     * Populates lattice nodes.
     * @param {TokenLattice} lattice The token lattice to populate with nodes.
     */populateNodes(n){let r=n.sentence,i=r.length,a=0;for(;a<i;){let i=1,s=!1,o=[];for(let l of this.trie.commonPrefixSearch(r.slice(a))){o.push(l);let r=this.tokens_to_ids.get(l),u=this.scores[r],c=l.length;n.insert(a,c,u,r),s||c!==i||(s=!0)}s||n.insert(a,i,this.unkScore,this.unk_token_id),a+=i}}/**
     * Encodes an array of tokens into an array of subtokens using the unigram model.
     *
     * @param {string} normalized The normalized string.
     * @returns {string[]} An array of subtokens obtained by encoding the input tokens using the unigram model.
     */tokenize(n){let r=new $b35f5df89a97db8e$export$eb65960645f606f8(n,this.bosTokenId,this.eosTokenId);return this.populateNodes(r),r.tokens()}/**
     * Encodes an array of tokens using Unigram encoding.
     * @param {Array} tokens The tokens to encode.
     * @returns {Array} An array of encoded tokens.
     */encode(n){let r=[];for(let i of n){let n=this.tokenize(i);r.push(...n)}return r}}/**
 * Returns list of utf-8 byte and a mapping to unicode strings.
 * Specifically avoids mapping to whitespace/control characters the BPE code barfs on.
 * @returns {Object} Object with utf-8 byte keys and unicode string values.
 */const $a6a9715ee3096371$var$BYTES_TO_UNICODE=(()=>{// Returns list of utf-8 byte and a mapping to unicode strings.
// We specifically avoids mapping to whitespace/control characters
// the bpe code barfs on.
let n=[...Array.from({length:94},(n,r)=>r+33),...Array.from({length:12},(n,r)=>r+161),...Array.from({length:82},(n,r)=>r+174)],r=n.slice(),i=0;for(let a=0;a<256;++a)n.includes(a)||(n.push(a),r.push(256+i),i+=1);let a=r.map(n=>String.fromCharCode(n));return Object.fromEntries(n.map((n,r)=>[n,a[r]]))})(),$a6a9715ee3096371$var$UNICODE_TO_BYTES=$2a81087eb92e3db1$export$2c62c6689f9e9be0($a6a9715ee3096371$var$BYTES_TO_UNICODE);/**
 * @typedef {Object} BPENode
 * @property {string} token The token associated with the node
 * @property {number} bias A positional bias for the node.
 * @property {number} [score] The score of the node.
 * @property {BPENode} [prev] The previous node in the linked list.
 * @property {BPENode} [next] The next node in the linked list.
 *//**
 * BPE class for encoding text into Byte-Pair-Encoding (BPE) tokens.
 * @extends TokenizerModel
 */class $a6a9715ee3096371$var$BPE extends $a6a9715ee3096371$export$3cd9e7252bd18962{/**
     * Create a BPE instance.
     * @param {Object} config The configuration object for BPE.
     * @param {Object} config.vocab A mapping of tokens to ids.
     * @param {string} config.unk_token The unknown token used for out of vocabulary words.
     * @param {string} config.end_of_word_suffix The suffix to place at the end of each word.
     * @param {Array} config.merges An array of BPE merges as strings.
     */constructor(n){for(let[r,i]of(super(n),this.BPE_SPLIT_TOKEN=" ",/** @type {Map<string, number>} */this.tokens_to_ids=$a6a9715ee3096371$var$objectToMap(n.vocab),this.unk_token_id=this.tokens_to_ids.get(n.unk_token),this.unk_token=n.unk_token,this.vocab=Array(this.tokens_to_ids.size),this.tokens_to_ids))this.vocab[i]=r;this.bpe_ranks=new Map(n.merges.map((n,r)=>[n,r])),this.merges=n.merges.map(n=>n.split(this.BPE_SPLIT_TOKEN)),this.end_of_word_suffix=n.end_of_word_suffix,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),/** @type {Map<string, string[]>} */this.cache=new Map}/**
     * Apply Byte-Pair-Encoding (BPE) to a given token. Efficient heap-based priority
     * queue implementation adapted from https://github.com/belladoreai/llama-tokenizer-js.
     * @param {string} token The token to encode.
     * @returns {string[]} The BPE encoded tokens.
     */bpe(n){if(0===n.length)return[];let r=this.cache.get(n);if(void 0!==r)return r;let i=Array.from(n);this.end_of_word_suffix&&(i[i.length-1]+=this.end_of_word_suffix);let a=[];if(i.length>1){// Create a priority queue to store the nodes that will be merged.
// The comparator function compares the scores of the nodes.
let n=new $b35f5df89a97db8e$export$8fbd1ac8e83536df((n,r)=>n.score<r.score),r={token:i[0],bias:0,prev:null,next:null},s=r;for(let r=1;r<i.length;++r){let a={bias:r/i.length,token:i[r],prev:s,next:null};s.next=a,this._add_node(n,s),s=a}for(;!n.isEmpty();){// Get the next node with the highest priority
let i=n.pop();// Check that this merge is still possible
if(i.deleted||!i.next||i.next.deleted)continue;// Next, we fix the node that comes before the current node (i.e., left side of the merge).
if(// Here, we mark the current node (left side of the merge) and the next node (right side of the merge) as deleted.
// This is because they will both be replaced by a new node representing the merge result.
i.deleted=!0,i.next.deleted=!0,i.prev){// Make a shallow copy of the previous node
let n={...i.prev};// Mark the old previous node as deleted. This avoids erroneous merges later,
// because there may still be references to this node in the priority queue.
i.prev.deleted=!0,i.prev=n,n.prev?n.prev.next=n:// `newPreviousNode` must be the new `startingNode`.
r=n}// Create a new node which represents the result of the merge.
let a={token:i.token+i.next.token,bias:i.bias,prev:i.prev,next:i.next.next};a.prev?(a.prev.next=a,this._add_node(n,a.prev)):r=a,a.next&&(a.next.prev=a,this._add_node(n,a))}// Traverse the linked list, starting from the `startingNode`, and collect the tokens.
for(let n=r;null!==n;n=n.next)a.push(n.token)}else a=i;return(// Save the result to the cache
this.cache.set(n,a),a)}/**
     * Helper function to add a node to the priority queue.
     * @param {PriorityQueue} queue 
     * @param {BPENode} node
     * @private
     */_add_node(n,r){// `score` is a measure of the merge priority: lower means higher priority
// We use the BPE rank as a measure of priority (i.e., the local of the merge in the merges list)
// We also add a fractional component to the score to break ties (with the earlier character having higher priority)
let i=this.bpe_ranks.get(r.token+this.BPE_SPLIT_TOKEN+r.next.token);void 0!==i&&(r.score=i+r.bias,n.push(r))}/**
     * Encodes the input sequence of tokens using the BPE algorithm and returns the resulting subword tokens.
     * @param {string[]} tokens The input sequence of tokens to encode.
     * @returns {string[]} The resulting subword tokens after applying the BPE algorithm to the input sequence of tokens.
     */encode(n){let r=[];for(let i of n)for(let n of this.bpe(i))this.tokens_to_ids.has(n)?r.push(n):this.byte_fallback?r.push(...Array.from(this.text_encoder.encode(n)).map(n=>`<0x${n.toString(16).toUpperCase().padStart(2,"0")}>`)):r.push(this.unk_token);return r}}/**
 * Legacy tokenizer class for tokenizers with only a vocabulary.
 */class $a6a9715ee3096371$var$LegacyTokenizerModel extends $a6a9715ee3096371$export$3cd9e7252bd18962{/**
     * Create a LegacyTokenizerModel instance.
     * @param {Object} config The configuration object for LegacyTokenizerModel.
     * @param {Object} config.vocab A (possibly nested) mapping of tokens to ids.
     * @param {Object} moreConfig Additional configuration object for the LegacyTokenizerModel model.
     */constructor(n,r){for(let[i,a]of(super(n),/**@type {Map<string, number>} */this.tokens_to_ids=$a6a9715ee3096371$var$objectToMap(r.target_lang?n.vocab[r.target_lang]:n.vocab),this.bos_token=r.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=r.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=r.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=r.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=Array(this.tokens_to_ids.size),this.tokens_to_ids))this.vocab[a]=i}encode(n){return n}}/**
 * A base class for text normalization.
 * @abstract
 */class $a6a9715ee3096371$var$Normalizer extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
     * @param {Object} config The configuration object for the normalizer.
     */constructor(n){super(),this.config=n}/**
     * Factory method for creating normalizers from config objects.
     * @static
     * @param {Object} config The configuration object for the normalizer.
     * @returns {Normalizer} A Normalizer object.
     * @throws {Error} If an unknown Normalizer type is specified in the config.
     */static fromConfig(n){if(null===n)return null;switch(n.type){case"BertNormalizer":return new $a6a9715ee3096371$var$BertNormalizer(n);case"Precompiled":return new $a6a9715ee3096371$var$Precompiled(n);case"Sequence":return new $a6a9715ee3096371$var$NormalizerSequence(n);case"Replace":return new $a6a9715ee3096371$var$Replace(n);case"NFC":return new $a6a9715ee3096371$var$NFC(n);case"NFKD":return new $a6a9715ee3096371$var$NFKD(n);case"Strip":return new $a6a9715ee3096371$var$StripNormalizer(n);case"StripAccents":return new $a6a9715ee3096371$var$StripAccents(n);case"Lowercase":return new $a6a9715ee3096371$var$Lowercase(n);case"Prepend":return new $a6a9715ee3096371$var$Prepend(n);default:throw Error(`Unknown Normalizer type: ${n.type}`)}}/**
     * Normalize the input text.
     * @abstract
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     * @throws {Error} If this method is not implemented in a subclass.
     */normalize(n){throw Error("normalize should be implemented in subclass.")}/**
     * Alias for {@link Normalizer#normalize}.
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     */_call(n){return this.normalize(n)}}/**
 * Replace normalizer that replaces occurrences of a pattern with a given string or regular expression.
 * @extends Normalizer
 */class $a6a9715ee3096371$var$Replace extends $a6a9715ee3096371$var$Normalizer{/**
     * Normalize the input text by replacing the pattern with the content.
     * @param {string} text The input text to be normalized.
     * @returns {string} The normalized text after replacing the pattern with the content.
     */normalize(n){let r=$a6a9715ee3096371$var$createPattern(this.config.pattern);return null===r?n:n=n.replaceAll(r,this.config.content)}}/**
 * A normalizer that applies Unicode normalization form C (NFC) to the input text.
 * @extends Normalizer
 */class $a6a9715ee3096371$var$NFC extends $a6a9715ee3096371$var$Normalizer{/**
     * Normalize the input text by applying Unicode normalization form C (NFC).
     * @param {string} text The input text to be normalized.
     * @returns {string} The normalized text.
     */normalize(n){return n=n.normalize("NFC")}}/**
 * NFKD Normalizer.
 * @extends Normalizer
 */class $a6a9715ee3096371$var$NFKD extends $a6a9715ee3096371$var$Normalizer{/**
     * Normalize text using NFKD normalization.
     * @param {string} text The text to be normalized.
     * @returns {string} The normalized text.
     */normalize(n){return n=n.normalize("NFKD")}}/**
 * A normalizer that strips leading and/or trailing whitespace from the input text.
 */class $a6a9715ee3096371$var$StripNormalizer extends $a6a9715ee3096371$var$Normalizer{/**
     * Strip leading and/or trailing whitespace from the input text.
     * @param {string} text The input text.
     * @returns {string} The normalized text.
     */normalize(n){return this.config.strip_left&&this.config.strip_right?n=n.trim():(this.config.strip_left&&(n=n.trimStart()),this.config.strip_right&&(n=n.trimEnd())),n}}/**
 * StripAccents normalizer removes all accents from the text.
 * @extends Normalizer
 */class $a6a9715ee3096371$var$StripAccents extends $a6a9715ee3096371$var$Normalizer{/**
     * Remove all accents from the text.
     * @param {string} text The input text.
     * @returns {string} The normalized text without accents.
     */normalize(n){return n=$a6a9715ee3096371$var$remove_accents(n)}}/**
 * A Normalizer that lowercases the input string.
 * @extends Normalizer
 */class $a6a9715ee3096371$var$Lowercase extends $a6a9715ee3096371$var$Normalizer{/**
     * Lowercases the input string.
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     */normalize(n){return n=n.toLowerCase()}}/**
 * A Normalizer that prepends a string to the input string.
 * @extends Normalizer
 */class $a6a9715ee3096371$var$Prepend extends $a6a9715ee3096371$var$Normalizer{/**
     * Prepends the input string.
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     */normalize(n){return n=this.config.prepend+n}}/**
 * A Normalizer that applies a sequence of Normalizers.
 * @extends Normalizer
 */class $a6a9715ee3096371$var$NormalizerSequence extends $a6a9715ee3096371$var$Normalizer{/**
   * Create a new instance of NormalizerSequence.
   * @param {Object} config The configuration object.
   * @param {Object[]} config.normalizers An array of Normalizer configuration objects.
   */constructor(n){super(n),this.normalizers=n.normalizers.map(n=>$a6a9715ee3096371$var$Normalizer.fromConfig(n))}/**
    * Apply a sequence of Normalizers to the input text.
    * @param {string} text The text to normalize.
    * @returns {string} The normalized text.
    */normalize(n){return this.normalizers.reduce((n,r)=>r.normalize(n),n)}}/**
 * A class representing a normalizer used in BERT tokenization.
 * @extends Normalizer
 */class $a6a9715ee3096371$var$BertNormalizer extends $a6a9715ee3096371$var$Normalizer{/**
     * Adds whitespace around any CJK (Chinese, Japanese, or Korean) character in the input text.
     *
     * @param {string} text The input text to tokenize.
     * @returns {string} The tokenized text with whitespace added around CJK characters.
     */_tokenize_chinese_chars(n){/* Adds whitespace around any CJK character. */let r=[];for(let i=0;i<n.length;++i){let a=n[i],s=a.charCodeAt(0);this._is_chinese_char(s)?(r.push(" "),r.push(a),r.push(" ")):r.push(a)}return r.join("")}/**
     * Checks whether the given Unicode codepoint represents a CJK (Chinese, Japanese, or Korean) character.
     *
     * A "chinese character" is defined as anything in the CJK Unicode block:
     * https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)
     *
     * Note that the CJK Unicode block is NOT all Japanese and Korean characters, despite its name.
     * The modern Korean Hangul alphabet is a different block, as is Japanese Hiragana and Katakana.
     * Those alphabets are used to write space-separated words, so they are not treated specially
     * and are handled like all other languages.
     *
     * @param {number} cp The Unicode codepoint to check.
     * @returns {boolean} True if the codepoint represents a CJK character, false otherwise.
     */_is_chinese_char(n){return n>=19968&&n<=40959||n>=13312&&n<=19903||n>=131072&&n<=173791||n>=173824&&n<=177983||n>=177984&&n<=178207||n>=178208&&n<=183983||n>=63744&&n<=64255||n>=194560&&n<=195103}/**
     * Strips accents from the given text.
     * @param {string} text The text to strip accents from.
     * @returns {string} The text with accents removed.
     */stripAccents(n){return n.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}/**
     * Normalizes the given text based on the configuration.
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     */normalize(n){return this.config.handle_chinese_chars&&(n=this._tokenize_chinese_chars(n)),this.config.lowercase?(n=n.toLowerCase(),!1!==this.config.strip_accents&&(n=this.stripAccents(n))):this.config.strip_accents&&(n=this.stripAccents(n)),n}}/**
 * A callable class representing a pre-tokenizer used in tokenization. Subclasses
 * should implement the `pre_tokenize_text` method to define the specific pre-tokenization logic.
 * @extends Callable
 */class $a6a9715ee3096371$var$PreTokenizer extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
   * Factory method that returns an instance of a subclass of `PreTokenizer` based on the provided configuration.
   *
   * @static
   * @param {Object} config A configuration object for the pre-tokenizer.
   * @returns {PreTokenizer} An instance of a subclass of `PreTokenizer`.
   * @throws {Error} If the provided configuration object does not correspond to any known pre-tokenizer.
   */static fromConfig(n){if(null===n)return null;switch(n.type){case"BertPreTokenizer":return new $a6a9715ee3096371$var$BertPreTokenizer(n);case"Sequence":return new $a6a9715ee3096371$var$PreTokenizerSequence(n);case"WhitespaceSplit":return new $a6a9715ee3096371$var$WhitespaceSplit(n);case"Metaspace":return new $a6a9715ee3096371$var$MetaspacePreTokenizer(n);case"ByteLevel":return new $a6a9715ee3096371$var$ByteLevelPreTokenizer(n);case"Split":return new $a6a9715ee3096371$var$SplitPreTokenizer(n);case"Punctuation":return new $a6a9715ee3096371$var$PunctuationPreTokenizer(n);case"Digits":return new $a6a9715ee3096371$var$DigitsPreTokenizer(n);default:throw Error(`Unknown PreTokenizer type: ${n.type}`)}}/**
   * Method that should be implemented by subclasses to define the specific pre-tokenization logic.
   *
   * @abstract
   * @param {string} text The text to pre-tokenize.
   * @returns {string[]} The pre-tokenized text.
   * @throws {Error} If the method is not implemented in the subclass.
   */pre_tokenize_text(n){throw Error("pre_tokenize_text should be implemented in subclass.")}/**
     * Tokenizes the given text into pre-tokens.
     * @param {string|string[]} text The text or array of texts to pre-tokenize.
     * @returns {string[]} An array of pre-tokens.
     */pre_tokenize(n){let r=[];return(r=Array.isArray(n)?n.map(n=>this.pre_tokenize_text(n)):this.pre_tokenize_text(n)).flat()}/**
     * Alias for {@link PreTokenizer#pre_tokenize}.
     * @param {string|string[]} text The text or array of texts to pre-tokenize.
     * @returns {string[]} An array of pre-tokens.
     */_call(n){return this.pre_tokenize(n)}}/**
 * @extends PreTokenizer
 */class $a6a9715ee3096371$var$BertPreTokenizer extends $a6a9715ee3096371$var$PreTokenizer{/**
     * A PreTokenizer that splits text into wordpieces using a basic tokenization scheme
     * similar to that used in the original implementation of BERT.
     * 
     * @param {Object} config The configuration object.
     */constructor(n){super(),// Construct a pattern which matches the rust implementation:
// https://github.com/huggingface/tokenizers/blob/b4fcc9ce6e4ad5806e82826f816acfdfdc4fcc67/tokenizers/src/pre_tokenizers/bert.rs#L11
// Equivalent to removing whitespace and splitting on punctuation (both \p{P} and other ascii characters)
this.pattern=RegExp(`[^\\s${$a6a9715ee3096371$var$PUNCTUATION_REGEX}]+|[${$a6a9715ee3096371$var$PUNCTUATION_REGEX}]`,"gu")}/**
     * Tokenizes a single text using the BERT pre-tokenization scheme.
     * 
     * @param {string} text The text to tokenize.
     * @returns {string[]} An array of tokens.
     */pre_tokenize_text(n){return n.trim().match(this.pattern)||[]}}/**
 * A pre-tokenizer that splits text into Byte-Pair-Encoding (BPE) subwords.
 * @extends PreTokenizer
 */class $a6a9715ee3096371$var$ByteLevelPreTokenizer extends $a6a9715ee3096371$var$PreTokenizer{/**
     * Creates a new instance of the `ByteLevelPreTokenizer` class.
     * @param {Object} config The configuration object.
     */constructor(n){super(),this.config=n,/**
         * @type {boolean} Whether to add a leading space to the first word.
         * This allows to treat the leading word just as any other word.
         */this.add_prefix_space=this.config.add_prefix_space,/**
         * @type {boolean} Whether the post processing step should trim offsets
         * to avoid including whitespaces.
         * @todo Use this in the pretokenization step.
         */this.trim_offsets=this.config.trim_offsets,/**
         * @type {boolean} Whether to use the standard GPT2 regex for whitespace splitting.
         * Set it to False if you want to use your own splitting. Defaults to true.
         */this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=$a6a9715ee3096371$var$BYTES_TO_UNICODE,this.text_encoder=new TextEncoder}/**
     * Tokenizes a single piece of text using byte-level tokenization.
     * @param {string} text The text to tokenize.
     * @returns {string[]} An array of tokens.
     */pre_tokenize_text(n){// Maps all our bytes to unicode strings, avoiding control tokens of the BPE (spaces in our case)
return this.add_prefix_space&&!n.startsWith(" ")&&(n=" "+n),(this.use_regex?n.match(this.pattern)||[]:[n]).map(n=>Array.from(this.text_encoder.encode(n),n=>this.byte_encoder[n]).join(""))}}/**
 * @typedef {'removed'|'isolated'|'mergedWithPrevious'|'mergedWithNext'|'contiguous'} SplitDelimiterBehavior
 *//**
 * Splits text using a given pattern.
 * @extends PreTokenizer
 */class $a6a9715ee3096371$var$SplitPreTokenizer extends $a6a9715ee3096371$var$PreTokenizer{/**
     * @param {Object} config The configuration options for the pre-tokenizer.
     * @param {Object} config.pattern The pattern used to split the text. Can be a string or a regex object.
     * @param {string|undefined} config.pattern.String The string to use for splitting. Only defined if the pattern is a string.
     * @param {string|undefined} config.pattern.Regex The regex to use for splitting. Only defined if the pattern is a regex.
     * @param {SplitDelimiterBehavior} config.behavior The behavior to use when splitting.
     * @param {boolean} config.invert Whether to split (invert=false) or match (invert=true) the pattern.
     */constructor(n){super(),this.config=n,// TODO support all behaviours (config.behavior)
this.pattern=$a6a9715ee3096371$var$createPattern(this.config.pattern,this.config.invert)}/**
     * Tokenizes text by splitting it using the given pattern.
     * @param {string} text The text to tokenize.
     * @returns {string[]} An array of tokens.
     */pre_tokenize_text(n){return null===this.pattern?[]:this.config.invert?n.match(this.pattern)||[]:n.split(this.pattern).filter(n=>n)}}/**
 * Splits text based on punctuation.
 * @extends PreTokenizer
 */class $a6a9715ee3096371$var$PunctuationPreTokenizer extends $a6a9715ee3096371$var$PreTokenizer{/**
     * @param {Object} config The configuration options for the pre-tokenizer.
     * @param {SplitDelimiterBehavior} config.behavior The behavior to use when splitting.
     */constructor(n){super(),this.config=n,this.pattern=RegExp(`[^${$a6a9715ee3096371$var$PUNCTUATION_REGEX}]+|[${$a6a9715ee3096371$var$PUNCTUATION_REGEX}]+`,"gu")}/**
     * Tokenizes text by splitting it using the given pattern.
     * @param {string} text The text to tokenize.
     * @returns {string[]} An array of tokens.
     */pre_tokenize_text(n){return n.match(this.pattern)||[]}}/**
 * Splits text based on digits.
 * @extends PreTokenizer
 */class $a6a9715ee3096371$var$DigitsPreTokenizer extends $a6a9715ee3096371$var$PreTokenizer{/**
     * @param {Object} config The configuration options for the pre-tokenizer.
     * @param {boolean} config.individual_digits Whether to split on individual digits.
     */constructor(n){super(),this.config=n;// Construct a pattern which matches the rust implementation:
let r=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=RegExp(r,"gu")}/**
     * Tokenizes text by splitting it using the given pattern.
     * @param {string} text The text to tokenize.
     * @returns {string[]} An array of tokens.
     */pre_tokenize_text(n){return n.match(this.pattern)||[]}}/**
 * @extends Callable
 */class $a6a9715ee3096371$var$PostProcessor extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
     * @param {Object} config The configuration for the post-processor.
     */constructor(n){super(),this.config=n}/**
     * Factory method to create a PostProcessor object from a configuration object.
     *
     * @param {Object} config Configuration object representing a PostProcessor.
     * @returns {PostProcessor} A PostProcessor object created from the given configuration.
     * @throws {Error} If an unknown PostProcessor type is encountered.
     */static fromConfig(n){if(null===n)return null;switch(n.type){case"TemplateProcessing":return new $a6a9715ee3096371$var$TemplateProcessing(n);case"ByteLevel":return new $a6a9715ee3096371$var$ByteLevelPostProcessor(n);case"RobertaProcessing":return new $a6a9715ee3096371$var$RobertaProcessing(n);case"BertProcessing":return new $a6a9715ee3096371$var$BertProcessing(n);default:throw Error(`Unknown PostProcessor type: ${n.type}`)}}/**
     * Method to be implemented in subclass to apply post-processing on the given tokens.
     *
     * @param {Array} tokens The input tokens to be post-processed.
     * @param {...*} args Additional arguments required by the post-processing logic.
     * @returns {Array} The post-processed tokens.
     * @throws {Error} If the method is not implemented in subclass.
     */post_process(n,...r){throw Error("post_process should be implemented in subclass.")}/**
     * Alias for {@link PostProcessor#post_process}.
     * @param {Array} tokens The text or array of texts to post-process.
     * @param {...*} args Additional arguments required by the post-processing logic.
     * @returns {Array} An array of post-processed tokens.
     */_call(n,...r){return this.post_process(n,...r)}}/**
 * A post-processor that adds special tokens to the beginning and end of the input.
 */class $a6a9715ee3096371$var$BertProcessing extends $a6a9715ee3096371$var$PostProcessor{/**
     * @param {Object} config The configuration for the post-processor.
     * @param {string[]} config.cls The special tokens to add to the beginning of the input.
     * @param {string[]} config.sep The special tokens to add to the end of the input.
     */constructor(n){super(n),// TODO use all of config: add_prefix_space, trim_offsets
this.cls=n.cls[0],this.sep=n.sep[0]}/**
     * Adds the special tokens to the beginning and end of the input.
     * @param {string[]} tokens The input tokens.
     * @param {string[]|null} tokens_pair An optional second set of input tokens.
     * @returns {string[]} The input tokens with the special tokens added to the beginning and end.
     */post_process(n,r=null){return n=$2a81087eb92e3db1$export$9826fe7ad3921016([this.cls],n,[this.sep]),null!==r&&(n=$2a81087eb92e3db1$export$9826fe7ad3921016(n,[this.sep],r,[this.sep])),n}}class $a6a9715ee3096371$var$RobertaProcessing extends $a6a9715ee3096371$var$BertProcessing{}// NOTE: extends BertProcessing
/**
 * Post processor that replaces special tokens in a template with actual tokens.
 * @extends PostProcessor
 */class $a6a9715ee3096371$var$TemplateProcessing extends $a6a9715ee3096371$var$PostProcessor{/**
     * Creates a new instance of `TemplateProcessing`.
     * @param {Object} config The configuration options for the post processor.
     * @param {Array} config.single The template for a single sequence of tokens.
     * @param {Array} config.pair The template for a pair of sequences of tokens.
     */constructor(n){super(n),this.single=n.single,this.pair=n.pair}/**
     * Replaces special tokens in the template with actual tokens.
     * @param {Array} tokens The list of tokens for the first sequence.
     * @param {Array} [tokens_pair=null] The list of tokens for the second sequence (optional).
     * @returns {Array} The list of tokens with the special tokens replaced with actual tokens.
     */post_process(n,r=null){let i=null===r?this.single:this.pair,a=[];for(let s of i)"SpecialToken"in s?a.push(s.SpecialToken.id):"Sequence"in s&&("A"===s.Sequence.id?a=$2a81087eb92e3db1$export$9826fe7ad3921016(a,n):"B"===s.Sequence.id&&(a=$2a81087eb92e3db1$export$9826fe7ad3921016(a,r)));return a}}/**
 * A PostProcessor that returns the given tokens as is.
 * @extends PostProcessor
 */class $a6a9715ee3096371$var$ByteLevelPostProcessor extends $a6a9715ee3096371$var$PostProcessor{/**
     * Post process the given tokens.
     * @param {string[]} tokens The tokens to be post processed.
     * @returns {string[]} The post processed tokens.
     */post_process(n){return n}}/**
 * The base class for token decoders.
 * @extends Callable
 */class $a6a9715ee3096371$var$Decoder extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
    * Creates an instance of `Decoder`.
    *
    * @param {Object} config The configuration object.
    */constructor(n){super(),this.config=n,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=n.trim_offsets}/**
   * Creates a decoder instance based on the provided configuration.
   *
   * @param {Object} config The configuration object.
   * @returns {Decoder} A decoder instance.
   * @throws {Error} If an unknown decoder type is provided.
   */static fromConfig(n){switch(n.type){case"WordPiece":return new $a6a9715ee3096371$var$WordPieceDecoder(n);case"Metaspace":return new $a6a9715ee3096371$var$MetaspaceDecoder(n);case"ByteLevel":return new $a6a9715ee3096371$var$ByteLevelDecoder(n);case"Replace":return new $a6a9715ee3096371$var$ReplaceDecoder(n);case"ByteFallback":return new $a6a9715ee3096371$var$ByteFallback(n);case"Fuse":return new $a6a9715ee3096371$var$FuseDecoder(n);case"Strip":return new $a6a9715ee3096371$var$StripDecoder(n);case"Sequence":return new $a6a9715ee3096371$var$DecoderSequence(n);case"CTC":return new $a6a9715ee3096371$var$CTCDecoder(n);case"BPEDecoder":return new $a6a9715ee3096371$var$BPEDecoder(n);default:throw Error(`Unknown Decoder type: ${n.type}`)}}/**
    * Calls the `decode` method.
    *
    * @param {string[]} tokens The list of tokens.
    * @returns {string} The decoded string.
    */_call(n){return this.decode(n)}/**
    * Decodes a list of tokens.
    * @param {string[]} tokens The list of tokens.
    * @returns {string} The decoded string.
    */decode(n){return this.decode_chain(n).join("")}/**
     * Apply the decoder to a list of tokens.
     * 
     * @param {string[]} tokens The list of tokens.
     * @returns {string[]} The decoded list of tokens.
     * @throws {Error} If the `decode_chain` method is not implemented in the subclass.
     */decode_chain(n){throw Error("`decode_chain` should be implemented in subclass.")}}class $a6a9715ee3096371$var$ReplaceDecoder extends $a6a9715ee3096371$var$Decoder{/** @type {Decoder['decode_chain']} */decode_chain(n){let r=$a6a9715ee3096371$var$createPattern(this.config.pattern);return null===r?n:n.map(n=>n.replaceAll(r,this.config.content))}}class $a6a9715ee3096371$var$ByteFallback extends $a6a9715ee3096371$var$Decoder{constructor(n){super(n),this.text_decoder=new TextDecoder}/** @type {Decoder['decode_chain']} */decode_chain(n){let r=[],i=[];for(let a of n){let n=null;if(6===a.length&&a.startsWith("<0x")&&a.endsWith(">")){let r=parseInt(a.slice(3,5),16);isNaN(r)||(n=r)}if(null!==n)i.push(n);else{if(i.length>0){let n=this.text_decoder.decode(Uint8Array.from(i));r.push(n),i=[]}r.push(a)}}if(i.length>0){let n=this.text_decoder.decode(Uint8Array.from(i));r.push(n),i=[]}return r}}/**
 * Fuse simply fuses all tokens into one big string.
 * It's usually the last decoding step anyway, but this decoder
 * exists incase some decoders need to happen after that step
 */class $a6a9715ee3096371$var$FuseDecoder extends $a6a9715ee3096371$var$Decoder{/** @type {Decoder['decode_chain']} */decode_chain(n){return[n.join("")]}}class $a6a9715ee3096371$var$StripDecoder extends $a6a9715ee3096371$var$Decoder{constructor(n){super(n),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}/** @type {Decoder['decode_chain']} */decode_chain(n){return n.map(n=>{let r=0;for(let i=0;i<this.start&&n[i]===this.content;++i)r=i+1;let i=n.length;for(let r=0;r<this.stop;++r){let a=n.length-r-1;if(n[a]===this.content){i=a;continue}break}return n.slice(r,i)})}}/**
 * A decoder that decodes a list of WordPiece tokens into a single string.
 * @extends Decoder
 */class $a6a9715ee3096371$var$WordPieceDecoder extends $a6a9715ee3096371$var$Decoder{/**
     * Creates a new instance of WordPieceDecoder.
     * @param {Object} config The configuration object.
     * @param {string} config.prefix The prefix used for WordPiece encoding.
     * @param {boolean} config.cleanup Whether to cleanup the decoded string.
     */constructor(n){super(n),this.cleanup=n.cleanup}/** @type {Decoder['decode_chain']} */decode_chain(n){return n.map((n,r)=>(0!==r&&(n=n.startsWith(this.config.prefix)?n.replace(this.config.prefix,""):" "+n),this.cleanup&&(n=$a6a9715ee3096371$var$clean_up_tokenization(n)),n))}}/**
 * Byte-level decoder for tokenization output. Inherits from the `Decoder` class.
 * @extends Decoder
 */class $a6a9715ee3096371$var$ByteLevelDecoder extends $a6a9715ee3096371$var$Decoder{/**
     * Create a `ByteLevelDecoder` object.
     * @param {Object} config Configuration object.
     */constructor(n){super(n),this.byte_decoder=$a6a9715ee3096371$var$UNICODE_TO_BYTES,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}/**
     * Convert an array of tokens to string by decoding each byte.
     * @param {string[]} tokens Array of tokens to be decoded.
     * @returns {string} The decoded string.
     */convert_tokens_to_string(n){let r=n.join(""),i=new Uint8Array([...r].map(n=>this.byte_decoder[n]));return this.text_decoder.decode(i)}/** @type {Decoder['decode_chain']} */decode_chain(n){// TODO move to base class (like HF)
// tokens === filtered_tokens
// To avoid mixing byte-level and unicode for byte-level BPT
// we need to build string separately for added tokens and byte-level tokens
// cf. https://github.com/huggingface/transformers/issues/1133
let r=[],i=[];for(let a of n)// if (skip_special_tokens && this.all_special_ids.includes(token)) {
//     continue;
// }
this.added_tokens.includes(a)?(i.length>0&&(r.push(this.convert_tokens_to_string(i)),i=[]),r.push(a)):i.push(a);// TODO add spaces_between_special_tokens and clean_up_tokenization_spaces options
return i.length>0&&r.push(this.convert_tokens_to_string(i)),r}}/**
 * The CTC (Connectionist Temporal Classification) decoder.
 * See https://github.com/huggingface/tokenizers/blob/bb38f390a61883fc2f29d659af696f428d1cda6b/tokenizers/src/decoders/ctc.rs
 */class $a6a9715ee3096371$var$CTCDecoder extends $a6a9715ee3096371$var$Decoder{constructor(n){super(n),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}/**
     * Converts a connectionist-temporal-classification (CTC) output tokens into a single string.
     * @param {string[]} tokens Array of tokens to be decoded.
     * @returns {string} The decoded string.
     */convert_tokens_to_string(n){if(0===n.length)return"";// group same tokens into non-repeating tokens in CTC style decoding
let r=[n[0]];for(let i=1;i<n.length;++i)n[i]!==r.at(-1)&&r.push(n[i]);let i=r.filter(n=>n!==this.pad_token).join("");return this.cleanup&&(i=$a6a9715ee3096371$var$clean_up_tokenization(i).replaceAll(this.word_delimiter_token," ").trim()),i}/** @type {Decoder['decode_chain']} */decode_chain(n){return[this.convert_tokens_to_string(n)]}}/**
 * Apply a sequence of decoders.
 * @extends Decoder
 */class $a6a9715ee3096371$var$DecoderSequence extends $a6a9715ee3096371$var$Decoder{/**
     * Creates a new instance of DecoderSequence.
     * @param {Object} config The configuration object.
     * @param {Decoder[]} config.decoders The list of decoders to apply.
     */constructor(n){super(n),this.decoders=n.decoders.map(n=>$a6a9715ee3096371$var$Decoder.fromConfig(n))}/** @type {Decoder['decode_chain']} */decode_chain(n){// Use reduce to apply each decoder to the tokens
return this.decoders.reduce((n,r)=>r.decode_chain(n),n)}}class $a6a9715ee3096371$var$BPEDecoder extends $a6a9715ee3096371$var$Decoder{constructor(n){super(n),this.suffix=this.config.suffix}/** @type {Decoder['decode_chain']} */decode_chain(n){return n.map((r,i)=>r.replaceAll(this.suffix,i===n.length-1?"":" "))}}/**
 * This PreTokenizer replaces spaces with the given replacement character, adds a prefix space if requested,
 * and returns a list of tokens.
 * @extends PreTokenizer
 */class $a6a9715ee3096371$var$MetaspacePreTokenizer extends $a6a9715ee3096371$var$PreTokenizer{/**
     * @param {Object} config The configuration object for the MetaspacePreTokenizer.
     * @param {boolean} config.add_prefix_space Whether to add a prefix space to the first token.
     * @param {string} config.replacement The character to replace spaces with.
     * @param {string} [config.str_rep=config.replacement] An optional string representation of the replacement character.
     */constructor(n){super(),this.addPrefixSpace=n.add_prefix_space,this.replacement=n.replacement,this.strRep=n.str_rep||this.replacement}/**
     * This method takes a list of normalized tokens, replaces spaces with the replacement character,
     * adds a prefix space if requested, and returns a new list of tokens.
     * @param {string[]|string} normalizedTokens The list of normalized tokens to pre-tokenize.
     * @returns {string[]} A new list of pre-tokenized tokens.
     */pre_tokenize(n){"string"==typeof n&&// NOTE: For some reason, metaspace includes trailing whitespace, so we only trim leading whitespace.
// See: https://github.com/huggingface/tokenizers/issues/1250
(n=n.trimStart().split(/\s+/));let r=[];for(let i of n){let n=i.replaceAll(" ",this.strRep);this.addPrefixSpace&&!n.startsWith(this.replacement)&&(n=this.strRep+n),r.push(n)}return r}}/**
 * MetaspaceDecoder class extends the Decoder class and decodes Metaspace tokenization.
 * @extends Decoder
 */class $a6a9715ee3096371$var$MetaspaceDecoder extends $a6a9715ee3096371$var$Decoder{/**
     * Constructs a new MetaspaceDecoder object.
     * @param {Object} config The configuration object for the MetaspaceDecoder.
     * @param {boolean} config.add_prefix_space Whether to add a prefix space to the decoded string.
     * @param {string} config.replacement The string to replace spaces with.
     */constructor(n){super(n),this.addPrefixSpace=n.add_prefix_space,this.replacement=n.replacement}/** @type {Decoder['decode_chain']} */decode_chain(n){let r=[];for(let i=0;i<n.length;++i){let a=n[i].replaceAll(this.replacement," ");this.addPrefixSpace&&0==i&&a.startsWith(" ")&&(a=a.substring(1)),r.push(a)}return r}}/**
 * A normalizer that applies a precompiled charsmap.
 * This is useful for applying complex normalizations in C++ and exposing them to JavaScript.
 * @extends Normalizer
 * @param {Object} config The configuration object for the Precompiled normalizer.
 * @param {Object} config.precompiled_charsmap The precompiled charsmap object.
 */class $a6a9715ee3096371$var$Precompiled extends $a6a9715ee3096371$var$Normalizer{/**
     * Create a new instance of Precompiled normalizer.
     * @param {Object} config The configuration object.
     * @param {any} config.precompiled_charsmap Precompiled chars mapping.
     */constructor(n){super(n),this.charsmap=n.precompiled_charsmap}/**
     * Normalizes the given text by applying the precompiled charsmap.
     * @param {string} text The text to normalize.
     * @returns {string} The normalized text.
     */normalize(n){if((n=// As stated in the sentencepiece normalization docs (https://github.com/google/sentencepiece/blob/master/doc/normalization.md#use-pre-defined-normalization-rule),
// there are 5 pre-defined normalization rules:
//  1. nmt_nfkc: NFKC normalization with some additional normalization around spaces. (default)
//  2. nfkc: original NFKC normalization.
//  3. nmt_nfkc_cf: nmt_nfkc + Unicode case folding (mostly lower casing)
//  4. nfkc_cf: nfkc + Unicode case folding.
//  5. identity: no normalization
// 
// For now, we only implement the default (nmt_nfkc).
// See https://raw.githubusercontent.com/google/sentencepiece/master/data/nmt_nfkc.tsv for the full list of rules.
// TODO: detect when a different `this.charsmap` is used.
(n=n.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,"")).replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," ")).includes("")){// To match the sentencepiece implementation 100%, we must handle a very strange edge-case.
// For some reason, the "Fullwidth Tilde" character (\uFF5E) should not be converted to the standard Tilde character (\u007E).
// However, NFKC normalization does do this conversion. As a result, we split the string on the Fullwidth Tilde character,
// perform NFKC normalization on each substring, and then join them back together with the Fullwidth Tilde character.
let r=n.split("");n=r.map(n=>n.normalize("NFKC")).join("")}else n=n.normalize("NFKC");return n}}/**
 * A pre-tokenizer that applies a sequence of pre-tokenizers to the input text.
 * @extends PreTokenizer
 */class $a6a9715ee3096371$var$PreTokenizerSequence extends $a6a9715ee3096371$var$PreTokenizer{/**
     * Creates an instance of PreTokenizerSequence.
     * @param {Object} config The configuration object for the pre-tokenizer sequence.
     * @param {Object[]} config.pretokenizers An array of pre-tokenizer configurations.
     */constructor(n){super(),this.tokenizers=n.pretokenizers.map(n=>$a6a9715ee3096371$var$PreTokenizer.fromConfig(n))}/**
     * Applies each pre-tokenizer in the sequence to the input text in turn.
     * @param {string|string[]} text The text(s) to pre-tokenize.
     * @returns {string[]} The pre-tokenized text.
     */pre_tokenize_text(n){// Use reduce to apply each tokenizer to the text
return"string"==typeof n&&(n=[n]),this.tokenizers.reduce((n,r)=>r.pre_tokenize(n),n)}}/**
 * Splits a string of text by whitespace characters into individual tokens.
 * @extends PreTokenizer
 */class $a6a9715ee3096371$var$WhitespaceSplit extends $a6a9715ee3096371$var$PreTokenizer{/**
     * Creates an instance of WhitespaceSplit.
     * @param {Object} config The configuration object for the pre-tokenizer sequence.
     */constructor(n){super()}/**
     * Pre-tokenizes the input text by splitting it on whitespace characters.
     * @param {string} text The text to be pre-tokenized.
     * @returns {string[]} An array of tokens produced by splitting the input text on whitespace.
     */pre_tokenize_text(n){return $a6a9715ee3096371$var$whitespace_split(n)}}class $a6a9715ee3096371$export$8117e0a660304ecb extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
     * Create a new PreTrainedTokenizer instance.
     * @param {Object} tokenizerJSON The JSON of the tokenizer.
     * @param {Object} tokenizerConfig The config of the tokenizer.
     */constructor(n,r){for(let i of(super(),// Construct parts of the tokenizer from the JSON
this.normalizer=$a6a9715ee3096371$var$Normalizer.fromConfig(n.normalizer),this.pre_tokenizer=$a6a9715ee3096371$var$PreTokenizer.fromConfig(n.pre_tokenizer),this.model=$a6a9715ee3096371$export$3cd9e7252bd18962.fromConfig(n.model,r),this.post_processor=$a6a9715ee3096371$var$PostProcessor.fromConfig(n.post_processor),// TODO: maybe, allow this to be null; in which case, we use model as decoder too?
this.decoder=$a6a9715ee3096371$var$Decoder.fromConfig(n.decoder),// Another slight hack to add `end_of_word_suffix` (if present) to the decoder
// This is needed for cases where BPE model and ByteLevel decoder are used
// For more information, see https://github.com/xenova/transformers.js/issues/74
// TODO: save this to the decoder when exporting?
this.decoder.end_of_word_suffix=this.model.end_of_word_suffix,// Add added_tokens to model
this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[],n.added_tokens)){let n=i.id,r=i.content;this.added_tokens.push(r),this.model.tokens_to_ids.set(r,n),this.model.vocab[n]=r,i.special&&(this.special_tokens.push(r),this.all_special_ids.push(n))}// Update additional_special_tokens
this.special_tokens.push(...r.additional_special_tokens??[]),this.special_tokens=[...new Set(this.special_tokens)],// Slight hack, but it prevents code duplication:
this.decoder.added_tokens=this.added_tokens,this.added_tokens_regex=this.added_tokens.length>0?RegExp("("+this.added_tokens.map($2a81087eb92e3db1$export$7c57da42ce8e346f).join("|")+")"):null,// Set mask token if present (otherwise will be undefined, which is fine)
this.mask_token=this.getToken(r,"mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken(r,"pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken(r,"sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.model_max_length=r.model_max_length,/** @type {boolean} Whether or not to strip the text when tokenizing (removing excess spaces before and after the string). */this.remove_space=r.remove_space,this.clean_up_tokenization_spaces=r.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=r.do_lowercase_and_remove_accent??!1,// TODO allow user to change this
this.padding_side="right"}/**
     * Returns the value of the first matching key in the tokenizer config object.
     * @param {...string} keys One or more keys to search for in the tokenizer config object.
     * @returns {string|null} The value associated with the first matching key, or null if no match is found.
     * @throws {Error} If an object is found for a matching key and its __type property is not "AddedToken".
     */getToken(n,...r){for(let i of r){let r=n[i];if(r){if("object"!=typeof r)return r;if("AddedToken"===r.__type)return r.content;throw Error(`Unknown token: ${r}`)}}return null}/**
     * Loads a pre-trained tokenizer from the given `pretrained_model_name_or_path`. 
     * 
     * @param {string} pretrained_model_name_or_path The path to the pre-trained tokenizer.
     * @param {PretrainedOptions} options Additional options for loading the tokenizer.
     * 
     * @throws {Error} Throws an error if the tokenizer.json or tokenizer_config.json files are not found in the `pretrained_model_name_or_path`.
     * @returns {Promise<PreTrainedTokenizer>} A new instance of the `PreTrainedTokenizer` class.
     */static async from_pretrained(n,{progress_callback:r=null,config:i=null,cache_dir:a=null,local_files_only:s=!1,revision:o="main"}={}){let l=await $a6a9715ee3096371$var$loadTokenizer(n,{progress_callback:r,config:i,cache_dir:a,local_files_only:s,revision:o});// @ts-ignore
return new this(...l)}/**
     * This function can be overridden by a subclass to apply additional preprocessing
     * to a model's input data.
     * @param {Object} inputs An object containing input data as properties.
     * @returns {Object} The modified inputs object.
     */prepare_model_inputs(n){return n}/**
     * Encode/tokenize the given text(s).
     * @param {string|string[]} text The text to tokenize.
     * @param {Object} options An optional object containing the following properties:
     * @param {string|string[]} [options.text_pair=null] Optional second sequence to be encoded. If set, must be the same type as text.
     * @param {boolean} [options.padding=false] Whether to pad the input sequences.
     * @param {boolean} [options.truncation=null] Whether to truncate the input sequences.
     * @param {number} [options.max_length=null] Maximum length of the returned list and optionally padding length.
     * @param {boolean} [options.return_tensor=true] Whether to return the results as Tensors or arrays.
     * @returns {{ input_ids: number[]|number[][]|Tensor, attention_mask: any[]|Tensor }} Object to be passed to the model.
     */_call(n,{text_pair:r=null,padding:i=!1,truncation:a=null,max_length:s=null,return_tensor:o=!0}={}){let l;if(Array.isArray(n)){if(0===n.length)throw Error("text array must be non-empty");if(null!==r){if(Array.isArray(r)){if(n.length!==r.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");l=n.map((n,i)=>this.encode(n,r[i]))}else l=n.map(n=>this.encode(n))}else{if(null===n)throw Error("text may not be null");if(Array.isArray(r))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");// For single input, we just wrap in an array, and then unwrap later.
l=[this.encode(n,r)]}// At this point, tokens is batched: [batch_size, tokens]
// However, array may be jagged. So, we pad to max_length
let u=$821ef51da65e5775$export$8960430cfd85939f(l.map(n=>n.length))[0];null===s&&(s=u),// Ensure it is less than model max length
s=Math.min(s,this.model_max_length);/** @type {any[]|Tensor} */let c=[];if(i||a)for(let n=0;n<l.length;++n){if(l[n].length===s){c.push(Array(l[n].length).fill(1));continue}if(l[n].length>s)a&&(l[n]=l[n].slice(0,s)),c.push(Array(l[n].length).fill(1));else if(i){let r=s-l[n].length;"right"===this.padding_side?(c.push(Array(l[n].length).fill(1).concat(Array(r).fill(0))),l[n].push(...Array(r).fill(this.pad_token_id))):(c.push(Array(r).fill(0).concat(Array(l[n].length).fill(1))),l[n].unshift(...Array(r).fill(this.pad_token_id)))}else c.push(Array(l[n].length).fill(1))}else c=l.map(n=>Array(n.length).fill(1));if(o){if(!(i&&a)&&l.some(n=>n.length!==l[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");// Now we actually convert to tensor
// NOTE: In the same way as the python library, we return a batched tensor, regardless of
// whether we have a single input or multiple inputs.
let n=[l.length,l[0].length];l=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",BigInt64Array.from(l.flat().map(BigInt)),n),c=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",BigInt64Array.from(c.flat().map(BigInt)),n)}else Array.isArray(n)||(// Input was not batched, so we unwrap
l=l[0],c=c[0]);// Finally, add attention mask, and possibly model-specific parameters
let h={input_ids:l,attention_mask:c};return this.prepare_model_inputs(h)}/**
     * Encodes a single text using the preprocessor pipeline of the tokenizer.
     *
     * @param {string|null} text The text to encode.
     * @returns {string[]|null} The encoded tokens.
     */_encode_text(n){if(null===n)return null;// Actual function which does encoding, for a single text
// First, we take care of special tokens. Needed to avoid issues arising from
// normalization and/or pretokenization (which may not preserve special tokens)
let r=this.added_tokens_regex?n.split(this.added_tokens_regex).filter(n=>n):[n];return r.map(n=>{if(this.added_tokens.includes(n))return n;{!0===this.remove_space&&(n=n.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(n=$a6a9715ee3096371$var$lowercase_and_remove_accent(n)),null!==this.normalizer&&(n=this.normalizer(n));let r=null!==this.pre_tokenizer?this.pre_tokenizer(n):[n];return this.model(r)}}).flat()}/**
     * Encodes a single text or a pair of texts using the model's tokenizer.
     *
     * @param {string} text The text to encode.
     * @param {string|null} text_pair The optional second text to encode.
     * @returns {number[]} An array of token IDs representing the encoded text(s).
     */encode(n,r=null){// Function called by users to encode possibly multiple texts
let i=this._encode_text(n),a=this._encode_text(r),s=null!==this.post_processor?this.post_processor(i,a):$2a81087eb92e3db1$export$9826fe7ad3921016(i??[],a??[]);return this.model.convert_tokens_to_ids(s)}/**
     * Decode a batch of tokenized sequences.
     * @param {number[][]} batch List of tokenized input sequences.
     * @param {Object} decode_args (Optional) Object with decoding arguments.
     * @returns {string[]} List of decoded sequences.
     */batch_decode(n,r={}){return n.map(n=>this.decode(n,r))}/**
     * Decodes a sequence of token IDs back to a string.
     *
     * @param {number[]} token_ids List of token IDs to decode.
     * @param {Object} [decode_args={}]
     * @param {boolean} [decode_args.skip_special_tokens=false] If true, special tokens are removed from the output string.
     * @param {boolean} [decode_args.clean_up_tokenization_spaces=true] If true, spaces before punctuations and abbreviated forms are removed.
     *
     * @returns {string} The decoded string.
     * @throws {Error} If `token_ids` is not a non-empty array of integers.
     */decode(n,r={}){if(!Array.isArray(n)||0===n.length||!$2a81087eb92e3db1$export$47ed7831511ab4cd(n[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(n,r)}/**
     * Decode a single list of token ids to a string.
     * @param {number[]} token_ids List of token ids to decode
     * @param {Object} decode_args Optional arguments for decoding
     * @param {boolean} [decode_args.skip_special_tokens=false] Whether to skip special tokens during decoding
     * @param {boolean} [decode_args.clean_up_tokenization_spaces=null] Whether to clean up tokenization spaces during decoding.
     * If null, the value is set to `this.decoder.cleanup` if it exists, falling back to `this.clean_up_tokenization_spaces` if it exists, falling back to `true`.
     * @returns {string} The decoded string
     */decode_single(n,{skip_special_tokens:r=!1,clean_up_tokenization_spaces:i=null}){let a=this.model.convert_ids_to_tokens(n);r&&(a=a.filter(n=>!this.special_tokens.includes(n)));/** @type {string} */let s=this.decoder(a);return this.decoder.end_of_word_suffix&&(s=s.replaceAll(this.decoder.end_of_word_suffix," "),r&&(s=s.trim())),(i??this.clean_up_tokenization_spaces)&&(s=$a6a9715ee3096371$var$clean_up_tokenization(s)),s}}/**
* Helper method for adding `token_type_ids` to model inputs
* @param {Object} inputs An object containing the input ids and attention mask.
* @returns {Object} The prepared inputs object.
*/function $a6a9715ee3096371$var$add_token_types(n){// TODO ensure correctness when token pair is present
if(n.input_ids instanceof $970f59cad5f0fd6a$export$7b6b8d90402f8814)n.token_type_ids=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",new BigInt64Array(n.input_ids.data.length),n.input_ids.dims);else if(Array.isArray(n.input_ids))Array.isArray(n.input_ids[0])?n.token_type_ids=n.input_ids.map(n=>Array(n.length).fill(0)):n.token_type_ids=Array(n.input_ids.length).fill(0);else throw Error("Input ids must be a Tensor or an Array");return n}class $a6a9715ee3096371$export$1272d61463841614 extends $a6a9715ee3096371$export$8117e0a660304ecb{/** @type {add_token_types} */prepare_model_inputs(n){return $a6a9715ee3096371$var$add_token_types(n)}}class $a6a9715ee3096371$export$ecb84099ba544a7 extends $a6a9715ee3096371$export$8117e0a660304ecb{/** @type {add_token_types} */prepare_model_inputs(n){return $a6a9715ee3096371$var$add_token_types(n)}}class $a6a9715ee3096371$export$8763a5327c48bc59 extends $a6a9715ee3096371$export$8117e0a660304ecb{/** @type {add_token_types} */prepare_model_inputs(n){return $a6a9715ee3096371$var$add_token_types(n)}}class $a6a9715ee3096371$export$32dba75c13f2bc88 extends $a6a9715ee3096371$export$8117e0a660304ecb{/** @type {add_token_types} */prepare_model_inputs(n){return $a6a9715ee3096371$var$add_token_types(n)}}class $a6a9715ee3096371$export$463c245396c8bd37 extends $a6a9715ee3096371$export$8117e0a660304ecb{/** @type {add_token_types} */prepare_model_inputs(n){return $a6a9715ee3096371$var$add_token_types(n)}}class $a6a9715ee3096371$export$5c2185c35d1f2e65 extends $a6a9715ee3096371$export$8117e0a660304ecb{/** @type {add_token_types} */prepare_model_inputs(n){return $a6a9715ee3096371$var$add_token_types(n)}}class $a6a9715ee3096371$export$39d9cfa72569e043 extends $a6a9715ee3096371$export$8117e0a660304ecb{/** @type {add_token_types} */prepare_model_inputs(n){return $a6a9715ee3096371$var$add_token_types(n)}}class $a6a9715ee3096371$export$8cd034a095bdc71 extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$a849c8ee2508ff29 extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$36813c1b7cf4a518 extends $a6a9715ee3096371$export$8117e0a660304ecb{constructor(n,r){super(n,r),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}/** @type {add_token_types} */prepare_model_inputs(n){return $a6a9715ee3096371$var$add_token_types(n)}}class $a6a9715ee3096371$export$871245cd0d194ed extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$1504ef98a86a7d1b extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$415a5b92def1e48b extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$8474578ce918e467 extends $a6a9715ee3096371$export$8117e0a660304ecb{constructor(n,r){super(n,r),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(n=>this.languageRegex.test(n)),this.lang_to_token=n=>n}/**
     * Helper function to build translation inputs for an `MBartTokenizer`.
     * @param {string|string[]} raw_inputs The text to tokenize.
     * @param {Object} tokenizer_options Options to be sent to the tokenizer
     * @param {Object} generate_kwargs Generation options.
     * @returns {Object} Object to be passed to the model.
     */_build_translation_inputs(n,r,i){return $a6a9715ee3096371$var$_build_translation_inputs(this,n,r,i)}}class $a6a9715ee3096371$export$c9c8df830c8192d extends $a6a9715ee3096371$export$8474578ce918e467{}// NOTE: extends MBartTokenizer
class $a6a9715ee3096371$export$9764e344cb7c8c4c extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$68f4b7e3d7b820c extends $a6a9715ee3096371$export$8117e0a660304ecb{constructor(n,r){// Override the default (invalid) regex of the pretokenizer.
// For more information, see https://github.com/xenova/transformers.js/issues/94
let i=".,!?",a=n.pre_tokenizer?.pretokenizers[0]?.pattern;a&&a.Regex===` ?[^(\\s|[${i}])]+`&&(a.Regex=` ?[^\\s${i}]+`),super(n,r)}}class $a6a9715ee3096371$export$93789d4dc2beeb0e extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$4b88368c13deaae9 extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$d57774da5814535b extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$4ece281755dddbdc extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$48a845f4c94658ce extends $a6a9715ee3096371$export$8117e0a660304ecb{/** @type {add_token_types} */prepare_model_inputs(n){return $a6a9715ee3096371$var$add_token_types(n)}}class $a6a9715ee3096371$export$4a26e986d3fc9045 extends $a6a9715ee3096371$export$8117e0a660304ecb{}/**
 * Helper function to build translation inputs for an `NllbTokenizer` or `M2M100Tokenizer`.
 * @param {PreTrainedTokenizer} self The tokenizer instance.
 * @param {string|string[]} raw_inputs The text to tokenize.
 * @param {Object} tokenizer_options Options to be sent to the tokenizer
 * @param {Object} generate_kwargs Generation options.
 * @returns {Object} Object to be passed to the model.
 * @private
 */function $a6a9715ee3096371$var$_build_translation_inputs(n,r,i,a){if(!("language_codes"in n)||!Array.isArray(n.language_codes))throw Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in n)||!(n.languageRegex instanceof RegExp))throw Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in n)||"function"!=typeof n.lang_to_token)throw Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");let s=a.src_lang,o=a.tgt_lang;// Check that the target language is valid:
if(!n.language_codes.includes(o))throw Error(`Target language code "${o}" is not valid. Must be one of: {${n.language_codes.join(", ")}}`);// Allow `src_lang` to be optional. If not set, we'll use the tokenizer's default.
if(void 0!==s){// Check that the source language is valid:
if(!n.language_codes.includes(s))throw Error(`Source language code "${s}" is not valid. Must be one of: {${n.language_codes.join(", ")}}`);// In the same way as the Python library, we override the post-processor
// to force the source language to be first:
for(let r of n.post_processor.config.single)if("SpecialToken"in r&&n.languageRegex.test(r.SpecialToken.id)){r.SpecialToken.id=n.lang_to_token(s);break}// TODO: Do the same for pair?
}return(// Override the `forced_bos_token_id` to force the correct language
a.forced_bos_token_id=n.model.convert_tokens_to_ids([n.lang_to_token(o)])[0],n._call(r,i))}class $a6a9715ee3096371$export$66ce0da2ecd3b55b extends $a6a9715ee3096371$export$8117e0a660304ecb{constructor(n,r){super(n,r),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(n=>this.languageRegex.test(n)),this.lang_to_token=n=>n}/**
     * Helper function to build translation inputs for an `NllbTokenizer`.
     * @param {string|string[]} raw_inputs The text to tokenize.
     * @param {Object} tokenizer_options Options to be sent to the tokenizer
     * @param {Object} generate_kwargs Generation options.
     * @returns {Object} Object to be passed to the model.
     */_build_translation_inputs(n,r,i){return $a6a9715ee3096371$var$_build_translation_inputs(this,n,r,i)}}class $a6a9715ee3096371$export$2a70c9c2ab41ba80 extends $a6a9715ee3096371$export$8117e0a660304ecb{constructor(n,r){super(n,r),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(n=>this.languageRegex.test(n)).map(n=>n.slice(2,-2)),this.lang_to_token=n=>`__${n}__`}/**
     * Helper function to build translation inputs for an `M2M100Tokenizer`.
     * @param {string|string[]} raw_inputs The text to tokenize.
     * @param {Object} tokenizer_options Options to be sent to the tokenizer
     * @param {Object} generate_kwargs Generation options.
     * @returns {Object} Object to be passed to the model.
     */_build_translation_inputs(n,r,i){return $a6a9715ee3096371$var$_build_translation_inputs(this,n,r,i)}}const $a6a9715ee3096371$var$WHISPER_LANGUAGES=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],$a6a9715ee3096371$var$WHISPER_LANGUAGE_MAPPING=new Map($a6a9715ee3096371$var$WHISPER_LANGUAGES),$a6a9715ee3096371$var$WHISPER_TO_LANGUAGE_CODE_MAPPING=new Map([...$a6a9715ee3096371$var$WHISPER_LANGUAGES.map(([n,r])=>[r,n]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);class $a6a9715ee3096371$export$cc4d47e252dd9cc2 extends $a6a9715ee3096371$export$8117e0a660304ecb{/**
     * Decodes automatic speech recognition (ASR) sequences.
     * @param {Array<{tokens: number[], token_timestamps?: number[], stride: number[]}>} sequences The sequences to decode.
     * @param {Object} options The options to use for decoding.
     * @returns {Array<string|{chunks?: undefined|Array<{language: string|null, timestamp: Array<number|null>, text: string}>}>} The decoded sequences.
     */_decode_asr(n,{return_timestamps:r=!1,return_language:i=!1,time_precision:a=null,force_full_sequences:s=!0}={}){// Set force_full_sequences=false if you want streaming
// TODO add support for `return_language`
// Internal method meant to only be used by asr pipeline.
// Handles all the little quirks specific to whisper to handle
// the various options not allowed in other seq2seq models
// =========== Overview ============
// - iterate over all outputs
// - all tokens within output
// - Each token can be
//   - language token
//   - special token
//   - timestamp token
//   - text token
// - We accumulate the text tokens.
// - We split on end timestamps
// - Lots of complexity comes from stride and timestamps
if(null===a)throw Error("Must specify time_precision");let o=null,l="word"===r;function u(){return{language:o,timestamp:[null,null],text:""}}// Welcome to the state machine!
let c=[],h=u(),d=0,p=this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1,f=[],m=[],g=!1,_=null,y=new Set(this.all_special_ids);for(let i of n){// NOTE: python version has batches, so it uses [0]
let n=i.tokens,s=l?i.token_timestamps:null,b=null,v=p;if("stride"in i){let[r,s,o]=i.stride;if(// Offset the timings to account for the other `model_outputs`.
d-=s,_=r-o,s&&(v=s/a+p),o)for(let r=n.length-1;r>=0;--r){let i=n[r];if(i>=p){// There can be several token in the right stride
// But the last one is ALWAYS going to be skipped
if(null!==b&&(i-p)*a<_)break;b=i}}}let x=[],w=[];// - all tokens within output
for(let i=0;i<n.length;++i){let _=n[i];// 4 possible states for each token
// - 1/ Language code
// - 2/ all other special tokens (which we ignore)
// - 3/ Timestamp
// - 4/ Regular text
if(y.has(_)){let n=this.decode([_]),i=$a6a9715ee3096371$var$WHISPER_LANGUAGE_MAPPING.get(n.slice(2,-2));if(void 0!==i){// 1/ Indeed some language
// TODO Handle when language is different from the previous
// one, and we cannot use timestamped tokens to create chunks
if(null!==o&&i!==o&&!r){f.push(x);let n=this.findLongestCommonSequence(f)[0],r=this.decode(n);h.text=r,c.push(h),// Flush all our temporary context
f=[],x=[],h=u()}o=h.language=i}}else if(_>=p){// 3/ Timestamp token
let n=(_-p)*a+d,r=$821ef51da65e5775$export$2077e0241d6afd3c(n,2);if(null!==b&&_>=b)// our stride, so we're going to skip it for the time being
// and resolve this later
// Skip is necessary because timestamp tokens always come
// by pair, so we need to skip the next one too (which would mark the start of another chunk).
g=!0;else if(g||f.length>0&&_<v)g=!1;else if(null===h.timestamp[0])h.timestamp[0]=r;else // This is the end of the timestamp chunk
if(r===h.timestamp[0]);else{h.timestamp[1]=r,// Handling merges
f.push(x),l&&m.push(w);let[n,i]=this.findLongestCommonSequence(f,m),a=this.decode(n);h.text=a,l&&(h.words=this.collateWordTimestamps(n,i,o)),c.push(h),// Flush all our temporary context
f=[],x=[],m=[],w=[],h=u()}}else if(// 4/ Regular token
// We just append to the list of all tokens so we can handle
// merges later and decode into text.
x.push(_),l){let n,r=$821ef51da65e5775$export$2077e0241d6afd3c(s[i]+d,2);n=i+1<s.length?$821ef51da65e5775$export$2077e0241d6afd3c(s[i+1]+d,2):null,w.push([r,n])}}if("stride"in i){let[n,r,a]=i.stride;d+=n-a}// Leftover tokens
x.length>0?(f.push(x),l&&m.push(w)):f.every(n=>0===n.length)&&(// Flushing previous tokens (END)"
h=u(),f=[],x=[],m=[],w=[])}if(f.length>0){if(s&&r)// leftover
throw Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");// Happens when we don't use timestamps
let[n,i]=this.findLongestCommonSequence(f,m),a=this.decode(n);h.text=a,l&&(h.words=this.collateWordTimestamps(n,i,o)),c.push(h)}let b=Object.create(null),v=c.map(n=>n.text).join("");if(r||i){for(let n=0;n<c.length;++n){let a=c[n];r||delete a.timestamp,i||delete a.language}if(l){let n=[];for(let r of c)for(let i of r.words)n.push(i);b={chunks:n}}else b={chunks:c}}return[v,b]}/**
     * Finds the longest common sequence among the provided sequences.
     * @param {number[][]} sequences An array of sequences of token ids to compare.
     * @returns {number[][]} The longest common sequence found.
     * @throws {Error} If there is a bug within the function.
     * @private
     */findLongestCommonSequence(n,r=null){// It would be much harder to do O(n) because of fault tolerance.
// We actually have a really good property which is that the total sequence
// MUST be those subsequences in order.
// If token_timestamp_sequences is provided, will split those sequences in
// exactly the same way.
let i=n[0],a=i.length,s=[],o=Array.isArray(r)&&r.length>0,l=o?[]:null,u=o?r[0]:null;for(let c=1;c<n.length;++c){let h=n[c],d=0,p=[a,a,0,0],f=h.length;for(let n=1;n<a+f;++n){let r=n/1e4,s=Math.max(0,a-n),o=Math.min(a,a+f-n),l=i.slice(s,o),u=Math.max(0,n-a),c=Math.min(f,n),m=h.slice(u,c);if(l.length!==m.length)throw Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let g=l.filter((n,r)=>n===m[r]).length,_=g/n+r;g>1&&_>d&&(d=_,p=[s,o,u,c])}let[m,g,_,y]=p,b=Math.floor((g+m)/2),v=Math.floor((y+_)/2);s.push(...i.slice(0,b)),a=(i=h.slice(v)).length,o&&(l.push(...u.slice(0,b)),u=r[c].slice(v))}return(s.push(...i),o)?(l.push(...u),[s,l]):[s,[]]}/** @private */collateWordTimestamps(n,r,i){let[a,s,o]=this.combineTokensIntoWords(n,i),l=[];for(let n=0;n<a.length;++n){let i=o[n];l.push({text:a[n],timestamp:[r[i.at(0)][0],r[i.at(-1)][1]]})}return l}/**
     * Groups tokens by word. Returns a tuple containing a list of strings with the words,
     * and a list of `token_id` sequences with the tokens making up each word.
     * @param {number[]} tokens 
     * @param {string} [language] 
     * @param {string} prepend_punctionations 
     * @param {string} append_punctuations 
     * 
     * @private
     */combineTokensIntoWords(n,r,i="\"'\xa1\xbf([{-",a="\"'.,!?:)]}"){let s,o,l;return["chinese","japanese","thai","lao","myanmar"].includes(r=r??"english")?[s,o,l]=this.splitTokensOnUnicode(n):[s,o,l]=this.splitTokensOnSpaces(n),this.mergePunctuations(s,o,l,i,a)}/** @type {PreTrainedTokenizer['decode']} */decode(n,r){// TODO: implement offsets
// if (decode_args.output_offsets) {
//     let offsets = this.computeOffsets
// }
return r&&r.decode_with_timestamps?this.decodeWithTimestamps(n,r):super.decode(n,r)}/**
     * @param {number[]} token_ids List of token IDs to decode.
     * @param {Object} decode_args Optional arguments for decoding
     * @private
     */decodeWithTimestamps(n,r){let i=r?.time_precision??.02,a=Array.from(this.all_special_ids).at(-1)+1,s=[[]];for(let r of n)if(r>=a){let n=(r-a)*i;n=$821ef51da65e5775$export$2077e0241d6afd3c(n,2),s.push(`<|${n}|>`),s.push([])}else s[s.length-1].push(r);return(s=s.map(n=>"string"==typeof n?n:super.decode(n,r))).join("")}/**
     * Combine tokens into words by splitting at any position where the tokens are decoded as valid unicode points.
     * @param {number[]} tokens 
     * @returns {*}
     * @private
     */splitTokensOnUnicode(n){let r=this.decode(n,{// @ts-ignore
decode_with_timestamps:!0}),i="",a=[],s=[],o=[],l=[],u=[],c=0;for(let h=0;h<n.length;++h){let d=n[h];l.push(d),u.push(h);let p=this.decode(l,{// @ts-ignore
decode_with_timestamps:!0});p.includes(i)&&r[c+p.indexOf(i)]!==i||(a.push(p),s.push(l),o.push(u),l=[],u=[],c+=p.length)}return[a,s,o]}/**
     * Combine tokens into words by splitting at whitespace and punctuation tokens.
     * @param {number[]} tokens 
     * @private
     */splitTokensOnSpaces(n){let[r,i,a]=this.splitTokensOnUnicode(n),s=[],o=[],l=[],u=RegExp(`^[${$a6a9715ee3096371$var$PUNCTUATION_REGEX}]$`,"gu");for(let n=0;n<r.length;++n){let c=r[n],h=i[n],d=a[n],p=h[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),f=c.startsWith(" "),m=c.trim(),g=u.test(m);if(p||f||g||0===s.length)s.push(c),o.push(h),l.push(d);else{let n=s.length-1;s[n]+=c,o[n].push(...h),l[n].push(...d)}}return[s,o,l]}/**
     * Merges punctuation tokens with neighboring words.
     * @param {string[]} words 
     * @param {number[][]} tokens 
     * @param {number[][]} indices 
     * @param {string} prepended 
     * @param {string} appended 
     * @private
     */mergePunctuations(n,r,i,a,s){let o=structuredClone(n),l=structuredClone(r),u=structuredClone(i),c=o.length-2,h=o.length-1;for(;c>=0;)o[c].startsWith(" ")&&a.includes(o[c].trim())?(o[h]=o[c]+o[h],l[h]=$2a81087eb92e3db1$export$9826fe7ad3921016(l[c],l[h]),u[h]=$2a81087eb92e3db1$export$9826fe7ad3921016(u[c],u[h]),o[c]="",l[c]=[],u[c]=[]):h=c,--c;for(// append punctuations
c=0,h=1;h<o.length;)!o[c].endsWith(" ")&&s.includes(o[h])?(o[c]+=o[h],l[c]=$2a81087eb92e3db1$export$9826fe7ad3921016(l[c],l[h]),u[c]=$2a81087eb92e3db1$export$9826fe7ad3921016(u[c],u[h]),o[h]="",l[h]=[],u[h]=[]):c=h,++h;return[o.filter(n=>n),l.filter(n=>n.length>0),u.filter(n=>n.length>0)]}/**
     * Helper function to build translation inputs for a `WhisperTokenizer`,
     * depending on the language, task, and whether to predict timestamp tokens.
     * 
     * Used to override the prefix tokens appended to the start of the label sequence.
     * 
     * **Example: Get ids for a language**
     * ```javascript
     * // instantiate the tokenizer and set the prefix token to Spanish
     * let tokenizer = await WhisperTokenizer.from_pretrained('Xenova/whisper-tiny');
     * let forced_decoder_ids = tokenizer.get_decoder_prompt_ids({ language: 'spanish' });
     * // [(1, 50262), (2, 50363)]
     * ```
     * 
     * @param {Object} options Options to generate the decoder prompt.
     * @param {string} [options.language] The language of the transcription text.
     * The corresponding language id token is appended to the start of the sequence for multilingual
     * speech recognition and speech translation tasks, e.g. for "Spanish" the token "<|es|>" is appended
     * to the start of sequence.
     * @param {string} [options.task] Task identifier to append at the start of sequence (if any).
     * This should be used for mulitlingual fine-tuning, with "transcribe" for speech recognition and
     * "translate" for speech translation.
     * @param {boolean} [options.no_timestamps] Whether to add the <|notimestamps|> token at the start of the sequence.
     * @returns {number[][]} The decoder prompt ids.
     */get_decoder_prompt_ids({language:n=null,task:r=null,no_timestamps:i=!0}={}){// <|lang_id|> <|task|> <|notimestamps|>
let a=[];if(n){// User wishes to specify the language
n=n.toLowerCase();// Map to code from user-friendly name (e.g., "english" -> "en")
let r=$a6a9715ee3096371$var$WHISPER_TO_LANGUAGE_CODE_MAPPING.get(n);if(void 0===r){// User provided something that is not a language name
if($a6a9715ee3096371$var$WHISPER_LANGUAGE_MAPPING.has(n))r=n;else{// User provided something that is not a language code or name
let r=2===n.length,i=r?$a6a9715ee3096371$var$WHISPER_LANGUAGE_MAPPING.keys():$a6a9715ee3096371$var$WHISPER_LANGUAGE_MAPPING.values();throw Error(`Language "${n}" is not supported. Must be one of: ${JSON.stringify(i)}`)}}let i=this.model.tokens_to_ids.get(`<|${r}|>`);if(void 0===i)throw Error(`Unable to find language "${r}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);a.push(i)}else a.push(null);if(r){if("transcribe"!==(r=r.toLowerCase())&&"translate"!==r)throw Error(`Task "${r}" is not supported. Must be one of: ["transcribe", "translate"]`);let n=this.model.tokens_to_ids.get(`<|${r}|>`);if(void 0===n)throw Error(`Unable to find task "${r}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);a.push(n)}else a.push(null);if(i){let n=this.model.tokens_to_ids.get("<|notimestamps|>");if(void 0===n)throw Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');a.push(n)}return a.map((n,r)=>[r+1,n]).filter(n=>null!==n[1])}}class $a6a9715ee3096371$export$9863ca5e567f8679 extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$1baa5613cbb55017 extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$1d0ec1d124248131 extends $a6a9715ee3096371$export$8117e0a660304ecb{/**
     * Create a new MarianTokenizer instance.
     * @param {Object} tokenizerJSON The JSON of the tokenizer.
     * @param {Object} tokenizerConfig The config of the tokenizer.
     */constructor(n,r){super(n,r),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(n=>this.languageRegex.test(n)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}/**
     * Encodes a single text. Overriding this method is necessary since the language codes
     * must be removed before encoding with sentencepiece model.
     * @see https://github.com/huggingface/transformers/blob/12d51db243a00726a548a43cc333390ebae731e3/src/transformers/models/marian/tokenization_marian.py#L204-L213
     *
     * @param {string|null} text The text to encode.
     * @returns {Array} The encoded tokens.
     */_encode_text(n){if(null===n)return null;// Check if text starts with language code:
let[r,...i]=n.trim().split(this.languageRegex);if(0===i.length)return super._encode_text(r);if(2===i.length){// Text starts with language code, so we do not encode it with sentencepiece.
let[n,r]=i;return this.supported_language_codes.includes(n)||console.warn(`Unsupported language code "${n}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),$2a81087eb92e3db1$export$9826fe7ad3921016([n],super._encode_text(r))}}}class $a6a9715ee3096371$export$a7bced49ddcd4364 extends $a6a9715ee3096371$export$8117e0a660304ecb{}class $a6a9715ee3096371$export$44e1b760ef6acae4{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:$a6a9715ee3096371$export$871245cd0d194ed,DistilBertTokenizer:$a6a9715ee3096371$export$8cd034a095bdc71,CamembertTokenizer:$a6a9715ee3096371$export$a849c8ee2508ff29,DebertaTokenizer:$a6a9715ee3096371$export$463c245396c8bd37,DebertaV2Tokenizer:$a6a9715ee3096371$export$5c2185c35d1f2e65,BertTokenizer:$a6a9715ee3096371$export$1272d61463841614,HerbertTokenizer:$a6a9715ee3096371$export$39d9cfa72569e043,XLMTokenizer:$a6a9715ee3096371$export$36813c1b7cf4a518,MobileBertTokenizer:$a6a9715ee3096371$export$8763a5327c48bc59,SqueezeBertTokenizer:$a6a9715ee3096371$export$32dba75c13f2bc88,AlbertTokenizer:$a6a9715ee3096371$export$ecb84099ba544a7,GPT2Tokenizer:$a6a9715ee3096371$export$1504ef98a86a7d1b,BartTokenizer:$a6a9715ee3096371$export$415a5b92def1e48b,MBartTokenizer:$a6a9715ee3096371$export$8474578ce918e467,MBart50Tokenizer:$a6a9715ee3096371$export$c9c8df830c8192d,RobertaTokenizer:$a6a9715ee3096371$export$9764e344cb7c8c4c,WhisperTokenizer:$a6a9715ee3096371$export$cc4d47e252dd9cc2,CodeGenTokenizer:$a6a9715ee3096371$export$9863ca5e567f8679,CLIPTokenizer:$a6a9715ee3096371$export$1baa5613cbb55017,MarianTokenizer:$a6a9715ee3096371$export$1d0ec1d124248131,BloomTokenizer:$a6a9715ee3096371$export$68f4b7e3d7b820c,NllbTokenizer:$a6a9715ee3096371$export$66ce0da2ecd3b55b,M2M100Tokenizer:$a6a9715ee3096371$export$2a70c9c2ab41ba80,LlamaTokenizer:$a6a9715ee3096371$export$93789d4dc2beeb0e,CodeLlamaTokenizer:$a6a9715ee3096371$export$4b88368c13deaae9,XLMRobertaTokenizer:$a6a9715ee3096371$export$d57774da5814535b,MPNetTokenizer:$a6a9715ee3096371$export$4ece281755dddbdc,FalconTokenizer:$a6a9715ee3096371$export$48a845f4c94658ce,GPTNeoXTokenizer:$a6a9715ee3096371$export$4a26e986d3fc9045,Wav2Vec2CTCTokenizer:$a6a9715ee3096371$export$a7bced49ddcd4364,PreTrainedTokenizer:$a6a9715ee3096371$export$8117e0a660304ecb};/**
     * Instantiate one of the tokenizer classes of the library from a pretrained model.
     * 
     * The tokenizer class to instantiate is selected based on the `tokenizer_class` property of the config object
     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)
     * 
     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:
     * - A string, the *model id* of a pretrained tokenizer hosted inside a model repo on huggingface.co.
     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a
     *   user or organization name, like `dbmdz/bert-base-german-cased`.
     * - A path to a *directory* containing tokenizer files, e.g., `./my_model_directory/`.
     * @param {PretrainedOptions} options Additional options for loading the tokenizer.
     * 
     * @returns {Promise<PreTrainedTokenizer>} A new instance of the PreTrainedTokenizer class.
     */static async from_pretrained(n,{quantized:r=!0,progress_callback:i=null,config:a=null,cache_dir:s=null,local_files_only:o=!1,revision:l="main"}={}){let[u,c]=await $a6a9715ee3096371$var$loadTokenizer(n,{quantized:r,progress_callback:i,config:a,cache_dir:s,local_files_only:o,revision:l}),h=c.tokenizer_class.replace(/Fast$/,""),d=this.TOKENIZER_CLASS_MAPPING[h];return d||(console.warn(`Unknown tokenizer class "${h}", attempting to construct from base class.`),d=$a6a9715ee3096371$export$8117e0a660304ecb),new d(u,c)}}/**
 * @file Definitions of all models available in Transformers.js.
 * 
 * **Example:** Load and run an `AutoModel`.
 * 
 * ```javascript
 * import { AutoModel, AutoTokenizer } from '@xenova/transformers';
 *
 * let tokenizer = await AutoTokenizer.from_pretrained('Xenova/bert-base-uncased');
 * let model = await AutoModel.from_pretrained('Xenova/bert-base-uncased');
 *
 * let inputs = await tokenizer('I love transformers!');
 * let { logits } = await model(inputs);
 * // Tensor {
 * //     data: Float32Array(183132) [-7.117443084716797, -7.107812881469727, -7.092104911804199, ...]
 * //     dims: (3) [1, 6, 30522],
 * //     type: "float32",
 * //     size: 183132,
 * // }
 * ```
 * 
 * We also provide other `AutoModel`s (listed below), which you can use in the same way as the Python library. For example:
 * 
 * **Example:** Load and run a `AutoModelForSeq2SeqLM`.
 * ```javascript
 * import { AutoModelForSeq2SeqLM, AutoTokenizer } from '@xenova/transformers';
 * 
 * let tokenizer = await AutoTokenizer.from_pretrained('Xenova/t5-small');
 * let model = await AutoModelForSeq2SeqLM.from_pretrained('Xenova/t5-small');
 *
 * let { input_ids } = await tokenizer('translate English to German: I love transformers!');
 * let outputs = await model.generate(input_ids);
 * let decoded = tokenizer.decode(outputs[0], { skip_special_tokens: true });
 * // 'Ich liebe Transformatoren!'
 * ```
 * 
 * @module models
 *//**
 * @file Helper module for using model configs. For more information, see the corresponding
 * [Python documentation](https://huggingface.co/docs/transformers/main/en/model_doc/auto#transformers.AutoConfig).
 * 
 * **Example:** Load an `AutoConfig`.
 * 
 * ```javascript
 * import { AutoConfig } from '@xenova/transformers';
 * let config = await AutoConfig.from_pretrained('bert-base-uncased');
 * console.log(config);
 * // PretrainedConfig {
 * //   "model_type": "bert",
 * //   "is_encoder_decoder": false,
 * //   "architectures": [
 * //       "BertForMaskedLM"
 * //   ],
 * //   "vocab_size": 30522
 * //   "num_attention_heads": 12,
 * //   "num_hidden_layers": 12,
 * //   "hidden_size": 768,
 * //   "max_position_embeddings": 512,
 * //   ...
 * // }
 * ```
 * 
 * @module configs
 *//**
 * @typedef {import('./utils/hub.js').PretrainedOptions} PretrainedOptions
 *//**
 * Loads a config from the specified path.
 * @param {string} pretrained_model_name_or_path The path to the config directory.
 * @param {PretrainedOptions} options Additional options for loading the config.
 * @returns {Promise<Array>} A promise that resolves with information about the loaded config.
 */async function $d0feda9c43436cc0$var$loadConfig(n,r){return await $fb1f2fa9752dcff4$export$bdb2295ec9595824(n,"config.json",!0,r)}class $d0feda9c43436cc0$export$f4da1f0f0f6f5930{// NOTE: Typo in original
/**
     * Create a new PreTrainedTokenizer instance.
     * @param {Object} configJSON The JSON of the config.
     */constructor(n){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,n)}/**
     * Loads a pre-trained config from the given `pretrained_model_name_or_path`. 
     * 
     * @param {string} pretrained_model_name_or_path The path to the pre-trained config.
     * @param {PretrainedOptions} options Additional options for loading the config.
     * @throws {Error} Throws an error if the config.json is not found in the `pretrained_model_name_or_path`.
     * 
     * @returns {Promise<PretrainedConfig>} A new instance of the `PretrainedConfig` class.
     */static async from_pretrained(n,{progress_callback:r=null,config:i=null,cache_dir:a=null,local_files_only:s=!1,revision:o="main"}={}){let l=i??await $d0feda9c43436cc0$var$loadConfig(n,{progress_callback:r,config:i,cache_dir:a,local_files_only:s,revision:o});return new this(l)}}class $d0feda9c43436cc0$export$774ba61eeb9f6e8{/** @type {PretrainedConfig.from_pretrained} */static async from_pretrained(...n){return $d0feda9c43436cc0$export$f4da1f0f0f6f5930.from_pretrained(...n)}}/**
 * @file Classes, functions, and utilities for generation.
 * 
 * @todo Describe how to create a custom `GenerationConfig`.
 * 
 * @module utils/generation
 */class $61e4fb922b7bb9b4$export$f89551bc91e7a8bf extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
     * Constructs a new instance of `LogitsProcessorList`.
     */constructor(){super(),this.processors=[]}/**
     * Adds a new logits processor to the list.
     *
     * @param {LogitsProcessor} item The logits processor function to add.
     */push(n){this.processors.push(n)}/**
     * Adds multiple logits processors to the list.
     *
     * @param {LogitsProcessor[]} items The logits processor functions to add.
     */extend(n){this.processors.push(...n)}/**
     * Applies all logits processors in the list to a batch of logits, modifying them in-place.
     *
     * @param {number[]} input_ids The input IDs for the language model.
     * @param {number[][]} batchedLogits A 2D array of logits, where each row corresponds to a single
     *                                                input sequence in the batch.
     */_call(n,r){// NOTE: This is different from the Python code, since vanilla JS does not support vectorized operations. 
// As a result, we apply each processor to each item in the batch.
for(let i of r)this.processors.forEach(r=>r(n,i))}[Symbol.iterator](){return this.processors.values()}}class $61e4fb922b7bb9b4$export$74642517ba175a90 extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
     * Apply the processor to the input logits.
     *
     * @abstract
     * @param {Array} input_ids The input ids.
     * @param {Tensor} logits The logits to process.
     * @throws {Error} Throws an error if `_call` is not implemented in the subclass.
     */_call(n,r){throw Error("`_call` should be implemented in a subclass")}}class $61e4fb922b7bb9b4$export$2248f8e9679e34ce extends $61e4fb922b7bb9b4$export$74642517ba175a90{/**
     * Constructs a new instance of `ForceTokensLogitsProcessor`.
     * 
     * @param {Array} forced_decoder_ids The ids of tokens that should be forced.
     */constructor(n){super(),this.force_token_map=Object.fromEntries(n??[])}/**
     * Apply the processor to the input logits.
     *
     * @param {Array} input_ids The input ids.
     * @param {Tensor} logits The logits to process.
     * @returns {Tensor} The processed logits.
     */_call(n,r){let i=this.force_token_map[n.length];return $2a81087eb92e3db1$export$f7e9f41ea797a17(i)&&(r.data.fill(-1/0),r.data[i]=0),r}}class $61e4fb922b7bb9b4$export$ca2ca37265a40c2f extends $61e4fb922b7bb9b4$export$74642517ba175a90{/**
     * Create a ForcedBOSTokenLogitsProcessor.
     * @param {number} bos_token_id The ID of the beginning-of-sequence token to be forced.
     */constructor(n){super(),this.bos_token_id=n}/**
     * Apply the BOS token forcing to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with BOS token forcing.
     */_call(n,r){return 1===n.length&&(r.data.fill(-1/0),r.data[this.bos_token_id]=0),r}}class $61e4fb922b7bb9b4$export$64e4adbc163422bb extends $61e4fb922b7bb9b4$export$74642517ba175a90{/**
     * Create a ForcedEOSTokenLogitsProcessor.
     * @param {number} max_length Max length of the sequence.
     * @param {number|number[]} forced_eos_token_id The ID of the end-of-sequence token to be forced.
     */constructor(n,r){super(),this.max_length=n,this.forced_eos_token_id=r}/**
     * Apply the processor to input_ids and logits.
     * 
     * @param {number[]} input_ids The input ids.
     * @param {Tensor} logits The logits tensor.
     */_call(n,r){// console.log('call ForcedEOSTokenLogitsProcessor')
// TODO
}}class $61e4fb922b7bb9b4$export$c1e2265678aded42 extends $61e4fb922b7bb9b4$export$74642517ba175a90{/**
     * Create a SuppressTokensAtBeginLogitsProcessor.
     * @param {number[]} begin_suppress_tokens The IDs of the tokens to suppress.
     * @param {number} begin_index The number of tokens to generate before suppressing tokens.
     */constructor(n,r){super(),this.begin_suppress_tokens=n,this.begin_index=r}/**
     * Apply the BOS token forcing to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with BOS token forcing.
     */_call(n,r){if(n.length===this.begin_index)for(let n of this.begin_suppress_tokens)r.data[n]=-1/0;return r}}class $61e4fb922b7bb9b4$export$e1af0caf3e32b4e9 extends $61e4fb922b7bb9b4$export$74642517ba175a90{/**
     * Constructs a new WhisperTimeStampLogitsProcessor.
     * @param {Object} generate_config The config object passed to the `generate()` method of a transformer model.
     * @param {number} generate_config.eos_token_id The ID of the end-of-sequence token.
     * @param {number} generate_config.no_timestamps_token_id The ID of the token used to indicate that a token should not have a timestamp.
     * @param {number[][]} [generate_config.forced_decoder_ids] An array of two-element arrays representing decoder IDs that are forced to appear in the output. The second element of each array indicates whether the token is a timestamp.
     * @param {number} [generate_config.max_initial_timestamp_index] The maximum index at which an initial timestamp can appear.
     */constructor(n){super(),this.eos_token_id=n.eos_token_id,this.no_timestamps_token_id=n.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=(n.forced_decoder_ids||[]).length+2,n.forced_decoder_ids.slice(-1)[0][1]===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=n.max_initial_timestamp_index}/**
     * Modify the logits to handle timestamp tokens.
     * @param {Array} input_ids The input sequence of tokens.
     * @param {Tensor} logits The logits output by the model.
     * @returns {Tensor} The modified logits.
     */_call(n,r){if(// suppress <|notimestamps|> which is handled by without_timestamps
r.data[this.no_timestamps_token_id]=-1/0,n.length===this.begin_index-1)return r.data.fill(-1/0),r.data[this.timestamp_begin]=0,r;// timestamps have to appear in pairs, except directly before eos_token; mask logits accordingly
let i=n.slice(this.begin_index),a=i.length>=1&&i[i.length-1]>=this.timestamp_begin,s=i.length<2||i[i.length-2]>=this.timestamp_begin;// apply the `max_initial_timestamp` option
if(a&&(s?r.data.subarray(this.timestamp_begin).fill(-1/0):r.data.subarray(0,this.eos_token_id).fill(-1/0)),n.length===this.begin_index&&null!==this.max_initial_timestamp_index){let n=this.timestamp_begin+this.max_initial_timestamp_index;r.data.subarray(n+1).fill(-1/0)}// if sum of probability over timestamps is above any other token, sample timestamp
let o=$821ef51da65e5775$export$82ac14ef2b5818d0(r.data),l=Math.log(o.subarray(this.timestamp_begin).map(Math.exp).reduce((n,r)=>n+r)),u=$821ef51da65e5775$export$8960430cfd85939f(o.subarray(0,this.timestamp_begin))[0];return l>u&&r.data.subarray(0,this.timestamp_begin).fill(-1/0),r}}class $61e4fb922b7bb9b4$export$84e434bdb5aa3973 extends $61e4fb922b7bb9b4$export$74642517ba175a90{/**
     * Create a NoRepeatNGramLogitsProcessor.
     * @param {number} no_repeat_ngram_size The no-repeat-ngram size. All ngrams of this size can only occur once.
     */constructor(n){super(),this.no_repeat_ngram_size=n}/**
     * Generate n-grams from a sequence of token ids.
     * @param {number[]} prevInputIds List of previous input ids
     * @returns {Map<string, number[]>} Map of generated n-grams
     */getNgrams(n){let r=n.length,i=[];for(let a=0;a<r+1-this.no_repeat_ngram_size;++a){let r=[];for(let i=0;i<this.no_repeat_ngram_size;++i)r.push(n[a+i]);i.push(r)}/** @type {Map<string, number[]>} */let a=new Map;for(let n of i){let r=n.slice(0,n.length-1),i=JSON.stringify(r),s=a.get(i)??[];s.push(n[n.length-1]),a.set(i,s)}return a}/**
     * Generate n-grams from a sequence of token ids.
     * @param {Map<string, number[]>} bannedNgrams Map of banned n-grams
     * @param {number[]} prevInputIds List of previous input ids
     * @returns {number[]} Map of generated n-grams
     */getGeneratedNgrams(n,r){let i=r.slice(r.length+1-this.no_repeat_ngram_size,r.length),a=n.get(JSON.stringify(i))??[];return a}/**
     * Calculate banned n-gram tokens
     * @param {number[]} prevInputIds List of previous input ids
     * @returns {number[]} Map of generated n-grams
     */calcBannedNgramTokens(n){let r=[];if(n.length+1<this.no_repeat_ngram_size)return r;{let r=this.getNgrams(n),i=this.getGeneratedNgrams(r,n);return i}}/**
     * Apply the no-repeat-ngram processor to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with no-repeat-ngram processing.
     */_call(n,r){let i=this.calcBannedNgramTokens(n);for(let n of i)r.data[n]=-1/0;return r}}class $61e4fb922b7bb9b4$export$a8a272be4e45be99 extends $61e4fb922b7bb9b4$export$74642517ba175a90{/**
     * Create a RepetitionPenaltyLogitsProcessor.
     * @param {number} penalty The penalty to apply for repeated tokens.
     */constructor(n){super(),this.penalty=n}/**
     * Apply the repetition penalty to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with repetition penalty processing.
     */_call(n,r){// Modify the logits corresponding to each element in `input_ids`.
// As a consequence, the logits corresponding to tokens that appear
// many times in the output will be penalised more.
for(let i of n)r.data[i]<0?r.data[i]*=this.penalty:r.data[i]/=this.penalty;return r}}class $61e4fb922b7bb9b4$export$4a9075b060f88b7f extends $61e4fb922b7bb9b4$export$74642517ba175a90{/**
     * Create a MinLengthLogitsProcessor.
     * @param {number} min_length The minimum length below which the score of `eos_token_id` is set to negative infinity.
     * @param {number|number[]} eos_token_id The ID/IDs of the end-of-sequence token.
     */constructor(n,r){super(),this.min_length=n,this.eos_token_id=Array.isArray(r)?r:[r]}/**
     * Apply logit processor.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The processed logits.
     */_call(n,r){if(n.length<this.min_length)for(let n of this.eos_token_id)r.data[n]=-1/0;return r}}class $61e4fb922b7bb9b4$export$64f19ec0905c9acf extends $61e4fb922b7bb9b4$export$74642517ba175a90{/**
     * Create a MinNewTokensLengthLogitsProcessor.
     * @param {number} prompt_length_to_skip The input tokens length.
     * @param {number} min_new_tokens The minimum *new* tokens length below which the score of `eos_token_id` is set to negative infinity.
     * @param {number|number[]} eos_token_id The ID/IDs of the end-of-sequence token.
     */constructor(n,r,i){super(),this.prompt_length_to_skip=n,this.min_new_tokens=r,this.eos_token_id=Array.isArray(i)?i:[i]}/**
     * Apply logit processor.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The processed logits.
     */_call(n,r){let i=n.length-this.prompt_length_to_skip;if(i<this.min_new_tokens)for(let n of this.eos_token_id)r.data[n]=-1/0;return r}}class $61e4fb922b7bb9b4$export$be173e4c0d82d4ec{/**
     * Create a GenerationConfig object
     * @param {Object} [kwargs={}] The configuration parameters. If not set, the default values are used.
     * @param {number} [kwargs.max_length=20] The maximum length the generated tokens can have. Corresponds to the length of the input prompt + `max_new_tokens`. Its effect is overridden by `max_new_tokens`, if also set.
     * @param {number} [kwargs.max_new_tokens=null] The maximum numbers of tokens to generate, ignoring the number of tokens in the prompt.
     * @param {number} [kwargs.min_length=0] The minimum length of the sequence to be generated. Corresponds to the length of the input prompt + `min_new_tokens`. Its effect is overridden by `min_new_tokens`, if also set.
     * @param {number} [kwargs.min_new_tokens=null] The minimum numbers of tokens to generate, ignoring the number of tokens in the prompt.
     * @param {boolean|"never"} [kwargs.early_stopping=false] Controls the stopping condition for beam-based methods, like beam-search. It accepts the following values:
     * - `true`, where the generation stops as soon as there are `num_beams` complete candidates;
     * - `false`, where an heuristic is applied and the generation stops when is it very unlikely to find better candidates;
     * - `"never"`, where the beam search procedure only stops when there cannot be better candidates (canonical beam search algorithm).
     * @param {number} [kwargs.max_time=null] The maximum amount of time you allow the computation to run for in seconds. Generation will still finish the current pass after allocated time has been passed.
     *
     * @param {boolean} [kwargs.do_sample=false] Whether or not to use sampling; use greedy decoding otherwise.
     * @param {number} [kwargs.num_beams=1] Number of beams for beam search. 1 means no beam search.
     * @param {number} [kwargs.num_beam_groups=1] Number of groups to divide `num_beams` into in order to ensure diversity among different groups of beams. See [this paper](https://arxiv.org/pdf/1610.02424.pdf) for more details.
     * @param {number} [kwargs.penalty_alpha=null] The values balance the model confidence and the degeneration penalty in contrastive search decoding.
     * @param {boolean} [kwargs.use_cache=true] Whether or not the model should use the past last key/values attentions (if applicable to the model) to speed up decoding.
     *
     * @param {number} [kwargs.temperature=1.0] The value used to modulate the next token probabilities.
     * @param {number} [kwargs.top_k=50] The number of highest probability vocabulary tokens to keep for top-k-filtering.
     * @param {number} [kwargs.top_p=1.0] If set to float < 1, only the smallest set of most probable tokens with probabilities that add up to `top_p` or higher are kept for generation.
     * @param {number} [kwargs.typical_p=1.0] Local typicality measures how similar the conditional probability of predicting a target token next is to the expected conditional probability of predicting a random token next, given the partial text already generated. If set to float < 1, the smallest set of the most locally typical tokens with probabilities that add up to `typical_p` or higher are kept for generation. See [this paper](https://arxiv.org/pdf/2202.00666.pdf) for more details.
     * @param {number} [kwargs.epsilon_cutoff=0.0] If set to float strictly between 0 and 1, only tokens with a conditional probability greater than `epsilon_cutoff` will be sampled. In the paper, suggested values range from 3e-4 to 9e-4, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.
     * @param {number} [kwargs.eta_cutoff=0.0] Eta sampling is a hybrid of locally typical sampling and epsilon sampling. If set to float strictly between 0 and 1, a token is only considered if it is greater than either `eta_cutoff` or `sqrt(eta_cutoff) * exp(-entropy(softmax(next_token_logits)))`. The latter term is intuitively the expected next token probability, scaled by `sqrt(eta_cutoff)`. In the paper, suggested values range from 3e-4 to 2e-3, depending on the size of the model. See [Truncation Sampling as Language Model Desmoothing](https://arxiv.org/abs/2210.15191) for more details.
     * @param {number} [kwargs.diversity_penalty=0.0] This value is subtracted from a beam's score if it generates a token same as any beam from other group at a particular time. Note that `diversity_penalty` is only effective if `group beam search` is enabled.
     * @param {number} [kwargs.repetition_penalty=1.0] The parameter for repetition penalty. 1.0 means no penalty. See [this paper](https://arxiv.org/pdf/1909.05858.pdf) for more details.
     * @param {number} [kwargs.encoder_repetition_penalty=1.0] The paramater for encoder_repetition_penalty. An exponential penalty on sequences that are not in the original input. 1.0 means no penalty.
     * @param {number} [kwargs.length_penalty=1.0] Exponential penalty to the length that is used with beam-based generation. It is applied as an exponent to the sequence length, which in turn is used to divide the score of the sequence. Since the score is the log likelihood of the sequence (i.e. negative), `length_penalty` > 0.0 promotes longer sequences, while `length_penalty` < 0.0 encourages shorter sequences.
     * @param {number} [kwargs.no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size can only occur once.
     * @param {number[][]} [kwargs.bad_words_ids=null] List of token ids that are not allowed to be generated. In order to get the token ids of the words that should not appear in the generated text, use `(await tokenizer(bad_words, {add_prefix_space: true, add_special_tokens: false})).input_ids`.
     * @param {number[][]|number[][][]} [kwargs.force_words_ids=null] List of token ids that must be generated. If given a `number[][]`, this is treated as a simple list of words that must be included, the opposite to `bad_words_ids`. If given `number[][][]`, this triggers a [disjunctive constraint](https://github.com/huggingface/transformers/issues/14081), where one can allow different forms of each word.
     * @param {boolean} [kwargs.renormalize_logits=false] Whether to renormalize the logits after applying all the logits processors or warpers (including the custom ones). It's highly recommended to set this flag to `true` as the search algorithms suppose the score logits are normalized but some logit processors or warpers break the normalization.
     * @param {Object[]} [kwargs.constraints=null] Custom constraints that can be added to the generation to ensure that the output will contain the use of certain tokens as defined by `Constraint` objects, in the most sensible way possible.
     * 
     * @param {number} [kwargs.forced_bos_token_id=null] The id of the token to force as the first generated token after the `decoder_start_token_id`. Useful for multilingual models like mBART where the first generated token needs to be the target language token.
     * @param {number|number[]} [kwargs.forced_eos_token_id=null] The id of the token to force as the last generated token when `max_length` is reached. Optionally, use a list to set multiple *end-of-sequence* tokens.
     * @param {boolean} [kwargs.remove_invalid_values=false] Whether to remove possible *nan* and *inf* outputs of the model to prevent the generation method to crash. Note that using `remove_invalid_values` can slow down generation.
     * @param {number[]} [kwargs.exponential_decay_length_penalty=null] This Tuple adds an exponentially increasing length penalty, after a certain amount of tokens have been generated. The tuple shall consist of: `(start_index, decay_factor)` where `start_index` indicates where penalty starts and `decay_factor` represents the factor of exponential decay.
     * @param {number[]} [kwargs.suppress_tokens=null] A list of tokens that will be suppressed at generation. The `SupressTokens` logit processor will set their log probs to `-inf` so that they are not sampled.
     * @param {number[]} [kwargs.begin_suppress_tokens=null] A list of tokens that will be suppressed at the beginning of the generation. The `SupressBeginTokens` logit processor will set their log probs to `-inf` so that they are not sampled.
     * @param {number[][]} [kwargs.forced_decoder_ids=null] A list of pairs of integers which indicates a mapping from generation indices to token indices that will be forced before sampling. For example, `[[1, 123]]` means the second generated token will always be a token of index 123.
     * 
     * @param {number} [kwargs.num_return_sequences=1] The number of independently computed returned sequences for each element in the batch.
     * @param {boolean} [kwargs.output_attentions=false] Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned tensors for more details.
     * @param {boolean} [kwargs.output_hidden_states=false] Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for more details.
     * @param {boolean} [kwargs.output_scores=false] Whether or not to return the prediction scores. See `scores` under returned tensors for more details.
     * @param {boolean} [kwargs.return_dict_in_generate=false] Whether or not to return a `ModelOutput` instead of a plain tuple.
     * 
     * @param {number} [kwargs.pad_token_id=null] The id of the *padding* token.
     * @param {number} [kwargs.bos_token_id=null] The id of the *beginning-of-sequence* token.
     * @param {number|number[]} [kwargs.eos_token_id=null] The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.
     * 
     * @param {number} [kwargs.encoder_no_repeat_ngram_size=0] If set to int > 0, all ngrams of that size that occur in the `encoder_input_ids` cannot occur in the `decoder_input_ids`.
     * @param {number} [kwargs.decoder_start_token_id=null] If an encoder-decoder model starts decoding with a different token than *bos*, the id of that token.
     * 
     * @param {Object} [kwargs.generation_kwargs={}] Additional generation kwargs will be forwarded to the `generate` function of the model. Kwargs that are not present in `generate`'s signature will be used in the model forward pass.
     */constructor(n={}){// Parameters that control the length of the output
this.max_length=n.max_length??20,this.max_new_tokens=n.max_new_tokens??null,this.min_length=n.min_length??0,this.min_new_tokens=n.min_new_tokens??null,this.early_stopping=n.early_stopping??!1,this.max_time=n.max_time??null,// Parameters that control the generation strategy used
this.do_sample=n.do_sample??!1,this.num_beams=n.num_beams??1,this.num_beam_groups=n.num_beam_groups??1,this.penalty_alpha=n.penalty_alpha??null,this.use_cache=n.use_cache??!0,// Parameters for manipulation of the model output logits
this.temperature=n.temperature??1,this.top_k=n.top_k??50,this.top_p=n.top_p??1,this.typical_p=n.typical_p??1,this.epsilon_cutoff=n.epsilon_cutoff??0,this.eta_cutoff=n.eta_cutoff??0,this.diversity_penalty=n.diversity_penalty??0,this.repetition_penalty=n.repetition_penalty??1,this.encoder_repetition_penalty=n.encoder_repetition_penalty??1,this.length_penalty=n.length_penalty??1,this.no_repeat_ngram_size=n.no_repeat_ngram_size??0,this.bad_words_ids=n.bad_words_ids??null,this.force_words_ids=n.force_words_ids??null,this.renormalize_logits=n.renormalize_logits??!1,this.constraints=n.constraints??null,this.forced_bos_token_id=n.forced_bos_token_id??null,this.forced_eos_token_id=n.forced_eos_token_id??null,this.remove_invalid_values=n.remove_invalid_values??!1,this.exponential_decay_length_penalty=n.exponential_decay_length_penalty??null,this.suppress_tokens=n.suppress_tokens??null,this.begin_suppress_tokens=n.begin_suppress_tokens??null,this.forced_decoder_ids=n.forced_decoder_ids??null,// Parameters that define the output variables of `generate`
this.num_return_sequences=n.num_return_sequences??1,this.output_attentions=n.output_attentions??!1,this.output_hidden_states=n.output_hidden_states??!1,this.output_scores=n.output_scores??!1,this.return_dict_in_generate=n.return_dict_in_generate??!1,// Special tokens that can be used at generation time
this.pad_token_id=n.pad_token_id??null,this.bos_token_id=n.bos_token_id??null,this.eos_token_id=n.eos_token_id??null,// Generation parameters exclusive to encoder-decoder models
this.encoder_no_repeat_ngram_size=n.encoder_no_repeat_ngram_size??0,this.decoder_start_token_id=n.decoder_start_token_id??null,// Wild card
this.generation_kwargs=n.generation_kwargs??{}}}class $61e4fb922b7bb9b4$export$322f102bec719b22 extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
     * Creates a new Sampler object with the specified generation config.
     * @param {GenerationConfig} generation_config The generation config.
     */constructor(n){super(),this.generation_config=n}/**
     * Executes the sampler, using the specified logits.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {void}
     */_call(n,r=-1){// Sample from logits, of dims [batch, sequence_length, vocab_size].
// If index is specified, sample from [batch, index, vocab_size].
return this.sample(n,r)}/**
     * Abstract method for sampling the logits.
     * @param {Tensor} logits
     * @param {number} index
     * @throws {Error}
     */sample(n,r){throw Error("sample should be implemented in subclasses.")}/**
     * Returns the specified logits as an array, with temperature applied.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {Array}
     */getLogits(n,r){let i=n.dims.at(-1),a=n.data;if(-1===r)a=a.slice(-i);else{let n=r*i;a=a.slice(n,n+i)}return this.generation_config.temperature>0&&(a=a.map(n=>n/this.generation_config.temperature)),a}/**
     * Selects an item randomly based on the specified probabilities.
     * @param {Array} probabilities An array of probabilities to use for selection.
     * @returns {number} The index of the selected item.
     */randomSelect(n){let r=Math.random()*n.reduce((n,r)=>n+r,0);for(let i=0;i<n.length;++i)if((r-=n[i])<=0)return i;return 0;// return first (most probable) as a fallback
}/**
     * Returns a Sampler object based on the specified options.
     * @param {GenerationConfig} generation_config An object containing options for the sampler.
     * @returns {Sampler} A Sampler object.
     */static getSampler(n){// - *greedy decoding*: `num_beams=1` and `do_sample=False`
// - *contrastive search*: `penalty_alpha>0` and `top_k>1`
// - *multinomial sampling*: `num_beams=1` and `do_sample=True`
// - *beam-search decoding*: `num_beams>1` and `do_sample=False`
// - *beam-search multinomial sampling*: `num_beams>1` and `do_sample=True`
// - *diverse beam-search decoding*: `num_beams>1` and `num_beam_groups>1`
// - *constrained beam-search decoding*: `constraints!=None` or `force_words_ids!=None`
// NOTE: beam search is implemented directly into the generation function
if(n.do_sample)return new $61e4fb922b7bb9b4$var$MultinomialSampler(n);if(n.num_beams>1)return new $61e4fb922b7bb9b4$var$BeamSearchSampler(n);if(n.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${n.num_return_sequences}.`);return new $61e4fb922b7bb9b4$var$GreedySampler(n)}}/**
 * Class representing a Greedy Sampler.
 * @extends Sampler
 */class $61e4fb922b7bb9b4$var$GreedySampler extends $61e4fb922b7bb9b4$export$322f102bec719b22{/**
     * Sample the maximum probability of a given logits tensor.
     * @param {Tensor} logits
     * @param {number} [index=-1]
     * @returns {Array} An array with a single tuple, containing the index of the maximum value and a meaningless score (since this is a greedy search).
     */sample(n,r=-1){// Note: score is meaningless in this context, since we are performing
// greedy search (p = 1 => log(p) = 0)
return[[$821ef51da65e5775$export$8960430cfd85939f(this.getLogits(n,r))[1],0]]}}/**
 * Class representing a MultinomialSampler.
 * @extends Sampler
 */class $61e4fb922b7bb9b4$var$MultinomialSampler extends $61e4fb922b7bb9b4$export$322f102bec719b22{/**
     * Sample from the logits.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {Array}
     */sample(n,r=-1){let i=n.dims.at(-1);// defaults to vocab size
this.generation_config.top_k>0&&(i=Math.min(this.generation_config.top_k,i));// Get logits of nth token
let a=this.getLogits(n,r),s=$821ef51da65e5775$export$dd136ade76918e5b(a,i),o=$821ef51da65e5775$export$e008137e76238601(s.map(n=>n[1]));return Array.from({length:this.generation_config.num_beams},()=>{let n=this.randomSelect(o);return[s[n][0],Math.log(o[n])]})}}/**
 * Class representing a BeamSearchSampler.
 * @extends Sampler
 */class $61e4fb922b7bb9b4$var$BeamSearchSampler extends $61e4fb922b7bb9b4$export$322f102bec719b22{/**
     * Sample from the logits.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {Array}
     */sample(n,r=-1){let i=n.dims.at(-1);// defaults to vocab size
this.generation_config.top_k>0&&(i=Math.min(this.generation_config.top_k,i));// Get logits of nth token
let a=this.getLogits(n,r),s=$821ef51da65e5775$export$dd136ade76918e5b(a,i),o=$821ef51da65e5775$export$e008137e76238601(s.map(n=>n[1]));return Array.from({length:this.generation_config.num_beams},(n,r)=>[s[r][0],Math.log(o[r])])}}const{InferenceSession:$16c3c01c3acb118d$var$InferenceSession,Tensor:$16c3c01c3acb118d$var$ONNXTensor}=$b8705bfef224a9de$export$1cf47f9eac95b665,$16c3c01c3acb118d$var$MODEL_TYPES={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4},$16c3c01c3acb118d$var$MODEL_TYPE_MAPPING=new Map,$16c3c01c3acb118d$var$MODEL_NAME_TO_CLASS_MAPPING=new Map,$16c3c01c3acb118d$var$MODEL_CLASS_TO_NAME_MAPPING=new Map;/**
 * Constructs an InferenceSession using a model file located at the specified path.
 * @param {string} pretrained_model_name_or_path The path to the directory containing the model file.
 * @param {string} fileName The name of the model file.
 * @param {PretrainedOptions} options Additional options for loading the model.
 * @returns {Promise<InferenceSession>} A Promise that resolves to an InferenceSession object.
 * @private
 */async function $16c3c01c3acb118d$var$constructSession(n,r,i){// TODO add option for user to force specify their desired execution provider
let a=`onnx/${r}${i.quantized?"_quantized":""}.onnx`,s=await $fb1f2fa9752dcff4$export$e5c5b77f730156(n,a,!0,i);try{return await $16c3c01c3acb118d$var$InferenceSession.create(s,{executionProviders:$b8705bfef224a9de$export$114f36f141c3ad7c})}catch(n){// If the execution provided was only wasm, throw the error
if(1===$b8705bfef224a9de$export$114f36f141c3ad7c.length&&"wasm"===$b8705bfef224a9de$export$114f36f141c3ad7c[0])throw n;return console.warn(n),console.warn("Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "),await $16c3c01c3acb118d$var$InferenceSession.create(s,{executionProviders:["wasm"]})}}/**
 * Validate model inputs
 * @param {InferenceSession} session The InferenceSession object that will be run.
 * @param {Object} inputs The inputs to check.
 * @returns {Promise<Object>} A Promise that resolves to the checked inputs.
 * @throws {Error} If any inputs are missing.
 * @private
 */async function $16c3c01c3acb118d$var$validateInputs(n,r){// NOTE: Only create a shallow copy
let i={},a=[];for(let s of n.inputNames)void 0===r[s]?a.push(s):i[s]=r[s];if(a.length>0)throw Error(`An error occurred during model execution: "Missing the following inputs: ${a.join(", ")}.`);let s=Object.keys(r).length,o=n.inputNames.length;if(s>o){// No missing inputs, but too many inputs were provided.
// Warn the user and ignore the extra inputs.
let i=Object.keys(r).filter(r=>!n.inputNames.includes(r));console.warn(`WARNING: Too many inputs were provided (${s} > ${o}). The following inputs will be ignored: "${i.join(", ")}".`)}return i}/**
 * Executes an InferenceSession using the specified inputs.
 * NOTE: `inputs` must contain at least the input names of the model.
 *  - If additional inputs are passed, they will be ignored.
 *  - If inputs are missing, an error will be thrown.
 * 
 * @param {InferenceSession} session The InferenceSession object to run.
 * @param {Object} inputs An object that maps input names to input tensors.
 * @returns {Promise<Object>} A Promise that resolves to an object that maps output names to output tensors.
 * @private
 */async function $16c3c01c3acb118d$var$sessionRun(n,r){let i=await $16c3c01c3acb118d$var$validateInputs(n,r);try{let r=await n.run(i);return r=$16c3c01c3acb118d$var$replaceTensors(r)}catch(n){throw(// This usually occurs when the inputs are of the wrong type.
console.error(`An error occurred during model execution: "${n}".`),console.error("Inputs given to model:",i),n)}}/**
 * Replaces ONNX Tensor objects with custom Tensor objects to support additional functions.
 * @param {Object} obj The object to replace tensor objects in.
 * @returns {Object} The object with tensor objects replaced by custom Tensor objects.
 * @private
 */function $16c3c01c3acb118d$var$replaceTensors(n){for(let r in n)n[r]instanceof $16c3c01c3acb118d$var$ONNXTensor?n[r]=new $970f59cad5f0fd6a$export$7b6b8d90402f8814(n[r]):"object"==typeof n[r]&&$16c3c01c3acb118d$var$replaceTensors(n[r]);return n}/**
 * Converts an array or Tensor of integers to an int64 Tensor.
 * @param {Array|Tensor} items The input integers to be converted.
 * @returns {Tensor} The int64 Tensor with the converted values.
 * @throws {Error} If the input array is empty or the input is a batched Tensor and not all sequences have the same length.
 * @private
 */function $16c3c01c3acb118d$var$toI64Tensor(n){if(n instanceof $970f59cad5f0fd6a$export$7b6b8d90402f8814)return n;// items is an array
if(0===n.length)throw Error("items must be non-empty");if(!Array.isArray(n[0]))return new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",BigInt64Array.from(n.map(n=>BigInt(n))),[1,n.length]);// batched
if(n.some(r=>r.length!==n[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",BigInt64Array.from(n.flat().map(n=>BigInt(n))),[n.length,n[0].length])}/**
 * Prepares an attention mask for a sequence of tokens based on configuration options.
 * @param {Object} self The calling object instance.
 * @param {Tensor} tokens The input tokens.
 * @returns {Tensor} The attention mask tensor.
 * @private
 */function $16c3c01c3acb118d$var$prepareAttentionMask(n,r){// Prepare attention mask
let i=n.config.pad_token_id??null,a=n.config.eos_token_id??null;$2a81087eb92e3db1$export$47ed7831511ab4cd(a)&&(a=[a]);let s=-1!==r.indexOf(i),o=null===a||!a.includes(i);if(!s||!o)return new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",new BigInt64Array(r.data.length).fill(1n),r.dims);{let n=BigInt64Array.from(r.data.map(n=>n!=i));return new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",n,r.dims)}}/**
 * Creates a boolean tensor with a single value.
 * @param {boolean} value The value of the tensor.
 * @returns {Tensor} The boolean tensor.
 * @private
 */function $16c3c01c3acb118d$var$boolTensor(n){return new $970f59cad5f0fd6a$export$7b6b8d90402f8814("bool",[n],[1])}// JS doesn't support mixins, so we define some reused functions here, and allow "this" to be passed in
/**
 * Perform forward pass on the seq2seq model (both encoder and decoder).
 * @param {Object} self The seq2seq model object.
 * @param {Object} model_inputs The input object for the model containing encoder and decoder inputs.
 * @returns {Promise<Seq2SeqLMOutput>} Promise that resolves with the output of the seq2seq model.
 * @private
 */async function $16c3c01c3acb118d$var$seq2seqForward(n,r){let i=n.add_decoder_pkv??!0,{encoder_outputs:a,past_key_values:s}=r;a||(a=(await $16c3c01c3acb118d$var$encoderForward(n,r)).last_hidden_state);let o={input_ids:r.decoder_input_ids,encoder_hidden_states:a,use_cache_branch:$16c3c01c3acb118d$var$boolTensor(!!s)};n.decoder_merged_session.inputNames.includes("encoder_attention_mask")&&(o.encoder_attention_mask=r.attention_mask),n.addPastKeyValues(o,s,i);let l=await $16c3c01c3acb118d$var$sessionRun(n.decoder_merged_session,o),u=l.logits;s=n.getPastKeyValues(l,s);// Get cross attention and/or decoder attentions if they are present
let c=n.getAttentions(l);return new $16c3c01c3acb118d$export$b8379c304ac703bb({logits:u,past_key_values:s,encoder_outputs:a,...c})}/**
 * Start the beam search process for the seq2seq model.
 * @param {PreTrainedModel} self The seq2seq model object.
 * @param {Object[]} inputTokenIds Array of input token ids for each input sequence.
 * @param {number} numOutputTokens The maximum number of output tokens for the model.
 * @returns {Object[]} Array of beam search objects.
 * @private
 */function $16c3c01c3acb118d$var$seq2seqStartBeams(n,r,i){let a=[],s=0,o=n.requires_attention_mask??!0,l=n.config.decoder_start_token_id;for(let i of(Array.isArray(l)||(l=[l]),r)){// TODO: Improve
// Currently, just add back batch dimension.
// In future, allow for true parallel execution
i.dims=[1,...i.dims];// Create beam
let r={inputs:i,encoder_outputs:null,prev_model_outputs:null,output_token_ids:l,done:!1,score:0,id:s++// assign unique id to beams
};o&&(r.attention_mask=$16c3c01c3acb118d$var$prepareAttentionMask(n,i)),a.push(r)}return a}/**
 * Run beam search on the seq2seq model for a single beam.
 * @param {PreTrainedModel} self The seq2seq model object.
 * @param {Object} beam The beam search object for which to run the model.
 * @param {Object} options options
 * @param {string} [options.input_name='input_ids'] The name of the input tensor for the encoder.
 * @returns {Promise<Object>} Promise that resolves with the output of the seq2seq model for the given beam.
 * @private
 */async function $16c3c01c3acb118d$var$seq2seqRunBeam(n,r){let i=n.main_input_name,a={[i]:r.inputs,decoder_input_ids:$16c3c01c3acb118d$var$toI64Tensor(r.output_token_ids.slice(-1)),encoder_outputs:r.encoder_outputs,past_key_values:r.prev_model_outputs?.past_key_values};r.attention_mask&&(a.attention_mask=r.attention_mask);// 2. Run
let s=await n.forward(a);return(// 3. Update
r.prev_model_outputs=s,r.encoder_outputs=s.encoder_outputs,s)}/**
 * Update a beam with a new token ID.
 * @param {Object} beam The beam to update.
 * @param {number} newTokenId The new token ID to add to the beam's output.
 * @private
 */function $16c3c01c3acb118d$var$seq2seqUpdatebeam(n,r){n.output_token_ids=[...n.output_token_ids,r]}/**
 * Forward pass of an encoder model.
 * @param {Object} self The encoder model.
 * @param {Object} model_inputs The input data to be used for the forward pass.
 * @returns {Promise<Object>} Promise that resolves with an object containing the model's outputs.
 * @private
 */async function $16c3c01c3acb118d$var$encoderForward(n,r){let i={};for(let a of n.session.inputNames)i[a]=r[a];return await $16c3c01c3acb118d$var$sessionRun(n.session,i)}/**
 * Forward pass of a decoder model.
 * @param {Object} self The decoder model.
 * @param {Object} model_inputs The input data to be used for the forward pass.
 * @returns {Promise<Object>} Promise that resolves with an object containing the logits and past key values.
 * @private
 */async function $16c3c01c3acb118d$var$decoderForward(n,r){let{input_ids:i,past_key_values:a,attention_mask:s}=r,o={input_ids:i,attention_mask:s??$16c3c01c3acb118d$var$prepareAttentionMask(n,i),use_cache_branch:$16c3c01c3acb118d$var$boolTensor(!!a)};n.addPastKeyValues(o,a);let l=await $16c3c01c3acb118d$var$sessionRun(n.session,o);return{logits:l.logits,past_key_values:a=n.getPastKeyValues(l,a)}}/**
 * Starts the generation of text by initializing the beams for the given input token IDs.
 * @param {Object} self The text generation model object.
 * @param {any} inputTokenIds An array of input token IDs to generate text from.
 * @param {number} numOutputTokens The maximum number of tokens to generate for each beam.
 * @param {Tensor} [inputs_attention_mask] The attention mask tensor for the input token IDs.
 * @returns {Object[]} An array of beams initialized with the given inputs and parameters.
 * @private
 */function $16c3c01c3acb118d$var$decoderStartBeams(n,r,i,a){let s=[],o=0;for(let l of r){let r,u=l.tolist().map(Number);// TODO: Improve
// Currently, just add back batch dimension.
// In future, allow for true parallel execution
l.dims=[1,...l.dims],a?(r=a[o]).dims=[1,...r.dims]:r=$16c3c01c3acb118d$var$prepareAttentionMask(n,l);let c={input:l,model_input_ids:l,attention_mask:r,prev_model_outputs:null,output_token_ids:u,num_output_tokens:i,done:!1,score:0,id:o++// assign unique id to beams
};s.push(c)}return s}/**
 * Runs a single step of the text generation process for a given beam.
 *
 * @param {Object} self The decoder object.
 * @param {Object} beam The beam to run.
 * @param {Tensor} beam.input The input tensor.
 * @param {Tensor} beam.model_input_ids The input ids to the model.
 * @param {Tensor} beam.attention_mask The attention mask.
 * @param {Object} beam.prev_model_outputs The past key values.
 * @param {number[]} beam.output_token_ids The output token ids.
 * @returns {Promise<Object>} The output of the generation step.
 * @private
 */async function $16c3c01c3acb118d$var$decoderRunBeam(n,r){let i=new BigInt64Array(r.output_token_ids.length).fill(1n),a={input_ids:r.model_input_ids,attention_mask:new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",i,[1,i.length]),past_key_values:r.prev_model_outputs?.past_key_values},s=await n.forward(a);return(// 3. Update
r.prev_model_outputs=s,s)}/**
 * Update a beam with a new token ID.
 * @param {Object} beam The beam to update.
 * @param {number} newTokenId The new token ID to add to the beam's output.
 * @private
 */function $16c3c01c3acb118d$var$decoderUpdatebeam(n,r){n.output_token_ids=[...n.output_token_ids,r],n.model_input_ids=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",[BigInt(r)],[1,1])}class $16c3c01c3acb118d$export$13e52fe1ef3065ca extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{main_input_name="input_ids";/**
     * Creates a new instance of the `PreTrainedModel` class.
     * @param {Object} config The model configuration.
     * @param {any} session session for the model.
     */constructor(n,r){super(),this.config=n,this.session=r;let i=$16c3c01c3acb118d$var$MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor),a=$16c3c01c3acb118d$var$MODEL_TYPE_MAPPING.get(i);this.can_generate=!1,this._runBeam=null,this._getStartBeams=null,this._updateBeam=null,this._forward=null,a===$16c3c01c3acb118d$var$MODEL_TYPES.DecoderOnly?(this.can_generate=!0,this._runBeam=$16c3c01c3acb118d$var$decoderRunBeam,this._getStartBeams=$16c3c01c3acb118d$var$decoderStartBeams,this._updateBeam=$16c3c01c3acb118d$var$decoderUpdatebeam,this._forward=$16c3c01c3acb118d$var$decoderForward):a===$16c3c01c3acb118d$var$MODEL_TYPES.Seq2Seq||a===$16c3c01c3acb118d$var$MODEL_TYPES.Vision2Seq?(this.can_generate=!0,this._runBeam=$16c3c01c3acb118d$var$seq2seqRunBeam,this._getStartBeams=$16c3c01c3acb118d$var$seq2seqStartBeams,this._updateBeam=$16c3c01c3acb118d$var$seq2seqUpdatebeam,this._forward=$16c3c01c3acb118d$var$seq2seqForward):($16c3c01c3acb118d$var$MODEL_TYPES.EncoderDecoder,this._forward=$16c3c01c3acb118d$var$encoderForward)}/**
    * Disposes of all the ONNX sessions that were created during inference.
    * @returns {Promise<unknown[]>} An array of promises, one for each ONNX session that is being disposed.
    * @todo Use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry
    */async dispose(){let n=[];for(let r of Object.keys(this)){let i=this[r];i instanceof $16c3c01c3acb118d$var$InferenceSession&&n.push(i.handler.dispose())}return await Promise.all(n)}/**
     * Instantiate one of the model classes of the library from a pretrained model.
     * 
     * The model class to instantiate is selected based on the `model_type` property of the config object
     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)
     * 
     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:
     * - A string, the *model id* of a pretrained model hosted inside a model repo on huggingface.co.
     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a
     *   user or organization name, like `dbmdz/bert-base-german-cased`.
     * - A path to a *directory* containing model weights, e.g., `./my_model_directory/`.
     * @param {PretrainedOptions} options Additional options for loading the model.
     * 
     * @returns {Promise<PreTrainedModel>} A new instance of the `PreTrainedModel` class.
     */static async from_pretrained(n,{quantized:r=!0,progress_callback:i=null,config:a=null,cache_dir:s=null,local_files_only:o=!1,revision:l="main",model_file_name:u=null}={}){let c,h={quantized:r,progress_callback:i,config:a,cache_dir:s,local_files_only:o,revision:l,model_file_name:u},d=$16c3c01c3acb118d$var$MODEL_CLASS_TO_NAME_MAPPING.get(this),p=$16c3c01c3acb118d$var$MODEL_TYPE_MAPPING.get(d);// @ts-ignore
return p===$16c3c01c3acb118d$var$MODEL_TYPES.DecoderOnly?c=await Promise.all([$d0feda9c43436cc0$export$774ba61eeb9f6e8.from_pretrained(n,h),$16c3c01c3acb118d$var$constructSession(n,h.model_file_name??"decoder_model_merged",h),$fb1f2fa9752dcff4$export$bdb2295ec9595824(n,"generation_config.json",!1,h)]):p===$16c3c01c3acb118d$var$MODEL_TYPES.Seq2Seq||p===$16c3c01c3acb118d$var$MODEL_TYPES.Vision2Seq?c=await Promise.all([$d0feda9c43436cc0$export$774ba61eeb9f6e8.from_pretrained(n,h),$16c3c01c3acb118d$var$constructSession(n,"encoder_model",h),$16c3c01c3acb118d$var$constructSession(n,"decoder_model_merged",h),$fb1f2fa9752dcff4$export$bdb2295ec9595824(n,"generation_config.json",!1,h)]):p===$16c3c01c3acb118d$var$MODEL_TYPES.EncoderDecoder?c=await Promise.all([$d0feda9c43436cc0$export$774ba61eeb9f6e8.from_pretrained(n,h),$16c3c01c3acb118d$var$constructSession(n,"encoder_model",h),$16c3c01c3acb118d$var$constructSession(n,"decoder_model_merged",h)]):(p!==$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly&&console.warn(`Model type for '${d}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`),c=await Promise.all([$d0feda9c43436cc0$export$774ba61eeb9f6e8.from_pretrained(n,h),$16c3c01c3acb118d$var$constructSession(n,h.model_file_name??"model",h)])),new this(...c)}/**
     * Runs the model with the provided inputs
     * @param {Object} model_inputs Object containing input tensors
     * @returns {Promise<Object>} Object containing output tensors
     */async _call(n){return await this.forward(n)}/**
     * Forward method for a pretrained model. If not overridden by a subclass, the correct forward method
     * will be chosen based on the model type.
     * @param {Object} model_inputs The input data to the model in the format specified in the ONNX model.
     * @returns {Promise<Object>} The output data from the model in the format specified in the ONNX model.
     * @throws {Error} This method must be implemented in subclasses.
     */async forward(n){return await this._forward(this,n)}/**
     * @param {GenerationConfig} generation_config 
     * @param {number} input_ids_seq_length The starting sequence length for the input ids.
     * @returns {LogitsProcessorList}
     * @private
     */_get_logits_processor(n,r,// prefix_allowed_tokens_fn, TODO
i=null){let a=new $61e4fb922b7bb9b4$export$f89551bc91e7a8bf;// if (generation_config.remove_invalid_values === true) {
//     processors.push(new InfNanRemoveLogitsProcessor());
// }
// if (generation_config.exponential_decay_length_penalty !== null) {
//     processors.push(new ExponentialDecayLengthPenalty(
//         generation_config.exponential_decay_length_penalty,
//         generation_config.eos_token_id,
//         input_ids_seq_length
//     ));
// }
// if (generation_config.suppress_tokens !== null) {
//     processors.push(new SuppressTokensLogitsProcessor(generation_config.suppress_tokens));
// }
if(null!==n.repetition_penalty&&1!==n.repetition_penalty&&a.push(new $61e4fb922b7bb9b4$export$a8a272be4e45be99(n.repetition_penalty)),null!==n.no_repeat_ngram_size&&n.no_repeat_ngram_size>0&&a.push(new $61e4fb922b7bb9b4$export$84e434bdb5aa3973(n.no_repeat_ngram_size)),null!==n.min_length&&null!==n.eos_token_id&&n.min_length>0&&a.push(new $61e4fb922b7bb9b4$export$4a9075b060f88b7f(n.min_length,n.eos_token_id)),null!==n.min_new_tokens&&null!==n.eos_token_id&&n.min_new_tokens>0&&a.push(new $61e4fb922b7bb9b4$export$64f19ec0905c9acf(r,n.min_new_tokens,n.eos_token_id)),null!==n.forced_bos_token_id&&a.push(new $61e4fb922b7bb9b4$export$ca2ca37265a40c2f(n.forced_bos_token_id)),null!==n.forced_eos_token_id&&a.push(new $61e4fb922b7bb9b4$export$64e4adbc163422bb(n.max_length,n.forced_eos_token_id)),null!==n.begin_suppress_tokens){let i=r>1||null===n.forced_bos_token_id?r:r+1;null!==n.forced_decoder_ids&&(i+=n.forced_decoder_ids[n.forced_decoder_ids.length-1][0]),a.push(new $61e4fb922b7bb9b4$export$c1e2265678aded42(n.begin_suppress_tokens,i))}// `LogitNormalization` should always be the last logit processor, when present
// if (generation_config.renormalize_logits === true) {
//     processors.push(new LogitNormalization());
// }
return null!==n.forced_decoder_ids&&a.push(new $61e4fb922b7bb9b4$export$2248f8e9679e34ce(n.forced_decoder_ids)),null!==i&&a.extend(i),a}/**
     * This function merges multiple generation configs together to form a final generation config to be used by the model for text generation.
     * It first creates an empty `GenerationConfig` object, then it applies the model's own `generation_config` property to it. Finally, if a `generation_config` object was passed in the arguments, it overwrites the corresponding properties in the final config with those of the passed config object.
     *
     * @param {GenerationConfig} generation_config A `GenerationConfig` object containing generation parameters.
     * @returns {GenerationConfig} The final generation config object to be used by the model for text generation.
     */_get_generation_config(n){// Create empty generation config (contains defaults)
// We pass `this.config` so that if `eos_token_id` or `bos_token_id` exist in the model's config, we will use them
let r=new $61e4fb922b7bb9b4$export$be173e4c0d82d4ec(this.config);return"generation_config"in this&&Object.assign(r,this.generation_config),null!==n&&Object.assign(r,n),r}/**
     * @typedef {import('./utils/maths.js').TypedArray} TypedArray
     *//**
     * @typedef {{ sequences: Tensor, decoder_attentions: Tensor, cross_attentions: Tensor }} EncoderDecoderOutput
     * @typedef {Object} DecoderOutput
     * 
     * Generates text based on the given inputs and generation configuration using the model.
     * @param {Tensor|Array|TypedArray} inputs An array of input token IDs.
     * @param {Object|GenerationConfig|null} generation_config The generation configuration to use. If null, default configuration will be used.
     * @param {Object|null} logits_processor An optional logits processor to use. If null, a new LogitsProcessorList instance will be created.
     * @param {Object} options options
     * @param {Object} [options.inputs_attention_mask=null] An optional attention mask for the inputs.
     * @returns {Promise<number[][]|EncoderDecoderOutput|DecoderOutput>} An array of generated output sequences, where each sequence is an array of token IDs.
     * @throws {Error} Throws an error if the inputs array is empty.
     */async generate(n,r=null,i=null,{inputs_attention_mask:a=null}={}){let s;if(!this.can_generate){let n=$16c3c01c3acb118d$var$MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor),r=`The current model class (${n}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`,i=this.config.model_type,a=$16c3c01c3acb118d$var$MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(i)??$16c3c01c3acb118d$var$MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES.get(i)??$16c3c01c3acb118d$var$MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES.get(i);throw a&&(r+=` Please use the following class instead: '${a[0]}'`),Error(r)}if(!(n instanceof $970f59cad5f0fd6a$export$7b6b8d90402f8814)&&!$2a81087eb92e3db1$export$b119cc7e1840e59c(n)&&!Array.isArray(n))throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${n.constructor.name}".`);// Prepare `input_ids` which will be used for auto-regressive generation
// TODO: Update to align with HF transformers' implementation
if(this.config.is_encoder_decoder)s=0;else // decoder-only
if(0===(s=n instanceof $970f59cad5f0fd6a$export$7b6b8d90402f8814?n.dims.at(-1):n.length))throw Error("Must supply a non-empty array of input token ids.");// Update generation config with defaults
r=this._get_generation_config(r),i=i??new $61e4fb922b7bb9b4$export$f89551bc91e7a8bf,// Update logits processor
i=this._get_logits_processor(r,s,i);/** @type {number[]} */let o=r.eos_token_id;null===o||Array.isArray(o)||(o=[o]);// TODO implement early_stopping
// https://huggingface.co/blog/how-to-generate
let l=1,u=l+(r.max_new_tokens??1/0),c=Number.isInteger(r.max_length)&&(r.max_new_tokens??null)===null,h=$61e4fb922b7bb9b4$export$322f102bec719b22.getSampler(r),d=this.getStartBeams(n,l,a);for(;d.some(n=>!n.done)&&l<u;){let n=[];for(let a of d){if(a.done){// Add this beam back into the pool
n.push(a);continue}if(c&&a.output_token_ids.length>=r.max_length){// Set this beam to done and add it back into the pool
a.done=!0,n.push(a);continue}// @ts-ignore
let s=await this.runBeam(a);r.output_attentions&&this.addAttentionsToBeam(a,s),r.output_scores;// Logits are of the form [batch_size, out_seq_length, vocab_size]
// In most cases, this will be [batch_size, 1, vocab_size]
// So, we select the last token's logits:
// (equivalent to `logits = outputs.logits[:, -1, :]`)
let l=s.logits.slice(null,-1,null);for(let[r,s]of(// Apply logits processor
i(a.output_token_ids,l),h(l))){// use previous beam as a starting point
let i={...a};// update new beam
// @ts-ignore
this.updateBeam(i,r),i.score+=s,o&&o.includes(r)&&(i.done=!0),n.push(i)}}++l,// Flatten beams
d=// Next, we get the best beams, per ID
(n=this.groupBeams(n).map(n=>n.sort((n,r)=>r.score-n.score)// sort by score
    .slice(0,r.num_beams)// remove outside beam width
)).flat(),r.callback_function&&r.callback_function(d)}// TODO: Ensure that we can return non-batched outputs
let p=this.groupBeams(d),f=n=>p.map(i=>r.num_return_sequences>1?i.slice(0,r.num_return_sequences).map(r=>r[n]):[i[0][n]]).flat(),m=f("output_token_ids");if(!r.return_dict_in_generate)return m;{// NOTE: `decoder_attentions` and `cross_attentions` should be:
//    list (one element for each generated token)
//    of list (one element for each layer of the decoder)
//    of torch.FloatTensor of shape (batch_size, num_heads, generated_length, sequence_length)
// However, since we are only generating one batch at a time, they are of the form:
//   list (batches)
//   of list (one element for each generated token)
//   of list (one element for each layer of the decoder)
//   of torch.FloatTensor of shape (1, num_heads, generated_length, sequence_length)
// 
// TODO: In future (when true parallelism, we should be able to return the correct shape)
let n=f("decoder_attentions"),r=f("cross_attentions");return{sequences:m,decoder_attentions:n,cross_attentions:r}}}/**
     * Helper function to add attentions to beam
     * @param {Object} beam 
     * @param {Object} output
     * @private 
     */addAttentionsToBeam(n,r){if(this.config.is_encoder_decoder){if(!r.cross_attentions||0===r.cross_attentions.length)throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");n.cross_attentions||(n.cross_attentions=[]),n.cross_attentions.push(r.cross_attentions)}if(!r.decoder_attentions||0===r.decoder_attentions.length)throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");n.decoder_attentions||(n.decoder_attentions=[]),n.decoder_attentions.push(r.decoder_attentions)}/**
     * Groups an array of beam objects by their ids.
     *
     * @param {Array} beams The array of beam objects to group.
     * @returns {Array} An array of arrays, where each inner array contains beam objects with the same id.
     */groupBeams(n){// Group beams by their ids
let r=Object.create(null);for(let i of n)void 0===r[i.id]?r[i.id]=[i]:r[i.id].push(i);return Object.values(r)}/**
     * Returns an object containing past key values from the given decoder results object.
     *
     * @param {Object} decoderResults The decoder results object.
     * @param {Object} pastKeyValues The previous past key values.
     * @returns {Object} An object containing past key values.
     */getPastKeyValues(n,r){let i=Object.create(null);for(let a in n)if(a.startsWith("present")){let s=a.replace("present","past_key_values");r&&a.includes("encoder")?// outputs with the previous past key values.
// https://github.com/huggingface/optimum/blob/0bf2c05fb7e1182b52d21b703cfc95fd9e4ea3dc/optimum/onnxruntime/base.py#L677-L704
i[s]=r[s]:i[s]=n[a]}return i}/**
     * Returns an object containing attentions from the given decoder results object.
     *
     * @param {Object} decoderResults The decoder results object.
     * @returns {Object} An object containing attentions.
     */getAttentions(n){let r=Object.create(null);for(let i of["cross_attentions","decoder_attentions"]){let a=[];for(let r in n)if(r.startsWith(i)){let i=r.split(".").pop();a[i]=n[r]}r[i]=a}return r}/**
     * Adds past key values to the decoder feeds object. If pastKeyValues is null, creates new tensors for past key values.
     *
     * @param {Object} decoderFeeds The decoder feeds object to add past key values to.
     * @param {Object} pastKeyValues An object containing past key values.
     * @param {boolean} [hasDecoder=false] Whether the model has a decoder.
     */addPastKeyValues(n,r,i=!1){if(r)Object.assign(n,r);else if(i){// @ts-ignore
let r=[1,this.num_encoder_heads,0,this.encoder_dim_kv];// @ts-ignore
for(let i=0;i<this.num_encoder_layers;++i)n[`past_key_values.${i}.encoder.key`]=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",[],r),n[`past_key_values.${i}.encoder.value`]=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",[],r);// @ts-ignore
let i=[1,this.num_decoder_heads,0,this.decoder_dim_kv];// @ts-ignore
for(let r=0;r<this.num_decoder_layers;++r)n[`past_key_values.${r}.decoder.key`]=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",[],i),n[`past_key_values.${r}.decoder.value`]=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",[],i)}else if(this.config.multi_query){// @ts-ignore
let r=[1,0,2*this.dim_kv];// @ts-ignore
for(let i=0;i<this.num_layers;++i)n[`past_key_values.${i}.key_value`]=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",[],r)}else if("bloom"===this.config.model_type){// Custom implementation for Bloom
// @ts-ignore
let r=[1*this.num_heads,this.dim_kv,0]// [batch_size x num_heads,64,past_sequence_length]
,i=[1*this.num_heads,0,this.dim_kv]// [batch_size x num_heads,past_sequence_length,64]
;// @ts-ignore
for(let a=0;a<this.num_layers;++a)n[`past_key_values.${a}.key`]=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",[],r),n[`past_key_values.${a}.value`]=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",[],i)}else{// @ts-ignore
let r=[1,this.num_heads,0,this.dim_kv];// @ts-ignore
for(let i=0;i<this.num_layers;++i)n[`past_key_values.${i}.key`]=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",[],r),n[`past_key_values.${i}.value`]=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",[],r)}}/**
     * Initializes and returns the beam for text generation task
     * @param {Tensor} inputTokenIds The input token ids.
     * @param {number} numOutputTokens The number of tokens to be generated.
     * @param {Tensor} inputs_attention_mask Optional input attention mask.
     * @returns {any} A Beam object representing the initialized beam.
     * @private
     */getStartBeams(n,r,i){return this._getStartBeams(this,n,r,i)}/**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     * @private
     */async runBeam(n){return await this._runBeam(this,n)}/**
     * Update a beam with a new token ID.
     * @param {Object} beam The beam to update.
     * @param {number} newTokenId The new token ID to add to the beam's output.
     * @private
     */updateBeam(n,r){return this._updateBeam(n,r)}}class $16c3c01c3acb118d$export$58ceee390f0aa3e7{}class $16c3c01c3acb118d$export$fc9fb9059313a8d0 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$50d26602687925fb extends $16c3c01c3acb118d$export$fc9fb9059313a8d0{}class $16c3c01c3acb118d$export$adb6944686c9f054 extends $16c3c01c3acb118d$export$fc9fb9059313a8d0{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$2e07b9082029c653 extends $16c3c01c3acb118d$export$fc9fb9059313a8d0{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$cbcac39eef7ced85 extends $16c3c01c3acb118d$export$fc9fb9059313a8d0{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */async _call(n){return new $16c3c01c3acb118d$export$91b98ca4a8106cfb(await super._call(n))}}class $16c3c01c3acb118d$export$dcda5cb55325c8d9 extends $16c3c01c3acb118d$export$fc9fb9059313a8d0{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$e949353ad48578e0 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$108a48c7f7eacf2c extends $16c3c01c3acb118d$export$e949353ad48578e0{}class $16c3c01c3acb118d$export$616d4353f8f8850a extends $16c3c01c3acb118d$export$e949353ad48578e0{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$c067b10486a01f43 extends $16c3c01c3acb118d$export$e949353ad48578e0{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$12326a9609fa28fa extends $16c3c01c3acb118d$export$e949353ad48578e0{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */async _call(n){return new $16c3c01c3acb118d$export$91b98ca4a8106cfb(await super._call(n))}}class $16c3c01c3acb118d$export$55fbace81d2ba5c1 extends $16c3c01c3acb118d$export$e949353ad48578e0{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$6a28443d00fd8166 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$281c92ea51c11a65 extends $16c3c01c3acb118d$export$6a28443d00fd8166{}class $16c3c01c3acb118d$export$1a5d8309ea04aa49 extends $16c3c01c3acb118d$export$6a28443d00fd8166{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$9a103a267172fbc4 extends $16c3c01c3acb118d$export$6a28443d00fd8166{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$44c9db9aa4387473 extends $16c3c01c3acb118d$export$6a28443d00fd8166{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */async _call(n){return new $16c3c01c3acb118d$export$91b98ca4a8106cfb(await super._call(n))}}class $16c3c01c3acb118d$export$f0f2cda3db1d7204 extends $16c3c01c3acb118d$export$6a28443d00fd8166{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$24ee206bc24b07a3 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$e6dcb08950625725 extends $16c3c01c3acb118d$export$24ee206bc24b07a3{}class $16c3c01c3acb118d$export$cd2e138af46480a2 extends $16c3c01c3acb118d$export$24ee206bc24b07a3{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$1ed212aa166595ca extends $16c3c01c3acb118d$export$24ee206bc24b07a3{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$4bba9d70b65586e0 extends $16c3c01c3acb118d$export$24ee206bc24b07a3{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */async _call(n){return new $16c3c01c3acb118d$export$91b98ca4a8106cfb(await super._call(n))}}class $16c3c01c3acb118d$export$a22ac5b62929568a extends $16c3c01c3acb118d$export$24ee206bc24b07a3{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$985ce2a4e02ec388 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$3cbbba98374fa579 extends $16c3c01c3acb118d$export$985ce2a4e02ec388{}class $16c3c01c3acb118d$export$e230dcc6fd271ac7 extends $16c3c01c3acb118d$export$985ce2a4e02ec388{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$58af094f1150618e extends $16c3c01c3acb118d$export$985ce2a4e02ec388{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */async _call(n){return new $16c3c01c3acb118d$export$91b98ca4a8106cfb(await super._call(n))}}class $16c3c01c3acb118d$export$5e621b9500c77df3 extends $16c3c01c3acb118d$export$985ce2a4e02ec388{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$c294fec67de0e8c8 extends $16c3c01c3acb118d$export$985ce2a4e02ec388{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$b640f1c9d68fb817 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$f5f0cbdf9fb64558 extends $16c3c01c3acb118d$export$b640f1c9d68fb817{}class $16c3c01c3acb118d$export$864591201f039978 extends $16c3c01c3acb118d$export$b640f1c9d68fb817{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$bea32095ba959e6e extends $16c3c01c3acb118d$export$b640f1c9d68fb817{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$7c8b5a948d525f24 extends $16c3c01c3acb118d$export$b640f1c9d68fb817{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$7966734afbe14711 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$eb1c54902dbeeeb6 extends $16c3c01c3acb118d$export$7966734afbe14711{}class $16c3c01c3acb118d$export$728981f6c2b2f8c3 extends $16c3c01c3acb118d$export$7966734afbe14711{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$5243d11e2a59b18 extends $16c3c01c3acb118d$export$7966734afbe14711{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$1457e614d4dba781 extends $16c3c01c3acb118d$export$7966734afbe14711{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */async _call(n){return new $16c3c01c3acb118d$export$91b98ca4a8106cfb(await super._call(n))}}class $16c3c01c3acb118d$export$85b9f959452f122b extends $16c3c01c3acb118d$export$7966734afbe14711{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$71d4926abb7f03eb extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$680dbbf29f7a337c extends $16c3c01c3acb118d$export$71d4926abb7f03eb{}class $16c3c01c3acb118d$export$5cc0106d2c05335b extends $16c3c01c3acb118d$export$71d4926abb7f03eb{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$f43496fe547d0f7e extends $16c3c01c3acb118d$export$71d4926abb7f03eb{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$ac848ea3ecbdb5a0 extends $16c3c01c3acb118d$export$71d4926abb7f03eb{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$ef3a3e0bdb989646 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$36bd0eb31e80f9e2 extends $16c3c01c3acb118d$export$ef3a3e0bdb989646{}class $16c3c01c3acb118d$export$1bf0a3507fa7e0b8 extends $16c3c01c3acb118d$export$ef3a3e0bdb989646{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$ccc15aa3448e0ef8 extends $16c3c01c3acb118d$export$ef3a3e0bdb989646{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$780187a73886f6b0 extends $16c3c01c3acb118d$export$ef3a3e0bdb989646{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$a8d8acfc1f06b029 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$101f7292b9f7db90 extends $16c3c01c3acb118d$export$a8d8acfc1f06b029{}class $16c3c01c3acb118d$export$12670a13d0db4f5d extends $16c3c01c3acb118d$export$a8d8acfc1f06b029{/**
     * Creates a new instance of the `T5ForConditionalGeneration` class.
     * @param {Object} config The model configuration.
     * @param {any} session session for the model.
     * @param {any} decoder_merged_session session for the decoder.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i,a){super(n,r),this.decoder_merged_session=i,this.generation_config=a,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class $16c3c01c3acb118d$export$f168bdb74f182466 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$2c2aab1e578145a1 extends $16c3c01c3acb118d$export$f168bdb74f182466{}class $16c3c01c3acb118d$export$9c357e7bf6c3bbc0 extends $16c3c01c3acb118d$export$f168bdb74f182466{/**
     * Creates a new instance of the `MT5ForConditionalGeneration` class.
     * @param {any} config The model configuration.
     * @param {any} session The ONNX session containing the encoder weights.
     * @param {any} decoder_merged_session The ONNX session containing the merged decoder weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i,a){super(n,r),this.decoder_merged_session=i,this.generation_config=a,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}}class $16c3c01c3acb118d$export$cb2f9dec15cabcd4 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$6dc0871b6b23f02c extends $16c3c01c3acb118d$export$cb2f9dec15cabcd4{}class $16c3c01c3acb118d$export$81a4719e629f1e9c extends $16c3c01c3acb118d$export$cb2f9dec15cabcd4{/**
     * Creates a new instance of the `BartForConditionalGeneration` class.
     * @param {Object} config The configuration object for the Bart model.
     * @param {Object} session The ONNX session used to execute the model.
     * @param {Object} decoder_merged_session The ONNX session used to execute the decoder.
     * @param {Object} generation_config The generation configuration object.
     */constructor(n,r,i,a){super(n,r),this.decoder_merged_session=i,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class $16c3c01c3acb118d$export$ed7bb28547c7d7e8 extends $16c3c01c3acb118d$export$cb2f9dec15cabcd4{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$ff39497e829e655b extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$658ebdbbcb19839f extends $16c3c01c3acb118d$export$ff39497e829e655b{}class $16c3c01c3acb118d$export$82c8c60a52b00127 extends $16c3c01c3acb118d$export$ff39497e829e655b{/**
     * Creates a new instance of the `MBartForConditionalGeneration` class.
     * @param {Object} config The configuration object for the Bart model.
     * @param {Object} session The ONNX session used to execute the model.
     * @param {Object} decoder_merged_session The ONNX session used to execute the decoder.
     * @param {Object} generation_config The generation configuration object.
     */constructor(n,r,i,a){super(n,r),this.decoder_merged_session=i,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}}class $16c3c01c3acb118d$export$9c70230cc724a590 extends $16c3c01c3acb118d$export$ff39497e829e655b{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$e99fe74c19e61cde extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$d91085650dc57f0e extends $16c3c01c3acb118d$export$e99fe74c19e61cde{}class $16c3c01c3acb118d$export$e4184c6fee46303f extends $16c3c01c3acb118d$export$e99fe74c19e61cde{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$251bfb6c3b9f95f7 extends $16c3c01c3acb118d$export$e99fe74c19e61cde{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$e77708316736df09 extends $16c3c01c3acb118d$export$e99fe74c19e61cde{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */async _call(n){return new $16c3c01c3acb118d$export$91b98ca4a8106cfb(await super._call(n))}}class $16c3c01c3acb118d$export$9a9ab2575fcc6baa extends $16c3c01c3acb118d$export$e99fe74c19e61cde{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$4d59fe3f09c5df7 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$4e990258938f2f51 extends $16c3c01c3acb118d$export$4d59fe3f09c5df7{}class $16c3c01c3acb118d$export$2f651cadd7fa9895 extends $16c3c01c3acb118d$export$4d59fe3f09c5df7{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$5e5abea0031c6572 extends $16c3c01c3acb118d$export$4d59fe3f09c5df7{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$71f287c5e42eae5 extends $16c3c01c3acb118d$export$4d59fe3f09c5df7{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */async _call(n){return new $16c3c01c3acb118d$export$91b98ca4a8106cfb(await super._call(n))}}class $16c3c01c3acb118d$export$bd711ce0e58ec451 extends $16c3c01c3acb118d$export$4d59fe3f09c5df7{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$a2215d93aa09bad5 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$f2ab68ddae296db6 extends $16c3c01c3acb118d$export$a2215d93aa09bad5{}class $16c3c01c3acb118d$export$f58e2f3f37b73bfa extends $16c3c01c3acb118d$export$a2215d93aa09bad5{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$be90aa37c12fd6ad(await super._call(n))}}class $16c3c01c3acb118d$export$1998bba773e1211 extends $16c3c01c3acb118d$export$a2215d93aa09bad5{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$7659b63d6857f5ea extends $16c3c01c3acb118d$export$a2215d93aa09bad5{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */async _call(n){return new $16c3c01c3acb118d$export$91b98ca4a8106cfb(await super._call(n))}}class $16c3c01c3acb118d$export$8d4b984adf730433 extends $16c3c01c3acb118d$export$a2215d93aa09bad5{/**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */async _call(n){return new $16c3c01c3acb118d$export$8d0bb3c3da84b5fe(await super._call(n))}}class $16c3c01c3acb118d$export$c81e78a46555fbf3 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$fd7a195762895f0 extends $16c3c01c3acb118d$export$c81e78a46555fbf3{}class $16c3c01c3acb118d$export$14659d9ec3a67109 extends $16c3c01c3acb118d$export$c81e78a46555fbf3{requires_attention_mask=!1;main_input_name="input_features";/**
     * Creates a new instance of the `WhisperForConditionalGeneration` class.
     * @param {Object} config Configuration object for the model.
     * @param {Object} session ONNX Session object for the model.
     * @param {Object} decoder_merged_session ONNX Session object for the decoder.
     * @param {Object} generation_config Configuration object for the generation process.
     */constructor(n,r,i,a){super(n,r),this.decoder_merged_session=i,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}/**
     * @typedef {Object} WhisperGenerationConfig
     * @extends GenerationConfig
     * @property {boolean} [return_timestamps=null] Whether to return the timestamps with the text. This enables the `WhisperTimestampsLogitsProcessor`.
     * @property {boolean} [return_token_timestamps=null] Whether to return token-level timestamps
     * with the text. This can be used with or without the `return_timestamps` option. To get word-level
     * timestamps, use the tokenizer to group the tokens into words.
     * @property {number} [num_frames=null]  The number of audio frames available in this chunk. This is only used generating word-level timestamps.
     *//**
     * Generates outputs based on input and generation configuration.
     * @param {Object} inputs Input data for the model.
     * @param {WhisperGenerationConfig} generation_config Configuration object for the generation process.
     * @param {Object} logits_processor Optional logits processor object.
     * @returns {Promise<Object>} Promise object represents the generated outputs.
     */async generate(n,r=null,i=null){if(// Create generation config object
r=this._get_generation_config(r),// Whisper has additional options for returning timestamps
r.return_timestamps??=!1,r.return_timestamps&&(i=[new $61e4fb922b7bb9b4$export$e1af0caf3e32b4e9(r)]),r.return_token_timestamps&&(r.output_attentions=!0,r.return_dict_in_generate=!0,"translate"===r.task&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),!r.alignment_heads))throw Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");let a=await super.generate(n,r,i);return r.return_token_timestamps&&r.alignment_heads&&(a.token_timestamps=this._extract_token_timestamps(a,r.alignment_heads,r.num_frames)),a}/**
     * Calculates token-level timestamps using the encoder-decoder cross-attentions and
     * dynamic time-warping (DTW) to map each output token to a position in the input audio.
     * @param {Object} generate_outputs Outputs generated by the model
     * @param {Tensor[][][]} generate_outputs.cross_attentions The cross attentions output by the model
     * @param {Tensor[][][]} generate_outputs.decoder_attentions The decoder attentions output by the model
     * @param {number[][]} generate_outputs.sequences The sequences output by the model
     * @param {number[][]} alignment_heads Alignment heads of the model
     * @param {number} [num_frames=null] Number of frames in the input audio.
     * @param {number} [time_precision=0.02] Precision of the timestamps in seconds
     * @returns {Tensor} tensor containing the timestamps in seconds for each predicted token
     */_extract_token_timestamps(n,r,i=null,a=.02){if(!n.cross_attentions)throw Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");let s=this.config.median_filter_width;void 0===s&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),s=7);let o=n.cross_attentions.map(n=>{// Create a list with `decoder_layers` elements, each a tensor of shape
// (batch size, attention_heads, output length, input length).
let a=Array.from({length:this.config.decoder_layers},(r,i)=>$970f59cad5f0fd6a$export$99aaa11fb71d263(n.map(n=>n[i]),2)),o=$970f59cad5f0fd6a$export$a57ab32f40f83ea9(r.map(([n,r])=>i?a[n].slice(null,r,null,[0,i]):a[n].slice(null,r))),[l,u]=$970f59cad5f0fd6a$export$a2ad268dbb52039d(o=o.transpose(1,0,2,3),-2,0,!0),c=o.clone();for(let n=0;n<c.dims[0];++n){let r=c[n];// [8, seqLength, 1500]
for(let i=0;i<r.dims[0];++i){let a=r[i],o=l[n][i][0],c=u[n][i][0];// [seqLength, 1500]
for(let n=0;n<a.dims[0];++n){let r=a[n];// [1500]
for(let n=0;n<r.data.length;++n)r.data[n]=(r.data[n]-c.data[n])/o.data[n];// Apply median filter.
r.data.set($821ef51da65e5775$export$26eccfba0731e2c4(r.data,s))}}}// Average the different cross-attention heads.
let h=$970f59cad5f0fd6a$export$1ce691f85baaa52(c,1);return h}),l=[n.sequences.length,n.sequences[0].length],u=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",new Float32Array(l[0]*l[1]),l);// Perform dynamic time warping on each element of the batch.
for(let n=0;n<l[0];++n){// NOTE: Since we run only one batch at a time, we can squeeze to get the same dimensions
// as the python implementation
let r=o[n].neg().squeeze_(0),[i,s]=$970f59cad5f0fd6a$export$65a9a636508fbc8d(r),l=$2a81087eb92e3db1$export$9826fe7ad3921016([1],Array.from({length:i.length-1},(n,r)=>i[r+1]-i[r])).map(n=>!!n),c=[];for(let n=0;n<l.length;++n)l[n]&&c.push(s[n]*a);u[n].data.set(c,1)}return u}}class $16c3c01c3acb118d$export$cc5a9e224842b44b extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{main_input_name="pixel_values";add_decoder_pkv=!1;/**
     * Creates a new instance of the `VisionEncoderDecoderModel` class.
     * @param {Object} config The configuration object specifying the hyperparameters and other model settings.
     * @param {Object} session The ONNX session containing the encoder model.
     * @param {any} decoder_merged_session The ONNX session containing the merged decoder model.
     * @param {Object} generation_config Configuration object for the generation process.
     */constructor(n,r,i,a){super(n,r),this.decoder_merged_session=i,this.generation_config=a,this.num_layers=this.config.decoder.n_layer,this.num_heads=this.config.decoder.n_head,this.dim_kv=this.config.decoder.n_embd/this.num_heads}}class $16c3c01c3acb118d$export$32ad7c7189014d85 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$12fe9439f561c98 extends $16c3c01c3acb118d$export$32ad7c7189014d85{}class $16c3c01c3acb118d$export$62655b6db5e46a62 extends $16c3c01c3acb118d$export$32ad7c7189014d85{/** @type {PreTrainedModel.from_pretrained} */static async from_pretrained(n,r={}){return(// Update default model file name if not provided
r.model_file_name??="text_model",super.from_pretrained(n,r))}}class $16c3c01c3acb118d$export$51616dd9ead7b60c extends $16c3c01c3acb118d$export$32ad7c7189014d85{/** @type {PreTrainedModel.from_pretrained} */static async from_pretrained(n,r={}){return(// Update default model file name if not provided
r.model_file_name??="vision_model",super.from_pretrained(n,r))}}class $16c3c01c3acb118d$export$918e02463b5bd956 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{/**
     * Creates a new instance of the `GPT2PreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i){super(n,r),this.generation_config=i,// config doesn't contain pad_token_id, so we assume it is the eos_token_id
this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class $16c3c01c3acb118d$export$5d50839baef5e65 extends $16c3c01c3acb118d$export$918e02463b5bd956{}class $16c3c01c3acb118d$export$fb0afd234c443cfb extends $16c3c01c3acb118d$export$918e02463b5bd956{}class $16c3c01c3acb118d$export$2cbf01681d81c304 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{/**
     * Creates a new instance of the `GPTNeoPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i){super(n,r),this.generation_config=i,// config doesn't contain pad_token_id, so we assume it is the eos_token_id
this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_heads,this.num_layers=this.config.num_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class $16c3c01c3acb118d$export$e93722bf71f70270 extends $16c3c01c3acb118d$export$2cbf01681d81c304{}class $16c3c01c3acb118d$export$a9d539ded7cb5eee extends $16c3c01c3acb118d$export$2cbf01681d81c304{}class $16c3c01c3acb118d$export$2e92b551c9018d50 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{/**
     * Creates a new instance of the `GPTNeoXPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i){super(n,r),this.generation_config=i,// config doesn't contain pad_token_id, so we assume it is the eos_token_id
this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class $16c3c01c3acb118d$export$60c531699d4680cb extends $16c3c01c3acb118d$export$2e92b551c9018d50{}class $16c3c01c3acb118d$export$fcf362cd2088f288 extends $16c3c01c3acb118d$export$2e92b551c9018d50{}class $16c3c01c3acb118d$export$ce2963f857c575ed extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{/**
     * Creates a new instance of the `GPTJPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i){super(n,r),this.generation_config=i,// config doesn't contain pad_token_id, so we assume it is the eos_token_id
this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class $16c3c01c3acb118d$export$d06d9186085aa042 extends $16c3c01c3acb118d$export$ce2963f857c575ed{}class $16c3c01c3acb118d$export$660f664770d31ae1 extends $16c3c01c3acb118d$export$ce2963f857c575ed{}class $16c3c01c3acb118d$export$3f1f10df2a16a017 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{/**
     * Creates a new instance of the `GPTBigCodePreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i){super(n,r),this.generation_config=i,// config doesn't contain pad_token_id, so we assume it is the eos_token_id
this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class $16c3c01c3acb118d$export$9e6e7feb639c4792 extends $16c3c01c3acb118d$export$3f1f10df2a16a017{}class $16c3c01c3acb118d$export$9e0f92330a5523a7 extends $16c3c01c3acb118d$export$3f1f10df2a16a017{}class $16c3c01c3acb118d$export$6ed665da3ec0db85 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{/**
     * Creates a new instance of the `CodeGenPreTrainedModel` class.
     * @param {Object} config The model configuration object.
     * @param {Object} session The ONNX session object.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i){super(n,r),this.generation_config=i,// config doesn't contain pad_token_id, so we assume it is the eos_token_id
this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class $16c3c01c3acb118d$export$92a7805edd7edb3f extends $16c3c01c3acb118d$export$6ed665da3ec0db85{}class $16c3c01c3acb118d$export$f6421463ca6ac59c extends $16c3c01c3acb118d$export$6ed665da3ec0db85{}class $16c3c01c3acb118d$export$1591fb339f62df4b extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{/**
     * Creates a new instance of the `LlamaPreTrainedModel` class.
     * @param {Object} config The model configuration object.
     * @param {Object} session The ONNX session object.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i){super(n,r),this.generation_config=i,// config doesn't contain pad_token_id, so we assume it is the eos_token_id
this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class $16c3c01c3acb118d$export$7e8f6ff658bef53a extends $16c3c01c3acb118d$export$1591fb339f62df4b{}class $16c3c01c3acb118d$export$d3481c3099e3a948 extends $16c3c01c3acb118d$export$1591fb339f62df4b{}class $16c3c01c3acb118d$export$e0ad8f464dc5ccca extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{/**
     * Creates a new instance of the `BloomPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i){super(n,r),this.generation_config=i,// config doesn't contain pad_token_id, so we assume it is the eos_token_id
this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.hidden_size/this.num_heads}}class $16c3c01c3acb118d$export$e18e51d1520fa1e4 extends $16c3c01c3acb118d$export$e0ad8f464dc5ccca{}class $16c3c01c3acb118d$export$db4605baef1ad703 extends $16c3c01c3acb118d$export$e0ad8f464dc5ccca{}class $16c3c01c3acb118d$export$69372f5c0829b847 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{/**
     * Creates a new instance of the `MptPreTrainedModel` class.
     * @param {Object} config The model configuration object.
     * @param {Object} session The ONNX session object.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i){super(n,r),this.generation_config=i,// config doesn't contain pad_token_id, so we assume it is the eos_token_id
this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_heads,this.num_layers=this.config.n_layers,this.dim_kv=this.config.d_model/this.num_heads}}class $16c3c01c3acb118d$export$d8053218a28ecd6b extends $16c3c01c3acb118d$export$69372f5c0829b847{}class $16c3c01c3acb118d$export$8adc2830e45c5d81 extends $16c3c01c3acb118d$export$69372f5c0829b847{}class $16c3c01c3acb118d$export$fe63781e15851d18 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{/**
     * Creates a new instance of the `OPTPreTrainedModel` class.
     * @param {Object} config The model configuration object.
     * @param {Object} session The ONNX session object.
     * @param {GenerationConfig} generation_config The generation configuration.
     */constructor(n,r,i){super(n,r),this.generation_config=i,// config doesn't contain pad_token_id, so we assume it is the eos_token_id
this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class $16c3c01c3acb118d$export$cf7ff954c787290a extends $16c3c01c3acb118d$export$fe63781e15851d18{}class $16c3c01c3acb118d$export$636b1f4e25c56a84 extends $16c3c01c3acb118d$export$fe63781e15851d18{}class $16c3c01c3acb118d$export$cce76330980c3e56 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$25ad685be53f99c3 extends $16c3c01c3acb118d$export$cce76330980c3e56{}class $16c3c01c3acb118d$export$8056898fd48de051 extends $16c3c01c3acb118d$export$cce76330980c3e56{/**
     * @param {any} model_inputs
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$c6cdf7c41fd4ad15 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$3a5a362071f91e3c extends $16c3c01c3acb118d$export$c6cdf7c41fd4ad15{}class $16c3c01c3acb118d$export$8abe54b4a664ccd4 extends $16c3c01c3acb118d$export$c6cdf7c41fd4ad15{/**
     * @param {any} model_inputs
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$ee96312603f49960 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$d7c580c4ae6e599e extends $16c3c01c3acb118d$export$ee96312603f49960{}class $16c3c01c3acb118d$export$3959526358d86329 extends $16c3c01c3acb118d$export$ee96312603f49960{/**
     * @param {any} model_inputs
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$df721241c3c2e4fc extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$928ad63a58a1048a extends $16c3c01c3acb118d$export$df721241c3c2e4fc{}class $16c3c01c3acb118d$export$9f3163d7b8c81cae extends $16c3c01c3acb118d$export$df721241c3c2e4fc{/**
     * @param {any} model_inputs
     */async _call(n){return new $16c3c01c3acb118d$export$ee62f06975a011bd(await super._call(n))}}class $16c3c01c3acb118d$export$6eb7c9cfd6f94019 extends $16c3c01c3acb118d$export$df721241c3c2e4fc{/**
     * Runs the model with the provided inputs
     * @param {Object} model_inputs Model inputs
     * @returns {Promise<DetrSegmentationOutput>} Object containing segmentation outputs
     */async _call(n){return new $16c3c01c3acb118d$export$37e6a7b86f70fa58(await super._call(n))}}class $16c3c01c3acb118d$export$ee62f06975a011bd extends $16c3c01c3acb118d$export$58ceee390f0aa3e7{/**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Classification logits (including no-object) for all queries.
     * @param {Tensor} output.pred_boxes Normalized boxes coordinates for all queries, represented as (center_x, center_y, width, height).
     * These values are normalized in [0, 1], relative to the size of each individual image in the batch (disregarding possible padding).
     */constructor({logits:n,pred_boxes:r}){super(),this.logits=n,this.pred_boxes=r}}class $16c3c01c3acb118d$export$37e6a7b86f70fa58 extends $16c3c01c3acb118d$export$58ceee390f0aa3e7{/**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits The output logits of the model.
     * @param {Tensor} output.pred_boxes Predicted boxes.
     * @param {Tensor} output.pred_masks Predicted masks.
     */constructor({logits:n,pred_boxes:r,pred_masks:i}){super(),this.logits=n,this.pred_boxes=r,this.pred_masks=i}}class $16c3c01c3acb118d$export$4d2474dfe42f89e7 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$a65a2cace7670987 extends $16c3c01c3acb118d$export$4d2474dfe42f89e7{}class $16c3c01c3acb118d$export$7d5ec2f3b9a69f18 extends $16c3c01c3acb118d$export$4d2474dfe42f89e7{/**
     * @param {any} model_inputs
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$6356f397b4a5dfb3 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$35bf570b3612471 extends $16c3c01c3acb118d$export$6356f397b4a5dfb3{}class $16c3c01c3acb118d$export$b8ac7b0b1a1967f7 extends $16c3c01c3acb118d$export$6356f397b4a5dfb3{/**
     * @param {any} model_inputs
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$a04fc382bf62450f extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$caa7d09dd91dd8e6 extends $16c3c01c3acb118d$export$a04fc382bf62450f{}class $16c3c01c3acb118d$export$44bf4f8d726af353 extends $16c3c01c3acb118d$export$a04fc382bf62450f{/**
     * @param {any} model_inputs
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$fc1bd86b469b264c extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$fd94796a6c9135b6 extends $16c3c01c3acb118d$export$fc1bd86b469b264c{}class $16c3c01c3acb118d$export$586262ebafe533a9 extends $16c3c01c3acb118d$export$fc1bd86b469b264c{/**
     * @param {any} model_inputs
     */async _call(n){return new $16c3c01c3acb118d$export$9e3ffe3c6d5c0e4c(await super._call(n))}}class $16c3c01c3acb118d$export$9e3ffe3c6d5c0e4c extends $16c3c01c3acb118d$export$58ceee390f0aa3e7{/**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Classification logits (including no-object) for all queries.
     * @param {Tensor} output.pred_boxes Normalized boxes coordinates for all queries, represented as (center_x, center_y, width, height).
     * These values are normalized in [0, 1], relative to the size of each individual image in the batch (disregarding possible padding).
     */constructor({logits:n,pred_boxes:r}){super(),this.logits=n,this.pred_boxes=r}}class $16c3c01c3acb118d$export$bccdbc89963cc423 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$396a35b9c75aea93 extends $16c3c01c3acb118d$export$bccdbc89963cc423{/**
     * @param {Object} model_inputs
     * @param {Tensor} model_inputs.pixel_values Pixel values as a Tensor with shape `(batch_size, num_channels, height, width)`.
     * @param {Tensor} model_inputs.input_points Input 2D spatial points with shape `(batch_size, num_points, 2)`. This is used by the prompt encoder to encode the prompt.
     * @todo Add support for `input_labels`, `input_boxes`, `input_masks`, and `image_embeddings`.
     */async _call(n){return new $16c3c01c3acb118d$export$d89a87101a0a233d(await super._call(n))}}class $16c3c01c3acb118d$export$d89a87101a0a233d extends $16c3c01c3acb118d$export$58ceee390f0aa3e7{/**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.iou_scores The output logits of the model.
     * @param {Tensor} output.pred_masks Predicted boxes.
     */constructor({iou_scores:n,pred_masks:r}){super(),this.iou_scores=n,this.pred_masks=r}}class $16c3c01c3acb118d$export$a36543952eb3458b extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$8b8504830d322b16 extends $16c3c01c3acb118d$export$a36543952eb3458b{}class $16c3c01c3acb118d$export$32b75fa8763a1b74 extends $16c3c01c3acb118d$export$a36543952eb3458b{/**
     * Creates a new instance of the `MarianMTModel` class.
    * @param {Object} config The model configuration object.
    * @param {Object} session The ONNX session object.
    * @param {any} decoder_merged_session 
    * @param {any} generation_config 
    */constructor(n,r,i,a){super(n,r),this.decoder_merged_session=i,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}/**
     * @param {any} model_inputs
     * @returns {Promise<Seq2SeqLMOutput>}
     */async forward(n){return await $16c3c01c3acb118d$var$seq2seqForward(this,n)}}class $16c3c01c3acb118d$export$5eead838cefb74aa extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$f8c5397d173cf173 extends $16c3c01c3acb118d$export$5eead838cefb74aa{}class $16c3c01c3acb118d$export$3f67d86e2e80a9a8 extends $16c3c01c3acb118d$export$5eead838cefb74aa{/**
     * Creates a new instance of the `M2M100ForConditionalGeneration` class.
    * @param {Object} config The model configuration object.
    * @param {Object} session The ONNX session object.
    * @param {any} decoder_merged_session 
    * @param {any} generation_config 
    */constructor(n,r,i,a){super(n,r),this.decoder_merged_session=i,this.generation_config=a,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}/**
     * @param {any} model_inputs
     * @returns {Promise<Seq2SeqLMOutput>}
     */async forward(n){return await $16c3c01c3acb118d$var$seq2seqForward(this,n)}}class $16c3c01c3acb118d$export$657ba3228a49e42d extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$713bbb39248ef1a9 extends $16c3c01c3acb118d$export$657ba3228a49e42d{}class $16c3c01c3acb118d$export$5ac03f06cc0d106 extends $16c3c01c3acb118d$export$657ba3228a49e42d{/**
     * @param {Object} model_inputs
     * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
     * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
     */async _call(n){return new $16c3c01c3acb118d$export$703872bb1a6df64a(await super._call(n))}}class $16c3c01c3acb118d$export$7af81766798a9e63 extends $16c3c01c3acb118d$export$657ba3228a49e42d{/**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$c350960262c5dff7 extends $16c3c01c3acb118d$export$13e52fe1ef3065ca{}class $16c3c01c3acb118d$export$882a75cc7a838e62 extends $16c3c01c3acb118d$export$c350960262c5dff7{}class $16c3c01c3acb118d$export$4b3b438d0912f979 extends $16c3c01c3acb118d$export$c350960262c5dff7{/**
     * @param {Object} model_inputs
     * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
     * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
     */async _call(n){return new $16c3c01c3acb118d$export$703872bb1a6df64a(await super._call(n))}}class $16c3c01c3acb118d$export$4d4d4722ea02b83d extends $16c3c01c3acb118d$export$c350960262c5dff7{/**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */async _call(n){return new $16c3c01c3acb118d$export$7b579e71aab4693f(await super._call(n))}}class $16c3c01c3acb118d$export$19866aabdc4ff51b{/**
     * Mapping from model type to model class.
     * @type {Map<string, Object>[]}
     */static MODEL_CLASS_MAPPINGS=null;/**
     * Whether to attempt to instantiate the base class (`PretrainedModel`) if 
     * the model type is not found in the mapping.
     */static BASE_IF_FAIL=!1;/** @type {PreTrainedModel.from_pretrained} */static async from_pretrained(n,{quantized:r=!0,progress_callback:i=null,config:a=null,cache_dir:s=null,local_files_only:o=!1,revision:l="main",model_file_name:u=null}={}){let c={quantized:r,progress_callback:i,config:a,cache_dir:s,local_files_only:o,revision:l,model_file_name:u};if(a=await $d0feda9c43436cc0$export$774ba61eeb9f6e8.from_pretrained(n,c),c.config||(c.config=a),!this.MODEL_CLASS_MAPPINGS)throw Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(let r of this.MODEL_CLASS_MAPPINGS){let i=r.get(a.model_type);if(i)return await i[1].from_pretrained(n,c);// Item not found in this mapping
}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${a.model_type}", attempting to construct from base class.`),await $16c3c01c3acb118d$export$13e52fe1ef3065ca.from_pretrained(n,c);throw Error(`Unsupported model type: ${a.model_type}`)}}const $16c3c01c3acb118d$var$MODEL_MAPPING_NAMES_ENCODER_ONLY=new Map([["bert",["BertModel",$16c3c01c3acb118d$export$50d26602687925fb]],["camembert",["CamembertModel",$16c3c01c3acb118d$export$108a48c7f7eacf2c]],["deberta",["DebertaModel",$16c3c01c3acb118d$export$281c92ea51c11a65]],["deberta-v2",["DebertaV2Model",$16c3c01c3acb118d$export$e6dcb08950625725]],["mpnet",["MPNetModel",$16c3c01c3acb118d$export$eb1c54902dbeeeb6]],["albert",["AlbertModel",$16c3c01c3acb118d$export$36bd0eb31e80f9e2]],["distilbert",["DistilBertModel",$16c3c01c3acb118d$export$3cbbba98374fa579]],["roberta",["RobertaModel",$16c3c01c3acb118d$export$d91085650dc57f0e]],["xlm",["XLMModel",$16c3c01c3acb118d$export$4e990258938f2f51]],["xlm-roberta",["XLMRobertaModel",$16c3c01c3acb118d$export$f2ab68ddae296db6]],["clip",["CLIPModel",$16c3c01c3acb118d$export$12fe9439f561c98]],["mobilebert",["MobileBertModel",$16c3c01c3acb118d$export$f5f0cbdf9fb64558]],["squeezebert",["SqueezeBertModel",$16c3c01c3acb118d$export$680dbbf29f7a337c]],["wav2vec2",["Wav2Vec2Model",$16c3c01c3acb118d$export$713bbb39248ef1a9]],["wavlm",["WavLMModel",$16c3c01c3acb118d$export$882a75cc7a838e62]],["detr",["DetrModel",$16c3c01c3acb118d$export$928ad63a58a1048a]],["vit",["ViTModel",$16c3c01c3acb118d$export$25ad685be53f99c3]],["mobilevit",["MobileViTModel",$16c3c01c3acb118d$export$3a5a362071f91e3c]],["beit",["BeitModel",$16c3c01c3acb118d$export$d7c580c4ae6e599e]],["deit",["DeiTModel",$16c3c01c3acb118d$export$a65a2cace7670987]],["resnet",["ResNetModel",$16c3c01c3acb118d$export$35bf570b3612471]],["swin",["SwinModel",$16c3c01c3acb118d$export$caa7d09dd91dd8e6]],["yolos",["YolosModel",$16c3c01c3acb118d$export$fd94796a6c9135b6]],["sam",["SamModel",$16c3c01c3acb118d$export$396a35b9c75aea93]]]),$16c3c01c3acb118d$var$MODEL_MAPPING_NAMES_ENCODER_DECODER=new Map([["t5",["T5Model",$16c3c01c3acb118d$export$101f7292b9f7db90]],["mt5",["MT5Model",$16c3c01c3acb118d$export$2c2aab1e578145a1]],["bart",["BartModel",$16c3c01c3acb118d$export$6dc0871b6b23f02c]],["mbart",["MBartModel",$16c3c01c3acb118d$export$658ebdbbcb19839f]],["marian",["MarianModel",$16c3c01c3acb118d$export$8b8504830d322b16]],["whisper",["WhisperModel",$16c3c01c3acb118d$export$fd7a195762895f0]],["m2m_100",["M2M100Model",$16c3c01c3acb118d$export$f8c5397d173cf173]]]),$16c3c01c3acb118d$var$MODEL_MAPPING_NAMES_DECODER_ONLY=new Map([["bloom",["BloomModel",$16c3c01c3acb118d$export$e18e51d1520fa1e4]],["gpt2",["GPT2Model",$16c3c01c3acb118d$export$5d50839baef5e65]],["gptj",["GPTJModel",$16c3c01c3acb118d$export$d06d9186085aa042]],["gpt_bigcode",["GPTBigCodeModel",$16c3c01c3acb118d$export$9e6e7feb639c4792]],["gpt_neo",["GPTNeoModel",$16c3c01c3acb118d$export$e93722bf71f70270]],["gpt_neox",["GPTNeoXModel",$16c3c01c3acb118d$export$60c531699d4680cb]],["codegen",["CodeGenModel",$16c3c01c3acb118d$export$92a7805edd7edb3f]],["llama",["LlamaModel",$16c3c01c3acb118d$export$7e8f6ff658bef53a]],["mpt",["MptModel",$16c3c01c3acb118d$export$d8053218a28ecd6b]],["opt",["OPTModel",$16c3c01c3acb118d$export$cf7ff954c787290a]]]),$16c3c01c3acb118d$var$MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForSequenceClassification",$16c3c01c3acb118d$export$2e07b9082029c653]],["camembert",["CamembertForSequenceClassification",$16c3c01c3acb118d$export$c067b10486a01f43]],["deberta",["DebertaForSequenceClassification",$16c3c01c3acb118d$export$9a103a267172fbc4]],["deberta-v2",["DebertaV2ForSequenceClassification",$16c3c01c3acb118d$export$1ed212aa166595ca]],["mpnet",["MPNetForSequenceClassification",$16c3c01c3acb118d$export$5243d11e2a59b18]],["albert",["AlbertForSequenceClassification",$16c3c01c3acb118d$export$1bf0a3507fa7e0b8]],["distilbert",["DistilBertForSequenceClassification",$16c3c01c3acb118d$export$e230dcc6fd271ac7]],["roberta",["RobertaForSequenceClassification",$16c3c01c3acb118d$export$251bfb6c3b9f95f7]],["xlm",["XLMForSequenceClassification",$16c3c01c3acb118d$export$5e5abea0031c6572]],["xlm-roberta",["XLMRobertaForSequenceClassification",$16c3c01c3acb118d$export$1998bba773e1211]],["bart",["BartForSequenceClassification",$16c3c01c3acb118d$export$ed7bb28547c7d7e8]],["mbart",["MBartForSequenceClassification",$16c3c01c3acb118d$export$9c70230cc724a590]],["mobilebert",["MobileBertForSequenceClassification",$16c3c01c3acb118d$export$bea32095ba959e6e]],["squeezebert",["SqueezeBertForSequenceClassification",$16c3c01c3acb118d$export$f43496fe547d0f7e]]]),$16c3c01c3acb118d$var$MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES=new Map([["bert",["BertForTokenClassification",$16c3c01c3acb118d$export$cbcac39eef7ced85]],["camembert",["CamembertForTokenClassification",$16c3c01c3acb118d$export$12326a9609fa28fa]],["deberta",["DebertaForTokenClassification",$16c3c01c3acb118d$export$44c9db9aa4387473]],["deberta-v2",["DebertaV2ForTokenClassification",$16c3c01c3acb118d$export$4bba9d70b65586e0]],["mpnet",["MPNetForTokenClassification",$16c3c01c3acb118d$export$1457e614d4dba781]],["distilbert",["DistilBertForTokenClassification",$16c3c01c3acb118d$export$58af094f1150618e]],["roberta",["RobertaForTokenClassification",$16c3c01c3acb118d$export$e77708316736df09]],["xlm",["XLMForTokenClassification",$16c3c01c3acb118d$export$71f287c5e42eae5]],["xlm-roberta",["XLMRobertaForTokenClassification",$16c3c01c3acb118d$export$7659b63d6857f5ea]]]),$16c3c01c3acb118d$var$MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES=new Map([["t5",["T5ForConditionalGeneration",$16c3c01c3acb118d$export$12670a13d0db4f5d]],["mt5",["MT5ForConditionalGeneration",$16c3c01c3acb118d$export$9c357e7bf6c3bbc0]],["bart",["BartForConditionalGeneration",$16c3c01c3acb118d$export$81a4719e629f1e9c]],["mbart",["MBartForConditionalGeneration",$16c3c01c3acb118d$export$82c8c60a52b00127]],["whisper",["WhisperForConditionalGeneration",$16c3c01c3acb118d$export$14659d9ec3a67109]],["marian",["MarianMTModel",$16c3c01c3acb118d$export$32b75fa8763a1b74]],["m2m_100",["M2M100ForConditionalGeneration",$16c3c01c3acb118d$export$3f67d86e2e80a9a8]]]),$16c3c01c3acb118d$var$MODEL_WITH_LM_HEAD_MAPPING_NAMES=new Map([["bloom",["BloomForCausalLM",$16c3c01c3acb118d$export$db4605baef1ad703]],["gpt2",["GPT2LMHeadModel",$16c3c01c3acb118d$export$fb0afd234c443cfb]],["gptj",["GPTJForCausalLM",$16c3c01c3acb118d$export$660f664770d31ae1]],["gpt_bigcode",["GPTBigCodeForCausalLM",$16c3c01c3acb118d$export$9e0f92330a5523a7]],["gpt_neo",["GPTNeoForCausalLM",$16c3c01c3acb118d$export$a9d539ded7cb5eee]],["gpt_neox",["GPTNeoXForCausalLM",$16c3c01c3acb118d$export$fcf362cd2088f288]],["codegen",["CodeGenForCausalLM",$16c3c01c3acb118d$export$f6421463ca6ac59c]],["llama",["LlamaForCausalLM",$16c3c01c3acb118d$export$d3481c3099e3a948]],["mpt",["MptForCausalLM",$16c3c01c3acb118d$export$8adc2830e45c5d81]],["opt",["OPTForCausalLM",$16c3c01c3acb118d$export$636b1f4e25c56a84]]]),$16c3c01c3acb118d$var$MODEL_FOR_MASKED_LM_MAPPING_NAMES=new Map([["bert",["BertForMaskedLM",$16c3c01c3acb118d$export$adb6944686c9f054]],["camembert",["CamembertForMaskedLM",$16c3c01c3acb118d$export$616d4353f8f8850a]],["deberta",["DebertaForMaskedLM",$16c3c01c3acb118d$export$1a5d8309ea04aa49]],["deberta-v2",["DebertaV2ForMaskedLM",$16c3c01c3acb118d$export$cd2e138af46480a2]],["mpnet",["MPNetForMaskedLM",$16c3c01c3acb118d$export$728981f6c2b2f8c3]],["albert",["AlbertForMaskedLM",$16c3c01c3acb118d$export$780187a73886f6b0]],["distilbert",["DistilBertForMaskedLM",$16c3c01c3acb118d$export$c294fec67de0e8c8]],["roberta",["RobertaForMaskedLM",$16c3c01c3acb118d$export$e4184c6fee46303f]],["xlm",["XLMWithLMHeadModel",$16c3c01c3acb118d$export$2f651cadd7fa9895]],["xlm-roberta",["XLMRobertaForMaskedLM",$16c3c01c3acb118d$export$f58e2f3f37b73bfa]],["mobilebert",["MobileBertForMaskedLM",$16c3c01c3acb118d$export$864591201f039978]],["squeezebert",["SqueezeBertForMaskedLM",$16c3c01c3acb118d$export$5cc0106d2c05335b]]]),$16c3c01c3acb118d$var$MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES=new Map([["bert",["BertForQuestionAnswering",$16c3c01c3acb118d$export$dcda5cb55325c8d9]],["camembert",["CamembertForQuestionAnswering",$16c3c01c3acb118d$export$55fbace81d2ba5c1]],["deberta",["DebertaForQuestionAnswering",$16c3c01c3acb118d$export$f0f2cda3db1d7204]],["deberta-v2",["DebertaV2ForQuestionAnswering",$16c3c01c3acb118d$export$a22ac5b62929568a]],["mpnet",["MPNetForQuestionAnswering",$16c3c01c3acb118d$export$85b9f959452f122b]],["albert",["AlbertForQuestionAnswering",$16c3c01c3acb118d$export$ccc15aa3448e0ef8]],["distilbert",["DistilBertForQuestionAnswering",$16c3c01c3acb118d$export$5e621b9500c77df3]],["roberta",["RobertaForQuestionAnswering",$16c3c01c3acb118d$export$9a9ab2575fcc6baa]],["xlm",["XLMForQuestionAnswering",$16c3c01c3acb118d$export$bd711ce0e58ec451]],["xlm-roberta",["XLMRobertaForQuestionAnswering",$16c3c01c3acb118d$export$8d4b984adf730433]],["mobilebert",["MobileBertForQuestionAnswering",$16c3c01c3acb118d$export$7c8b5a948d525f24]],["squeezebert",["SqueezeBertForQuestionAnswering",$16c3c01c3acb118d$export$ac848ea3ecbdb5a0]]]),$16c3c01c3acb118d$var$MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",$16c3c01c3acb118d$export$cc5a9e224842b44b]]]),$16c3c01c3acb118d$var$MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES=new Map([["vit",["ViTForImageClassification",$16c3c01c3acb118d$export$8056898fd48de051]],["mobilevit",["MobileViTForImageClassification",$16c3c01c3acb118d$export$8abe54b4a664ccd4]],["beit",["BeitForImageClassification",$16c3c01c3acb118d$export$3959526358d86329]],["deit",["DeiTForImageClassification",$16c3c01c3acb118d$export$7d5ec2f3b9a69f18]],["resnet",["ResNetForImageClassification",$16c3c01c3acb118d$export$b8ac7b0b1a1967f7]],["swin",["SwinForImageClassification",$16c3c01c3acb118d$export$44bf4f8d726af353]]]),$16c3c01c3acb118d$var$MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES=new Map([["detr",["DetrForObjectDetection",$16c3c01c3acb118d$export$9f3163d7b8c81cae]],["yolos",["YolosForObjectDetection",$16c3c01c3acb118d$export$586262ebafe533a9]]]),$16c3c01c3acb118d$var$MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES=new Map([["detr",["DetrForSegmentation",$16c3c01c3acb118d$export$6eb7c9cfd6f94019]]]),$16c3c01c3acb118d$var$MODEL_FOR_MASK_GENERATION_MAPPING_NAMES=new Map([["sam",["SamModel",$16c3c01c3acb118d$export$396a35b9c75aea93]]]),$16c3c01c3acb118d$var$MODEL_FOR_CTC_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForCTC",$16c3c01c3acb118d$export$5ac03f06cc0d106]],["wavlm",["WavLMForCTC",$16c3c01c3acb118d$export$4b3b438d0912f979]]]),$16c3c01c3acb118d$var$MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",$16c3c01c3acb118d$export$7af81766798a9e63]],["wavlm",["WavLMForSequenceClassification",$16c3c01c3acb118d$export$4d4d4722ea02b83d]]]),$16c3c01c3acb118d$var$MODEL_CLASS_TYPE_MAPPING=[[$16c3c01c3acb118d$var$MODEL_MAPPING_NAMES_ENCODER_ONLY,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],[$16c3c01c3acb118d$var$MODEL_MAPPING_NAMES_ENCODER_DECODER,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderDecoder],[$16c3c01c3acb118d$var$MODEL_MAPPING_NAMES_DECODER_ONLY,$16c3c01c3acb118d$var$MODEL_TYPES.DecoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.Seq2Seq],[$16c3c01c3acb118d$var$MODEL_WITH_LM_HEAD_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.DecoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_MASKED_LM_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.Vision2Seq],[$16c3c01c3acb118d$var$MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_MASK_GENERATION_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_CTC_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],[$16c3c01c3acb118d$var$MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly]];for(const[mappings,type]of $16c3c01c3acb118d$var$MODEL_CLASS_TYPE_MAPPING)for(const[name,model]of mappings.values())$16c3c01c3acb118d$var$MODEL_TYPE_MAPPING.set(name,type),$16c3c01c3acb118d$var$MODEL_CLASS_TO_NAME_MAPPING.set(model,name),$16c3c01c3acb118d$var$MODEL_NAME_TO_CLASS_MAPPING.set(name,model);const $16c3c01c3acb118d$var$CUSTOM_MAPPING=[["CLIPTextModelWithProjection",$16c3c01c3acb118d$export$62655b6db5e46a62,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly],["CLIPVisionModelWithProjection",$16c3c01c3acb118d$export$51616dd9ead7b60c,$16c3c01c3acb118d$var$MODEL_TYPES.EncoderOnly]];for(const[name,model,type]of $16c3c01c3acb118d$var$CUSTOM_MAPPING)$16c3c01c3acb118d$var$MODEL_TYPE_MAPPING.set(name,type),$16c3c01c3acb118d$var$MODEL_CLASS_TO_NAME_MAPPING.set(model,name),$16c3c01c3acb118d$var$MODEL_NAME_TO_CLASS_MAPPING.set(name,model);class $16c3c01c3acb118d$export$5377acb7b84ca903 extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_MAPPING_NAMES_ENCODER_ONLY,$16c3c01c3acb118d$var$MODEL_MAPPING_NAMES_ENCODER_DECODER,$16c3c01c3acb118d$var$MODEL_MAPPING_NAMES_DECODER_ONLY];static BASE_IF_FAIL=!0}class $16c3c01c3acb118d$export$e461000f728f0696 extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES]}class $16c3c01c3acb118d$export$1d56993e9c54b4ba extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES]}class $16c3c01c3acb118d$export$aa0088088f56c92d extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_SEQ_2_SEQ_MAPPING_NAMES]}class $16c3c01c3acb118d$export$ffaa33dde44939bd extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_WITH_LM_HEAD_MAPPING_NAMES]}class $16c3c01c3acb118d$export$41a6f7c951809cc2 extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_MASKED_LM_MAPPING_NAMES]}class $16c3c01c3acb118d$export$9cbe7fafb702bbbf extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES]}class $16c3c01c3acb118d$export$f8d9df114bc3682a extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES]}class $16c3c01c3acb118d$export$71d41439e591a26a extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES]}class $16c3c01c3acb118d$export$3b14fa9611967836 extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES]}class $16c3c01c3acb118d$export$c452f8980228d5 extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES]}class $16c3c01c3acb118d$export$bf1253060dfae3c7 extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_CTC_MAPPING_NAMES]}class $16c3c01c3acb118d$export$8a991c65f3aa09b0 extends $16c3c01c3acb118d$export$19866aabdc4ff51b{static MODEL_CLASS_MAPPINGS=[$16c3c01c3acb118d$var$MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES]}class $16c3c01c3acb118d$export$b8379c304ac703bb extends $16c3c01c3acb118d$export$58ceee390f0aa3e7{/**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits The output logits of the model.
     * @param {Tensor} output.past_key_values An tensor of key/value pairs that represent the previous state of the model.
     * @param {Tensor} output.encoder_outputs The output of the encoder in a sequence-to-sequence model.
     * @param {Tensor} [output.decoder_attentions] Attentions weights of the decoder, after the attention softmax, used to compute the weighted average in the self-attention heads.
     * @param {Tensor} [output.cross_attentions] Attentions weights of the decoder's cross-attention layer, after the attention softmax, used to compute the weighted average in the cross-attention heads.
     */constructor({logits:n,past_key_values:r,encoder_outputs:i,decoder_attentions:a=null,cross_attentions:s=null}){super(),this.logits=n,this.past_key_values=r,this.encoder_outputs=i,this.decoder_attentions=a,this.cross_attentions=s}}class $16c3c01c3acb118d$export$7b579e71aab4693f extends $16c3c01c3acb118d$export$58ceee390f0aa3e7{/**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits classification (or regression if config.num_labels==1) scores (before SoftMax).
     */constructor({logits:n}){super(),this.logits=n}}class $16c3c01c3acb118d$export$91b98ca4a8106cfb extends $16c3c01c3acb118d$export$58ceee390f0aa3e7{/**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Classification scores (before SoftMax).
     */constructor({logits:n}){super(),this.logits=n}}class $16c3c01c3acb118d$export$be90aa37c12fd6ad extends $16c3c01c3acb118d$export$58ceee390f0aa3e7{/**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).
     */constructor({logits:n}){super(),this.logits=n}}class $16c3c01c3acb118d$export$8d0bb3c3da84b5fe extends $16c3c01c3acb118d$export$58ceee390f0aa3e7{/**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.start_logits Span-start scores (before SoftMax).
     * @param {Tensor} output.end_logits Span-end scores (before SoftMax).
     */constructor({start_logits:n,end_logits:r}){super(),this.start_logits=n,this.end_logits=r}}class $16c3c01c3acb118d$export$703872bb1a6df64a extends $16c3c01c3acb118d$export$58ceee390f0aa3e7{/**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before softmax).
     */constructor({logits:n}){super(),this.logits=n}}/**
 * @file Processors are used to prepare non-textual inputs (e.g., image or audio) for a model.
 * 
 * **Example:** Using a `WhisperProcessor` to prepare an audio input for a model.
 * ```javascript
 * import { AutoProcessor, read_audio } from '@xenova/transformers';
 *
 * let processor = await AutoProcessor.from_pretrained('openai/whisper-tiny.en');
 * let audio = await read_audio('https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/mlk.flac', 16000);
 * let { input_features } = await processor(audio);
 * // Tensor {
 * //   data: Float32Array(240000) [0.4752984642982483, 0.5597258806228638, 0.56434166431427, ...],
 * //   dims: [1, 80, 3000],
 * //   type: 'float32',
 * //   size: 240000,
 * // }
 * ```
 * 
 * @module processors
 *//**
 * @file Helper module for image processing. 
 * 
 * These functions and classes are only used internally, 
 * meaning an end-user shouldn't need to access anything here.
 * 
 * @module utils/image
 */const $649b5a10055e0f2c$var$BROWSER_ENV="undefined"!=typeof self;if($649b5a10055e0f2c$var$BROWSER_ENV)// Running in browser or web-worker
$649b5a10055e0f2c$var$createCanvasFunction=(/** @type {number} */n,/** @type {number} */r)=>{if(!self.OffscreenCanvas)throw Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(n,r)},$649b5a10055e0f2c$var$loadImageFunction=self.createImageBitmap,$649b5a10055e0f2c$var$ImageDataClass=self.ImageData;else if(/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports))$649b5a10055e0f2c$var$loadImageFunction=async /**@type {sharp.Sharp}*/n=>{let r=await n.metadata(),i=r.channels,{data:a,info:s}=await n.raw().toBuffer({resolveWithObject:!0}),o=new $649b5a10055e0f2c$export$48705a6dac84618b(new Uint8ClampedArray(a),s.width,s.height,s.channels);return void 0!==i&&i!==s.channels&&// This is necessary for grayscale images.
o.convert(i),o};else throw Error("Unable to load image processing library.");// Defined here: https://github.com/python-pillow/Pillow/blob/a405e8406b83f8bfb8916e93971edc7407b8b1ff/src/libImaging/Imaging.h#L262-L268
const $649b5a10055e0f2c$var$RESAMPLING_MAPPING={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"};class $649b5a10055e0f2c$export$48705a6dac84618b{/**
     * Mapping from file extensions to MIME types.
     */_CONTENT_TYPE_MAP={png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};/**
     * Create a new `RawImage` object.
     * @param {Uint8ClampedArray} data The pixel data.
     * @param {number} width The width of the image.
     * @param {number} height The height of the image.
     * @param {1|2|3|4} channels The number of channels.
     */constructor(n,r,i,a){this._update(n,r,i,a)}/**
     * Helper method for reading an image from a variety of input types.
     * @param {RawImage|string|URL} input 
     * @returns The image object.
     * 
     * **Example:** Read image from a URL.
     * ```javascript
     * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');
     * // test {
     * //   "data": Uint8ClampedArray [ 25, 25, 25, 19, 19, 19, ... ],
     * //   "width": 800,
     * //   "height": 533,
     * //   "channels": 3
     * // }
     * ```
     */static async read(n){if(n instanceof $649b5a10055e0f2c$export$48705a6dac84618b)return n;if($2a81087eb92e3db1$export$844ec244b1367d54(n)||n instanceof URL)return await this.fromURL(n);throw Error(`Unsupported input type: ${typeof n}`)}/**
     * Read an image from a URL or file path.
     * @param {string|URL} url The URL or file path to read the image from.
     * @returns {Promise<RawImage>} The image object.
     */static async fromURL(n){let r=await $fb1f2fa9752dcff4$export$8b3ca78f81ec578c(n);if(200!==r.status)throw Error(`Unable to read image from "${n}" (${r.status} ${r.statusText})`);let i=await r.blob();return this.fromBlob(i)}/**
     * Helper method to create a new Image from a blob.
     * @param {Blob} blob The blob to read the image from.
     * @returns {Promise<RawImage>} The image object.
     */static async fromBlob(n){if($649b5a10055e0f2c$var$BROWSER_ENV){// Running in environment with canvas
let r=await $649b5a10055e0f2c$var$loadImageFunction(n),i=$649b5a10055e0f2c$var$createCanvasFunction(r.width,r.height).getContext("2d");return(// Draw image to context
i.drawImage(r,0,0),new this(i.getImageData(0,0,r.width,r.height).data,r.width,r.height,4))}{// Use sharp.js to read (and possible resize) the image.
let r=/*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports)(await n.arrayBuffer());return await $649b5a10055e0f2c$var$loadImageFunction(r)}}/**
     * Convert the image to grayscale format.
     * @returns {RawImage} `this` to support chaining.
     */grayscale(){if(1===this.channels)return this;let n=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let r=0,i=0;r<this.data.length;r+=this.channels){let a=this.data[r],s=this.data[r+1],o=this.data[r+2];n[i++]=Math.round(.2989*a+.587*s+.114*o)}break;default:throw Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(n,this.width,this.height,1)}/**
     * Convert the image to RGB format.
     * @returns {RawImage} `this` to support chaining.
     */rgb(){if(3===this.channels)return this;let n=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let r=0,i=0;r<this.data.length;++r)n[i++]=this.data[r],n[i++]=this.data[r],n[i++]=this.data[r];break;case 4:for(let r=0,i=0;r<this.data.length;r+=4)n[i++]=this.data[r],n[i++]=this.data[r+1],n[i++]=this.data[r+2];break;default:throw Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(n,this.width,this.height,3)}/**
     * Convert the image to RGBA format.
     * @returns {RawImage} `this` to support chaining.
     */rgba(){if(4===this.channels)return this;let n=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let r=0,i=0;r<this.data.length;++r)n[i++]=this.data[r],n[i++]=this.data[r],n[i++]=this.data[r],n[i++]=255;break;case 3:for(let r=0,i=0;r<this.data.length;r+=3)n[i++]=this.data[r],n[i++]=this.data[r+1],n[i++]=this.data[r+2],n[i++]=255;break;default:throw Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(n,this.width,this.height,4)}/**
     * Resize the image to the given dimensions. This method uses the canvas API to perform the resizing.
     * @param {number} width The width of the new image.
     * @param {number} height The height of the new image.
     * @param {Object} options Additional options for resizing.
     * @param {0|1|2|3|4|5|string} [options.resample] The resampling method to use.
     * @returns {Promise<RawImage>} `this` to support chaining.
     */async resize(n,r,{resample:i=2}={}){// Ensure resample method is a string
let a=$649b5a10055e0f2c$var$RESAMPLING_MAPPING[i]??i;if($649b5a10055e0f2c$var$BROWSER_ENV){// TODO use `resample` in browser environment
// Store number of channels before resizing
let i=this.channels,a=this.toCanvas(),s=$649b5a10055e0f2c$var$createCanvasFunction(n,r).getContext("2d");// Convert back so that image has the same number of channels as before
return(// Draw image to context, resizing in the process
s.drawImage(a,0,0,n,r),new $649b5a10055e0f2c$export$48705a6dac84618b(s.getImageData(0,0,n,r).data,n,r,4).convert(i))}{// Create sharp image from raw data, and resize
let i=this.toSharp();switch(a){case"box":case"hamming":("box"===a||"hamming"===a)&&(console.warn(`Resampling method ${a} is not yet supported. Using bilinear instead.`),a="bilinear");case"nearest":case"bilinear":case"bicubic":// Perform resizing using affine transform. 
// This matches how the python Pillow library does it.
i=i.affine([n/this.width,0,0,r/this.height],{interpolator:a});break;case"lanczos":// https://github.com/python-pillow/Pillow/discussions/5519
// https://github.com/lovell/sharp/blob/main/docs/api-resize.md
i=i.resize({width:n,height:r,fit:"fill",kernel:"lanczos3"});break;default:throw Error(`Resampling method ${a} is not supported.`)}return await $649b5a10055e0f2c$var$loadImageFunction(i)}}async pad([n,r,i,a]){if(n=Math.max(n,0),r=Math.max(r,0),i=Math.max(i,0),a=Math.max(a,0),0===n&&0===r&&0===i&&0===a)return this;if($649b5a10055e0f2c$var$BROWSER_ENV){// Store number of channels before padding
let s=this.channels,o=this.toCanvas(),l=this.width+n+r,u=this.height+i+a,c=$649b5a10055e0f2c$var$createCanvasFunction(l,u).getContext("2d");// Convert back so that image has the same number of channels as before
return(// Draw image to context, padding in the process
c.drawImage(o,0,0,this.width,this.height,n,i,l,u),new $649b5a10055e0f2c$export$48705a6dac84618b(c.getImageData(0,0,l,u).data,l,u,4).convert(s))}{let s=this.toSharp().extend({left:n,right:r,top:i,bottom:a});return await $649b5a10055e0f2c$var$loadImageFunction(s)}}async center_crop(n,r){// If the image is already the desired size, return it
if(this.width===n&&this.height===r)return this;// Determine bounds of the image in the new canvas
let i=(this.width-n)/2,a=(this.height-r)/2;if($649b5a10055e0f2c$var$BROWSER_ENV){// Store number of channels before resizing
let s=this.channels,o=this.toCanvas(),l=$649b5a10055e0f2c$var$createCanvasFunction(n,r).getContext("2d"),u=0,c=0,h=0,d=0;// Convert back so that image has the same number of channels as before
return i>=0?u=i:h=-i,a>=0?c=a:d=-a,// Draw image to context, cropping in the process
l.drawImage(o,u,c,n,r,h,d,n,r),new $649b5a10055e0f2c$export$48705a6dac84618b(l.getImageData(0,0,n,r).data,n,r,4).convert(s)}{// Create sharp image from raw data
let s=this.toSharp();if(i>=0&&a>=0)s=s.extract({left:Math.floor(i),top:Math.floor(a),width:n,height:r});else if(i<=0&&a<=0){// Cropped image lies entirely outside the original image,
// so we add padding
let o=Math.floor(-a),l=Math.floor(-i);s=s.extend({top:o,left:l,// Ensures the resulting image has the desired dimensions
right:n-this.width-l,bottom:r-this.height-o})}else{// Cropped image lies partially outside the original image.
// We first pad, then crop.
let o=[0,0],l=0;a<0?(o[0]=Math.floor(-a),o[1]=r-this.height-o[0]):l=Math.floor(a);let u=[0,0],c=0;i<0?(u[0]=Math.floor(-i),u[1]=n-this.width-u[0]):c=Math.floor(i),s=s.extend({top:o[0],bottom:o[1],left:u[0],right:u[1]}).extract({left:c,top:l,width:n,height:r})}return await $649b5a10055e0f2c$var$loadImageFunction(s)}}toCanvas(){if(!$649b5a10055e0f2c$var$BROWSER_ENV)throw Error("toCanvas() is only supported in browser environments.");// Clone, and convert data to RGBA before drawing to canvas.
// This is because the canvas API only supports RGBA
let n=this.clone().rgba(),r=$649b5a10055e0f2c$var$createCanvasFunction(n.width,n.height),i=new $649b5a10055e0f2c$var$ImageDataClass(n.data,n.width,n.height);return r.getContext("2d").putImageData(i,0,0),r}/**
     * Helper method to update the image data.
     * @param {Uint8ClampedArray} data The new image data.
     * @param {number} width The new width of the image.
     * @param {number} height The new height of the image.
     * @param {1|2|3|4} channels The new number of channels of the image.
     */_update(n,r,i,a=null){return this.data=n,this.width=r,this.height=i,null!==a&&(this.channels=a),this}/**
     * Clone the image
     * @returns {RawImage} The cloned image
     */clone(){return new $649b5a10055e0f2c$export$48705a6dac84618b(this.data.slice(),this.width,this.height,this.channels)}/**
     * Helper method for converting image to have a certain number of channels
     * @param {number} numChannels The number of channels. Must be 1, 3, or 4.
     * @returns {RawImage} `this` to support chaining.
     */convert(n){if(this.channels===n)return this;// Already correct number of channels
switch(n){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}/**
     * Save the image to the given path.
     * @param {string} path The path to save the image to.
     */save(n){if($649b5a10055e0f2c$var$BROWSER_ENV){let r=n.split(".").pop().toLowerCase(),i=this._CONTENT_TYPE_MAP[r]??"image/png",a=this.toCanvas(),s=a.toDataURL(i),o=document.createElement("a");o.href=s,// Set the download attribute to specify the desired filename for the downloaded image
o.download=n,// Trigger the download
o.click(),// Clean up: remove the anchor element from the DOM
o.remove()}else if($b7c5c2295e1edeeb$export$a7b6bc01c63cdfc3.useFS){let r=this.toSharp();r.toFile(n)}else throw Error("Unable to save the image because filesystem is disabled in this environment.")}toSharp(){if($649b5a10055e0f2c$var$BROWSER_ENV)throw Error("toSharp() is only supported in server-side environments.");return /*@__PURE__*/$parcel$interopDefault($7a70da87fd49fc04$exports)(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}/**
 * @file Helper module for audio processing. 
 * 
 * These functions and classes are only used internally, 
 * meaning an end-user shouldn't need to access anything here.
 * 
 * @module utils/audio
 */async function $3beda6f332fbbafd$export$db0a86f80e297540(n,r){let i;if("undefined"==typeof AudioContext)throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");let a=await (await $fb1f2fa9752dcff4$export$8b3ca78f81ec578c(n)).arrayBuffer(),s=new AudioContext({sampleRate:r});void 0===r&&console.warn(`No sampling rate provided, using default of ${s.sampleRate}Hz.`);let o=await s.decodeAudioData(a);// We now replicate HuggingFace's `ffmpeg_read` method:
if(2===o.numberOfChannels){// When downmixing a stereo audio file to mono using the -ac 1 option in FFmpeg,
// the audio signal is summed across both channels to create a single mono channel.
// However, if the audio is at full scale (i.e. the highest possible volume level),
// the summing of the two channels can cause the audio signal to clip or distort.
// To prevent this clipping, FFmpeg applies a scaling factor of 1/sqrt(2) (~ 0.707)
// to the audio signal before summing the two channels. This scaling factor ensures
// that the combined audio signal will not exceed the maximum possible level, even
// if both channels are at full scale.
// After applying this scaling factor, the audio signal from both channels is summed
// to create a single mono channel. It's worth noting that this scaling factor is
// only applied when downmixing stereo audio to mono using the -ac 1 option in FFmpeg.
// If you're using a different downmixing method, or if you're not downmixing the
// audio at all, this scaling factor may not be needed.
let n=Math.sqrt(2),r=o.getChannelData(0),a=o.getChannelData(1);i=new Float32Array(r.length);for(let s=0;s<o.length;++s)i[s]=n*(r[s]+a[s])/2}else i=o.getChannelData(0);return i}function $3beda6f332fbbafd$export$cffdaa17be32d63c(n,r,i=128){i=Math.floor(i);// Initialize the weights
let a=Math.floor(1+r/2),s=Array(i),o=$821ef51da65e5775$export$9e48bff21cf1b9ab(r,1/n),l=0,u=45.245640471924965,c=u-l,h=c/(i+1),d=0,p=200/3,f=Array(i+2),m=1e3,g=(m-d)/p,_=Math.log(6.4)/27,y=Array(f.length);for(let n=0;n<f.length;++n){let r=n*h+l;r>=g?f[n]=m*Math.exp(_*(r-g)):f[n]=d+p*r,y[n]=o.map(r=>f[n]-r)}let b=f.slice(1).map((n,r)=>1/(n-f[r]));for(let n=0;n<s.length;++n){s[n]=Array(a);let r=b[n],i=b[n+1],o=y[n],l=y[n+2],u=2/(f[n+2]-f[n]);for(let a=0;a<s[n].length;++a){// lower and upper slopes for all bins
let c=-o[a]*r,h=l[a]*i;s[n][a]=Math.max(0,Math.min(c,h))*u}}return s}// Helper functions
/**
 * Converts bounding boxes from center format to corners format.
 * 
 * @param {number[]} arr The coordinate for the center of the box and its width, height dimensions (center_x, center_y, width, height)
 * @returns {number[]} The coodinates for the top-left and bottom-right corners of the box (top_left_x, top_left_y, bottom_right_x, bottom_right_y)
 */function $3a884fd87742fa0d$var$center_to_corners_format([n,r,i,a]){return[n-i/2,r-a/2,n+i/2,r+a/2]}/**
 * Post-processes the outputs of the model (for object detection).
 * @param {Object} outputs The outputs of the model that must be post-processed
 * @param {Tensor} outputs.logits The logits
 * @param {Tensor} outputs.pred_boxes The predicted boxes.
 * @return {Object[]} An array of objects containing the post-processed outputs.
 */function $3a884fd87742fa0d$var$post_process_object_detection(n,r=.5,i=null){let a=n.logits,s=n.pred_boxes,[o,l,u]=a.dims;if(null!==i&&i.length!==o)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let c=[];for(let n=0;n<o;++n){let o=null!==i?i[n]:null,h={boxes:[],classes:[],scores:[]},d=a[n],p=s[n];for(let n=0;n<l;++n){let i=d[n],a=$821ef51da65e5775$export$8960430cfd85939f(i.data)[1];if(a===u-1)continue;let s=$821ef51da65e5775$export$e008137e76238601(i.data)[a];if(s>r){// Some class has a high enough probability
/** @type {number[]} */let r=p[n].data;// convert to [x0, y0, x1, y1] format
r=$3a884fd87742fa0d$var$center_to_corners_format(r),null!==o&&(r=r.map((n,r)=>n*o[(r+1)%2])),h.boxes.push(r),h.classes.push(a),h.scores.push(s)}}c.push(h)}return c}class $3a884fd87742fa0d$export$822ef4327cb692b3 extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
     * Constructs a new FeatureExtractor instance.
     *
     * @param {Object} config The configuration for the feature extractor.
     */constructor(n){super(),this.config=n}}class $3a884fd87742fa0d$export$726912fcf6fe230e extends $3a884fd87742fa0d$export$822ef4327cb692b3{/**
     * Constructs a new ImageFeatureExtractor instance.
     *
     * @param {Object} config The configuration for the feature extractor.
     * @param {number[]} config.image_mean The mean values for image normalization.
     * @param {number[]} config.image_std The standard deviation values for image normalization.
     * @param {boolean} config.do_rescale Whether to rescale the image pixel values to the [0,1] range.
     * @param {number} config.rescale_factor The factor to use for rescaling the image pixel values.
     * @param {boolean} config.do_normalize Whether to normalize the image pixel values.
     * @param {boolean} config.do_resize Whether to resize the image.
     * @param {number} config.resample What method to use for resampling.
     * @param {number} config.size The size to resize the image to.
     */constructor(n){super(n),this.image_mean=this.config.image_mean,this.image_std=this.config.image_std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.size=this.config.size,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.pad_size=this.config.pad_size,this.do_pad=(this.config.do_pad??!1)&&this.pad_size}/**
     * Preprocesses the given image.
     *
     * @param {RawImage} image The image to preprocess.
     * @returns {Promise<any>} The preprocessed image as a Tensor.
     */async preprocess(n){// First, convert image to RGB if specified in config.
this.do_convert_rgb&&(n=n.rgb());let r=n.width,i=n.height;// original width
// Next, resize all images
if(this.do_resize){// TODO:
// For efficiency reasons, it might be best to merge the resize and center crop operations into one.
// `this.size` comes in many forms, so we need to handle them all here:
// 1. `this.size` is an integer, in which case we resize the image to be a square 
let a,s;// If `longest_edge` and `shortest_edge` are set, maintain aspect ratio and resize to `shortest_edge`
// while keeping the largest dimension <= `longest_edge`
if(Number.isInteger(this.size)?(a=this.size,s=this.config.max_size??a):(// Extract known properties from `this.size`
a=this.size.shortest_edge,s=this.size.longest_edge),void 0!==a||void 0!==s){// http://opensourcehacker.com/2011/12/01/calculate-aspect-ratio-conserving-resize-for-images-in-javascript/
// Try resize so that shortest edge is `this.shortest_edge` (target)
let o=void 0===a?1// If `shortest_edge` is not set, don't upscale
:Math.max(a/r,a/i),l=r*o,u=i*o,c=void 0===s?1// If `longest_edge` is not set, don't downscale
:Math.min(s/l,s/u),h=Math.floor(Number((l*c).toPrecision(3))),d=Math.floor(Number((u*c).toPrecision(3)));// Perform resize
n=await n.resize(h,d,{resample:this.resample})}else if(void 0!==this.size.width&&void 0!==this.size.height)n=await n.resize(this.size.width,this.size.height,{resample:this.resample});else throw Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(this.size)}`)}if(this.do_center_crop){let r,i;Number.isInteger(this.crop_size)?(r=this.crop_size,i=this.crop_size):(r=this.crop_size.width,i=this.crop_size.height),n=await n.center_crop(r,i)}let a=[n.height,n.width];// TODO is it okay to pad before rescaling/normalizing?
if(this.do_pad){let r=0,i=this.pad_size.width-n.width,a=0,s=this.pad_size.height-n.height;n=await n.pad([r,i,a,s])}let s=Float32Array.from(n.data);if(this.do_rescale)for(let n=0;n<s.length;++n)s[n]=this.rescale_factor*s[n];if(this.do_normalize){let r=this.image_mean;Array.isArray(this.image_mean)||(r=Array(n.channels).fill(r));let i=this.image_std;if(Array.isArray(this.image_std)||(i=Array(n.channels).fill(r)),r.length!==n.channels||i.length!==n.channels)throw Error(`When set to arrays, the length of \`image_mean\` (${r.length}) and \`image_std\` (${i.length}) must match the number of channels in the image (${n.channels}).`);for(let r=0;r<s.length;r+=n.channels)for(let i=0;i<n.channels;++i)s[r+i]=(s[r+i]-this.image_mean[i])/this.image_std[i]}// convert to channel dimension format:
let o=[n.height,n.width,n.channels];return{original_size:[i,r],reshaped_input_size:a,pixel_values:$970f59cad5f0fd6a$export$9cb09a71b7d66923(new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",s,o),[2,0,1])}}/**
     * Calls the feature extraction process on an array of image
     * URLs, preprocesses each image, and concatenates the resulting
     * features into a single Tensor.
     * @param {any} images The URL(s) of the image(s) to extract features from.
     * @returns {Promise<Object>} An object containing the concatenated pixel values (and other metadata) of the preprocessed images.
     */async _call(n){Array.isArray(n)||(n=[n]);let r=await Promise.all(n.map(n=>this.preprocess(n)));return(// TODO:
// Concatenate pixel values
// TEMP: Add batch dimension so that concat works
r.forEach(n=>n.pixel_values.dims=[1,...n.pixel_values.dims]),{pixel_values:$970f59cad5f0fd6a$export$99aaa11fb71d263(r.map(n=>n.pixel_values)),// Original sizes of images
original_sizes:r.map(n=>n.original_size),// Reshaped sizes of images, before padding or cropping
reshaped_input_sizes:r.map(n=>n.reshaped_input_size)})}}class $3a884fd87742fa0d$export$4afb4715c32b59d7 extends $3a884fd87742fa0d$export$726912fcf6fe230e{}class $3a884fd87742fa0d$export$b27d2686902b5188 extends $3a884fd87742fa0d$export$726912fcf6fe230e{}class $3a884fd87742fa0d$export$fb138731fbe5b323 extends $3a884fd87742fa0d$export$726912fcf6fe230e{}class $3a884fd87742fa0d$export$5573be87c7e5565c extends $3a884fd87742fa0d$export$726912fcf6fe230e{}class $3a884fd87742fa0d$export$9dcdfee7b981cf25 extends $3a884fd87742fa0d$export$726912fcf6fe230e{}class $3a884fd87742fa0d$export$eb40888d5828a3b extends $3a884fd87742fa0d$export$726912fcf6fe230e{/**
     * Calls the feature extraction process on an array of image URLs, preprocesses
     * each image, and concatenates the resulting features into a single Tensor.
     * @param {any} urls The URL(s) of the image(s) to extract features from.
     * @returns {Promise<Object>} An object containing the concatenated pixel values of the preprocessed images.
     */async _call(n){let r=await super._call(n),i=[r.pixel_values.dims[0],64,64];return r.pixel_mask=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",new BigInt64Array(i.reduce((n,r)=>n*r)).fill(1n),i),r}/**
     * Post-processes the outputs of the model (for object detection).
     * @param {Object} outputs The outputs of the model that must be post-processed
     * @param {Tensor} outputs.logits The logits
     * @param {Tensor} outputs.pred_boxes The predicted boxes.
     * @return {Object[]} An array of objects containing the post-processed outputs.
     *//** @type {post_process_object_detection} */post_process_object_detection(...n){return $3a884fd87742fa0d$var$post_process_object_detection(...n)}/**
     * Binarize the given masks using `object_mask_threshold`, it returns the associated values of `masks`, `scores` and `labels`.
     * @param {Tensor} class_logits The class logits.
     * @param {Tensor} mask_logits The mask logits.
     * @param {number} object_mask_threshold A number between 0 and 1 used to binarize the masks.
     * @param {number} num_labels The number of labels.
     * @returns {[Tensor[], number[], number[]]} The binarized masks, the scores, and the labels.
     */remove_low_and_no_objects(n,r,i,a){let s=[],o=[],l=[];for(let u=0;u<n.dims[0];++u){let c=n[u],h=r[u],d=$821ef51da65e5775$export$8960430cfd85939f(c.data)[1];if(d===a)continue;let p=$821ef51da65e5775$export$e008137e76238601(c.data)[d];p>i&&(s.push(h),o.push(p),l.push(d))}return[s,o,l]}/**
     * Checks whether the segment is valid or not.
     * @param {Int32Array} mask_labels Labels for each pixel in the mask.
     * @param {Tensor[]} mask_probs Probabilities for each pixel in the masks.
     * @param {number} k The class id of the segment.
     * @param {number} mask_threshold The mask threshold.
     * @param {number} overlap_mask_area_threshold The overlap mask area threshold.
     * @returns {[boolean, number[]]} Whether the segment is valid or not, and the indices of the valid labels.
     */check_segment_validity(n,r,i,a=.5,s=.8){// mask_k is a 1D array of indices, indicating where the mask is equal to k
let o=[],l=0,u=0;// Compute the area of all the stuff in query k
for(let s=0;s<n.length;++s)n[s]===i&&(o.push(s),++l),r[i].data[s]>=a&&++u;let c=l>0&&u>0;return c&&(c=l/u>s),[c,o]}/**
     * Computes the segments.
     * @param {Tensor[]} mask_probs The mask probabilities.
     * @param {number[]} pred_scores The predicted scores.
     * @param {number[]} pred_labels The predicted labels.
     * @param {number} mask_threshold The mask threshold.
     * @param {number} overlap_mask_area_threshold The overlap mask area threshold.
     * @param {Set<number>} label_ids_to_fuse The label ids to fuse.
     * @param {number[]} target_size The target size of the image.
     * @returns {[Tensor, Array<{id: number, label_id: number, score: number}>]} The computed segments.
     */compute_segments(n,r,i,a,s,o=null,l=null){let[u,c]=l??n[0].dims,h=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int32",new Int32Array(u*c),[u,c]),d=[];// 1. If target_size is not null, we need to resize the masks to the target size
if(null!==l)for(let r=0;r<n.length;++r)n[r]=$970f59cad5f0fd6a$export$89e29e4ab65e70a9(n[r],l,"bilinear",!1);// 2. Weigh each mask by its prediction score
// NOTE: `mask_probs` is updated in-place
// 
// Temporary storage for the best label/scores for each pixel ([height, width]):
let p=new Int32Array(n[0].data.length),f=new Float32Array(n[0].data.length);for(let i=0;i<n.length;++i){let a=r[i];for(let r=0;r<n[i].data.length;++r)n[i].data[r]*=a,n[i].data[r]>f[r]&&(p[r]=i,f[r]=n[i].data[r])}let m=0;// let stuff_memory_list = {}
for(let o=0;o<i.length;++o){let l=i[o],[u,c]=this.check_segment_validity(p,n,o,a,s);if(u){// Add current object segment to final segmentation map
for(let n of(// TODO
// if (pred_class in stuff_memory_list) {
//     current_segment_id = stuff_memory_list[pred_class]
// } else {
//     current_segment_id += 1;
// }
++m,c))h.data[n]=m;d.push({id:m,label_id:l,// was_fused: should_fuse, TODO
score:r[o]})}// TODO
// if(should_fuse){
//     stuff_memory_list[pred_class] = current_segment_id
// }
}return[h,d]}/**
     * Post-process the model output to generate the final panoptic segmentation.
     * @param {*} outputs The model output to post process
     * @param {number} [threshold=0.5] The probability score threshold to keep predicted instance masks.
     * @param {number} [mask_threshold=0.5] Threshold to use when turning the predicted masks into binary values.
     * @param {number} [overlap_mask_area_threshold=0.8] The overlap mask area threshold to merge or discard small disconnected parts within each binary instance mask.
     * @param {Set<number>} [label_ids_to_fuse=null] The labels in this state will have all their instances be fused together.
     * @param {number[][]} [target_sizes=null] The target sizes to resize the masks to.
     * @returns {Array<{ segmentation: Tensor, segments_info: Array<{id: number, label_id: number, score: number}>}>}
     */post_process_panoptic_segmentation(n,r=.5,i=.5,a=.8,s=null,o=null){null===s&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),s=new Set);let l=n.logits,u=n.pred_masks,c=u.sigmoid()// [batch_size, num_queries, height, width]
,[h,d,p]=l.dims;// [batch_size, num_queries, num_classes+1]
if(p-=1,null!==o&&o.length!==h)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let f=[];for(let n=0;n<h;++n){let u=null!==o?o[n]:null,h=l[n],d=c[n],[m,g,_]=this.remove_low_and_no_objects(h,d,r,p);if(0===_.length){// No mask found
let[n,r]=u??d.dims.slice(-2),i=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int32",new Int32Array(n*r).fill(-1),[n,r]);f.push({segmentation:i,segments_info:[]});continue}// Get segmentation map and segment information of batch item
let[y,b]=this.compute_segments(m,g,_,i,a,s,u);f.push({segmentation:y,segments_info:b})}return f}post_process_instance_segmentation(){// TODO
throw Error("Not implemented yet")}}class $3a884fd87742fa0d$export$cd0f60300c3ec032 extends $3a884fd87742fa0d$export$726912fcf6fe230e{/** @type {post_process_object_detection} */post_process_object_detection(...n){return $3a884fd87742fa0d$var$post_process_object_detection(...n)}}class $3a884fd87742fa0d$export$5d80e50b016e2a3c extends $3a884fd87742fa0d$export$726912fcf6fe230e{async _call(n,r){let{pixel_values:i,original_sizes:a,reshaped_input_sizes:s}=await super._call(n),o=$2a81087eb92e3db1$export$da67e68efa508cf6(r);if(3===o.length)// Correct user's input
o=[1,...o],r=[r];else if(4!==o.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");// Reshape input points
for(let n=0;n<r.length;++n){let i=a[n],o=s[n],l=[o[0]/i[0],o[1]/i[1]];for(let i=0;i<r[n].length;++i)for(let a=0;a<r[n][i].length;++a)for(let s=0;s<r[n][i][a].length;++s)r[n][i][a][s]*=l[s]}// TODO: allowed to be floats?
// let input_points_tensor = new Tensor(
//     'float32',
//     Float32Array.from(input_points.flat(Infinity)),
//     shape
// )
return{pixel_values:i,original_sizes:a,reshaped_input_sizes:s,input_points:new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",BigInt64Array.from(r.flat(1/0).map(n=>BigInt(Math.round(n)))),o)}}/**
     * Remove padding and upscale masks to the original image size.
     * @param {Tensor} masks Batched masks from the mask_decoder in (batch_size, num_channels, height, width) format.
     * @param {number[][]} original_sizes The original sizes of each image before it was resized to the model's expected input shape, in (height, width) format.
     * @param {number[][]} reshaped_input_sizes The size of each image as it is fed to the model, in (height, width) format. Used to remove padding.
     * @param {Object} options Optional parameters for post-processing.
     * @param {number} [options.mask_threshold] The threshold to use for binarizing the masks.
     * @param {boolean} [options.binarize] Whether to binarize the masks.
     * @param {Object} [options.pad_size] The target size the images were padded to before being passed to the model. If `null`, the target size is assumed to be the processor's `pad_size`.
     * @param {number} [options.pad_size.height] The height the images were padded to.
     * @param {number} [options.pad_size.width] The width the images were padded to.
     * @returns {Tensor[]} Batched masks in batch_size, num_channels, height, width) format, where (height, width) is given by original_size.
     */post_process_masks(n,r,i,{mask_threshold:a=0,binarize:s=!0,pad_size:o=null}={}){// masks: [1, 1, 3, 256, 256]
let l=[],u=[(o=o??this.pad_size).height,o.width];for(let o=0;o<r.length;++o){let c=r[o],h=i[o],d=n[o],p=[];for(let n=0;n<d.dims[0];++n){// Upscale mask to padded size
let r=$970f59cad5f0fd6a$export$89e29e4ab65e70a9(d[n],u,"bilinear",!1);// Crop mask
r=r.slice(null,[0,h[0]],[0,h[1]]),// Downscale mask
r=$970f59cad5f0fd6a$export$89e29e4ab65e70a9(d,c,"bilinear",!1),s&&(r=new $970f59cad5f0fd6a$export$7b6b8d90402f8814("bool",Array.from(r.data).map(n=>n>a),r.dims)),// add back batch dim for concat
r.dims=[1,...r.dims],p.push(r)}let f=$970f59cad5f0fd6a$export$99aaa11fb71d263(p);l.push(f)}return l}}class $3a884fd87742fa0d$export$5c134f9e0216d2b6 extends $3a884fd87742fa0d$export$822ef4327cb692b3{constructor(n){super(n),// Prefer given `mel_filters` from preprocessor_config.json, or calculate them if they don't exist.
this.config.mel_filters??=$3beda6f332fbbafd$export$cffdaa17be32d63c(this.config.sampling_rate,this.config.n_fft,this.config.feature_size)}/**
     * Calculates the index offset for a given index and window size.
     * @param {number} i The index.
     * @param {number} w The window size.
     * @returns {number} The index offset.
     */calcOffset(n,r){return Math.abs((n+r)%(2*r)-r)}/**
     * Pads an array with a reflected version of itself on both ends.
     * @param {Float32Array} array The array to pad.
     * @param {number} left The amount of padding to add to the left.
     * @param {number} right The amount of padding to add to the right.
     * @returns {Float32Array} The padded array.
     */padReflect(n,r,i){let a=new Float32Array(n.length+r+i),s=n.length-1;for(let i=0;i<n.length;++i)a[r+i]=n[i];for(let i=1;i<=r;++i)a[r-i]=n[this.calcOffset(i,s)];for(let o=1;o<=i;++o)a[s+r+o]=n[this.calcOffset(s-o,s)];return a}/**
     * Calculates the complex Short-Time Fourier Transform (STFT) of the given framed signal.
     * 
     * @param {number[][]} frames A 2D array representing the signal frames.
     * @param {number[]} window A 1D array representing the window to be applied to the frames.
     * @returns {Object} An object with the following properties:
     * - data: A 1D array representing the complex STFT of the signal.
     * - dims: An array representing the dimensions of the STFT data, i.e. [num_frames, num_fft_bins].
     */stft(n,r){// Calculates the complex Short-Time Fourier Transform (STFT) of the given framed signal.
// 
// NOTE: Since the window width is not a power of 2, we must 
// perform Fast Fourier Transform with chirp-z transform:
// https://math.stackexchange.com/questions/77118/non-power-of-2-ffts/77156#77156
// Helper variables
let i=this.config.n_fft,a=2*(i-1),s=2*(2*i-1),o=2**Math.ceil(Math.log2(s)),l=i+2,u=new Float32Array(l*n.length),c=new Float32Array(s),h=new Float32Array(o),d=new Float32Array(o),p=new Float32Array(o),f=new Float32Array(o),m=new Float32Array(o),g=new Float32Array(o),_=-2*Math.PI/i,y=Math.cos(_),b=Math.sin(_);// Precompute helper for chirp-z transform
for(let n=0;n<s>>1;++n){// Compute complex power:
let r=(n+1-i)**2/2,a=Math.sqrt(y**2+b**2)**r,s=r*Math.atan2(b,y),o=2*n;c[o]=a*Math.cos(s),c[o+1]=a*Math.sin(s),// conjugate
h[o]=c[o],h[o+1]=-c[o+1]}let v=c.subarray(a,s),x=new $821ef51da65e5775$export$677347237c014ba(o>>1);// TODO: decide between Float32Array and Float64Array
x.transform(f,h);for(let i=0;i<n.length;++i){let s=n[i];for(let n=0;n<v.length;n+=2){let i=n+1,a=n>>1,o=s[a]*r[a];d[n]=o*v[n],d[i]=o*v[i]}// TODO: decide between Float32Array and Float64Array
x.transform(m,d);for(let n=0;n<f.length;n+=2){let r=n+1;p[n]=m[n]*f[n]-m[r]*f[r],p[r]=m[n]*f[r]+m[r]*f[n]}// TODO: decide between Float32Array and Float64Array
x.inverseTransform(g,p);let o=i*l;for(let n=0;n<l;n+=2){let r=g[n+a],i=g[n+a+1],s=v[n],l=v[n+1],c=o+n;u[c]=r*s-i*l,u[c+1]=r*l+i*s}}return{data:u,dims:[n.length,l]// [3001, 402]
}}/**
     * Creates an array of frames from a given waveform.
     *
     * @param {Float32Array} waveform The waveform to create frames from.
     * @param {boolean} [center=true] Whether to center the frames on their corresponding positions in the waveform. Defaults to true.
     * @returns {Array} An array of frames.
     */fram_wave(n,r=!0){let i=[],a=Math.floor((this.config.n_fft-1)/2)+1,s=n.length;for(let o=0;o<s+1;o+=this.config.hop_length){let l;if(r){let r=o>a?o-a:0,i=o<s-a?o+a:s;l=n.subarray(r,i),0===r?l=this.padReflect(l,-o+a,0):i===s&&(l=this.padReflect(l,0,o-s+a))}else{l=new Float32Array(this.config.n_fft);let r=n.subarray(o,o+this.config.n_fft);r.length<this.config.n_fft?(l.set(r),l.fill(0,r.length,this.config.n_fft)):l=r}i.push(l)}return i}/**
     * Generates a Hanning window of length M.
     *
     * @param {number} M The length of the Hanning window to generate.
     * @returns {*} The generated Hanning window.
     */hanning(n){if(n<1)return[];if(1===n)return[1];let r=n-1,i=new Float32Array(r);for(let a=0;a<r;++a){let s=2*a-n+1;i[a]=.5+.5*Math.cos(Math.PI*s/r)}return i}/**
     * Computes the log-Mel spectrogram of the provided audio waveform.
     * @param {Float32Array|Float64Array} waveform The audio waveform to process.
     * @returns {{data: Float32Array, dims: number[]}} An object containing the log-Mel spectrogram data as a Float32Array and its dimensions as an array of numbers.
     */_extract_fbank_features(n){// Compute the log-Mel spectrogram of the provided audio
let r=new Float32Array(this.config.n_samples);r.set(n);let i=this.hanning(this.config.n_fft+1),a=this.fram_wave(r),s=this.stft(a,i),o=s.data,l=s.dims[0]-1,u=s.dims[1]>>1,c=new Float32Array(l*u);for(let n=0;n<l;++n)for(let r=0;r<u;++r){// let outOffset = (j * d1 + i); // transpose
let i=n*u+r,a=i<<1,s=o[a]**2+o[a+1]**2;c[i]=s}let h=this.config.mel_filters,d=h.length,p=new Float32Array(d*l),f=0;// Perform matrix muliplication:
// mel_spec = filters @ magnitudes
//  - filters.shape=(80, 201)
//  - magnitudes.shape=(201, 3000)
//  - mel_spec.shape=(80, 3000)
for(let n=0;n<d;++n){let r=h[n];for(let n=0;n<l;++n){let i=0;// perform dot product
for(let a=0;a<u;++a)i+=r[a]*c[n*u+a];p[f++]=i}}let m=1e-10,g=new Float32Array(p.length),_=0;for(let n=0;n<p.length;++n){let r=Math.max(m,p[n]),i=Math.log10(r);g[n]=i,_=Math.max(i,_)}for(let n=0;n<g.length;++n)g[n]=Math.max(g[n],_-8),g[n]=(g[n]+4)/4;return{data:g,dims:[d,l]}}/**
     * Asynchronously extracts features from a given audio using the provided configuration.
     * @param {Float32Array|Float64Array} audio The audio data as a Float32Array/Float64Array.
     * @returns {Promise<{ input_features: Tensor }>} A Promise resolving to an object containing the extracted input features as a Tensor.
     */async _call(n){if(!(n instanceof Float32Array||n instanceof Float64Array))throw Error(`WhisperFeatureExtractor expects input to be a Float32Array or a Float64Array, but got ${n?.constructor?.name??typeof n} instead.If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`);n.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`.");let r=n.slice(0,this.config.n_samples),i=this._extract_fbank_features(r);return{input_features:new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",i.data,[1,...i.dims])}}}class $3a884fd87742fa0d$export$be889cdc479bd384 extends $3a884fd87742fa0d$export$822ef4327cb692b3{/**
     * @param {Float32Array} input_values 
     * @returns {Float32Array} 
     */_zero_mean_unit_var_norm(n){// TODO support batch?
let r=n.reduce((n,r)=>n+r,0),i=r/n.length,a=n.reduce((n,r)=>n+(r-i)**2,0)/n.length;return n.map(n=>(n-i)/Math.sqrt(a+1e-7))}/**
     * Asynchronously extracts features from a given audio using the provided configuration.
     * @param {Float32Array|Float64Array} audio The audio data as a Float32Array/Float64Array.
     * @returns {Promise<{ input_values: Tensor; attention_mask: Tensor }>} A Promise resolving to an object containing the extracted input features and attention mask as Tensors.
     */async _call(n){// TODO: remove duplication
if(!(n instanceof Float32Array||n instanceof Float64Array))throw Error(`Wav2Vec2FeatureExtractor expects input to be a Float32Array or a Float64Array, but got ${n?.constructor?.name??typeof n} instead.If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`);n instanceof Float64Array&&(n=new Float32Array(n));let r=n;// zero-mean and unit-variance normalization
this.config.do_normalize&&(r=this._zero_mean_unit_var_norm(r));// TODO: allow user to pass in attention mask
let i=[1,r.length];return{input_values:new $970f59cad5f0fd6a$export$7b6b8d90402f8814("float32",r,i),attention_mask:new $970f59cad5f0fd6a$export$7b6b8d90402f8814("int64",new BigInt64Array(r.length).fill(1n),i)}}}class $3a884fd87742fa0d$export$c30cd198d731db19 extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
     * Creates a new Processor with the given feature extractor.
     * @param {FeatureExtractor} feature_extractor The function used to extract features from the input.
     */constructor(n){super(),this.feature_extractor=n;// TODO use tokenizer here?
}/**
     * Calls the feature_extractor function with the given input.
     * @param {any} input The input to extract features from.
     * @returns {Promise<any>} A Promise that resolves with the extracted features.
     */async _call(n){return await this.feature_extractor(n)}}class $3a884fd87742fa0d$export$73a028ac33f06b48 extends $3a884fd87742fa0d$export$c30cd198d731db19{async _call(n,r){return await this.feature_extractor(n,r)}/**
     * @borrows SamImageProcessor#post_process_masks as post_process_masks
     */post_process_masks(...n){// @ts-ignore
return this.feature_extractor.post_process_masks(...n)}}class $3a884fd87742fa0d$export$ab1d081019fa08c2 extends $3a884fd87742fa0d$export$c30cd198d731db19{/**
     * Calls the feature_extractor function with the given audio input.
     * @param {any} audio The audio input to extract features from.
     * @returns {Promise<any>} A Promise that resolves with the extracted features.
     */async _call(n){return await this.feature_extractor(n)}}class $3a884fd87742fa0d$export$35a16a5f784d078a extends $3a884fd87742fa0d$export$c30cd198d731db19{/**
     * Calls the feature_extractor function with the given audio input.
     * @param {any} audio The audio input to extract features from.
     * @returns {Promise<any>} A Promise that resolves with the extracted features.
     */async _call(n){return await this.feature_extractor(n)}}class $3a884fd87742fa0d$export$b2e0e52fe0bda75f{static FEATURE_EXTRACTOR_CLASS_MAPPING={WhisperFeatureExtractor:$3a884fd87742fa0d$export$5c134f9e0216d2b6,ViTFeatureExtractor:$3a884fd87742fa0d$export$b27d2686902b5188,MobileViTFeatureExtractor:$3a884fd87742fa0d$export$fb138731fbe5b323,ConvNextFeatureExtractor:$3a884fd87742fa0d$export$4afb4715c32b59d7,BeitFeatureExtractor:$3a884fd87742fa0d$export$9dcdfee7b981cf25,DeiTFeatureExtractor:$3a884fd87742fa0d$export$5573be87c7e5565c,DetrFeatureExtractor:$3a884fd87742fa0d$export$eb40888d5828a3b,YolosFeatureExtractor:$3a884fd87742fa0d$export$cd0f60300c3ec032,SamImageProcessor:$3a884fd87742fa0d$export$5d80e50b016e2a3c,Wav2Vec2FeatureExtractor:$3a884fd87742fa0d$export$be889cdc479bd384};static PROCESSOR_CLASS_MAPPING={WhisperProcessor:$3a884fd87742fa0d$export$ab1d081019fa08c2,Wav2Vec2ProcessorWithLM:$3a884fd87742fa0d$export$35a16a5f784d078a,SamProcessor:$3a884fd87742fa0d$export$73a028ac33f06b48};/**
     * Instantiate one of the processor classes of the library from a pretrained model.
     * 
     * The processor class to instantiate is selected based on the `feature_extractor_type` property of the config object
     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)
     * 
     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:
     * - A string, the *model id* of a pretrained processor hosted inside a model repo on huggingface.co.
     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a
     *   user or organization name, like `dbmdz/bert-base-german-cased`.
     * - A path to a *directory* containing processor files, e.g., `./my_model_directory/`.
     * @param {PretrainedOptions} options Additional options for loading the processor.
     * 
     * @returns {Promise<Processor>} A new instance of the Processor class.
     */static async from_pretrained(n,{progress_callback:r=null,config:i=null,cache_dir:a=null,local_files_only:s=!1,revision:o="main"}={}){let l=i??await $fb1f2fa9752dcff4$export$bdb2295ec9595824(n,"preprocessor_config.json",!0,{progress_callback:r,config:i,cache_dir:a,local_files_only:s,revision:o}),u=l.feature_extractor_type??l.image_processor_type,c=this.FEATURE_EXTRACTOR_CLASS_MAPPING[u];if(!c){if(void 0!==l.size)// Assume ImageFeatureExtractor
console.warn("Feature extractor type not specified, assuming ImageFeatureExtractor due to size parameter in config."),c=$3a884fd87742fa0d$export$726912fcf6fe230e;else throw Error(`Unknown Feature Extractor type: ${l.feature_extractor_type}`)}// If no associated processor class, use default
let h=this.PROCESSOR_CLASS_MAPPING[l.processor_class]??$3a884fd87742fa0d$export$c30cd198d731db19,d=new c(l);return new h(d)}}//////////////////////////////////////////////////
/**
 * Prepare images for further tasks.
 * @param {any[]} images images to prepare.
 * @returns {Promise<any[]>} returns processed images.
 * @private
 */async function $5e970beb0c658454$var$prepareImages(n){return Array.isArray(n)||(n=[n]),// Possibly convert any non-images to images
n=await Promise.all(n.map(n=>$649b5a10055e0f2c$export$48705a6dac84618b.read(n)))}class $5e970beb0c658454$export$abd47b564b6c9ce2 extends $2a81087eb92e3db1$export$c2c029f59bc4b5e{/**
     * Create a new Pipeline.
     * @param {Object} options An object containing the following properties:
     * @param {string} [options.task] The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} [options.model] The model to use.
     * @param {PreTrainedTokenizer} [options.tokenizer=null] The tokenizer to use (if any).
     * @param {Processor} [options.processor=null] The processor to use (if any).
     */constructor({task:n,model:r,tokenizer:i=null,processor:a=null}){super(),this.task=n,this.model=r,this.tokenizer=i,this.processor=a}/**
     * Disposes the model.
     * @returns {Promise<void>} A promise that resolves when the model has been disposed.
     */async dispose(){await this.model.dispose()}/**
     * Executes the task associated with the pipeline.
     * @param {any} texts The input texts to be processed.
     * @param {...any} args Additional arguments.
     * @returns {Promise<any>} A promise that resolves to an array containing the inputs and outputs of the task.
     */async _call(n,...r){// Run tokenization
let i=this.tokenizer(n,{padding:!0,truncation:!0}),a=await this.model(i);return[i,a]}}class $5e970beb0c658454$export$186bcb8fa7d87f7f extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Executes the text classification task.
     * @param {any} texts The input texts to be classified.
     * @param {Object} options An optional object containing the following properties:
     * @param {number} [options.topk=1] The number of top predictions to be returned.
     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted labels and scores.
     */async _call(n,{topk:r=1}={}){// TODO: Use softmax tensor function
let i="multi_label_classification"===this.model.config.problem_type?n=>n.sigmoid().data:n=>$821ef51da65e5775$export$e008137e76238601(n.data),[a,s]=await super._call(n),o=this.model.config.id2label,l=[];// single_label_classification (default)
for(let n of s.logits){let a=$821ef51da65e5775$export$dd136ade76918e5b(i(n),r).map(function(n){return{label:o[n[0]],score:n[1]}});1===r?l.push(...a):l.push(a)}return Array.isArray(n)||1===r?l:l[0]}}class $5e970beb0c658454$export$bf440abe9be1bfae extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Executes the token classification task.
     * @param {any} texts The input texts to be classified.
     * @param {Object} options An optional object containing the following properties:
     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted labels and scores.
     */async _call(n,{ignore_labels:r=["O"]}={}){let i=Array.isArray(n);i||(n=[n]);let a=this.tokenizer,[s,o]=await super._call(n),l=o.logits,u=this.model.config.id2label,c=[];for(let n=0;n<l.dims[0];++n){let i=s.input_ids[n],o=l[n],h=[];for(let n=0;n<o.dims[0];++n){let s=o[n],l=$821ef51da65e5775$export$8960430cfd85939f(s.data)[1],c=u[l];if(r.includes(c))continue;// TODO add option to keep special tokens?
let d=a.decode([i[n].item()],{skip_special_tokens:!0});if(""===d)continue;let p=$821ef51da65e5775$export$e008137e76238601(s.data);h.push({entity:c,score:p[l],index:n,word:d,// TODO: null for now, but will add
start:null,end:null})}c.push(h)}return i?c:c[0]}}class $5e970beb0c658454$export$b6b65b11cfc9a3c1 extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Executes the question answering task.
     * @param {string|string[]} question The question(s) to be answered.
     * @param {string|string[]} context The context(s) where the answer(s) can be found.
     * @param {Object} options An optional object containing the following properties:
     * @param {number} [options.topk=1] The number of top answer predictions to be returned.
     * @returns {QuestionAnsweringReturnType} A promise that resolves to an array or object
     * containing the predicted answers and scores.
     */async _call(n,r,{topk:i=1}={}){// Run tokenization
let a=this.tokenizer(n,{text_pair:r,padding:!0,truncation:!0}),s=await this.model(a),o=[];for(let n=0;n<s.start_logits.dims[0];++n){let r=a.input_ids[n],l=r.indexOf(this.tokenizer.sep_token_id),u=$2a81087eb92e3db1$export$dbd0f18357df1ddd(Array.from($821ef51da65e5775$export$e008137e76238601(s.start_logits[n].data)).map((n,r)=>[n,r]).filter(n=>n[1]>l),Array.from($821ef51da65e5775$export$e008137e76238601(s.end_logits[n].data)).map((n,r)=>[n,r]).filter(n=>n[1]>l)).filter(n=>n[0][1]<=n[1][1]).map(n=>[n[0][1],n[1][1],n[0][0]*n[1][0]]).sort((n,r)=>r[2]-n[2]);for(let n=0;n<Math.min(u.length,i);++n){let[i,a,s]=u[n],l=[...r].slice(i,a+1),c=this.tokenizer.decode(l,{skip_special_tokens:!0});// TODO add start and end?
// NOTE: HF returns character index
o.push({answer:c,score:s})}}// Mimic HF's return type based on topk
return 1===i?o[0]:o}}class $5e970beb0c658454$export$14aa29edf8895a8 extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Fill the masked token in the text(s) given as inputs.
     * @param {any} texts The masked input texts.
     * @param {Object} options An optional object containing the following properties:
     * @param {number} [options.topk=5] The number of top predictions to be returned.
     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted tokens and scores.
     */async _call(n,{topk:r=5}={}){// Run tokenization
let[i,a]=await super._call(n),s=this.tokenizer,o=[];for(let n=0;n<i.input_ids.dims[0];++n){let l=i.input_ids[n],u=l.indexOf(this.tokenizer.mask_token_id);if(-1===u)throw Error(`Mask token (${s.mask_token}) not found in text.`);let c=$821ef51da65e5775$export$dd136ade76918e5b($821ef51da65e5775$export$e008137e76238601(a.logits[n][u].data),r);o.push(c.map(n=>{let r=[...l];return r[u]=n[0],{score:n[1],token:n[0],token_str:s.model.vocab[n[0]],sequence:s.decode(r,{skip_special_tokens:!0})}}))}return Array.isArray(n)?o:o[0]}}class $5e970beb0c658454$export$29f9a60e32392df2 extends $5e970beb0c658454$export$abd47b564b6c9ce2{_key=null;/**
     * Fill the masked token in the text(s) given as inputs.
     * @param {string|string[]} texts The text or array of texts to be processed.
     * @param {Object} [options={}] Options for the fill-mask pipeline.
     * @param {number} [options.topk=5] The number of top-k predictions to return.
     * @returns {Promise<any>} An array of objects containing the score, predicted token, predicted token string,
     * and the sequence with the predicted token filled in, or an array of such arrays (one for each input text).
     * If only one input text is given, the output will be an array of objects.
     * @throws {Error} When the mask token is not found in the input text.
     */async _call(n,r={}){let i;Array.isArray(n)||(n=[n]),this.model.config.prefix&&(n=n.map(n=>this.model.config.prefix+n));// Handle task specific params:
let a=this.model.config.task_specific_params;a&&a[this.task]&&a[this.task].prefix&&(n=n.map(n=>a[this.task].prefix+n));let s={padding:!0,truncation:!0};// Currently put here to avoid code duplication
// @ts-ignore
i=this instanceof $5e970beb0c658454$export$dac6385642a14901&&"_build_translation_inputs"in this.tokenizer?this.tokenizer._build_translation_inputs(n,s,r).input_ids:this.tokenizer(n,s).input_ids;let o=await this.model.generate(i,r),l=this.tokenizer.batch_decode(o,{skip_special_tokens:!0});return null!==this._key&&(l=l.map(n=>null===this._key?n:{[this._key]:n})),l}}class $5e970beb0c658454$export$abfbe9745aa2ee05 extends $5e970beb0c658454$export$29f9a60e32392df2{_key="summary_text"}class $5e970beb0c658454$export$dac6385642a14901 extends $5e970beb0c658454$export$29f9a60e32392df2{_key="translation_text"}class $5e970beb0c658454$export$f2fffa9ce762851a extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Generates text based on an input prompt.
     * @param {any} texts The input prompt or prompts to generate text from.
     * @param {Object} [generate_kwargs={}] Additional arguments for text generation.
     * @returns {Promise<any>} The generated text or texts.
     */async _call(n,r={}){let i="string"==typeof n||n instanceof String;i&&(n=[n]),this.tokenizer.padding_side="left";let a=this.tokenizer(n,{padding:!0,truncation:!0}),s=a.input_ids,o=a.attention_mask,l=await this.model.generate(s,r,null,{inputs_attention_mask:o}),u=this.tokenizer.batch_decode(l,{skip_special_tokens:!0}),c=Array.from({length:n.length},n=>[]);for(let r=0;r<u.length;++r){let i=Math.floor(r/l.length*n.length);c[i].push({generated_text:u[r]})}return i&&1===c.length?c[0]:c}}class $5e970beb0c658454$export$95e2a681318a0939 extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Create a new ZeroShotClassificationPipeline.
     * @param {Object} options An object containing the following properties:
     * @param {string} [options.task] The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} [options.model] The model to use.
     * @param {PreTrainedTokenizer} [options.tokenizer] The tokenizer to use.
     */constructor(n){super(n),// Use model config to get label2id mapping
this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([n,r])=>[n.toLowerCase(),r])),this.entailment_id=this.label2id.entailment,void 0===this.entailment_id&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,void 0===this.contradiction_id&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}/**
     * @param {any[]} texts
     * @param {string[]} candidate_labels
     * @param {Object} options Additional options:
     * @param {string} [options.hypothesis_template="This example is {}."] The template used to turn each
     * candidate label into an NLI-style hypothesis. The candidate label will replace the {} placeholder.
     * @param {boolean} [options.multi_label=false] Whether or not multiple candidate labels can be true.
     * If `false`, the scores are normalized such that the sum of the label likelihoods for each sequence
     * is 1. If `true`, the labels are considered independent and probabilities are normalized for each
     * candidate by doing a softmax of the entailment score vs. the contradiction score.
     * @return {Promise<Object|Object[]>} The prediction(s), as a map (or list of maps) from label to score.
     */async _call(n,r,{hypothesis_template:i="This example is {}.",multi_label:a=!1}={}){let s=Array.isArray(n);s||(n=[n]),Array.isArray(r)||(r=[r]);// Insert labels into hypothesis template
let o=r.map(n=>i.replace("{}",n)),l=a||1===r.length,u=[];for(let i of n){let n,a=[];for(let n of o){let r=this.tokenizer(i,{text_pair:n,padding:!0,truncation:!0}),s=await this.model(r);l?a.push([s.logits.data[this.contradiction_id],s.logits.data[this.entailment_id]]):a.push(s.logits.data[this.entailment_id])}// Sort by scores (desc) and return scores with indices
let s=(n=l?a.map(n=>$821ef51da65e5775$export$e008137e76238601(n)[1]):$821ef51da65e5775$export$e008137e76238601(a)).map((n,r)=>[n,r]).sort((n,r)=>r[0]-n[0]);u.push({sequence:i,labels:s.map(n=>r[n[1]]),scores:s.map(n=>n[0])})}return s?u:u[0]}}class $5e970beb0c658454$export$f0fec92a655c398c extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Extract the features of the input(s).
     * 
     * @param {string|string[]} texts The input texts
     * @param {Object} options Additional options:
     * @param {string} [options.pooling="none"] The pooling method to use. Can be one of: "none", "mean".
     * @param {boolean} [options.normalize=false] Whether or not to normalize the embeddings in the last dimension.
     * @returns The features computed by the model.
     */async _call(n,{pooling:r="none",normalize:i=!1}={}){let[a,s]=await super._call(n),o=s.last_hidden_state??s.logits;if("none"===r);else if("mean"===r)o=$970f59cad5f0fd6a$export$821ee5c568efc6b5(o,a.attention_mask);else throw Error(`Pooling method '${r}' not supported.`);return i&&(o=o.normalize(2,-1)),o}}class $5e970beb0c658454$export$d947c0535734e79e extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Create a new AudioClassificationPipeline.
     * @param {Object} options An object containing the following properties:
     * @param {string} [options.task] The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} [options.model] The model to use.
     * @param {Processor} [options.processor] The processor to use.
     */constructor(n){super(n)}/**
     * Preprocesses the input audio for the AutomaticSpeechRecognitionPipeline.
     * @param {any} audio The audio to be preprocessed.
     * @param {number} sampling_rate The sampling rate of the audio.
     * @returns {Promise<Float32Array>} A promise that resolves to the preprocessed audio data.
     * @private
     */async _preprocess(n,r){return $2a81087eb92e3db1$export$844ec244b1367d54(n)&&(n=await $3beda6f332fbbafd$export$db0a86f80e297540(n,r)),n}/**
     * Executes the audio classification task.
     * @param {any} audio The input audio files to be classified.
     * @param {Object} options An optional object containing the following properties:
     * @param {number} [options.topk=5] The number of top predictions to be returned.
     * @returns {Promise<Object[]|Object>} A promise that resolves to an array or object containing the predicted labels and scores.
     */async _call(n,{topk:r=5}={}){let i=!Array.isArray(n);i&&(n=[n]);let a=this.model.config.id2label,s=this.processor.feature_extractor.config.sampling_rate,o=[];for(let i of n){i=await this._preprocess(i,s);let n=await this.processor(i),l=await this.model(n),u=l.logits[0],c=$821ef51da65e5775$export$dd136ade76918e5b($821ef51da65e5775$export$e008137e76238601(u.data),r).map(function(n){return{label:a[n[0]],score:n[1]}});1===r?o.push(...c):o.push(c)}return i&&1!==r?o[0]:o}}class $5e970beb0c658454$export$9daf391557fc3de4 extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Create a new AutomaticSpeechRecognitionPipeline.
     * @param {Object} options An object containing the following properties:
     * @param {string} [options.task] The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} [options.model] The model to use.
     * @param {PreTrainedTokenizer} [options.tokenizer] The tokenizer to use.
     * @param {Processor} [options.processor] The processor to use.
     */constructor(n){super(n)}/**
     * Preprocesses the input audio for the AutomaticSpeechRecognitionPipeline.
     * @param {any} audio The audio to be preprocessed.
     * @param {number} sampling_rate The sampling rate of the audio.
     * @returns {Promise<Float32Array>} A promise that resolves to the preprocessed audio data.
     * @private
     */async _preprocess(n,r){return $2a81087eb92e3db1$export$844ec244b1367d54(n)&&(n=await $3beda6f332fbbafd$export$db0a86f80e297540(n,r)),n}/**
     * @typedef {import('./utils/tensor.js').Tensor} Tensor
     * @typedef {{stride: number[], input_features: Tensor, is_last: boolean, tokens?: number[], token_timestamps?: number[]}} Chunk
     * 
     * @callback ChunkCallback
     * @param {Chunk} chunk The chunk to process.
     *//**
     * Asynchronously processes audio and generates text transcription using the model.
     * @param {Float32Array|Float32Array[]} audio The audio to be transcribed. Can be a single Float32Array or an array of Float32Arrays.
     * @param {Object} [kwargs={}] Optional arguments.
     * @param {boolean|'word'} [kwargs.return_timestamps] Whether to return timestamps or not. Default is `false`.
     * @param {number} [kwargs.chunk_length_s] The length of audio chunks to process in seconds. Default is 0 (no chunking).
     * @param {number} [kwargs.stride_length_s] The length of overlap between consecutive audio chunks in seconds. If not provided, defaults to `chunk_length_s / 6`.
     * @param {ChunkCallback} [kwargs.chunk_callback] Callback function to be called with each chunk processed.
     * @param {boolean} [kwargs.force_full_sequences] Whether to force outputting full sequences or not. Default is `false`.
     * @param {string} [kwargs.language] The source language. Default is `null`, meaning it should be auto-detected. Use this to potentially improve performance if the source language is known.
     * @param {string} [kwargs.task] The task to perform. Default is `null`, meaning it should be auto-detected.
     * @param {number[][]} [kwargs.forced_decoder_ids] A list of pairs of integers which indicates a mapping from generation indices to token indices
     * that will be forced before sampling. For example, [[1, 123]] means the second generated token will always be a token of index 123.
     * @returns {Promise<Object>} A Promise that resolves to an object containing the transcription text and optionally timestamps if `return_timestamps` is `true`.
     */async _call(n,r={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(n,r);case"wav2vec2":return this._call_wav2vec2(n,r);default:throw Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}/** @private */async _call_wav2vec2(n,r={}){r.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),r.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');let i=!Array.isArray(n);i&&(n=[n]);let a=this.processor.feature_extractor.config.sampling_rate,s=[];for(let r of n){r=await this._preprocess(r,a);let n=await this.processor(r),i=await this.model(n),o=i.logits[0],l=[];for(let n of o)l.push($821ef51da65e5775$export$8960430cfd85939f(n.data)[1]);let u=this.tokenizer.decode(l);s.push({text:u})}return i?s[0]:s}/** @private */async _call_whisper(n,r={}){let i=r.return_timestamps??!1,a=r.chunk_length_s??0,s=r.stride_length_s??null,o=r.chunk_callback??null,l=r.force_full_sequences??!1;"word"===i&&(r.return_token_timestamps=!0);let u=$2a81087eb92e3db1$export$3e41007ebfff0e64(r,"language",null),c=$2a81087eb92e3db1$export$3e41007ebfff0e64(r,"task",null);if(u||c||i){if(r.forced_decoder_ids)throw Error("Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time.");// @ts-ignore
let n=this.tokenizer.get_decoder_prompt_ids({language:u,task:c,no_timestamps:!i});n.length>0&&(r.forced_decoder_ids=n)}let h=!Array.isArray(n);h&&(n=[n]);let d=this.processor.feature_extractor.config.sampling_rate,p=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,f=this.processor.feature_extractor.config.hop_length,m=[];for(let u of n){u=await this._preprocess(u,d);/** @type {Chunk[]} */let n=[];if(a>0){if(null===s)s=a/6;else if(a<=s)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");// TODO support different stride_length_s (for left and right)
let r=d*a,i=d*s,o=r-2*i,l=0;// Create subarrays of audio with overlaps
for(;l<u.length;){let a=u.subarray(l,l+r),s=await this.processor(a),c=0===l,h=l+o>=u.length;n.push({stride:[a.length,c?0:i,h?0:i],input_features:s.input_features,is_last:h}),l+=o}}else n=[{stride:[u.length,0,0],input_features:(await this.processor(u)).input_features,is_last:!0}];// Generate for each set of input features
for(let a of n){r.num_frames=Math.floor(a.stride[0]/f);// NOTE: doing sequentially for now
let n=await this.model.generate(a.input_features,r);"word"===i?(a.tokens=n.sequences[0],a.token_timestamps=n.token_timestamps.tolist()[0].map(n=>$821ef51da65e5775$export$2077e0241d6afd3c(n,2))):a.tokens=n[0],// convert stride to seconds
a.stride=a.stride.map(n=>n/d),null!==o&&o(a)}// Merge text chunks
// @ts-ignore
let[c,h]=this.tokenizer._decode_asr(n,{time_precision:p,return_timestamps:i,force_full_sequences:l});m.push({text:c,...h})}return h?m[0]:m}}class $5e970beb0c658454$export$435b7e664689d22 extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Create a new ImageToTextPipeline.
     * @param {Object} options An object containing the following properties:
     * @param {string} [options.task] The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} [options.model] The model to use.
     * @param {PreTrainedTokenizer} [options.tokenizer] The tokenizer to use.
     * @param {Processor} [options.processor] The processor to use.
     */constructor(n){super(n)}/**
     * Assign labels to the image(s) passed as inputs.
     * @param {any[]} images The images to be captioned.
     * @param {Object} [generate_kwargs={}] Optional generation arguments.
     * @returns {Promise<Object|Object[]>} A Promise that resolves to an object (or array of objects) containing the generated text(s).
     */async _call(n,r={}){let i=Array.isArray(n);n=await $5e970beb0c658454$var$prepareImages(n);let{pixel_values:a}=await this.processor(n),s=[];for(let n of a){n.dims=[1,...n.dims];let i=await this.model.generate(n,r),a=this.tokenizer.batch_decode(i,{skip_special_tokens:!0}).map(n=>({generated_text:n.trim()}));s.push(a)}return i?s:s[0]}}class $5e970beb0c658454$export$2ad9734e62a1f8b extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Create a new ImageClassificationPipeline.
     * @param {Object} options An object containing the following properties:
     * @param {string} [options.task] The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} [options.model] The model to use.
     * @param {Processor} [options.processor] The processor to use.
     */constructor(n){super(n)}/**
     * Classify the given images.
     * @param {any} images The images to classify.
     * @param {Object} options The options to use for classification.
     * @param {number} [options.topk=1] The number of top results to return.
     * @returns {Promise<any>} The top classification results for the images.
     */async _call(n,{topk:r=1}={}){let i=Array.isArray(n);n=await $5e970beb0c658454$var$prepareImages(n);let{pixel_values:a}=await this.processor(n),s=await this.model({pixel_values:a}),o=this.model.config.id2label,l=[];for(let n of s.logits){let i=$821ef51da65e5775$export$dd136ade76918e5b($821ef51da65e5775$export$e008137e76238601(n.data),r).map(function(n){return{label:o[n[0]],score:n[1]}});1===r?l.push(...i):l.push(i)}return i||1===r?l:l[0]}}class $5e970beb0c658454$export$dbfec244e90741b6 extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Create a new ImageSegmentationPipeline.
     * @param {Object} options An object containing the following properties:
     * @param {string} [options.task] The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} [options.model] The model to use.
     * @param {Processor} [options.processor] The processor to use.
     */constructor(n){super(n),this.subtasks_mapping={// Mapping of subtasks to their corresponding post-processing function names.
panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}/**
     * Segment the input images.
     * @param {Array} images The input images.
     * @param {Object} options The options to use for segmentation.
     * @param {number} [options.threshold=0.5] Probability threshold to filter out predicted masks.
     * @param {number} [options.mask_threshold=0.5] Threshold to use when turning the predicted masks into binary values.
     * @param {number} [options.overlap_mask_area_threshold=0.8] Mask overlap threshold to eliminate small, disconnected segments.
     * @param {null|string} [options.subtask=null] Segmentation task to be performed. One of [`panoptic`, `instance`, and `semantic`], depending on model capabilities. If not set, the pipeline will attempt to resolve (in that order).
     * @param {Array} [options.label_ids_to_fuse=null] List of label ids to fuse. If not set, do not fuse any labels.
     * @param {Array} [options.target_sizes=null] List of target sizes for the input images. If not set, use the original image sizes.
     * @returns {Promise<Array>} The annotated segments.
     */async _call(n,{threshold:r=.5,mask_threshold:i=.5,overlap_mask_area_threshold:a=.8,label_ids_to_fuse:s=null,target_sizes:o=null,subtask:l=null}={}){if(Array.isArray(n)&&1!==n.length)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");let u=(n=await $5e970beb0c658454$var$prepareImages(n)).map(n=>[n.height,n.width]),{pixel_values:c,pixel_mask:h}=await this.processor(n),d=await this.model({pixel_values:c,pixel_mask:h}),p=null;if(null!==l)p=this.subtasks_mapping[l];else for(let[n,r]of Object.entries(this.subtasks_mapping))if(r in this.processor.feature_extractor){p=this.processor.feature_extractor[r].bind(this.processor.feature_extractor),l=n;break}// add annotations
let f=[];if("panoptic"===l||"instance"===l){let n=p(d,r,i,a,s,o??u)[0],l=n.segmentation,c=this.model.config.id2label;for(let r of n.segments_info){let n=new Uint8ClampedArray(l.data.length);for(let i=0;i<l.data.length;++i)l.data[i]===r.id&&(n[i]=255);let i=new $649b5a10055e0f2c$export$48705a6dac84618b(n,l.dims[1],l.dims[0],1);f.push({score:r.score,label:c[r.label_id],mask:i})}}else if("semantic"===l)throw Error("semantic segmentation not yet supported.");else throw Error(`Subtask ${l} not supported.`);return f}}class $5e970beb0c658454$export$af7b358b81004776 extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Create a new ZeroShotImageClassificationPipeline.
     * @param {Object} options An object containing the following properties:
     * @param {string} [options.task] The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} [options.model] The model to use.
     * @param {PreTrainedTokenizer} [options.tokenizer] The tokenizer to use.
     * @param {Processor} [options.processor] The processor to use.
     */constructor(n){super(n)}/**
     * Classify the input images with candidate labels using a zero-shot approach.
     * @param {Array} images The input images.
     * @param {string[]} candidate_labels The candidate labels.
     * @param {Object} options The options for the classification.
     * @param {string} [options.hypothesis_template] The hypothesis template to use for zero-shot classification. Default: "This is a photo of {}".
     * @returns {Promise<any>} An array of classifications for each input image or a single classification object if only one input image is provided.
     */async _call(n,r,{hypothesis_template:i="This is a photo of {}"}={}){let a=Array.isArray(n);n=await $5e970beb0c658454$var$prepareImages(n);// Insert label into hypothesis template 
let s=r.map(n=>i.replace("{}",n)),o=this.tokenizer(s,{padding:!0,truncation:!0}),{pixel_values:l}=await this.processor(n),u=await this.model({...o,pixel_values:l}),c=[];for(let n of u.logits_per_image){// Compute softmax per image
let i=$821ef51da65e5775$export$e008137e76238601(n.data);c.push([...i].map((n,i)=>({score:n,label:r[i]})))}return a?c:c[0]}}class $5e970beb0c658454$export$3910cf3d8da829d0 extends $5e970beb0c658454$export$abd47b564b6c9ce2{/**
     * Create a new ObjectDetectionPipeline.
     * @param {Object} options An object containing the following properties:
     * @param {string} [options.task] The task of the pipeline. Useful for specifying subtasks.
     * @param {PreTrainedModel} [options.model] The model to use.
     * @param {Processor} [options.processor] The processor to use.
     */constructor(n){super(n)}/**
     * Detect objects (bounding boxes & classes) in the image(s) passed as inputs.
     * @param {any[]} images The input images.
     * @param {Object} options The options for the object detection.
     * @param {number} [options.threshold=0.9] The threshold used to filter boxes by score.
     * @param {boolean} [options.percentage=false] Whether to return the boxes coordinates in percentage (true) or in pixels (false).
     */async _call(n,{threshold:r=.9,percentage:i=!1}={}){let a=Array.isArray(n);if(a&&1!==n.length)throw Error("Object detection pipeline currently only supports a batch size of 1.");n=await $5e970beb0c658454$var$prepareImages(n);let s=i?null:n.map(n=>[n.height,n.width]),{pixel_values:o,pixel_mask:l}=await this.processor(n),u=await this.model({pixel_values:o,pixel_mask:l}),c=this.processor.feature_extractor.post_process_object_detection(u,r,s),h=this.model.config.id2label,d=c.map(n=>n.boxes.map((r,a)=>({score:n.scores[a],label:h[n.classes[a]],box:this._get_bounding_box(r,!i)})));return a?d:d[0]}/**
     * Helper function to convert list [xmin, xmax, ymin, ymax] into object { "xmin": xmin, ... }
     * @param {number[]} box The bounding box as a list.
     * @param {boolean} asInteger Whether to cast to integers.
     * @returns {Object} The bounding box as an object.
     * @private
     */_get_bounding_box(n,r){r&&(n=n.map(n=>0|n));let[i,a,s,o]=n;return{xmin:i,ymin:a,xmax:s,ymax:o}}}const $5e970beb0c658454$var$SUPPORTED_TASKS={"text-classification":{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$186bcb8fa7d87f7f,model:$16c3c01c3acb118d$export$e461000f728f0696,default:{// TODO: replace with original
// "model": "distilbert-base-uncased-finetuned-sst-2-english",
model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$bf440abe9be1bfae,model:$16c3c01c3acb118d$export$1d56993e9c54b4ba,default:{// TODO: replace with original
// "model": "Davlan/bert-base-multilingual-cased-ner-hrl",
model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$b6b65b11cfc9a3c1,model:$16c3c01c3acb118d$export$9cbe7fafb702bbbf,default:{// TODO: replace with original
// "model": "distilbert-base-cased-distilled-squad",
model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$14aa29edf8895a8,model:$16c3c01c3acb118d$export$41a6f7c951809cc2,default:{// TODO: replace with original
// "model": "bert-base-uncased",
model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$abfbe9745aa2ee05,model:$16c3c01c3acb118d$export$aa0088088f56c92d,default:{// TODO: replace with original
// "model": "sshleifer/distilbart-cnn-6-6",
model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$dac6385642a14901,model:$16c3c01c3acb118d$export$aa0088088f56c92d,default:{// TODO: replace with original
// "model": "t5-small",
model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$29f9a60e32392df2,model:$16c3c01c3acb118d$export$aa0088088f56c92d,default:{// TODO: replace with original
// "model": "google/flan-t5-small",
model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$f2fffa9ce762851a,model:$16c3c01c3acb118d$export$ffaa33dde44939bd,default:{// TODO: replace with original
// "model": "gpt2",
model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$95e2a681318a0939,model:$16c3c01c3acb118d$export$e461000f728f0696,default:{// TODO: replace with original
// "model": "typeform/distilbert-base-uncased-mnli",
model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:$5e970beb0c658454$export$d947c0535734e79e,model:$16c3c01c3acb118d$export$8a991c65f3aa09b0,processor:$3a884fd87742fa0d$export$b2e0e52fe0bda75f,default:{// TODO: replace with original
// "model": "superb/wav2vec2-base-superb-ks",
model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"automatic-speech-recognition":{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$9daf391557fc3de4,model:[$16c3c01c3acb118d$export$aa0088088f56c92d,$16c3c01c3acb118d$export$bf1253060dfae3c7],processor:$3a884fd87742fa0d$export$b2e0e52fe0bda75f,default:{// TODO: replace with original
// "model": "openai/whisper-tiny.en",
model:"Xenova/whisper-tiny.en"},type:"multimodal"},"image-to-text":{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$435b7e664689d22,model:$16c3c01c3acb118d$export$f8d9df114bc3682a,processor:$3a884fd87742fa0d$export$b2e0e52fe0bda75f,default:{// TODO: replace with original
// "model": "nlpconnect/vit-gpt2-image-captioning",
model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{// no tokenizer
pipeline:$5e970beb0c658454$export$2ad9734e62a1f8b,model:$16c3c01c3acb118d$export$71d41439e591a26a,processor:$3a884fd87742fa0d$export$b2e0e52fe0bda75f,default:{// TODO: replace with original
// "model": "google/vit-base-patch16-224",
model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{// no tokenizer
pipeline:$5e970beb0c658454$export$dbfec244e90741b6,model:$16c3c01c3acb118d$export$3b14fa9611967836,processor:$3a884fd87742fa0d$export$b2e0e52fe0bda75f,default:{// TODO: replace with original
// "model": "facebook/detr-resnet-50-panoptic",
model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{// no tokenizer
tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$af7b358b81004776,model:$16c3c01c3acb118d$export$5377acb7b84ca903,processor:$3a884fd87742fa0d$export$b2e0e52fe0bda75f,default:{// TODO: replace with original
// "model": "openai/clip-vit-base-patch32",
model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{// no tokenizer
pipeline:$5e970beb0c658454$export$3910cf3d8da829d0,model:$16c3c01c3acb118d$export$c452f8980228d5,processor:$3a884fd87742fa0d$export$b2e0e52fe0bda75f,default:{// TODO: replace with original
// "model": "facebook/detr-resnet-50",
model:"Xenova/detr-resnet-50"},type:"multimodal"},// This task serves as a useful interface for dealing with sentence-transformers (https://huggingface.co/sentence-transformers).
"feature-extraction":{tokenizer:$a6a9715ee3096371$export$44e1b760ef6acae4,pipeline:$5e970beb0c658454$export$f0fec92a655c398c,model:$16c3c01c3acb118d$export$5377acb7b84ca903,default:{// TODO: replace with original
// "model": "sentence-transformers/all-MiniLM-L6-v2",
model:"Xenova/all-MiniLM-L6-v2"},type:"text"}},$5e970beb0c658454$var$TASK_ALIASES={"sentiment-analysis":"text-classification",ner:"token-classification",vqa:"visual-question-answering",asr:"automatic-speech-recognition",// Add for backwards compatibility
embeddings:"feature-extraction"};async function $5e970beb0c658454$export$43f28b24e1eb8181(n,r=null,{quantized:i=!0,progress_callback:a=null,config:s=null,cache_dir:o=null,local_files_only:l=!1,revision:u="main"}={}){// Get pipeline info
let c=$5e970beb0c658454$var$SUPPORTED_TASKS[// Helper method to construct pipeline
// Apply aliases
(n=$5e970beb0c658454$var$TASK_ALIASES[n]??n).split("_",1)[0]];if(!c)throw Error(`Unsupported pipeline: ${n}. Must be one of [${Object.keys($5e970beb0c658454$var$SUPPORTED_TASKS)}]`);r||(r=c.default.model,console.log(`No model specified. Using default model: "${r}".`));let h={quantized:i,progress_callback:a,config:s,cache_dir:o,local_files_only:l,revision:u},d=new Map([["tokenizer",c.tokenizer],["model",c.model],["processor",c.processor]]),p=await $5e970beb0c658454$var$loadItems(d,r,h);return p.task=n,$2a81087eb92e3db1$export$184fc9ac8342b224(a,{status:"ready",task:n,model:r}),new c.pipeline(p)}/**
 * Helper function to get applicable model, tokenizer, or processor classes for a given model.
 * @param {Map<string, any>} mapping The mapping of names to classes, arrays of classes, or null.
 * @param {string} model The name of the model to load.
 * @param {PretrainedOptions} pretrainedOptions The options to pass to the `from_pretrained` method.
 * @private
 */async function $5e970beb0c658454$var$loadItems(n,r,i){let a=Object.create(null),s=[];for(let[o,l]of n.entries()){let n;l&&(n=Array.isArray(l)?new Promise(async(n,a)=>{let s;for(let a of l)try{n(await a.from_pretrained(r,i));return}catch(n){s=n}a(s)}):l.from_pretrained(r,i),a[o]=n,s.push(n))}// Then assign to result
for(let[n,r]of(// Wait for all promises to resolve (in parallel)
await Promise.all(s),Object.entries(a)))a[n]=await r;return a}// EMBEDDING GENERATION
// ----------------------------------------------------------------------------------
// Create a pipeline with the feature-extraction and gte-small components
const $1924ca1b0c205a21$var$pipe=await $5e970beb0c658454$export$43f28b24e1eb8181("feature-extraction","Supabase/gte-small");async function $1924ca1b0c205a21$var$generateEmbedding(n){// Generate the embedding from text
let r=await $1924ca1b0c205a21$var$pipe(n,{pooling:"mean",normalize:!0}),i=Array.from(r.data);return i}function $1924ca1b0c205a21$var$getMostSimilarEmbedding(n,r,i=.93){let a=-1,s=-1;// ref_embeddings is a dictionary
for(let[i,o]of Object.entries(r))for(let r of o){let o=$821ef51da65e5775$export$e9049d21b83f6c89(n,r);o>a&&(a=o,s=i)}return(console.log(a),a<i)?"unknown":s}// INPUT TEXT
// ----------------------------------------------------------------------------------
const $1924ca1b0c205a21$var$inputText=document.getElementById("inputText");let $1924ca1b0c205a21$var$embeddings,$1924ca1b0c205a21$var$lang="en",$1924ca1b0c205a21$var$audioIsPlaying=!1;async function $1924ca1b0c205a21$var$askQuestion(n){if(""==n)return $1924ca1b0c205a21$var$inputText.disabled=!1,!1;if(!0==$1924ca1b0c205a21$var$audioIsPlaying)return!1;$1924ca1b0c205a21$var$lang=$1924ca1b0c205a21$var$getCurrentLanguage();try{$1924ca1b0c205a21$var$inputText.disabled=!0,$1924ca1b0c205a21$var$inputText.value=n;let r=await $1924ca1b0c205a21$var$generateEmbedding(n),i=$1924ca1b0c205a21$var$getMostSimilarEmbedding(r,$1924ca1b0c205a21$var$embeddings[$1924ca1b0c205a21$var$lang]),a=`${i}_${$1924ca1b0c205a21$var$lang}-0`,s=a,o=$1924ca1b0c205a21$var$recognitionState,l=()=>{"active"==o&&$1924ca1b0c205a21$var$recognition&&$1924ca1b0c205a21$var$recognition.start(),$1924ca1b0c205a21$var$inputText.disabled=!1,$1924ca1b0c205a21$var$audioIsPlaying=!1};return $1924ca1b0c205a21$var$recognition&&$1924ca1b0c205a21$var$recognition.stop(),$1924ca1b0c205a21$var$audioIsPlaying=!0,$7c432a5c23fdd3a1$export$96ad37876925c7e6(s,l),setTimeout(()=>{$1924ca1b0c205a21$var$inputText.value=""},1500),!0}catch(n){return console.error(n),!1}}function $1924ca1b0c205a21$var$setupInputText(){fetch($ba30e20475feac5a$export$e506a1d27d1eaa20.EMBEDDINGS_PATH).then(n=>n.json()).then(n=>{$1924ca1b0c205a21$var$embeddings=n}).catch(n=>{console.error(n)}),$1924ca1b0c205a21$var$inputText.addEventListener("keydown",async n=>{if("Enter"===n.key){n.preventDefault();let r=n.target.value;$1924ca1b0c205a21$var$askQuestion(r)}})}// LANGUAGE
// ----------------------------------------------------------------------------------
function $1924ca1b0c205a21$var$changeLang(n,r){let i=document.querySelector(".chooseLang").classList;if(r=r.classList,i.contains("open")){i.remove("open"),r.contains("chosen")||(document.querySelector(".chooseLang .chosen").classList.remove("chosen"),r.add("chosen"),console.log(n+" chosen"),$1924ca1b0c205a21$var$updateSuggestionsMenu(),$1924ca1b0c205a21$var$setRecognitionLang(n));return}i.add("open")}function $1924ca1b0c205a21$var$setupChangeLanguage(){let n=["pt","en"];for(let r=0;r<n.length;r++){let i=n[r];document.getElementById(i+"-lang").onclick=function(){$1924ca1b0c205a21$var$changeLang(i,this)}}}function $1924ca1b0c205a21$var$getCurrentLanguage(){let n=document.getElementById("pt-lang");return n.classList.contains("chosen")?"pt":"en"}let $1924ca1b0c205a21$var$recognitionState="inactive";function $1924ca1b0c205a21$var$setRecognitionLang(n){$1924ca1b0c205a21$var$recognition&&($1924ca1b0c205a21$var$recognition.stop(),"pt"==n?$1924ca1b0c205a21$var$recognition.lang="pt-BR":$1924ca1b0c205a21$var$recognition.lang="en-US")}function $1924ca1b0c205a21$var$setupSpeechRecognition(){if("webkitSpeechRecognition"in window){($1924ca1b0c205a21$var$recognition=new webkitSpeechRecognition).lang="en-US",$1924ca1b0c205a21$var$recognition.maxAlternatives=1,$1924ca1b0c205a21$var$recognition.interimResults=!0,$1924ca1b0c205a21$var$recognition.addEventListener("result",n=>{let r="";for(let i=0;i<n.results.length;i++)n.results[i].isFinal||(r+=n.results[i][0].transcript);""==r&&$1924ca1b0c205a21$var$askQuestion(r=n.results[n.results.length-1][0].transcript),$1924ca1b0c205a21$var$inputText.value=r}),$1924ca1b0c205a21$var$recognition.addEventListener("start",()=>{console.log("Speech recognition started",$1924ca1b0c205a21$var$recognition);let n=document.getElementById("speechIcon");n.classList.remove("bi-mic"),n.classList.add("bi-mic-fill"),$1924ca1b0c205a21$var$recognitionState="active"}),$1924ca1b0c205a21$var$recognition.addEventListener("end",()=>{let n=document.getElementById("speechIcon");n.classList.remove("bi-mic-fill"),n.classList.add("bi-mic"),$1924ca1b0c205a21$var$recognitionState="inactive"});// setup speechButton
let n=document.getElementById("speechButton");n.onclick=()=>{console.log("speechButton clicked"),"active"==$1924ca1b0c205a21$var$recognitionState?(console.log("speechButton stop",$1924ca1b0c205a21$var$recognition),$1924ca1b0c205a21$var$recognition.stop()):(console.log("speechButton start",$1924ca1b0c205a21$var$recognition),$1924ca1b0c205a21$var$recognition.start())}}else{console.log("Speech recognition not supported"),$1924ca1b0c205a21$var$recognition=null;let n=document.getElementById("speechIcon");n.classList.remove("bi-mic"),n.classList.add("bi-mic-mute");let r=document.getElementById("speechButton");r.disabled=!0}}// SUGGESTIONS MENU
// ----------------------------------------------------------------------------------
function $1924ca1b0c205a21$var$updateSuggestionsMenu(){fetch($ba30e20475feac5a$export$e506a1d27d1eaa20.TEXTS_PATH).then(n=>n.json()).then(n=>{let r=document.getElementsByClassName("suggestions-menu-header"),i={en:"Suggestions",pt:"Sugest\xf5es"};r[0].textContent=i[$1924ca1b0c205a21$var$getCurrentLanguage()];let a=document.getElementsByClassName("suggestions-menu-body");for(;a[0].firstChild;)a[0].removeChild(a[0].firstChild);for(let[r,i]of Object.entries(n[$1924ca1b0c205a21$var$getCurrentLanguage()])){if(null==i.questions||!1==i.enable_suggestion)continue;let n=document.createElement("button");n.classList.add("btn","btn-secondary","sentence-button","mb-2"),n.textContent=i.questions[0],n.onclick=()=>{$1924ca1b0c205a21$var$askQuestion(i.questions[0])},a[0].appendChild(n)}}).catch(n=>{console.error(n)})}function $1924ca1b0c205a21$export$fc4508f6ce62417d(){$1924ca1b0c205a21$var$updateSuggestionsMenu(),$1924ca1b0c205a21$var$setupInputText(),$1924ca1b0c205a21$var$setupChangeLanguage(),$1924ca1b0c205a21$var$setupSpeechRecognition()}var $8d6448069697305c$exports={};!// stats.js - http://github.com/mrdoob/stats.js
function(n,r){$8d6448069697305c$exports=r()}(0,function(){var n=function(){function r(n){return s.appendChild(n.dom),n}function i(n){for(var r=0;r<s.children.length;r++)s.children[r].style.display=r===n?"block":"none";a=n}var a=0,s=document.createElement("div");s.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",s.addEventListener("click",function(n){n.preventDefault(),i(++a%s.children.length)},!1);var o=(performance||Date).now(),l=o,u=0,c=r(new n.Panel("FPS","#0ff","#002")),h=r(new n.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var d=r(new n.Panel("MB","#f08","#201"));return i(0),{REVISION:16,dom:s,addPanel:r,showPanel:i,begin:function(){o=(performance||Date).now()},end:function(){u++;var n=(performance||Date).now();if(h.update(n-o,200),n>l+1e3&&(c.update(1e3*u/(n-l),100),l=n,u=0,d)){var r=performance.memory;d.update(r.usedJSHeapSize/1048576,r.jsHeapSizeLimit/1048576)}return n},update:function(){o=this.end()},domElement:s,setMode:i}};return n.Panel=function(n,r,i){var a=1/0,s=0,o=Math.round,l=o(window.devicePixelRatio||1),u=80*l,c=48*l,h=3*l,d=2*l,p=3*l,f=15*l,m=74*l,g=30*l,_=document.createElement("canvas");_.width=u,_.height=c,_.style.cssText="width:80px;height:48px";var y=_.getContext("2d");return y.font="bold "+9*l+"px Helvetica,Arial,sans-serif",y.textBaseline="top",y.fillStyle=i,y.fillRect(0,0,u,c),y.fillStyle=r,y.fillText(n,h,d),y.fillRect(p,f,m,g),y.fillStyle=i,y.globalAlpha=.9,y.fillRect(p,f,m,g),{dom:_,update:function(c,b){a=Math.min(a,c),s=Math.max(s,c),y.fillStyle=i,y.globalAlpha=1,y.fillRect(0,0,u,f),y.fillStyle=r,y.fillText(o(c)+" "+n+" ("+o(a)+"-"+o(s)+")",h,d),y.drawImage(_,p+l,f,m-l,g,p,f,m-l,g),y.fillRect(p+m-l,f,l,g),y.fillStyle=i,y.globalAlpha=.9,y.fillRect(p+m-l,f,l,o((1-c/b)*g))}}},n});let $54b47fc030b7b21e$var$controlsActive=!1;const $54b47fc030b7b21e$var$stats=new/*@__PURE__*/($parcel$interopDefault($8d6448069697305c$exports));// stats.showPanel(0) // 0: fps, 1: ms, 2: mb, 3+: custom
// document.body.appendChild(stats.dom)
/**
 * Initializes the scene, camera, renderer, and controls.
 * Adds lights and the avatar to the scene.
 * Sets up keyboard controls.
 * Starts the animation loop.
 * @returns {void}
 */function $54b47fc030b7b21e$var$init(){($54b47fc030b7b21e$var$scene=new $d5b33d7c30034067$exports.Scene).background=new $d5b33d7c30034067$exports.Color(0),$54b47fc030b7b21e$var$clock=new $d5b33d7c30034067$exports.Clock,($54b47fc030b7b21e$var$camera=new $d5b33d7c30034067$exports.PerspectiveCamera(50,window.innerWidth/window.innerHeight,.1,5e3)).position.set(50,200,200),($54b47fc030b7b21e$var$renderer=new $d5b33d7c30034067$exports.WebGLRenderer({antialias:!0})).toneMapping=$d5b33d7c30034067$exports.ReinhardToneMapping,$54b47fc030b7b21e$var$renderer.toneMappingExposure=2.3,$54b47fc030b7b21e$var$renderer.shadowMap.enabled=!0,$54b47fc030b7b21e$var$renderer.setSize(window.innerWidth,window.innerHeight),document.body.appendChild($54b47fc030b7b21e$var$renderer.domElement),($54b47fc030b7b21e$var$controls=new $443c013b983d0324$export$8ff7788029dfdf52($54b47fc030b7b21e$var$camera,$54b47fc030b7b21e$var$renderer.domElement)).enablePan=!1,$54b47fc030b7b21e$var$controls.addEventListener("start",()=>$54b47fc030b7b21e$var$controlsActive=!0),$54b47fc030b7b21e$var$controls.addEventListener("end",()=>$54b47fc030b7b21e$var$controlsActive=!1),window.addEventListener("resize",$54b47fc030b7b21e$var$onResize,!1)}function $54b47fc030b7b21e$var$onResize(){$54b47fc030b7b21e$var$camera.aspect=window.innerWidth/window.innerHeight,$54b47fc030b7b21e$var$camera.updateProjectionMatrix(),$54b47fc030b7b21e$var$renderer.setSize(window.innerWidth,window.innerHeight)}function $54b47fc030b7b21e$var$setupInspector(){window.scene=$54b47fc030b7b21e$var$scene,window.THREE=$d5b33d7c30034067$exports}/**
 * Adds a hemisphere light and a point light to the scene.
 * @param {THREE.Scene} scene - The scene to add the lights to.
 */function $54b47fc030b7b21e$var$addLights(n){// Add hemisphere light
let r=new $d5b33d7c30034067$exports.HemisphereLight(16777215,16777215,.05);n.add(r);// Add point light
let i=new $d5b33d7c30034067$exports.PointLight(15649228,20);i.position.set(1,2,3),n.add(i);let a=new $d5b33d7c30034067$exports.PointLight(9055202,80);a.position.set(2.5,3,-3),n.add(a);let s=new $d5b33d7c30034067$exports.PointLight(255,80);s.position.set(-2.5,3,-3),n.add(s)}/**
 * Force camera to get smoothly back to the initial position and rotation
 * @returns {void}
 */function $54b47fc030b7b21e$var$updateCamera(n){let r=new $d5b33d7c30034067$exports.Vector3(...$ba30e20475feac5a$export$e506a1d27d1eaa20.CAMERA_POSITION);if($54b47fc030b7b21e$var$camera.position.distanceTo(r)>.01){let i=2*Math.min(Math.max(n,1/60),.1);$54b47fc030b7b21e$var$camera.position.lerp(r,1*i)}}function $54b47fc030b7b21e$var$animate(){requestAnimationFrame($54b47fc030b7b21e$var$animate),$54b47fc030b7b21e$var$stats.begin();let n=$54b47fc030b7b21e$var$clock.getDelta();$7c432a5c23fdd3a1$export$6909a70fbe283d38(n,$54b47fc030b7b21e$var$camera),$54b47fc030b7b21e$var$controlsActive||($54b47fc030b7b21e$var$updateCamera(n),$54b47fc030b7b21e$var$controls.update()),$54b47fc030b7b21e$var$renderer.render($54b47fc030b7b21e$var$scene,$54b47fc030b7b21e$var$camera),$54b47fc030b7b21e$var$stats.end()}$54b47fc030b7b21e$var$init(),$54b47fc030b7b21e$var$addLights($54b47fc030b7b21e$var$scene),$7c432a5c23fdd3a1$export$7ae28b8722707c61($54b47fc030b7b21e$var$scene),$54b47fc030b7b21e$var$setupInspector(),$1924ca1b0c205a21$export$fc4508f6ce62417d(),$54b47fc030b7b21e$var$animate();//# sourceMappingURL=index.eb629895.js.map

//# sourceMappingURL=index.eb629895.js.map
